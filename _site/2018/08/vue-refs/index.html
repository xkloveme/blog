<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <title>Vue中的代理Proxy和$refs</title>
  <meta
    name="description"
    content="前言"
  />
  <meta name="author" content="stidio" />

  <meta name="twitter:card" content="summary" />
  <meta
    name="twitter:title"
    content="Vue中的代理Proxy和$refs"
  />
  <meta
    name="twitter:description"
    content="前言"
  />

  <meta property="og:type" content="article" />
  <meta
    property="og:title"
    content="Vue中的代理Proxy和$refs"
  />
  <meta
    property="og:description"
    content="前言"
  />

  <link rel="icon" type="image/png" href="/images/favicon.png" />
  <link href="/images/favicon.png" rel="shortcut icon" type="image/png" />

  <link rel="stylesheet" href="/css/main.css" />
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" />

  <link rel="canonical" href="http://localhost:4000/2018/08/vue-refs/" />
  <link
    rel="alternate"
    type="application/rss+xml"
    title="冀小康"
    href="http://localhost:4000/feed.xml"
  />

  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />

  <!-- 百度统计 -->
  
  <script>
    var _hmt = _hmt || []
    ;(function() {
      var hm = document.createElement('script')
      hm.src = 'https://hm.baidu.com/hm.js?8a53acda192498ed67b829d820a4d8f3'
      var s = document.getElementsByTagName('script')[0]
      s.parentNode.insertBefore(hm, s)
    })()
  </script>

  

  <!-- google 统计 -->
  <!--  -->
</head>


  <body>

    <span class="mobile btn-mobile-menu">        
      <div class="nav_container">
         <nav class="nav-menu-item" style = "float:right">
            <i class="nav-menu-item">
              <a href="/#blog" title="" class="blog-button">  主页
              </a>
            </i>
            
                <i class="nav-menu-item">

                  <a href="/archive" title="archive" class="btn-mobile-menu__icon">
                      存档
                  </a>
                </i>
            
                <i class="nav-menu-item">

                  <a href="/tags" title="tags" class="btn-mobile-menu__icon">
                      标签
                  </a>
                </i>
            
                <i class="nav-menu-item">

                  <a href="/about" title="about" class="btn-mobile-menu__icon">
                      关于
                  </a>
                </i>
            
          </nav>
      </div>
    </span>
    
    <header class="panel-cover panel-cover--collapsed">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">
        <!-- 头像效果-start -->
        <div class="ih-item circle effect right_to_left">            
            <a href="/#blog" title="前往 冀小康 的主页" class="blog-button">
                <div class="img"><img src="/images/avatar.jpg" alt="img"></div>
                <div class="info">
                    <div class="info-back">
                        <h2> 
                            
                                爱好
                            
                        </h2>
                        <p>
                           
                                编程·钻研·运动·读书
                            
                        </p>
                    </div>
                </div>
            </a>
        </div>
        <!-- 头像效果-end -->
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="前往 冀小康 的主页" class="blog-button">冀小康</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">xkloveme</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">云中一樵夫</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        

        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">主页</a></li>
                
                  <li class="navigation__item"><a href="/archive" title="archive">存档</a></li>
                
                  <li class="navigation__item"><a href="/tags" title="tags">标签</a></li>
                
                  <li class="navigation__item"><a href="/about" title="about">关于</a></li>
                
              </ul>
            </nav>
          </div>          
        </div>


        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-purple"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title">Vue中的代理Proxy和$refs</h1>
    <div class="post-meta">
      <time datetime="2018-08-10 00:00:00 +0800" itemprop="datePublished" class="post-meta__date date">2018-08-10</time>
     
      <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span id="busuanzi_container_page_pv">　　阅读：<span id="busuanzi_value_page_pv"></span>次</span>
    </p>
    </div>
  </header>

  <section class="post">
    <h2 id="前言">前言</h2>

<blockquote>
  <p>最近国内 VPN 限制的严厉的多，一不小心就会被抓去签保证书，为了能和小伙伴联系，也为了能查到相关资讯，了解国内动态，关注权利的猎物老郭
特此写博，然而这一切都是免费的！免费的！免费的！（重要的事情讲三遍）</p>
</blockquote>

<h2 id="正文开始">正文开始</h2>

<p>一、 代理 Proxy</p>

<ol>
  <li>
    <p>介绍</p>
  </li>
  <li>
    <p>Proxy 又称为代理。在现实生活中，大家对代理二字并不会太陌生，比如某产品的代理。打个比方来说，我们要买一台手机，我们不会直接到一家手机厂去买，会在手机的代理商中买。</p>
  </li>
  <li>
    <p>在 JavaScript 中，Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种元编程，即对编程语言进行编程。</p>

    <ol>
      <li>Proxy 可以理解成，在目标对象之前架设一层拦截，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来代理某些操作，可以译为代理器。</li>
    </ol>
  </li>
  <li>
    <p>基本语法</p>
  </li>
</ol>

<p>1 // @param {Object} target 用来被代理的对象</p>

<p>2 // @param {Object} handler 用来设置代理的对象</p>

<p>3 let proxy = new Proxy(target, handler)</p>

<p>1 Proxy，见名知意，其功能非常类似于设计模式中的代理模式，该模式常用于三个方面：</p>

<p>2 拦截和监视外部对对象的访问</p>

<p>3 降低函数或类的复杂度</p>

<p>4 在复杂操作前对操作进行校验或对所需资源进行管理</p>

<p>5 在支持 Proxy 的浏览器环境中，Proxy 是一个全局对象，可以直接使用。Proxy(target, handler) 是一个构造函数，target 是被代理的对象，handlder 是声明了各类代理操作的对象，最终返回一个代理对象。外界每次通过代理对象访问 target 对象的属性时，就会经过 handler 对象，从这个流程来看，代理对象很类似 middleware（中间件）。那么 Proxy 可以拦截什么操作呢？最常见的就是 get（读取）、set（修改）对象属性等操作，完整的可拦截操作列表请点击这里。此外，Proxy 对象还提供了一个 revoke 方法，可以随时注销所有的代理操作。</p>

<p>一个代理的例子：</p>

<p>1const target = { name:’Billy Bob’, age:15 };
2 const handler = { get(target, key, proxy) { const today = new Date();
3 console.log(<code class="highlighter-rouge">GET request made for ${key} at ${today}</code>);
return Reflect.get(target, key, proxy); } };
4 const proxy = new Proxy(target, handler);
5 proxy.name; // =&gt; “GET request made for name at Thu Jul 21 2016 15:26:20 GMT+0800 (CST)” // =&gt; “Billy Bob”</p>

<p>1.Reflect 称为反射。它也是 ES6 中为了操作对象而提供的新的 API，用来替代直接调用 Object 的方法。Reflect 是一个内置的对象，它提供可拦截 JavaScript 操作的方法。方法与代理处理程序的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。</p>

<p>Reflect 与大多数全局对象不同，Reflect 没有构造函数。你不能将其与一个 new 运算符一起使用，或者将 Reflect 对象作为一个函数来调用。</p>

<ol>
  <li>处理器对象 handler</li>
</ol>

<p>处理器对象 handler 一共提供了 14 种可代理操作，每种操作的代号（属性名/方法名）和触发这种操作的方式如下：</p>

<p>handler.getPrototypeOf()：在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy)时</p>

<p>handler.setPrototypeOf()：在设置代理对象的原型时触发该操作，比如在执行 Object.setprototypeOf(proxy, null)时</p>

<p>handler.isExtensible()：在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy)时</p>

<p>handler.preventExtensions()：在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy)时</p>

<p>handler.getOwnPropertyDescriptor()：在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, ‘foo’)时</p>

<p>handler.defineProperty()：在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy,’foo’,{})时</p>

<p>handler.has()：在判断代理对象是否拥有某个属性时触发该操作，比如在执行’foo’ in proxy 时</p>

<p>handler.get()：在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时</p>

<p>handler.set()：在给代理对象的某个赋值时触发该操作，比如在执行 proxy.foo = 1 时</p>

<p>handler.deleteProperty()：在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时</p>

<p>handler.ownKeys()：在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy)时</p>

<p>handler.apply()：在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy()时</p>

<p>handler.construct()：在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行 new proxy()时</p>

<p>Reflect 对象拥有对应的可以控制各种元编程任务的静态方法。这些功能和 Proxy 一一对应。</p>

<p>下面的这些名称你可能看起来很眼熟（因为他们也是 Object 上的方法）：</p>

<p>Reflect.getOwnPropertyDescriptor(..)</p>

<p>Reflect.defineProperty(..)</p>

<p>Reflect.getPrototypeOf(..)</p>

<p>Reflect.setPrototypeOf(..)</p>

<p>Reflect.preventExtensions(..)</p>

<p>Reflect.isExtensible(..)</p>

<p>这些方法和在 Object 上的同名方法一样。然后，一个区别在于，Object 上这么方法的第一个参数是一个对象，Reflect 遇到这种情况会扔出一个错误。</p>

<ol>
  <li>陷阱代理</li>
</ol>

<p>使用 set 陷阱验证属性</p>

<p>假设创建一个属性值是数字的对象，对象中每新增一个属性都要加以验证，如果不是数字必须抛出错误。为了实现这个任务，可以定义一个 set 陷阱来覆写设置值的默认特性。</p>

<p>set 陷阱接受 4 个参数：</p>

<p>trapTaqget 用于接收属性(代理的目标)的对象</p>

<p>key 要写入的属性键(字符串或 Symbol 类型)</p>

<p>value 被写入属性的值</p>

<p>receiver 操作发生的对象(通常是代理)</p>

<p>Reflect.set()是 set 陷阱对应的反射方法和默认特性，它和 set 代理陷阱一样也接受相同的 4 个参数，以方便在陷阱中使用。如果属性已设置陷阱应该返回 true，如果未设置则返回 false。(Reflect.set()方法基于操作是否成功来返回恰当的值)。</p>

<p>可以使用 set 陷阱并检查传入的值来验证属性值：</p>

<p>1 //set 陷阱并检查传入的值来验证属性值</p>

<p>2 let target = { name: “target” };</p>

<p>3 let proxy = new Proxy(target, {</p>

<p>4 set(trapTarget, key, value, receiver) {</p>

<p>5 // 忽略已有属性，避免影响它们</p>

<p>6 if (!trapTarget.hasOwnProperty(key)) {</p>

<p>7 if (isNaN(value)) { throw new TypeError(“Property must be a number.”); }</p>

<p>8 } // 添加属性</p>

<p>9 return Reflect.set(trapTarget, key, value, receiver);</p>

<p>10 }</p>

<p>11 });</p>

<p>12 // 添加一个新属性</p>

<p>13 proxy.count = 1;</p>

<p>14 console.log(proxy.count); // =&gt; 1</p>

<p>15 console.log(target.count); // =&gt; 1 // 你可以为 name 赋一个非数值类型的值，因为该属性已经存在</p>

<p>16 proxy.name = “proxy”;</p>

<p>17 console.log(proxy.name); // =&gt; “proxy”</p>

<p>18 console.log(target.name); // =&gt; “proxy”</p>

<p>// 抛出错误 proxy.anotherName = “proxy”;</p>

<p>这段代码定义了一个代理来验证添加到 target 的新属性，当执行 proxy.count=1 时，set 陷阱被调用，此时 trapTarget 的值等于 target，key 等于”count”，value 等于 1，receiver 等于 proxy。</p>

<p>由于 target 上没有 count 属性，因此代理继续将 value 值传入 isNaN()，如果结果是 NaN，则证明传入的属性值不是数字，同时也抛出一个错误。在这段代码中，count 被设置为 1，所以代理调用 Reflect.set()方法并传入陷阱接受的 4 个参数来添加新属性。</p>

<p>proxy.name 可以成功被赋值为一个字符串，这是因为 target 已经拥有一个 name 属性，但通过调用 trapTarget.hasownproperty()方法验证检查后被排除了，所以目标已有的非数字属性仍然可以被操作。</p>

<p>然而，将 proxy.anotherName 赋值为一个字符串时会抛出错误。目标上没有 anotherName 属性，所以它的值需要被验证，而由于”Proxy”不是一个数字值，因此抛出错误。</p>

<p>set 代理陷阱可以拦截写入属性的操作，get 代理陷阱可以拦截读取属性的操作</p>

<p>用 get 陷阱验证对象结构(Object Shape)</p>

<p>JS 有一个时常令人感到困惑的特殊行为，即读取不存在的属性时不会抛出错误，而是用 undefined 代替被读取属性的值。</p>

<p>1 //用 get 陷阱验证对象结构(Object Shape)</p>

<p>2 let target = {};</p>

<p>3 console.log(target.name); // =&gt; undefined</p>

<p>对象结构是指对象中所有可用属性和方法的集合，JS 引擎通过对象结构来优化代码，通常会创建类来表示对象，如果可以安全地假定一个对象将始终具有相同的属性和方法，那么当程序试图访问不存在的属性时会抛出错误。代理让对象结构检验变得简单。</p>

<p>因为只有当读取属性时才会检验属性，所以无论对象中是否存在某个属性，都可以通过 get 陷阱来检测，它接受 3 个参数：</p>

<p>trapTarget 被读取属性的源对象(代理的目标)</p>

<p>key 要读取的属性键(字符串或 Symbol)</p>

<p>receiver 操作发生的对象(通常是代理)</p>

<p>由于 get 陷阱不写入值，所以它复刻了 set 陷阱中除 value 外的其他 3 个参数，Reflect.get()也接受同样 3 个参数并返回属性的默认值。</p>

<p>如果属性在目标上不存在，则使用 get 陷阱和 Reflect.get()时会抛出错误：</p>

<p>let proxy = new Proxy({}, {</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>get(trapTarget, key, receiver) {

    if (!(key in receiver)) {

        throw new TypeError("Property " + key + " doesn't exist.");

    }

    return Reflect.get(trapTarget, key, receiver);

}
</code></pre></div></div>

<p>});</p>

<p>// 添加属性的功能正常</p>

<p>proxy.name = “proxy”;</p>

<p>console.log(proxy.name); // =&gt; “proxy”</p>

<p>// 读取不存在属性会抛出错误</p>

<p>console.log(proxy.nme); // =&gt; 抛出错误</p>

<p>原型代理陷阱
Object.setPrototypeOf()方法被用于作为 ES5 中的 Object.getPrototypeOf()方法的补充。通过代理中的 setPrototypeOf 陷阱和 getPrototypeOf 陷阱可以拦截这两个方法的执行过程，在这两种情况下，Object 上的方法会调用代理中的同名陷阱来改变方法的行为。</p>

<p>两个陷阱均与代理有关，但具体到方法只与每个陷阱的类型有关，setPrototypeOf 陷阱接受以下这些参数:</p>

<p>trapTarget 接受原型设置的对象(代理的目标)</p>

<p>proto 作为原型使用的对象</p>

<p>传入 Object.setPrototypeOf()方法和 Reflect.setPrototypeOf()方法的均是以上两个参数，另一方面，getPrototypeOf 陷阱中的 Object.getPrototypeOf()方法和 Reflect.getPrototypeOf()方法只接受参数 trapTarget。</p>

<p>原型代理陷阱的运行机制
原型代理陷阱有一些限制。首先，getPrototypeOf 陷阱必须返回对象或 null，否则将导致运行时错误，返回值检查可以确保 Object.getPrototypeOf()返回的总是预期的值；其次，在 setPrototypeOf 陷阱中，如果操作失败则返回的一定是 false，此时 Object.setPrototypeOf()会抛出错误，如果 setPrototypeOf 返回了任何不是 false 的值，那么 Object.setPrototypeOf()便假设操作成功。</p>

<p>以下示例通过总是返回 null，且不允许改变原型的方式隐藏了代理的原型:</p>

<p>1 let target = {};</p>

<p>2 let proxy = new Proxy(target, {</p>

<p>3 getPrototypeOf(trapTarget) {</p>

<p>4 returnnull;</p>

<p>5 },</p>

<p>6 setPrototypeOf(trapTarget, proto) {</p>

<p>7 returnfalse;</p>

<p>8 }</p>

<p>9 });</p>

<p>10 let targetProto = Object.getPrototypeOf(target);</p>

<p>11 let proxyProto = Object.getPrototypeOf(proxy);</p>

<p>12 console.log(targetProto ===Object.prototype); // =&gt; true</p>

<p>13 console.log(proxyProto ===Object.prototype); // =&gt; false</p>

<p>14 console.log(proxyProto); // =&gt; null</p>

<p>// 成功</p>

<p>15 Object.setPrototypeOf(target, {});</p>

<p>// 抛出错误</p>

<p>16 Object.setPrototypeOf(proxy, {});</p>

<p>代码强调了 target 和 proxy 的行为差异。Object.getPrototypeOf()给 target 返回的是值，而给 proxy 返回值时，由于 getPrototypeOf 陷阱被调用，返回的是 null；同样，Object.setPrototypeOf()成功为 target 设置原型，而给 proxy 设置原型时，由于 setPrototypeOf 陷阱被调用，最终抛出一个错误。</p>

<p>一、 vue 的$ref</p>

<p>一个对象，持有注册过 ref 特性 的所有 DOM 元素和组件实例。</p>

<p>ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：</p>

<!-- `vm.$refs.p` will be the DOM node -->
<p ref="p">hello</p>

<!-- `vm.$refs.child` will be the child component instance -->

<child-component ref="child"></child-component>

<p>ref 属性不是一个标准的 HTML 属性，只是 Vue 中的一个属性。实际上，它甚至不会是 DOM 的一部分，所以在浏览器中你查看渲染的 HTML，你是看不到有关于 ref 的任何东西。因为在它前面没有添加:，而且它也不是一个指令</p>

<div ref="demo"></div>

<p>document.querySelector(‘[ref=demo]’);</p>


  </section>
</article>

<section>
       <ul class="pager">
        
        <li class="previous">
            <a href="/2017/08/change_hosts/" data-toggle="tooltip" data-placement="top" title="抛弃VPN使用host越过长城防火墙">上一篇：  <span>抛弃VPN使用host越过长城防火墙</span>
            </a>
        </li>
        
        
    </ul>
</section>

<section class="post-comments">

  
    <div class="ds-thread" data-thread-key="/2018/08/vue-refs/" data-title="Vue中的代理Proxy和$refs" data-url="http://localhost:4000/2018/08/vue-refs/"></div>

    <script type="text/javascript">
        var duoshuoQuery = {short_name:"xkloveme"};
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';ds.async = true;
            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-102352377-1', 'auto');
  ga('send', 'pageview');

</script>
  
  
  
  
</section>


            <section class="footer">
    <footer>
        <div class = "footer_div">  
        <nav class="cover-navigation navigation--social">
          <ul class="navigation">

          
          <!-- Weibo -->
          <li class="navigation__item_social">
            <a href="http://weibo.com/5043054630" title="@5043054630 的 微博" target="_blank">
              <i class='social fa fa-weibo fa-2x'></i>
              <span class="label">Weibo</span>
            </a>
          </li>
          

          
          <!-- Github -->
          <li class="navigation__item_social">
            <a href="https://github.com/xkloveme" title="@xkloveme 的 Github" target="_blank">
              <i class='social fa fa-github fa-2x'></i>
              <span class="label">Github</span>
            </a>
          </li>
          
          
          

          

          <!-- RSS -->
          <li class="navigation__item_social">
            <a href="/feed.xml" rel="author" title="RSS" target="_blank">
              <i class='social fa fa-rss fa-2x'></i>
              <span class="label">RSS</span>
            </a>
          </li>

          
          <!-- Email -->
          <li class="navigation__item_social">
            <a href="mailto:18538715282@qq.com" title="Contact me">
              <i class='social fa fa-envelope fa-2x'></i>
              <span class="label">Email</span>
            </a>
          </li>
          

          </ul>
        </nav>

        </div>
        <br/>
        <div class = "footer_div">  
           <div class="copyright text-muted" style="float:left; width:100%;margin-right: -200px;">
            Copyright &copy; 冀小康 2019 Theme by <a href="http://xkloveme.github.io/">xkloveme</a> |
            <iframe
                style="margin-left: 2px; margin-bottom:-5px;"
                frameborder="0" scrolling="0" width="91px" height="20px"
                src="https://ghbtns.com/github-btn.html?user=xkloveme&repo=xkloveme.github.io&type=star&count=true" >
            </iframe>
            </div>
        	<div align="right" style="float: right; width: 200px;">
    			<link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
    			<span id="busuanzi_value_page_pv"></span> 本站访问：<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> 次
          	</div>
        <div>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>
<script type="text/javascript" src="/js/main.js"></script>



    
  </body>

</html>
