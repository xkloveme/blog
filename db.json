{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/hexo-theme/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/css/my.css","path":"css/my.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/js/matery.js","path":"js/matery.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/css/matery.css","path":"css/matery.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/comment_bg.png","path":"medias/comment_bg.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/avatar.jpg","path":"medias/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/logo.png","path":"medias/logo.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/icp.png","path":"medias/icp.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/cover.jpg","path":"medias/cover.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/background/canvas-nest.js","path":"libs/background/canvas-nest.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/background/ribbon.min.js","path":"libs/background/ribbon.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/background/ribbon-dynamic.js","path":"libs/background/ribbon-dynamic.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/instantpage/instantpage.js","path":"libs/instantpage/instantpage.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/jquery/jquery.min.js","path":"libs/jquery/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-regular-400.eot","path":"libs/awesome/webfonts/fa-regular-400.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-regular-400.woff","path":"libs/awesome/webfonts/fa-regular-400.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/awesome/css/all.css","path":"libs/awesome/css/all.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-regular-400.woff2","path":"libs/awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-regular-400.ttf","path":"libs/awesome/webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-brands-400.woff2","path":"libs/awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-brands-400.woff","path":"libs/awesome/webfonts/fa-brands-400.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-solid-900.woff","path":"libs/awesome/webfonts/fa-solid-900.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-solid-900.woff2","path":"libs/awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-brands-400.ttf","path":"libs/awesome/webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-brands-400.eot","path":"libs/awesome/webfonts/fa-brands-400.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-regular-400.svg","path":"libs/awesome/webfonts/fa-regular-400.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-solid-900.eot","path":"libs/awesome/webfonts/fa-solid-900.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-solid-900.ttf","path":"libs/awesome/webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-brands-400.svg","path":"libs/awesome/webfonts/fa-brands-400.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-solid-900.svg","path":"libs/awesome/webfonts/fa-solid-900.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme/.gitignore","hash":"727607929a51db7ea10968f547c26041eee9cfff","modified":1584151124476},{"_id":"themes/hexo-theme/.DS_Store","hash":"f96139548d379283292203c21da0c262225409ed","modified":1584187183941},{"_id":"themes/hexo-theme/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1584073384500},{"_id":"themes/hexo-theme/README.md","hash":"79920e18af132f1749de76ee89519ce3f48e344c","modified":1584185354329},{"_id":"themes/hexo-theme/_config.yml","hash":"d49b78483c316dc283c0ff61eb53fc6881d8e49b","modified":1587442053940},{"_id":"themes/hexo-theme/README_CN.md","hash":"a2086c1f3e1db80ed27ad80ac9f0d528b4cbc7fa","modified":1584185353504},{"_id":"themes/hexo-theme/layout/.DS_Store","hash":"9b3d41e67c7dc45c122948d61996717b25e2808e","modified":1584188150204},{"_id":"themes/hexo-theme/layout/about.ejs","hash":"ee639d0310867976b3e5fb9f92c215a17a433703","modified":1584073384509},{"_id":"themes/hexo-theme/layout/category.ejs","hash":"cad6ec638187975b948be4c48d407866ca0354e8","modified":1584191947532},{"_id":"themes/hexo-theme/layout/categories.ejs","hash":"8e54665cc25d7c333da7d9f312987190be6215da","modified":1584073384509},{"_id":"themes/hexo-theme/layout/archive.ejs","hash":"d903eece7340805260e95e72958691dc43e3c3f5","modified":1584191911007},{"_id":"themes/hexo-theme/layout/contact.ejs","hash":"c3396cc5b1cbb102f500554f76946f5b45ee6d54","modified":1584073384509},{"_id":"themes/hexo-theme/layout/friends.ejs","hash":"f7bd9c216dd1b0b8795d084ae7ded09fe3374653","modified":1584073384509},{"_id":"themes/hexo-theme/layout/index.ejs","hash":"d0d06d140299ba3f70619d50c65a4d7fae929b2d","modified":1584191958574},{"_id":"themes/hexo-theme/layout/layout.ejs","hash":"1aa056da301aae15955ba6b6aea0a9e90aba5ad7","modified":1585997171484},{"_id":"themes/hexo-theme/layout/post.ejs","hash":"f9662a96d0f497a3b2731472b8ad871c7cbdf13a","modified":1584073384510},{"_id":"themes/hexo-theme/layout/tags.ejs","hash":"cf9517aa6a0111355121f44615d6923e312283c7","modified":1584073384510},{"_id":"themes/hexo-theme/layout/tag.ejs","hash":"089f5d9d723a7c2a9234d0f353a97b5123296243","modified":1584191813977},{"_id":"themes/hexo-theme/languages/default.yml","hash":"54ccc01b097c5bf6820f0edfcece1a87b78ab32d","modified":1584073384501},{"_id":"themes/hexo-theme/languages/zh-CN.yml","hash":"a957b05f70265a86a87d922e18488571809d2472","modified":1584338897489},{"_id":"themes/hexo-theme/source/.DS_Store","hash":"e05ea998914aebf5ccf5ec56024d0bcbabd20492","modified":1584186572362},{"_id":"themes/hexo-theme/source/favicon.png","hash":"10625e1476d62cf878c295774b82181e5ea33c14","modified":1551530394836},{"_id":"source/_posts/2016-11-23-aflred_workflow.md","hash":"04f220fe39fc9ae19fc04f65fb0b84ae536e2068","modified":1584865244400},{"_id":"source/_posts/2017-08-09-找工作的经历.md","hash":"1610835c3b5249f77bc911c51cb883cfabee758d","modified":1584168278491},{"_id":"source/_posts/2016-11-18-build_blog_with_github_and_jekyll.md","hash":"98a8045522b7d71d543b20ff799a32ec5c788dad","modified":1584168234306},{"_id":"source/_posts/2017-08-08-Flex 布局教程：语法篇.md","hash":"170eebacb4ccc57fac660ef7d7394afe98022d5b","modified":1584168260111},{"_id":"source/_posts/2017-08-12-轻松搞定 flex 布局（精细篇）.md","hash":"298fca0f5b20d49d425215f3e0fd31ff22d3184f","modified":1584168287414},{"_id":"source/_posts/2017-08-12-CSS中em、rem和px.md","hash":"f6a37878d3458219b3a733415dbe577bdc0073c2","modified":1584168300925},{"_id":"source/_posts/2017-08-17-Vue2.0父子组件之间和兄弟组件之间的数据交互.md","hash":"19041d8dbac9a10399415d854d54305dfd2218a0","modified":1584168337105},{"_id":"source/_posts/2017-08-15-Git使用教程及常用命令大全.md","hash":"99f418e37005f422080a8f4e8fd223e195e3f059","modified":1584168318993},{"_id":"source/_posts/2017-08-17-mint-ui —— navbar和tab-container的区别.md","hash":"bd9dd8aad2a43ffe219b379cbad20c8e5fdcac84","modified":1584168329151},{"_id":"source/_posts/2017-08-15-Git使用教程及常用命令.md","hash":"a6e2ffdb687f64f1591058d1a3e014b4154b5549","modified":1584168310584},{"_id":"source/_posts/2017-08-23-git使用记录.md","hash":"bb4153f766d7a3e8ac67d8282daa3695d96d780c","modified":1584168347267},{"_id":"source/_posts/2017-08-23-Vuex新手入门指南-基本介绍.md","hash":"b7ec3d3d62c788de1205493bb3d4d622497c2ffb","modified":1584168361461},{"_id":"source/_posts/2017-08-24-Vue 实例中的生命周期钩子.md","hash":"e715ad3203d640d5822ec12955c20c6fd65f6eb2","modified":1584168369983},{"_id":"source/_posts/2017-08-26-对vue生命周期钩子函数的理解.md","hash":"73a896eb3c799c978c87c9d032d9e01cac60cb5c","modified":1584168393507},{"_id":"source/_posts/2017-08-24-Vuex框架原理与源码分析.md","hash":"32db255d7aff84c43e45951c96d155a1b4f67e35","modified":1584168377190},{"_id":"source/_posts/2017-08-27-Web前端开发规范文档.md","hash":"96b357ed40898ce117fd60ca10cbe717fcb46afb","modified":1584168415827},{"_id":"source/_posts/2017-08-27-前端性能优化最佳实践.md","hash":"e55d022a27e99cf6963bd65083acfd64bcbe046b","modified":1584168407995},{"_id":"source/_posts/2017-08-27-解决导航下图片不能按需加载的问题减少对资源请求数量.md","hash":"d98b2d2ff941b66dcadb7ced25d36b1c677ece85","modified":1584168399767},{"_id":"source/_posts/2017-08-28-推荐大家使用的CSS书写规范、顺序.md","hash":"4cf0091252517adf9e994a90b6ef740e5b3b0d51","modified":1584168420149},{"_id":"source/_posts/2017-08-31-Promises.md","hash":"228592249d217f43640da081c3f529001b74bf51","modified":1584168436277},{"_id":"source/_posts/2017-08-31-JS 开发者必须知道的十个 ES6 新特性.md","hash":"6aa7e9a476ad05a9bbbbbbbbe747c13199361e98","modified":1584168428922},{"_id":"source/_posts/2017-09-09-Vimium~让您的Chrome起飞.md","hash":"517bbec231b4ee10a95bfebd0ece055e72c7c21f","modified":1584168460883},{"_id":"source/_posts/2017-09-09-chrome插件.md","hash":"7a22284bbe532a47e2a9e53f70ce240c685f3194","modified":1584168455163},{"_id":"source/_posts/2017-08-31-移动端不允许点击返回按钮.md","hash":"cf77c50c883191e177c8ed1358039399fd2d4261","modified":1584168424802},{"_id":"source/_posts/2017-09-09-编辑器之战: Vim 的复仇.md","hash":"ddbbf03b135f5baa346d509d56d1b47fdc8f09d8","modified":1584169561217},{"_id":"source/_posts/2017-09-09-如何更好地运用 Chrome.md","hash":"3eea6220f202fe86247fdead2d46a8a8bec99f91","modified":1584168450742},{"_id":"source/_posts/2017-09-15-vue中过滤器比较两个数组取相同值.md","hash":"c5d202aa6492e8596e9b66d8dff7363b51c83d06","modified":1584168481284},{"_id":"source/_posts/2017-09-11-iview中使用Tag时进行数据的变化.md","hash":"2169dcd0e723dfeb1785494e8a3b11364639c883","modified":1584168472013},{"_id":"source/_posts/2017-09-19-googlehosts.md","hash":"5580a4be75d64035f0cee5cfab1c41fb2d03bff5","modified":1584168496562},{"_id":"source/_posts/2017-09-19-js中字符串的替换.md","hash":"b4ca2173a459a391cb22d0562c54e5eb1419050b","modified":1584168508673},{"_id":"source/_posts/2017-09-20-前端模板Nunjucks简介.md","hash":"2fd1e6d0605c684d0a33c180a33d40510466b819","modified":1584168515188},{"_id":"source/_posts/2017-09-19-常用正则表达式总结.md","hash":"d53eac04c4ce67e04c730873c4499ce2a639114a","modified":1584168492198},{"_id":"source/_posts/2017-09-20-node.js的request模块.md","hash":"30c0191930d98649570f104a780219a46a44f778","modified":1584168519373},{"_id":"source/_posts/2017-09-21-JS异步加载的三种方式.md","hash":"d99f650bb2e880da8f698f7b847c1d5a72b54b3d","modified":1584168524830},{"_id":"source/_posts/2017-10-09-命名规范.md","hash":"631d49ae4a2bcca24f2080a1351c6631dfcb2f56","modified":1584168527588},{"_id":"source/_posts/2017-11-12-控制台console的用法.md","hash":"b80e20b5598fab326d0f1cdf91cd8ce33ee70e0a","modified":1584168538621},{"_id":"source/_posts/2017-11-22-页面重载的几种方法.md","hash":"ace8c14e8b533d8e1e7092267be906c11ee16d68","modified":1584168550890},{"_id":"source/_posts/2017-11-22-HTTP状态码列表.md","hash":"a5c48716355f49ab58844b1deb94c93e1ff9faa8","modified":1584168557058},{"_id":"source/_posts/2017-12-29-nuxt踩过的坑.md","hash":"4cf240735f83753c85cb2b9732a92b364272f59f","modified":1584168576213},{"_id":"source/_posts/2017-11-23-Linux 运维人员最常用 150 个命令汇总.md","hash":"887fbb39190507e5b9a682b4b4225439041204cc","modified":1584168570983},{"_id":"source/_posts/2018-01-25-(Chrome)扩展crx文件.md","hash":"e97ef671c6d41468830659c5c1388efe471b6d1f","modified":1584168591368},{"_id":"source/_posts/2018-01-19-小程序开发wepy框架类vue的开发方式.md","hash":"37e078b11bb74d103d29ec00414cd2c579c36057","modified":1584168579649},{"_id":"source/_posts/2018-01-27-六个月产出.md","hash":"25b34f98b3f0a027dafe99a20b1af6a5c11c3af4","modified":1584168602144},{"_id":"source/_posts/2018-02-09-架設 ShadowSocks(SS) + BBR.md","hash":"f6e29736e74c7fcd704e8381f882dde9ed33c9e8","modified":1584168608352},{"_id":"source/_posts/2018-02-26-字符串方法.md","hash":"093aea7216eaa38a36a2dc95d9c1f59a3071b6a1","modified":1584168627685},{"_id":"source/_posts/2018-02-09-webVPN离线安装.md","hash":"fa104d6d1230fa03eb989a968de97d960e8bd9df","modified":1584168615502},{"_id":"source/_posts/2018-02-26-数组方法.md","hash":"89a026731b97caff35e40ea8800930d2c384b1a6","modified":1584168622132},{"_id":"source/_posts/2018-03-16-Mac 使用技巧总结.md","hash":"4cc0d8c49f97d7be78b846f2c68c3e42177bc95c","modified":1584168668212},{"_id":"source/_posts/2018-03-13-ESLint 配置.md","hash":"6186dbc45f6150ad1aeea172a64c2e600b52177e","modified":1584168635857},{"_id":"source/_posts/2018-03-16-Mac 快捷键.md","hash":"0a2d8d43d4b072a12eeb4eeac6afe9549d166a08","modified":1584168659349},{"_id":"source/_posts/2018-03-14-Vue前端框架面试问题.md","hash":"9758d80d2f37d18a24459c9345ec08b322be8eb3","modified":1584168642262},{"_id":"source/_posts/2018-03-18-Mac OS X 终端切换root用户.md","hash":"b06b4ae52d323aca0cc8594f604963760843fc61","modified":1584168676478},{"_id":"source/_posts/2018-05-17-vue 分享知识点.md","hash":"b1e44e2033677e7b7a90331840364383597d4101","modified":1584168692708},{"_id":"source/_posts/2018-05-15-vscode 常用配置.md","hash":"72948e73655c81a9217ccc25e291c4b849353592","modified":1584168685831},{"_id":"source/_posts/2018-05-31-javascript逻辑运算符“||”和“&&”的简单梳理.md","hash":"70a65749ded873fb40f5bd13b16d49c206e8f24e","modified":1584168712336},{"_id":"source/_posts/2018-06-27-Vue中数组和对象更改后视图不刷新的问题.md","hash":"4949cd353511ac1c03f5ee6ce829671ac30ea25a","modified":1584168716187},{"_id":"source/_posts/2018-05-17-超简单！Mac打造漂亮又好用的 zsh shell 环境.md","hash":"27e3888518f01bb00c1847d82a915224a08904a8","modified":1584168707969},{"_id":"source/_posts/2018-05-27-JS几种数组遍历方式详解.md","hash":"42d5086cad9db746d2d66a01d3443a4376343589","modified":1584168696124},{"_id":"source/_posts/2019-09-16-vue实现非路由跳转以及数据传递.md","hash":"bf6c229b0898da14a36d87dcd3f4fb1df1528e95","modified":1584168743107},{"_id":"source/_posts/2018-07-24-黑匣子里到底装了什么.md","hash":"084ff7caf035fcda8f78de35261aab44bb2b064d","modified":1584169759363},{"_id":"source/_posts/2018-07-10-vue-refs.md","hash":"c2d62aa9f6f48918502ea82bbc5010c594651db6","modified":1584168723314},{"_id":"source/_posts/2020-03-13-发哨子的人.md","hash":"2877e4151da87824e027b877444217a32bef46cc","modified":1584168756525},{"_id":"source/_posts/2019-10-12-如何上传自己的UI组件包.md","hash":"61e0659263e724d927c745bb0703d303b5e705ea","modified":1584186841546},{"_id":"source/_posts/2019-10-12-vue-v-xxx基于 Vue拓展的 v-xxx 库.md","hash":"2df178c697e601c327556d50888992663ee49f48","modified":1584186839439},{"_id":"source/_posts/2020-03-14-约在春天相见.md","hash":"426c379f8d7902d3d84d91d47aa1b9c7c00a4f5f","modified":1584188704735},{"_id":"source/about/index.md","hash":"31df7d3d56a434da4108e81c9cc55d878d1b1e08","modified":1584071744352},{"_id":"source/tags/index.md","hash":"0d0cfb6c09ba8c101652e0d88fd02d2345d0f5fe","modified":1584071720498},{"_id":"source/categories/index.md","hash":"b0e50da64bda6745c34a59ceee15298434d65f6f","modified":1584071685064},{"_id":"source/_data/friends.json","hash":"2d353853aebcf6c2666121315c2188c9776eba80","modified":1584325334202},{"_id":"source/friends/index.md","hash":"a8bf146db37a6b02316e9d5038cffde363e890d9","modified":1584169625929},{"_id":"themes/hexo-theme/source/favicon.ico","hash":"514a2ecd35ef5ae6b659d8f13f465cf39216331b","modified":1584186640857},{"_id":"themes/hexo-theme/layout/_partial/back-top.ejs","hash":"47ee36a042bb6d52bbe1d0f329637e8ffcf1d0aa","modified":1584073384502},{"_id":"themes/hexo-theme/layout/_partial/baidu-analytics.ejs","hash":"3bbcdb474ca1dcad514bdc4b7763e17c55df04fd","modified":1584073384502},{"_id":"themes/hexo-theme/layout/_partial/baidu-push.ejs","hash":"2cebcc5ea3614d7f76ec36670e68050cbe611202","modified":1584073384502},{"_id":"themes/hexo-theme/layout/_partial/disqus.ejs","hash":"a0f53d1a9b579d52e52ccad8c6e330bf3b89547e","modified":1584073384502},{"_id":"themes/hexo-theme/layout/_partial/bg-cover.ejs","hash":"02191109712f61c0e487b8f0b8466597181a9004","modified":1584073384502},{"_id":"themes/hexo-theme/layout/_partial/gitalk.ejs","hash":"fe7c785f0536ad828d957a9565ca5c53a0cead43","modified":1584073384503},{"_id":"themes/hexo-theme/layout/_partial/gitment.ejs","hash":"4f3a8f243ea07644fc599bdb44cc6be1a78fb0a1","modified":1584073384503},{"_id":"themes/hexo-theme/layout/_partial/github-link.ejs","hash":"f051c75d792f67a3ef84575853b66d30a87adc2e","modified":1584185355995},{"_id":"themes/hexo-theme/layout/_partial/footer.ejs","hash":"421d256b05f7c8a55a7611d0e9ed9d486c71bb4e","modified":1584074905236},{"_id":"themes/hexo-theme/layout/_partial/google-analytics.ejs","hash":"5f4992205617da5f8cc5863c62b5ec46e414e2fb","modified":1584073384503},{"_id":"themes/hexo-theme/layout/_partial/head.ejs","hash":"d18e20d74a6a060a70b6a01888299a01775c7448","modified":1584073384503},{"_id":"themes/hexo-theme/layout/_partial/header.ejs","hash":"f555d813f568a2dbf6f572559020c44d13975449","modified":1584073384503},{"_id":"themes/hexo-theme/layout/_partial/index-cover.ejs","hash":"4f1b25a337777c953dfb467ddae1391a591d01e1","modified":1584073384504},{"_id":"themes/hexo-theme/layout/_partial/bg-cover-content.ejs","hash":"063e869c6f16ae60e621d857ae347b8f7f6602ea","modified":1587442041256},{"_id":"themes/hexo-theme/layout/_partial/livere.ejs","hash":"9c3401b42ea7f26410a5593bae93ada7e57b43be","modified":1584073384504},{"_id":"themes/hexo-theme/layout/_partial/mobile-nav.ejs","hash":"153b80047ac06a8d06a97002a98d38111d92b494","modified":1584073384504},{"_id":"themes/hexo-theme/layout/_partial/navigation.ejs","hash":"5ff6fdfe973619120a9eda4505bbff4545e39ff0","modified":1584073384504},{"_id":"themes/hexo-theme/layout/_partial/paging.ejs","hash":"e2df12cf92a82b1a7a7add2eac1db1d954bc5511","modified":1584073384504},{"_id":"themes/hexo-theme/layout/_partial/post-detail-toc.ejs","hash":"f6af8182b1a64da2229729e51e670777b3c8e812","modified":1584073384505},{"_id":"themes/hexo-theme/layout/_partial/post-statis.ejs","hash":"04889f9031743c6b081d02fa4027b0dbfcc45ecf","modified":1584073384505},{"_id":"themes/hexo-theme/layout/_partial/post-detail.ejs","hash":"2a000638814aafe4d812f09ce8f1b10bca314d8d","modified":1584073384505},{"_id":"themes/hexo-theme/layout/_partial/prev-next.ejs","hash":"35b6b4a0200c10be6ae9d9558367718290476f84","modified":1584073384505},{"_id":"themes/hexo-theme/layout/_partial/search.ejs","hash":"84e1073b3bef478c352c271f8169d667db42f5eb","modified":1584073384505},{"_id":"themes/hexo-theme/layout/_partial/reprint-statement.ejs","hash":"01f5eef82bbcb9d432631dbb78dd51d4d4b3b8b5","modified":1584073384505},{"_id":"themes/hexo-theme/layout/_partial/reward.ejs","hash":"fb7d3b4ed5e22aa33c342ca83420cf7982579360","modified":1584075389930},{"_id":"themes/hexo-theme/layout/_partial/share.ejs","hash":"5bf9dabd3ab2e298ead92256f5a732f27939ec66","modified":1584073384506},{"_id":"themes/hexo-theme/layout/_partial/social-link.ejs","hash":"6f871bd3a70f720e4e451f1f4f625cbc6d8994a4","modified":1584073384506},{"_id":"themes/hexo-theme/layout/_partial/valine.ejs","hash":"60bcc9b0a0983d631c0fb69f6d1672d895df5107","modified":1584073384506},{"_id":"themes/hexo-theme/layout/_widget/category-radar.ejs","hash":"f5561dd7d53d68897a33090bf677719213459b19","modified":1584073384506},{"_id":"themes/hexo-theme/layout/_partial/post-cover.ejs","hash":"f8d6048c7b5a4e1f2bb4495428f2fa84e586f11b","modified":1584191723044},{"_id":"themes/hexo-theme/layout/_widget/category-cloud.ejs","hash":"424ef5db791264a79c1f3338e7c43a2f445cb2ab","modified":1584073384506},{"_id":"themes/hexo-theme/layout/_widget/music.ejs","hash":"c43196a7a1ff9380b0ebcca142b8bbd831949fb9","modified":1584073384507},{"_id":"themes/hexo-theme/layout/_widget/my-gallery.ejs","hash":"de2e0abc085b721318f35c0b5d4891230be36529","modified":1584073384507},{"_id":"themes/hexo-theme/layout/_widget/my-projects.ejs","hash":"dbd8df5146bd6e873535e24f09dd7cf04e17a4e4","modified":1584073384507},{"_id":"themes/hexo-theme/layout/_widget/dream.ejs","hash":"ba83115ce66f4328601e567aa30f50d1410b9bfa","modified":1584192489068},{"_id":"themes/hexo-theme/layout/_widget/my-skills.ejs","hash":"89a0092df72d23093128f2fbbdc8ca7f83ebcfd9","modified":1584073384508},{"_id":"themes/hexo-theme/layout/_widget/post-calendar.ejs","hash":"06c5196b3115b2a30cc6001529b08f21b54ce31f","modified":1584073384508},{"_id":"themes/hexo-theme/layout/_widget/post-charts.ejs","hash":"a3666971c96169aac38708675dbd2df2b44a4cdd","modified":1584073384508},{"_id":"themes/hexo-theme/layout/_widget/tag-wordcloud.ejs","hash":"cb7a0151cd20e90351e151c22bca9d4c3112f234","modified":1584073384508},{"_id":"themes/hexo-theme/layout/_widget/tag-cloud.ejs","hash":"fc42b72cddc231f7485cdc1fd6852b66be6add26","modified":1584073384508},{"_id":"themes/hexo-theme/layout/_widget/recommend.ejs","hash":"5c46cdeb5f4252b4913a433651554f85fcd084fb","modified":1584340063453},{"_id":"themes/hexo-theme/layout/_widget/video.ejs","hash":"4162453e7e125013c8b1ad18ffc691a6ba124b88","modified":1584073384509},{"_id":"themes/hexo-theme/source/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1584073384511},{"_id":"themes/hexo-theme/source/css/my.css","hash":"10577fbc30f241b126d1b51b1f56136ecba86b19","modified":1584073384511},{"_id":"themes/hexo-theme/source/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1584073384511},{"_id":"themes/hexo-theme/source/js/matery.js","hash":"07ed4f743a497d7850b3fdda2a5d9beccc5a8fb5","modified":1584073384512},{"_id":"themes/hexo-theme/source/css/matery.css","hash":"6dce753c9d5bbe4090f1fa5cb1e3218c57b18c50","modified":1584185859907},{"_id":"themes/hexo-theme/source/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1584073384512},{"_id":"themes/hexo-theme/source/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1584073384561},{"_id":"themes/hexo-theme/source/medias/.DS_Store","hash":"40c729971d19da037f580f4c72d86a12754e599f","modified":1584092253873},{"_id":"themes/hexo-theme/source/medias/avatar.jpg","hash":"cfc45c3714ab72719a83dc1afa95bfefb25d01b5","modified":1557108389495},{"_id":"themes/hexo-theme/source/medias/logo.png","hash":"10625e1476d62cf878c295774b82181e5ea33c14","modified":1551530394836},{"_id":"themes/hexo-theme/source/medias/icp.png","hash":"5d1a1f3051c8a4ad70afa0a5488dfa7f0bb27bd5","modified":1584073384574},{"_id":"themes/hexo-theme/source/medias/featureimages/13.jpg","hash":"66706dfde7d910182c2f1dbadd0e9e917630b8dd","modified":1584073384566},{"_id":"themes/hexo-theme/source/medias/featureimages/15.jpg","hash":"5cf9fc64d5d74ab6ba69bb8bff580fdc22ba32d0","modified":1584073384567},{"_id":"themes/hexo-theme/source/medias/featureimages/16.jpg","hash":"9cac6b80b0cc8959fc8aabfbd1adcab79ebebfc9","modified":1584073384567},{"_id":"themes/hexo-theme/source/medias/featureimages/2.jpg","hash":"16f1d89cdba4dce935ac0f12599e0fcfda543a93","modified":1584073384568},{"_id":"themes/hexo-theme/source/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1584073384562},{"_id":"themes/hexo-theme/source/medias/featureimages/22.jpg","hash":"bf5b59d193e5ca089a7fff034c222bfa2c4dc41f","modified":1584073384570},{"_id":"themes/hexo-theme/source/medias/featureimages/23.jpg","hash":"ed5ac9f616d3b99af5188a10b1761884c37e93e5","modified":1584073384570},{"_id":"themes/hexo-theme/source/medias/featureimages/5.jpg","hash":"c3c1f36a1b1886037db604f151f335cd4599e970","modified":1584073384571},{"_id":"themes/hexo-theme/source/medias/featureimages/8.jpg","hash":"5a46ca4ab4c4ab2101a2af77a31a8878bccc483c","modified":1584073384572},{"_id":"themes/hexo-theme/source/medias/reward/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1584074626921},{"_id":"themes/hexo-theme/source/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1584073384512},{"_id":"themes/hexo-theme/source/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1584073384513},{"_id":"themes/hexo-theme/source/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1584073384513},{"_id":"themes/hexo-theme/source/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1584073384535},{"_id":"themes/hexo-theme/source/libs/background/ribbon.min.js","hash":"fa679c94df8fdd2bfe183b2496410afede480f38","modified":1584073384535},{"_id":"themes/hexo-theme/source/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1584073384536},{"_id":"themes/hexo-theme/source/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1584073384535},{"_id":"themes/hexo-theme/source/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1584073384513},{"_id":"themes/hexo-theme/source/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1584073384536},{"_id":"themes/hexo-theme/source/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1584073384536},{"_id":"themes/hexo-theme/source/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1584073384514},{"_id":"themes/hexo-theme/source/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1584073384536},{"_id":"themes/hexo-theme/source/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1584073384537},{"_id":"themes/hexo-theme/source/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1584073384537},{"_id":"themes/hexo-theme/source/libs/gitalk/gitalk.css","hash":"3aac1db83b0135c521187254ff302d125cc30706","modified":1584073384542},{"_id":"themes/hexo-theme/source/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1584073384543},{"_id":"themes/hexo-theme/source/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1584073384544},{"_id":"themes/hexo-theme/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1584073384544},{"_id":"themes/hexo-theme/source/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1584073384544},{"_id":"themes/hexo-theme/source/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1584073384547},{"_id":"themes/hexo-theme/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1584073384550},{"_id":"themes/hexo-theme/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1584073384550},{"_id":"themes/hexo-theme/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1584073384550},{"_id":"themes/hexo-theme/source/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1584073384552},{"_id":"themes/hexo-theme/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1584073384553},{"_id":"themes/hexo-theme/source/medias/featureimages/0.jpg","hash":"2066cdda98ad0035071cd4aa7bd696eb078c0b6d","modified":1584073384562},{"_id":"themes/hexo-theme/source/medias/featureimages/10.jpg","hash":"838e704942de076c60894d14e5f280e2724b6f68","modified":1584073384563},{"_id":"themes/hexo-theme/source/medias/featureimages/1.jpg","hash":"d16e28bd23ea3a63643826dde5eea6b7a9bdda5d","modified":1584073384562},{"_id":"themes/hexo-theme/source/medias/featureimages/11.jpg","hash":"9ed45f95b83626e3d91d6c405eb8bfe6fcb9736a","modified":1584073384563},{"_id":"themes/hexo-theme/source/medias/featureimages/14.jpg","hash":"8aeb816faca2d5eaea4cce9e881d6ff87b8c7cf1","modified":1584073384566},{"_id":"themes/hexo-theme/source/medias/featureimages/18.jpg","hash":"ae23fdfaa59bc57b7ed49e90c5d59e4b68e1eea5","modified":1584073384567},{"_id":"themes/hexo-theme/source/medias/featureimages/17.jpg","hash":"f168ca5b046d10a878a7b0bcfab540e2c4428887","modified":1584073384567},{"_id":"themes/hexo-theme/source/medias/featureimages/19.jpg","hash":"57bc7c804b78b5cceb4eb1f9e51b734b75151b71","modified":1584073384568},{"_id":"themes/hexo-theme/source/medias/featureimages/20.jpg","hash":"8271c4a327632b566ea62f546c083d08a0528e72","modified":1584073384569},{"_id":"themes/hexo-theme/source/medias/featureimages/21.jpg","hash":"d70b088850c3565e5b5bb9eb8fe4abe688c964cf","modified":1584073384569},{"_id":"themes/hexo-theme/source/medias/featureimages/3.jpg","hash":"5e879652e032f02961a331b598a50b60ebe80a39","modified":1584073384570},{"_id":"themes/hexo-theme/source/medias/featureimages/4.jpg","hash":"4eea5bdb5724ef1ed65790e481eda0d2fb176bf0","modified":1584073384571},{"_id":"themes/hexo-theme/source/medias/featureimages/6.jpg","hash":"c63ff64bdd5f6c82da8804c7248fc519d23eaf0b","modified":1584073384571},{"_id":"themes/hexo-theme/source/medias/featureimages/7.jpg","hash":"a0246a4a560438938489cdd154e35f172b3f31b0","modified":1584073384571},{"_id":"themes/hexo-theme/source/medias/featureimages/9.jpg","hash":"815c84778b721e3606c2bd7c099c7de7c53251ba","modified":1584073384573},{"_id":"themes/hexo-theme/source/medias/reward/alipay.jpg","hash":"9a6b703ee45767d8f67b1416b9d394b058c9bcbf","modified":1531288722081},{"_id":"themes/hexo-theme/source/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1584073384538},{"_id":"themes/hexo-theme/source/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1584073384543},{"_id":"themes/hexo-theme/source/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1584073384545},{"_id":"themes/hexo-theme/source/libs/valine/Valine.min.js","hash":"6cbdbf91e1f046dd41267a5ff0691a1fccba99df","modified":1584073384553},{"_id":"themes/hexo-theme/source/medias/banner/3.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1584073384559},{"_id":"themes/hexo-theme/source/medias/banner/5.jpg","hash":"4a08deec1dd5b4f1490e8fc23adfb75a0f88b0c4","modified":1584073384560},{"_id":"themes/hexo-theme/source/medias/banner/2.jpg","hash":"8d3c8391ff161eec70f66d69e5545a9468cc52ef","modified":1584073384558},{"_id":"themes/hexo-theme/source/medias/featureimages/12.jpg","hash":"047be4239dd7e0be83243ee6b49a392a61f16b9a","modified":1584073384565},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1584073384525},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1584073384526},{"_id":"themes/hexo-theme/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1584073384545},{"_id":"themes/hexo-theme/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1584073384545},{"_id":"themes/hexo-theme/source/libs/lightGallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1584073384545},{"_id":"themes/hexo-theme/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1584073384546},{"_id":"themes/hexo-theme/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1584073384546},{"_id":"themes/hexo-theme/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1584073384545},{"_id":"themes/hexo-theme/source/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1584073384546},{"_id":"themes/hexo-theme/source/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1584073384546},{"_id":"themes/hexo-theme/source/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1584073384546},{"_id":"themes/hexo-theme/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1584073384551},{"_id":"themes/hexo-theme/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1584073384551},{"_id":"themes/hexo-theme/source/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1584073384552},{"_id":"themes/hexo-theme/source/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1584073384552},{"_id":"themes/hexo-theme/source/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1584073384550},{"_id":"themes/hexo-theme/source/libs/share/fonts/iconfont.svg","hash":"f0a1b849868a6bf351ff98dc3924a4e7254eb88b","modified":1584073384551},{"_id":"themes/hexo-theme/source/medias/banner/1.jpg","hash":"c3d5ab183b39a7140941b8375e29498f9d24f343","modified":1584073384558},{"_id":"themes/hexo-theme/source/medias/banner/6.jpg","hash":"62e9586a8cec91a160f147c424a3d1d1aea360f9","modified":1584073384561},{"_id":"themes/hexo-theme/source/medias/banner/0.jpg","hash":"1f2ec55fe7825475fde2601573bb622f0bf2acba","modified":1584073384557},{"_id":"themes/hexo-theme/source/medias/reward/wechat.png","hash":"80b8346dc5d69ae5fc876898ce5f3c8b71a07685","modified":1584074519274},{"_id":"themes/hexo-theme/source/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1584073384514},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1584073384526},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1584073384526},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1584073384524},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1584073384524},{"_id":"themes/hexo-theme/source/libs/materialize/materialize.min.css","hash":"53d9b7f48fb9e2f48bd3d223b761efb9eba45563","modified":1584185355740},{"_id":"themes/hexo-theme/source/libs/gitalk/gitalk.min.js","hash":"734f56442e62fe55f677e8ccae7f175445667767","modified":1584073384543},{"_id":"themes/hexo-theme/source/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1584073384549},{"_id":"themes/hexo-theme/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1584073384551},{"_id":"themes/hexo-theme/source/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1584073384554},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1584073384534},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1584073384534},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1584073384523},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1584073384517},{"_id":"themes/hexo-theme/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1584073384547},{"_id":"themes/hexo-theme/source/medias/banner/4.jpg","hash":"56850c3139cbd72a0eff0c35d8fac32c9c66dd6a","modified":1584073384560},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-regular-400.svg","hash":"229afff648cbd17de80176e0feb969c7f514be7e","modified":1584073384526},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1584073384528},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1584073384534},{"_id":"themes/hexo-theme/source/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1584073384541},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-brands-400.svg","hash":"25612c76ded31c497effe46454d8d2bb36fb99d6","modified":1584073384522},{"_id":"themes/hexo-theme/source/libs/awesome/webfonts/fa-solid-900.svg","hash":"2c026711e4dd6b6d805cc19c0e4a572e6239a05b","modified":1584073384532},{"_id":"source/_posts/2020-03-22-前端面试之HTTP.md","hash":"0668d0e9fbe72f8464a7173f8121948dc9dcd91e","modified":1584866938911},{"_id":"source/_posts/2020-04-06浅拷贝和深拷贝.md","hash":"4a615ae6de6fb7ce6b117464068c0347c82d2f25","modified":1586184527054}],"Category":[{"name":"琐碎","_id":"ck7u2pvji00044k8ybsqqbmkf"},{"name":"教程","_id":"ck7u2pvjn000b4k8yani676jc"},{"name":"前端","_id":"ck7u2pvjt000h4k8y899m5mjg"},{"name":"工具","_id":"ck7u2pvka001a4k8y1uqz70u2"},{"name":"面试","_id":"ck7u2pvn4005f4k8ydb649ny6"}],"Data":[{"_id":"friends","data":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}],"Page":[{"title":"about","date":"2020-03-13T03:55:29.000Z","type":"about","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-03-13 11:55:29\ntype: \"about\"\nlayout: \"about\"\n---\n","updated":"2020-03-13T03:55:44.352Z","path":"about/index.html","comments":1,"_id":"ck7u2pvje00014k8ydcy9hr6f","content":"","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":""},{"title":"tags","date":"2020-03-13T03:54:59.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-03-13 11:54:59\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2020-03-13T03:55:20.498Z","path":"tags/index.html","comments":1,"_id":"ck7u2pvjh00034k8y1i51eiaw","content":"","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":""},{"title":"categories","date":"2020-03-13T03:53:59.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-03-13 11:53:59\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2020-03-13T03:54:45.064Z","path":"categories/index.html","comments":1,"_id":"ck7u2pvjk00074k8yhkchcs99","content":"","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":""},{"title":"friends","date":"2020-03-13T03:55:52.000Z","type":"friends","layout":"friends","_content":"\n想要加友链的可以在下面评论,格式如下:\n\n```json\n{\n  \"avatar\": \"https://s1.ax1x.com/2020/03/13/8nIuY6.png\",\n  \"name\": \"小康之家\",\n  \"introduction\": \"輕云薄霧，不似秋光\",\n  \"url\": \"https://jixiaokang.com/\",\n  \"title\": \"前端日常\"\n}\n```\n","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2020-03-13 11:55:52\ntype: \"friends\"\nlayout: \"friends\"\n---\n\n想要加友链的可以在下面评论,格式如下:\n\n```json\n{\n  \"avatar\": \"https://s1.ax1x.com/2020/03/13/8nIuY6.png\",\n  \"name\": \"小康之家\",\n  \"introduction\": \"輕云薄霧，不似秋光\",\n  \"url\": \"https://jixiaokang.com/\",\n  \"title\": \"前端日常\"\n}\n```\n","updated":"2020-03-14T07:07:05.929Z","path":"friends/index.html","comments":1,"_id":"ck7u2pvjm00094k8yfdr61v0d","content":"<p>想要加友链的可以在下面评论,格式如下:</p>\n<pre class=\" language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"avatar\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"https://s1.ax1x.com/2020/03/13/8nIuY6.png\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"小康之家\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"introduction\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"輕云薄霧，不似秋光\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"url\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"https://jixiaokang.com/\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"title\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"前端日常\"</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>想要加友链的可以在下面评论,格式如下:</p>\n<pre><code class=\"json\">{\n  &quot;avatar&quot;: &quot;https://s1.ax1x.com/2020/03/13/8nIuY6.png&quot;,\n  &quot;name&quot;: &quot;小康之家&quot;,\n  &quot;introduction&quot;: &quot;輕云薄霧，不似秋光&quot;,\n  &quot;url&quot;: &quot;https://jixiaokang.com/&quot;,\n  &quot;title&quot;: &quot;前端日常&quot;\n}</code></pre>\n"}],"Post":[{"title":"来到杭州，找工作的经历","date":"2017-08-09T03:44:00.000Z","_content":"\n当毕业的一个瞬间，心里想着终于要解放了，终于要回归大自然了，再也不会被学校的魔爪所控制了，现在回想回想当时确实是激动了。\n\n\\- 毕业的那天下午就和同伴坐上了南下的火车，直奔杭州。在到的前几天里我们尽情的玩了几天，可是\n\n还没有找到落脚的地方，他们两个，一个北上，一个南下，剩我自己待在杭州了。\n\n\\- 在找到到一个落脚的时的前一周时，我也不知道脑子是如何抽了，心情怠慢，找工作的脚步基本没迈出去。白白浪费了一周。现在想想确实\n\n有些自责。在上一份工作丢到之时，我还没有看过多少面试题，甚至一个最简单的东西别人问我我都不知道。在投出那么多简历之后，也没有多少家去\n\n愿意发面试的，而现在已经八月份了，打电话面试的基本就是培训机构了。\n\n\\- 在我该了几遍简历之后，才忽然发现我会的东西原来太少了，面试的时候别人问你什么概念而自己却又不知道，那是一种很大的绝望，比如 ES6、前端模块化\n\n，我又想起来在面试中移在线时别人问我 MVC 框架我却道不上来，现在想想真是很傻很天真啊。\n\n\\- 在我不知道如何办才好的时候，发现宿舍的一个人每天去图书馆，也是学的前端，后来就做了个伴，天天结伴而行，把前端面试题看了一遍，虽然 JS 学的不咋滴但是\n\n总是在一步步进步着。又学了 Node、webpack、vue、linux 和面试的技巧，以前真的是一张白纸啊。\n\n\\- 本来自以为在毕业之前找了个好工作，可以学习下去，谁知道老板是个坑，谁没有掉过水沟呢\n\n\\-\\-\\-\\-\\-\\-\\-\\-\\-\n\n现在的我以然在找工作，当一个人闲久了会令人发疯的，精神会崩溃，心理防线会变得脆弱，到杭州也满打满算两个月了，我总觉的该写点什么，来纪念一下，我这段\n\n找工作的日子，现在前端行业不比从前了，初级前端一抓一大把，而且国内的就业形势不太好，不是培训机构就是传销，刚毕业的大学生进入社会这个大染缸里，独善其身\n\n求真务实太难了，社会充斥着假大空，人们的教育，文化、理念、传统已经被摧毁的体无完肤，希望社会能多一些真善美，也希望我能找到一个好工作。\n","source":"_posts/2017-08-09-找工作的经历.md","raw":"---\ntitle: 来到杭州，找工作的经历\ntags:\n  - 生活\ndate: 2017-08-09 11:44:00\ncategories: 琐碎\n---\n\n当毕业的一个瞬间，心里想着终于要解放了，终于要回归大自然了，再也不会被学校的魔爪所控制了，现在回想回想当时确实是激动了。\n\n\\- 毕业的那天下午就和同伴坐上了南下的火车，直奔杭州。在到的前几天里我们尽情的玩了几天，可是\n\n还没有找到落脚的地方，他们两个，一个北上，一个南下，剩我自己待在杭州了。\n\n\\- 在找到到一个落脚的时的前一周时，我也不知道脑子是如何抽了，心情怠慢，找工作的脚步基本没迈出去。白白浪费了一周。现在想想确实\n\n有些自责。在上一份工作丢到之时，我还没有看过多少面试题，甚至一个最简单的东西别人问我我都不知道。在投出那么多简历之后，也没有多少家去\n\n愿意发面试的，而现在已经八月份了，打电话面试的基本就是培训机构了。\n\n\\- 在我该了几遍简历之后，才忽然发现我会的东西原来太少了，面试的时候别人问你什么概念而自己却又不知道，那是一种很大的绝望，比如 ES6、前端模块化\n\n，我又想起来在面试中移在线时别人问我 MVC 框架我却道不上来，现在想想真是很傻很天真啊。\n\n\\- 在我不知道如何办才好的时候，发现宿舍的一个人每天去图书馆，也是学的前端，后来就做了个伴，天天结伴而行，把前端面试题看了一遍，虽然 JS 学的不咋滴但是\n\n总是在一步步进步着。又学了 Node、webpack、vue、linux 和面试的技巧，以前真的是一张白纸啊。\n\n\\- 本来自以为在毕业之前找了个好工作，可以学习下去，谁知道老板是个坑，谁没有掉过水沟呢\n\n\\-\\-\\-\\-\\-\\-\\-\\-\\-\n\n现在的我以然在找工作，当一个人闲久了会令人发疯的，精神会崩溃，心理防线会变得脆弱，到杭州也满打满算两个月了，我总觉的该写点什么，来纪念一下，我这段\n\n找工作的日子，现在前端行业不比从前了，初级前端一抓一大把，而且国内的就业形势不太好，不是培训机构就是传销，刚毕业的大学生进入社会这个大染缸里，独善其身\n\n求真务实太难了，社会充斥着假大空，人们的教育，文化、理念、传统已经被摧毁的体无完肤，希望社会能多一些真善美，也希望我能找到一个好工作。\n","slug":"2017-08-09-找工作的经历","published":1,"updated":"2020-03-14T06:44:38.491Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvj200004k8y12ox6u1n","content":"<p>当毕业的一个瞬间，心里想着终于要解放了，终于要回归大自然了，再也不会被学校的魔爪所控制了，现在回想回想当时确实是激动了。</p>\n<p>- 毕业的那天下午就和同伴坐上了南下的火车，直奔杭州。在到的前几天里我们尽情的玩了几天，可是</p>\n<p>还没有找到落脚的地方，他们两个，一个北上，一个南下，剩我自己待在杭州了。</p>\n<p>- 在找到到一个落脚的时的前一周时，我也不知道脑子是如何抽了，心情怠慢，找工作的脚步基本没迈出去。白白浪费了一周。现在想想确实</p>\n<p>有些自责。在上一份工作丢到之时，我还没有看过多少面试题，甚至一个最简单的东西别人问我我都不知道。在投出那么多简历之后，也没有多少家去</p>\n<p>愿意发面试的，而现在已经八月份了，打电话面试的基本就是培训机构了。</p>\n<p>- 在我该了几遍简历之后，才忽然发现我会的东西原来太少了，面试的时候别人问你什么概念而自己却又不知道，那是一种很大的绝望，比如 ES6、前端模块化</p>\n<p>，我又想起来在面试中移在线时别人问我 MVC 框架我却道不上来，现在想想真是很傻很天真啊。</p>\n<p>- 在我不知道如何办才好的时候，发现宿舍的一个人每天去图书馆，也是学的前端，后来就做了个伴，天天结伴而行，把前端面试题看了一遍，虽然 JS 学的不咋滴但是</p>\n<p>总是在一步步进步着。又学了 Node、webpack、vue、linux 和面试的技巧，以前真的是一张白纸啊。</p>\n<p>- 本来自以为在毕业之前找了个好工作，可以学习下去，谁知道老板是个坑，谁没有掉过水沟呢</p>\n<p>---------</p>\n<p>现在的我以然在找工作，当一个人闲久了会令人发疯的，精神会崩溃，心理防线会变得脆弱，到杭州也满打满算两个月了，我总觉的该写点什么，来纪念一下，我这段</p>\n<p>找工作的日子，现在前端行业不比从前了，初级前端一抓一大把，而且国内的就业形势不太好，不是培训机构就是传销，刚毕业的大学生进入社会这个大染缸里，独善其身</p>\n<p>求真务实太难了，社会充斥着假大空，人们的教育，文化、理念、传统已经被摧毁的体无完肤，希望社会能多一些真善美，也希望我能找到一个好工作。</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>当毕业的一个瞬间，心里想着终于要解放了，终于要回归大自然了，再也不会被学校的魔爪所控制了，现在回想回想当时确实是激动了。</p>\n<p>- 毕业的那天下午就和同伴坐上了南下的火车，直奔杭州。在到的前几天里我们尽情的玩了几天，可是</p>\n<p>还没有找到落脚的地方，他们两个，一个北上，一个南下，剩我自己待在杭州了。</p>\n<p>- 在找到到一个落脚的时的前一周时，我也不知道脑子是如何抽了，心情怠慢，找工作的脚步基本没迈出去。白白浪费了一周。现在想想确实</p>\n<p>有些自责。在上一份工作丢到之时，我还没有看过多少面试题，甚至一个最简单的东西别人问我我都不知道。在投出那么多简历之后，也没有多少家去</p>\n<p>愿意发面试的，而现在已经八月份了，打电话面试的基本就是培训机构了。</p>\n<p>- 在我该了几遍简历之后，才忽然发现我会的东西原来太少了，面试的时候别人问你什么概念而自己却又不知道，那是一种很大的绝望，比如 ES6、前端模块化</p>\n<p>，我又想起来在面试中移在线时别人问我 MVC 框架我却道不上来，现在想想真是很傻很天真啊。</p>\n<p>- 在我不知道如何办才好的时候，发现宿舍的一个人每天去图书馆，也是学的前端，后来就做了个伴，天天结伴而行，把前端面试题看了一遍，虽然 JS 学的不咋滴但是</p>\n<p>总是在一步步进步着。又学了 Node、webpack、vue、linux 和面试的技巧，以前真的是一张白纸啊。</p>\n<p>- 本来自以为在毕业之前找了个好工作，可以学习下去，谁知道老板是个坑，谁没有掉过水沟呢</p>\n<p>---------</p>\n<p>现在的我以然在找工作，当一个人闲久了会令人发疯的，精神会崩溃，心理防线会变得脆弱，到杭州也满打满算两个月了，我总觉的该写点什么，来纪念一下，我这段</p>\n<p>找工作的日子，现在前端行业不比从前了，初级前端一抓一大把，而且国内的就业形势不太好，不是培训机构就是传销，刚毕业的大学生进入社会这个大染缸里，独善其身</p>\n<p>求真务实太难了，社会充斥着假大空，人们的教育，文化、理念、传统已经被摧毁的体无完肤，希望社会能多一些真善美，也希望我能找到一个好工作。</p>\n"},{"layout":"post","title":"Alfred Workflow教程与实例","date":"2016-11-23T16:00:00.000Z","_content":"\n小帽子 [Alfred](https://www.alfredapp.com) 作为 macOS 上的最佳效率软件应该没太大争议([排名](https://github.com/hzlzh/Best-App))，而其中最强大的部分即为 Alfred 2.0 推出的[Workflow](https://www.alfredapp.com/workflows/)特性；其允许你将日常重复性的工作使用脚本语言(目前支持：bash, zsh, php, python, ruby, perl, osascript(AppleScript, JavaScript))封装起来，以 Alfred 作为统一的入口和呈现来使用，大大提高效率；本文将对其开发的一般流程进行讲述，并最终实现两个实例：\n\n> - `CDto`: 打开 Terminal 并转到任意文件夹或文件所在目录，使用 _bash+osascript_ 实现 [点此下载](https://raw.githubusercontent.com/stidio/Alfred-Workflow/master/CDto.alfredworkflow)\n>\n> - `Effective IP`: 查询本机和外网 IP 地址，解析任意 URL 和域名的 IP 地址，同时进行归属地和运营商查询，使用 _python_ 实现 [点此下载](https://raw.githubusercontent.com/stidio/Alfred-Workflow/master/Effective%20IP.alfredworkflow)\n\n本文源代码地址：[https://github.com/stidio/Alfred-Workflow](https://github.com/stidio/Alfred-Workflow)，如果喜欢请[Star!](https://github.com/stidio/Alfred-Workflow)，谢谢!\n\n### 概述\n\nAlfred Workflow 的整体架构，极度类似于 Windows 中的 Direct Show，首先由一个 Input 开始，中间经过一堆 filter，然后到一个 Output 结束，中间通过 Pin 连接，上一个 Output Pin 作为输入传递给下一个 Input Pin，从而形成一个完整的 Graph，而最终传递给 Alfred 做输出呈现的内容必须符合下面的形式：\n\n> ```xml\n> <?xml version=\"1.0\" encoding=\"utf-8\"?>\n> <items>\n>     <item valid=\"yes\">\n>         <title>10.0.2.11</title>\n>         <subtitle>45.76.65.119 美国新泽西州皮斯卡特维 choopa.com</subtitle>\n>         <icon>Info.icns</icon>\n>     </item>\n> </items>\n> ```\n>\n> Alfred 上每一行显示对应一个*item*，如果显示多行，那就在*items*下放入多个*item*即可\n>\n> - _valid_ 表现为可不可以选择，点击，再次传递\n> - _title_ 主标题\n> - _subtitle_ 副标题\n> - _icon_ 图标\n\n### 开发准备\n\n1. 使用[Option+空格]调出 Alfred，输入 alfred 打开 Alfred Preferences:\n\n2. 点击 Workflows 按钮，然后点击最下面的 **+** 按钮，创建一个 Blank Workflow，按照提示填入信息:\n\n   > **Bundle Id** 作为该 Workflow 的标识为必填内容，如果不填或与其他重复，有可能造成其不能正常运行\n\n### Workflow - CDto\n\n使用 Terminal 的一般步骤大概是运行 Terminal，然后一路 cd 到目标文件夹后开始使用；虽然 Finder 有 cd to 插件，但也需要你一路点到指定文件夹后，才能调起来；虽然 Alfred 的 Right Arrow 按键里面有 Open Terminal Here 操作，但排在太后面了，打开的操作路径至少需要：Right Arrow -> 输入 o -> [Command + 3]三步才能完成:\n\n作为一个需要频繁和 Terminal 交互的码农这完全不能忍，下面我们就利用 Workflow 做个一步到位的 CDto 神器\n\n1. 在 Alfred Workflows 的工作区点右键，选择菜单[Inputs -> File Filter]，并按下图设置好，其他两个选项卡使用默认设置即可:\n\n2. 在刚才插入的[File Filter]上点击右键，选择菜单[Insert After -> Actions -> Run Script]，并按照下图设置好，最下面的 Escaping 表示对指定字符进行转义，比如说:/Users/$a1，如果不对$转义，那外部会把\\$a1 一起当做一个变量，而这个变量未定义也就是为空，传递进来的参数最终变成:/Users/，[点此查看代码](https://github.com/stidio/Alfred-Workflow/blob/master/CDto/cdto.bash):\n\n### Workflow - Effective IP\n\n现在我们使用 Python 来做个更复杂的例子，[点此查看源码](https://github.com/stidio/Alfred-Workflow/blob/master/Effective%20IP/effectiveip.py)，具体分析见下图:\n\n我们基于[Full-featured python library for writing Alfred workflows](https://github.com/deanishe/alfred-workflow/)进行开发，具体的内容请参考前面的内容和[官方教程](http://www.deanishe.net/alfred-workflow/tutorial_1.html), 这里我只对两个设置界面进行必要的解释：\n\n1. 主设置界面\n\n   > 1. 直接输入 ip 无参形式是查询本机的本地和公网地址，有参形式是进行 DNS 解析，因此参数是可选的，需要设置为：[Argument Optional]\n   > 2. 点击 Run Behaviour 按钮，进行运行行为设置\n\n2. 运行行为设置\n\n   > 1. 如果输入发生变化，我们肯定是希望得到之后的结果，因此我们需要即时结束掉之前的查询\n   > 2. 在输入过程中不进行查询，Alfred 通过最后一个字符输入延迟来判断输入结束后才进行查询\n\n### 其他事项\n\n> 1. 左边列表区域里点右键选择[Open in Finder]可以打开该 Workflow 的目录进行文件查看和编辑\n> 2. 点此可以调出调试窗口，查看调试信息\n\n### 参考资料\n\n[神兵利器 — Alfred](http://macshuo.com/?p=625)  \n[Alfred workflow 开发指南](http://myg0u.com/python/2015/05/23/tutorial-alfred-workflow.html)  \n[JavaScript for OS X Automation by Example](http://developer.telerik.com/featured/javascript-os-x-automation-example/)  \n[Full-featured python library for writing Alfred workflows](http://www.deanishe.net/alfred-workflow/)\n\n<br/>\n\n> [原始链接]({{page.url}}) 版权声明：自由转载-非商用-非衍生-保持署名 \\| [Creative Commons BY-NC-ND 4.0](http://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh)\n","source":"_posts/2016-11-23-aflred_workflow.md","raw":"---\nlayout: post\ntitle: Alfred Workflow教程与实例\ndate: 2016-11-24\ncategories: 教程\ntags:\n  - 技术\n---\n\n小帽子 [Alfred](https://www.alfredapp.com) 作为 macOS 上的最佳效率软件应该没太大争议([排名](https://github.com/hzlzh/Best-App))，而其中最强大的部分即为 Alfred 2.0 推出的[Workflow](https://www.alfredapp.com/workflows/)特性；其允许你将日常重复性的工作使用脚本语言(目前支持：bash, zsh, php, python, ruby, perl, osascript(AppleScript, JavaScript))封装起来，以 Alfred 作为统一的入口和呈现来使用，大大提高效率；本文将对其开发的一般流程进行讲述，并最终实现两个实例：\n\n> - `CDto`: 打开 Terminal 并转到任意文件夹或文件所在目录，使用 _bash+osascript_ 实现 [点此下载](https://raw.githubusercontent.com/stidio/Alfred-Workflow/master/CDto.alfredworkflow)\n>\n> - `Effective IP`: 查询本机和外网 IP 地址，解析任意 URL 和域名的 IP 地址，同时进行归属地和运营商查询，使用 _python_ 实现 [点此下载](https://raw.githubusercontent.com/stidio/Alfred-Workflow/master/Effective%20IP.alfredworkflow)\n\n本文源代码地址：[https://github.com/stidio/Alfred-Workflow](https://github.com/stidio/Alfred-Workflow)，如果喜欢请[Star!](https://github.com/stidio/Alfred-Workflow)，谢谢!\n\n### 概述\n\nAlfred Workflow 的整体架构，极度类似于 Windows 中的 Direct Show，首先由一个 Input 开始，中间经过一堆 filter，然后到一个 Output 结束，中间通过 Pin 连接，上一个 Output Pin 作为输入传递给下一个 Input Pin，从而形成一个完整的 Graph，而最终传递给 Alfred 做输出呈现的内容必须符合下面的形式：\n\n> ```xml\n> <?xml version=\"1.0\" encoding=\"utf-8\"?>\n> <items>\n>     <item valid=\"yes\">\n>         <title>10.0.2.11</title>\n>         <subtitle>45.76.65.119 美国新泽西州皮斯卡特维 choopa.com</subtitle>\n>         <icon>Info.icns</icon>\n>     </item>\n> </items>\n> ```\n>\n> Alfred 上每一行显示对应一个*item*，如果显示多行，那就在*items*下放入多个*item*即可\n>\n> - _valid_ 表现为可不可以选择，点击，再次传递\n> - _title_ 主标题\n> - _subtitle_ 副标题\n> - _icon_ 图标\n\n### 开发准备\n\n1. 使用[Option+空格]调出 Alfred，输入 alfred 打开 Alfred Preferences:\n\n2. 点击 Workflows 按钮，然后点击最下面的 **+** 按钮，创建一个 Blank Workflow，按照提示填入信息:\n\n   > **Bundle Id** 作为该 Workflow 的标识为必填内容，如果不填或与其他重复，有可能造成其不能正常运行\n\n### Workflow - CDto\n\n使用 Terminal 的一般步骤大概是运行 Terminal，然后一路 cd 到目标文件夹后开始使用；虽然 Finder 有 cd to 插件，但也需要你一路点到指定文件夹后，才能调起来；虽然 Alfred 的 Right Arrow 按键里面有 Open Terminal Here 操作，但排在太后面了，打开的操作路径至少需要：Right Arrow -> 输入 o -> [Command + 3]三步才能完成:\n\n作为一个需要频繁和 Terminal 交互的码农这完全不能忍，下面我们就利用 Workflow 做个一步到位的 CDto 神器\n\n1. 在 Alfred Workflows 的工作区点右键，选择菜单[Inputs -> File Filter]，并按下图设置好，其他两个选项卡使用默认设置即可:\n\n2. 在刚才插入的[File Filter]上点击右键，选择菜单[Insert After -> Actions -> Run Script]，并按照下图设置好，最下面的 Escaping 表示对指定字符进行转义，比如说:/Users/$a1，如果不对$转义，那外部会把\\$a1 一起当做一个变量，而这个变量未定义也就是为空，传递进来的参数最终变成:/Users/，[点此查看代码](https://github.com/stidio/Alfred-Workflow/blob/master/CDto/cdto.bash):\n\n### Workflow - Effective IP\n\n现在我们使用 Python 来做个更复杂的例子，[点此查看源码](https://github.com/stidio/Alfred-Workflow/blob/master/Effective%20IP/effectiveip.py)，具体分析见下图:\n\n我们基于[Full-featured python library for writing Alfred workflows](https://github.com/deanishe/alfred-workflow/)进行开发，具体的内容请参考前面的内容和[官方教程](http://www.deanishe.net/alfred-workflow/tutorial_1.html), 这里我只对两个设置界面进行必要的解释：\n\n1. 主设置界面\n\n   > 1. 直接输入 ip 无参形式是查询本机的本地和公网地址，有参形式是进行 DNS 解析，因此参数是可选的，需要设置为：[Argument Optional]\n   > 2. 点击 Run Behaviour 按钮，进行运行行为设置\n\n2. 运行行为设置\n\n   > 1. 如果输入发生变化，我们肯定是希望得到之后的结果，因此我们需要即时结束掉之前的查询\n   > 2. 在输入过程中不进行查询，Alfred 通过最后一个字符输入延迟来判断输入结束后才进行查询\n\n### 其他事项\n\n> 1. 左边列表区域里点右键选择[Open in Finder]可以打开该 Workflow 的目录进行文件查看和编辑\n> 2. 点此可以调出调试窗口，查看调试信息\n\n### 参考资料\n\n[神兵利器 — Alfred](http://macshuo.com/?p=625)  \n[Alfred workflow 开发指南](http://myg0u.com/python/2015/05/23/tutorial-alfred-workflow.html)  \n[JavaScript for OS X Automation by Example](http://developer.telerik.com/featured/javascript-os-x-automation-example/)  \n[Full-featured python library for writing Alfred workflows](http://www.deanishe.net/alfred-workflow/)\n\n<br/>\n\n> [原始链接]({{page.url}}) 版权声明：自由转载-非商用-非衍生-保持署名 \\| [Creative Commons BY-NC-ND 4.0](http://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh)\n","slug":"2016-11-23-aflred_workflow","published":1,"updated":"2020-03-22T08:20:44.400Z","_id":"ck7u2pvjf00024k8y5j1y5n2r","comments":1,"photos":[],"link":"","content":"<p>小帽子 <a href=\"https://www.alfredapp.com\" target=\"_blank\" rel=\"noopener\">Alfred</a> 作为 macOS 上的最佳效率软件应该没太大争议(<a href=\"https://github.com/hzlzh/Best-App\" target=\"_blank\" rel=\"noopener\">排名</a>)，而其中最强大的部分即为 Alfred 2.0 推出的<a href=\"https://www.alfredapp.com/workflows/\" target=\"_blank\" rel=\"noopener\">Workflow</a>特性；其允许你将日常重复性的工作使用脚本语言(目前支持：bash, zsh, php, python, ruby, perl, osascript(AppleScript, JavaScript))封装起来，以 Alfred 作为统一的入口和呈现来使用，大大提高效率；本文将对其开发的一般流程进行讲述，并最终实现两个实例：</p>\n<blockquote>\n<ul>\n<li><p><code>CDto</code>: 打开 Terminal 并转到任意文件夹或文件所在目录，使用 <em>bash+osascript</em> 实现 <a href=\"https://raw.githubusercontent.com/stidio/Alfred-Workflow/master/CDto.alfredworkflow\" target=\"_blank\" rel=\"noopener\">点此下载</a></p>\n</li>\n<li><p><code>Effective IP</code>: 查询本机和外网 IP 地址，解析任意 URL 和域名的 IP 地址，同时进行归属地和运营商查询，使用 <em>python</em> 实现 <a href=\"https://raw.githubusercontent.com/stidio/Alfred-Workflow/master/Effective%20IP.alfredworkflow\" target=\"_blank\" rel=\"noopener\">点此下载</a></p>\n</li>\n</ul>\n</blockquote>\n<p>本文源代码地址：<a href=\"https://github.com/stidio/Alfred-Workflow\" target=\"_blank\" rel=\"noopener\">https://github.com/stidio/Alfred-Workflow</a>，如果喜欢请<a href=\"https://github.com/stidio/Alfred-Workflow\" target=\"_blank\" rel=\"noopener\">Star!</a>，谢谢!</p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Alfred Workflow 的整体架构，极度类似于 Windows 中的 Direct Show，首先由一个 Input 开始，中间经过一堆 filter，然后到一个 Output 结束，中间通过 Pin 连接，上一个 Output Pin 作为输入传递给下一个 Input Pin，从而形成一个完整的 Graph，而最终传递给 Alfred 做输出呈现的内容必须符合下面的形式：</p>\n<blockquote>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>items</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>item</span> <span class=\"token attr-name\">valid</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>yes<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span>10.0.2.11<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>subtitle</span><span class=\"token punctuation\">></span></span>45.76.65.119 美国新泽西州皮斯卡特维 choopa.com<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>subtitle</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>icon</span><span class=\"token punctuation\">></span></span>Info.icns<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>icon</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>item</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>items</span><span class=\"token punctuation\">></span></span></code></pre>\n<p>Alfred 上每一行显示对应一个<em>item</em>，如果显示多行，那就在<em>items</em>下放入多个<em>item</em>即可</p>\n<ul>\n<li><em>valid</em> 表现为可不可以选择，点击，再次传递</li>\n<li><em>title</em> 主标题</li>\n<li><em>subtitle</em> 副标题</li>\n<li><em>icon</em> 图标</li>\n</ul>\n</blockquote>\n<h3 id=\"开发准备\"><a href=\"#开发准备\" class=\"headerlink\" title=\"开发准备\"></a>开发准备</h3><ol>\n<li><p>使用[Option+空格]调出 Alfred，输入 alfred 打开 Alfred Preferences:</p>\n</li>\n<li><p>点击 Workflows 按钮，然后点击最下面的 <strong>+</strong> 按钮，创建一个 Blank Workflow，按照提示填入信息:</p>\n<blockquote>\n<p><strong>Bundle Id</strong> 作为该 Workflow 的标识为必填内容，如果不填或与其他重复，有可能造成其不能正常运行</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"Workflow-CDto\"><a href=\"#Workflow-CDto\" class=\"headerlink\" title=\"Workflow - CDto\"></a>Workflow - CDto</h3><p>使用 Terminal 的一般步骤大概是运行 Terminal，然后一路 cd 到目标文件夹后开始使用；虽然 Finder 有 cd to 插件，但也需要你一路点到指定文件夹后，才能调起来；虽然 Alfred 的 Right Arrow 按键里面有 Open Terminal Here 操作，但排在太后面了，打开的操作路径至少需要：Right Arrow -&gt; 输入 o -&gt; [Command + 3]三步才能完成:</p>\n<p>作为一个需要频繁和 Terminal 交互的码农这完全不能忍，下面我们就利用 Workflow 做个一步到位的 CDto 神器</p>\n<ol>\n<li><p>在 Alfred Workflows 的工作区点右键，选择菜单[Inputs -&gt; File Filter]，并按下图设置好，其他两个选项卡使用默认设置即可:</p>\n</li>\n<li><p>在刚才插入的[File Filter]上点击右键，选择菜单[Insert After -&gt; Actions -&gt; Run Script]，并按照下图设置好，最下面的 Escaping 表示对指定字符进行转义，比如说:/Users/$a1，如果不对$转义，那外部会把$a1 一起当做一个变量，而这个变量未定义也就是为空，传递进来的参数最终变成:/Users/，<a href=\"https://github.com/stidio/Alfred-Workflow/blob/master/CDto/cdto.bash\" target=\"_blank\" rel=\"noopener\">点此查看代码</a>:</p>\n</li>\n</ol>\n<h3 id=\"Workflow-Effective-IP\"><a href=\"#Workflow-Effective-IP\" class=\"headerlink\" title=\"Workflow - Effective IP\"></a>Workflow - Effective IP</h3><p>现在我们使用 Python 来做个更复杂的例子，<a href=\"https://github.com/stidio/Alfred-Workflow/blob/master/Effective%20IP/effectiveip.py\" target=\"_blank\" rel=\"noopener\">点此查看源码</a>，具体分析见下图:</p>\n<p>我们基于<a href=\"https://github.com/deanishe/alfred-workflow/\" target=\"_blank\" rel=\"noopener\">Full-featured python library for writing Alfred workflows</a>进行开发，具体的内容请参考前面的内容和<a href=\"http://www.deanishe.net/alfred-workflow/tutorial_1.html\" target=\"_blank\" rel=\"noopener\">官方教程</a>, 这里我只对两个设置界面进行必要的解释：</p>\n<ol>\n<li><p>主设置界面</p>\n<blockquote>\n<ol>\n<li>直接输入 ip 无参形式是查询本机的本地和公网地址，有参形式是进行 DNS 解析，因此参数是可选的，需要设置为：[Argument Optional]</li>\n<li>点击 Run Behaviour 按钮，进行运行行为设置</li>\n</ol>\n</blockquote>\n</li>\n<li><p>运行行为设置</p>\n<blockquote>\n<ol>\n<li>如果输入发生变化，我们肯定是希望得到之后的结果，因此我们需要即时结束掉之前的查询</li>\n<li>在输入过程中不进行查询，Alfred 通过最后一个字符输入延迟来判断输入结束后才进行查询</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"其他事项\"><a href=\"#其他事项\" class=\"headerlink\" title=\"其他事项\"></a>其他事项</h3><blockquote>\n<ol>\n<li>左边列表区域里点右键选择[Open in Finder]可以打开该 Workflow 的目录进行文件查看和编辑</li>\n<li>点此可以调出调试窗口，查看调试信息</li>\n</ol>\n</blockquote>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"http://macshuo.com/?p=625\" target=\"_blank\" rel=\"noopener\">神兵利器 — Alfred</a><br><a href=\"http://myg0u.com/python/2015/05/23/tutorial-alfred-workflow.html\" target=\"_blank\" rel=\"noopener\">Alfred workflow 开发指南</a><br><a href=\"http://developer.telerik.com/featured/javascript-os-x-automation-example/\" target=\"_blank\" rel=\"noopener\">JavaScript for OS X Automation by Example</a><br><a href=\"http://www.deanishe.net/alfred-workflow/\" target=\"_blank\" rel=\"noopener\">Full-featured python library for writing Alfred workflows</a></p>\n<br/>\n\n<blockquote>\n<p><a href=\"!--￼0--\">原始链接</a> 版权声明：自由转载-非商用-非衍生-保持署名 | <a href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh\" target=\"_blank\" rel=\"noopener\">Creative Commons BY-NC-ND 4.0</a></p>\n</blockquote>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>小帽子 <a href=\"https://www.alfredapp.com\" target=\"_blank\" rel=\"noopener\">Alfred</a> 作为 macOS 上的最佳效率软件应该没太大争议(<a href=\"https://github.com/hzlzh/Best-App\" target=\"_blank\" rel=\"noopener\">排名</a>)，而其中最强大的部分即为 Alfred 2.0 推出的<a href=\"https://www.alfredapp.com/workflows/\" target=\"_blank\" rel=\"noopener\">Workflow</a>特性；其允许你将日常重复性的工作使用脚本语言(目前支持：bash, zsh, php, python, ruby, perl, osascript(AppleScript, JavaScript))封装起来，以 Alfred 作为统一的入口和呈现来使用，大大提高效率；本文将对其开发的一般流程进行讲述，并最终实现两个实例：</p>\n<blockquote>\n<ul>\n<li><p><code>CDto</code>: 打开 Terminal 并转到任意文件夹或文件所在目录，使用 <em>bash+osascript</em> 实现 <a href=\"https://raw.githubusercontent.com/stidio/Alfred-Workflow/master/CDto.alfredworkflow\" target=\"_blank\" rel=\"noopener\">点此下载</a></p>\n</li>\n<li><p><code>Effective IP</code>: 查询本机和外网 IP 地址，解析任意 URL 和域名的 IP 地址，同时进行归属地和运营商查询，使用 <em>python</em> 实现 <a href=\"https://raw.githubusercontent.com/stidio/Alfred-Workflow/master/Effective%20IP.alfredworkflow\" target=\"_blank\" rel=\"noopener\">点此下载</a></p>\n</li>\n</ul>\n</blockquote>\n<p>本文源代码地址：<a href=\"https://github.com/stidio/Alfred-Workflow\" target=\"_blank\" rel=\"noopener\">https://github.com/stidio/Alfred-Workflow</a>，如果喜欢请<a href=\"https://github.com/stidio/Alfred-Workflow\" target=\"_blank\" rel=\"noopener\">Star!</a>，谢谢!</p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Alfred Workflow 的整体架构，极度类似于 Windows 中的 Direct Show，首先由一个 Input 开始，中间经过一堆 filter，然后到一个 Output 结束，中间通过 Pin 连接，上一个 Output Pin 作为输入传递给下一个 Input Pin，从而形成一个完整的 Graph，而最终传递给 Alfred 做输出呈现的内容必须符合下面的形式：</p>\n<blockquote>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;items&gt;\n    &lt;item valid=&quot;yes&quot;&gt;\n        &lt;title&gt;10.0.2.11&lt;/title&gt;\n        &lt;subtitle&gt;45.76.65.119 美国新泽西州皮斯卡特维 choopa.com&lt;/subtitle&gt;\n        &lt;icon&gt;Info.icns&lt;/icon&gt;\n    &lt;/item&gt;\n&lt;/items&gt;</code></pre>\n<p>Alfred 上每一行显示对应一个<em>item</em>，如果显示多行，那就在<em>items</em>下放入多个<em>item</em>即可</p>\n<ul>\n<li><em>valid</em> 表现为可不可以选择，点击，再次传递</li>\n<li><em>title</em> 主标题</li>\n<li><em>subtitle</em> 副标题</li>\n<li><em>icon</em> 图标</li>\n</ul>\n</blockquote>\n<h3 id=\"开发准备\"><a href=\"#开发准备\" class=\"headerlink\" title=\"开发准备\"></a>开发准备</h3><ol>\n<li><p>使用[Option+空格]调出 Alfred，输入 alfred 打开 Alfred Preferences:</p>\n</li>\n<li><p>点击 Workflows 按钮，然后点击最下面的 <strong>+</strong> 按钮，创建一个 Blank Workflow，按照提示填入信息:</p>\n<blockquote>\n<p><strong>Bundle Id</strong> 作为该 Workflow 的标识为必填内容，如果不填或与其他重复，有可能造成其不能正常运行</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"Workflow-CDto\"><a href=\"#Workflow-CDto\" class=\"headerlink\" title=\"Workflow - CDto\"></a>Workflow - CDto</h3><p>使用 Terminal 的一般步骤大概是运行 Terminal，然后一路 cd 到目标文件夹后开始使用；虽然 Finder 有 cd to 插件，但也需要你一路点到指定文件夹后，才能调起来；虽然 Alfred 的 Right Arrow 按键里面有 Open Terminal Here 操作，但排在太后面了，打开的操作路径至少需要：Right Arrow -&gt; 输入 o -&gt; [Command + 3]三步才能完成:</p>\n<p>作为一个需要频繁和 Terminal 交互的码农这完全不能忍，下面我们就利用 Workflow 做个一步到位的 CDto 神器</p>\n<ol>\n<li><p>在 Alfred Workflows 的工作区点右键，选择菜单[Inputs -&gt; File Filter]，并按下图设置好，其他两个选项卡使用默认设置即可:</p>\n</li>\n<li><p>在刚才插入的[File Filter]上点击右键，选择菜单[Insert After -&gt; Actions -&gt; Run Script]，并按照下图设置好，最下面的 Escaping 表示对指定字符进行转义，比如说:/Users/$a1，如果不对$转义，那外部会把$a1 一起当做一个变量，而这个变量未定义也就是为空，传递进来的参数最终变成:/Users/，<a href=\"https://github.com/stidio/Alfred-Workflow/blob/master/CDto/cdto.bash\" target=\"_blank\" rel=\"noopener\">点此查看代码</a>:</p>\n</li>\n</ol>\n<h3 id=\"Workflow-Effective-IP\"><a href=\"#Workflow-Effective-IP\" class=\"headerlink\" title=\"Workflow - Effective IP\"></a>Workflow - Effective IP</h3><p>现在我们使用 Python 来做个更复杂的例子，<a href=\"https://github.com/stidio/Alfred-Workflow/blob/master/Effective%20IP/effectiveip.py\" target=\"_blank\" rel=\"noopener\">点此查看源码</a>，具体分析见下图:</p>\n<p>我们基于<a href=\"https://github.com/deanishe/alfred-workflow/\" target=\"_blank\" rel=\"noopener\">Full-featured python library for writing Alfred workflows</a>进行开发，具体的内容请参考前面的内容和<a href=\"http://www.deanishe.net/alfred-workflow/tutorial_1.html\" target=\"_blank\" rel=\"noopener\">官方教程</a>, 这里我只对两个设置界面进行必要的解释：</p>\n<ol>\n<li><p>主设置界面</p>\n<blockquote>\n<ol>\n<li>直接输入 ip 无参形式是查询本机的本地和公网地址，有参形式是进行 DNS 解析，因此参数是可选的，需要设置为：[Argument Optional]</li>\n<li>点击 Run Behaviour 按钮，进行运行行为设置</li>\n</ol>\n</blockquote>\n</li>\n<li><p>运行行为设置</p>\n<blockquote>\n<ol>\n<li>如果输入发生变化，我们肯定是希望得到之后的结果，因此我们需要即时结束掉之前的查询</li>\n<li>在输入过程中不进行查询，Alfred 通过最后一个字符输入延迟来判断输入结束后才进行查询</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"其他事项\"><a href=\"#其他事项\" class=\"headerlink\" title=\"其他事项\"></a>其他事项</h3><blockquote>\n<ol>\n<li>左边列表区域里点右键选择[Open in Finder]可以打开该 Workflow 的目录进行文件查看和编辑</li>\n<li>点此可以调出调试窗口，查看调试信息</li>\n</ol>\n</blockquote>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"http://macshuo.com/?p=625\" target=\"_blank\" rel=\"noopener\">神兵利器 — Alfred</a><br><a href=\"http://myg0u.com/python/2015/05/23/tutorial-alfred-workflow.html\" target=\"_blank\" rel=\"noopener\">Alfred workflow 开发指南</a><br><a href=\"http://developer.telerik.com/featured/javascript-os-x-automation-example/\" target=\"_blank\" rel=\"noopener\">JavaScript for OS X Automation by Example</a><br><a href=\"http://www.deanishe.net/alfred-workflow/\" target=\"_blank\" rel=\"noopener\">Full-featured python library for writing Alfred workflows</a></p>\n<br/>\n\n<blockquote>\n<p><a href=\"!--￼0--\">原始链接</a> 版权声明：自由转载-非商用-非衍生-保持署名 | <a href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh\" target=\"_blank\" rel=\"noopener\">Creative Commons BY-NC-ND 4.0</a></p>\n</blockquote>\n"},{"title":"Vue2.0父子组件之间和兄弟组件之间的数据交互","date":"2017-08-17T04:41:00.000Z","_content":"\n#### 熟悉了 Vue.js 的同级组件之间通信，写此文章，以便记录。\n\n#### Vue 是一个轻量级的渐进式框架，对于它的一些特性和优点，请在官网上进行查看，不再赘述。\n\n使用 NPM 及相关命令行工具初始化的 Vue 工程，目录结构如下\n\n![](http://img.blog.csdn.net/20170723170241545)\n\n接着我们进入 Demo，首先我们可以删除掉模板项目中 src/components/Hello.vue,然后在 App.vue 中删除对于 Hello 子组件的注册和使用还有一些其他无关紧要的东西，此时的 App.vue 应为这样\n\n![](http://img.blog.csdn.net/20170723170721302)\n\n**一 .我们先来创建中央事件总线，在 src/assets/下创建一个 eventBus.js,内容如下**\n\n（eventBus 中我们只创建了一个新的 Vue 实例，以后它就承担起了组件之间通信的桥梁了，也就是中央事件总线。）\n\n![](http://img.blog.csdn.net/20170723220642249)\n\n**二 . 创建一个 firstChild 组件，引入 eventBus 这个事件总线，接着添加一个按钮并绑定一个点击事件**\n\n**![](http://img.blog.csdn.net/20170723220843946)  \n**\n\n1、我们在响应点击事件的 sendMsg 函数中用$emit触发了一个自定义的userDefinedEvent事件，并传递了一个字符串参数  \n2、$emit 实例方法触发当前实例(这里的当前实例就是 bus)上的事件,附加参数都会传给监听器回调。\n\n**三 . 我们再创建一个 secondChild 组件，引入 eventBus 事件总线，并用一个 p 标签来显示传递过来的值**\n\n![](http://img.blog.csdn.net/20170723221122492)\n\n1、我们在 mounted 中，监听了 userDefinedEvent,并把传递过来的字符串参数传递给了$on监听器的回调函数  \n2、mounted:是一个Vue生命周期中的钩子函数，简单点说就类似于jQuery的ready，Vue会在文档加载完毕后调用mounted函数。  \n3、$on:监听当前实例上的自定义事件(此处当前实例为 bus)。事件可以由$emit触发，回调函数会接收所有传入事件触发函数($emit)的额外参数。\n\n**四 . 在父组件中，注册这两个组件，并添加这两个组件的标签**\n\n![](http://img.blog.csdn.net/20170723221338855)\n\n**保存所有修改的文件，然后打开浏览器窗口，内容如下(css 请自行处理)**\n\n**![](http://img.blog.csdn.net/20170723221514399)  \n**\n\n**点击向组件传值按钮，我们可以看到传值成功**\n\n**![](http://img.blog.csdn.net/20170723221616095)  \n**\n\n**总结：  \n1、创建一个事件总线，例如 demo 中的 eventBus，用它作为通信桥梁  \n2、在需要传值的组件中用 bus.$emit触发一个自定义事件，并传递参数  \n3、在需要接收数据的组件中用bus.$on 监听自定义事件，并在回调函数中处理传递过来的参数  \n**\n\n**另外：**\n\n**1、兄弟组件之间与父子组件之间的数据交互，两者相比较，兄弟组件之间的通信其实和子组件向父组件传值有些类似，其实他们的通信原理都是相同的，例如子向父传值也是$emit和$on 的形式，只是没有 eventBus，但若我们仔细想想，此时父组件其实就充当了 bus 这个事件总线的角色。  \n2、这种用一个 Vue 实例来作为中央事件总线来管理组件通信的方法只适用于通信需求简单一点的项目，对于更复杂的情况，Vue 也有提供更复杂的状态管理模式 Vuex 来进行处理。**\n","source":"_posts/2017-08-17-Vue2.0父子组件之间和兄弟组件之间的数据交互.md","raw":"---\ntitle: Vue2.0父子组件之间和兄弟组件之间的数据交互\ntags:\n  - 技术\n  - vue\ndate: 2017-08-17 12:41:00\ncategories: 前端\n---\n\n#### 熟悉了 Vue.js 的同级组件之间通信，写此文章，以便记录。\n\n#### Vue 是一个轻量级的渐进式框架，对于它的一些特性和优点，请在官网上进行查看，不再赘述。\n\n使用 NPM 及相关命令行工具初始化的 Vue 工程，目录结构如下\n\n![](http://img.blog.csdn.net/20170723170241545)\n\n接着我们进入 Demo，首先我们可以删除掉模板项目中 src/components/Hello.vue,然后在 App.vue 中删除对于 Hello 子组件的注册和使用还有一些其他无关紧要的东西，此时的 App.vue 应为这样\n\n![](http://img.blog.csdn.net/20170723170721302)\n\n**一 .我们先来创建中央事件总线，在 src/assets/下创建一个 eventBus.js,内容如下**\n\n（eventBus 中我们只创建了一个新的 Vue 实例，以后它就承担起了组件之间通信的桥梁了，也就是中央事件总线。）\n\n![](http://img.blog.csdn.net/20170723220642249)\n\n**二 . 创建一个 firstChild 组件，引入 eventBus 这个事件总线，接着添加一个按钮并绑定一个点击事件**\n\n**![](http://img.blog.csdn.net/20170723220843946)  \n**\n\n1、我们在响应点击事件的 sendMsg 函数中用$emit触发了一个自定义的userDefinedEvent事件，并传递了一个字符串参数  \n2、$emit 实例方法触发当前实例(这里的当前实例就是 bus)上的事件,附加参数都会传给监听器回调。\n\n**三 . 我们再创建一个 secondChild 组件，引入 eventBus 事件总线，并用一个 p 标签来显示传递过来的值**\n\n![](http://img.blog.csdn.net/20170723221122492)\n\n1、我们在 mounted 中，监听了 userDefinedEvent,并把传递过来的字符串参数传递给了$on监听器的回调函数  \n2、mounted:是一个Vue生命周期中的钩子函数，简单点说就类似于jQuery的ready，Vue会在文档加载完毕后调用mounted函数。  \n3、$on:监听当前实例上的自定义事件(此处当前实例为 bus)。事件可以由$emit触发，回调函数会接收所有传入事件触发函数($emit)的额外参数。\n\n**四 . 在父组件中，注册这两个组件，并添加这两个组件的标签**\n\n![](http://img.blog.csdn.net/20170723221338855)\n\n**保存所有修改的文件，然后打开浏览器窗口，内容如下(css 请自行处理)**\n\n**![](http://img.blog.csdn.net/20170723221514399)  \n**\n\n**点击向组件传值按钮，我们可以看到传值成功**\n\n**![](http://img.blog.csdn.net/20170723221616095)  \n**\n\n**总结：  \n1、创建一个事件总线，例如 demo 中的 eventBus，用它作为通信桥梁  \n2、在需要传值的组件中用 bus.$emit触发一个自定义事件，并传递参数  \n3、在需要接收数据的组件中用bus.$on 监听自定义事件，并在回调函数中处理传递过来的参数  \n**\n\n**另外：**\n\n**1、兄弟组件之间与父子组件之间的数据交互，两者相比较，兄弟组件之间的通信其实和子组件向父组件传值有些类似，其实他们的通信原理都是相同的，例如子向父传值也是$emit和$on 的形式，只是没有 eventBus，但若我们仔细想想，此时父组件其实就充当了 bus 这个事件总线的角色。  \n2、这种用一个 Vue 实例来作为中央事件总线来管理组件通信的方法只适用于通信需求简单一点的项目，对于更复杂的情况，Vue 也有提供更复杂的状态管理模式 Vuex 来进行处理。**\n","slug":"2017-08-17-Vue2.0父子组件之间和兄弟组件之间的数据交互","published":1,"updated":"2020-03-14T06:45:37.105Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvjk00064k8ye9lta5ar","content":"<h4 id=\"熟悉了-Vue-js-的同级组件之间通信，写此文章，以便记录。\"><a href=\"#熟悉了-Vue-js-的同级组件之间通信，写此文章，以便记录。\" class=\"headerlink\" title=\"熟悉了 Vue.js 的同级组件之间通信，写此文章，以便记录。\"></a>熟悉了 Vue.js 的同级组件之间通信，写此文章，以便记录。</h4><h4 id=\"Vue-是一个轻量级的渐进式框架，对于它的一些特性和优点，请在官网上进行查看，不再赘述。\"><a href=\"#Vue-是一个轻量级的渐进式框架，对于它的一些特性和优点，请在官网上进行查看，不再赘述。\" class=\"headerlink\" title=\"Vue 是一个轻量级的渐进式框架，对于它的一些特性和优点，请在官网上进行查看，不再赘述。\"></a>Vue 是一个轻量级的渐进式框架，对于它的一些特性和优点，请在官网上进行查看，不再赘述。</h4><p>使用 NPM 及相关命令行工具初始化的 Vue 工程，目录结构如下</p>\n<p><img src=\"http://img.blog.csdn.net/20170723170241545\" alt=\"\"></p>\n<p>接着我们进入 Demo，首先我们可以删除掉模板项目中 src/components/Hello.vue,然后在 App.vue 中删除对于 Hello 子组件的注册和使用还有一些其他无关紧要的东西，此时的 App.vue 应为这样</p>\n<p><img src=\"http://img.blog.csdn.net/20170723170721302\" alt=\"\"></p>\n<p><strong>一 .我们先来创建中央事件总线，在 src/assets/下创建一个 eventBus.js,内容如下</strong></p>\n<p>（eventBus 中我们只创建了一个新的 Vue 实例，以后它就承担起了组件之间通信的桥梁了，也就是中央事件总线。）</p>\n<p><img src=\"http://img.blog.csdn.net/20170723220642249\" alt=\"\"></p>\n<p><strong>二 . 创建一个 firstChild 组件，引入 eventBus 这个事件总线，接着添加一个按钮并绑定一个点击事件</strong></p>\n<p>*<em><img src=\"http://img.blog.csdn.net/20170723220843946\" alt=\"\"><br>*</em></p>\n<p>1、我们在响应点击事件的 sendMsg 函数中用$emit触发了一个自定义的userDefinedEvent事件，并传递了一个字符串参数<br>2、$emit 实例方法触发当前实例(这里的当前实例就是 bus)上的事件,附加参数都会传给监听器回调。</p>\n<p><strong>三 . 我们再创建一个 secondChild 组件，引入 eventBus 事件总线，并用一个 p 标签来显示传递过来的值</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20170723221122492\" alt=\"\"></p>\n<p>1、我们在 mounted 中，监听了 userDefinedEvent,并把传递过来的字符串参数传递给了$on监听器的回调函数<br>2、mounted:是一个Vue生命周期中的钩子函数，简单点说就类似于jQuery的ready，Vue会在文档加载完毕后调用mounted函数。<br>3、$on:监听当前实例上的自定义事件(此处当前实例为 bus)。事件可以由$emit触发，回调函数会接收所有传入事件触发函数($emit)的额外参数。</p>\n<p><strong>四 . 在父组件中，注册这两个组件，并添加这两个组件的标签</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20170723221338855\" alt=\"\"></p>\n<p><strong>保存所有修改的文件，然后打开浏览器窗口，内容如下(css 请自行处理)</strong></p>\n<p>*<em><img src=\"http://img.blog.csdn.net/20170723221514399\" alt=\"\"><br>*</em></p>\n<p><strong>点击向组件传值按钮，我们可以看到传值成功</strong></p>\n<p>*<em><img src=\"http://img.blog.csdn.net/20170723221616095\" alt=\"\"><br>*</em></p>\n<p>*<em>总结：<br>1、创建一个事件总线，例如 demo 中的 eventBus，用它作为通信桥梁<br>2、在需要传值的组件中用 bus.$emit触发一个自定义事件，并传递参数<br>3、在需要接收数据的组件中用bus.$on 监听自定义事件，并在回调函数中处理传递过来的参数<br>*</em></p>\n<p><strong>另外：</strong></p>\n<p><strong>1、兄弟组件之间与父子组件之间的数据交互，两者相比较，兄弟组件之间的通信其实和子组件向父组件传值有些类似，其实他们的通信原理都是相同的，例如子向父传值也是$emit和$on 的形式，只是没有 eventBus，但若我们仔细想想，此时父组件其实就充当了 bus 这个事件总线的角色。<br>2、这种用一个 Vue 实例来作为中央事件总线来管理组件通信的方法只适用于通信需求简单一点的项目，对于更复杂的情况，Vue 也有提供更复杂的状态管理模式 Vuex 来进行处理。</strong></p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h4 id=\"熟悉了-Vue-js-的同级组件之间通信，写此文章，以便记录。\"><a href=\"#熟悉了-Vue-js-的同级组件之间通信，写此文章，以便记录。\" class=\"headerlink\" title=\"熟悉了 Vue.js 的同级组件之间通信，写此文章，以便记录。\"></a>熟悉了 Vue.js 的同级组件之间通信，写此文章，以便记录。</h4><h4 id=\"Vue-是一个轻量级的渐进式框架，对于它的一些特性和优点，请在官网上进行查看，不再赘述。\"><a href=\"#Vue-是一个轻量级的渐进式框架，对于它的一些特性和优点，请在官网上进行查看，不再赘述。\" class=\"headerlink\" title=\"Vue 是一个轻量级的渐进式框架，对于它的一些特性和优点，请在官网上进行查看，不再赘述。\"></a>Vue 是一个轻量级的渐进式框架，对于它的一些特性和优点，请在官网上进行查看，不再赘述。</h4><p>使用 NPM 及相关命令行工具初始化的 Vue 工程，目录结构如下</p>\n<p><img src=\"http://img.blog.csdn.net/20170723170241545\" alt=\"\"></p>\n<p>接着我们进入 Demo，首先我们可以删除掉模板项目中 src/components/Hello.vue,然后在 App.vue 中删除对于 Hello 子组件的注册和使用还有一些其他无关紧要的东西，此时的 App.vue 应为这样</p>\n<p><img src=\"http://img.blog.csdn.net/20170723170721302\" alt=\"\"></p>\n<p><strong>一 .我们先来创建中央事件总线，在 src/assets/下创建一个 eventBus.js,内容如下</strong></p>\n<p>（eventBus 中我们只创建了一个新的 Vue 实例，以后它就承担起了组件之间通信的桥梁了，也就是中央事件总线。）</p>\n<p><img src=\"http://img.blog.csdn.net/20170723220642249\" alt=\"\"></p>\n<p><strong>二 . 创建一个 firstChild 组件，引入 eventBus 这个事件总线，接着添加一个按钮并绑定一个点击事件</strong></p>\n<p>*<em><img src=\"http://img.blog.csdn.net/20170723220843946\" alt=\"\"><br>*</em></p>\n<p>1、我们在响应点击事件的 sendMsg 函数中用$emit触发了一个自定义的userDefinedEvent事件，并传递了一个字符串参数<br>2、$emit 实例方法触发当前实例(这里的当前实例就是 bus)上的事件,附加参数都会传给监听器回调。</p>\n<p><strong>三 . 我们再创建一个 secondChild 组件，引入 eventBus 事件总线，并用一个 p 标签来显示传递过来的值</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20170723221122492\" alt=\"\"></p>\n<p>1、我们在 mounted 中，监听了 userDefinedEvent,并把传递过来的字符串参数传递给了$on监听器的回调函数<br>2、mounted:是一个Vue生命周期中的钩子函数，简单点说就类似于jQuery的ready，Vue会在文档加载完毕后调用mounted函数。<br>3、$on:监听当前实例上的自定义事件(此处当前实例为 bus)。事件可以由$emit触发，回调函数会接收所有传入事件触发函数($emit)的额外参数。</p>\n<p><strong>四 . 在父组件中，注册这两个组件，并添加这两个组件的标签</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20170723221338855\" alt=\"\"></p>\n<p><strong>保存所有修改的文件，然后打开浏览器窗口，内容如下(css 请自行处理)</strong></p>\n<p>*<em><img src=\"http://img.blog.csdn.net/20170723221514399\" alt=\"\"><br>*</em></p>\n<p><strong>点击向组件传值按钮，我们可以看到传值成功</strong></p>\n<p>*<em><img src=\"http://img.blog.csdn.net/20170723221616095\" alt=\"\"><br>*</em></p>\n<p>*<em>总结：<br>1、创建一个事件总线，例如 demo 中的 eventBus，用它作为通信桥梁<br>2、在需要传值的组件中用 bus.$emit触发一个自定义事件，并传递参数<br>3、在需要接收数据的组件中用bus.$on 监听自定义事件，并在回调函数中处理传递过来的参数<br>*</em></p>\n<p><strong>另外：</strong></p>\n<p><strong>1、兄弟组件之间与父子组件之间的数据交互，两者相比较，兄弟组件之间的通信其实和子组件向父组件传值有些类似，其实他们的通信原理都是相同的，例如子向父传值也是$emit和$on 的形式，只是没有 eventBus，但若我们仔细想想，此时父组件其实就充当了 bus 这个事件总线的角色。<br>2、这种用一个 Vue 实例来作为中央事件总线来管理组件通信的方法只适用于通信需求简单一点的项目，对于更复杂的情况，Vue 也有提供更复杂的状态管理模式 Vuex 来进行处理。</strong></p>\n"},{"title":"Git使用教程及常用命令大全","date":"2017-08-15T01:14:00.000Z","_content":"\n一、git 命令名词解释  \n1、添加/跟踪/暂存：添加到本地索引    \n      git add  文件名  \n2、提交：提交到本地仓库    \n      git commit -m '注释'  \n3、推送：将提交到本地仓库的所有更新提交到服务器    \n      git push mycode release  \n4、更新/拉取：将远程最新的仓库或拉到本地，两种方法  \n      a)  从远程获取最新版本，不会自动合并(merge)：   \n            git checkout release  \n            git fetch origin release  \n      b)  从远程获取最新版本并自动 merge：  \n            git checkout release  \n            git pull origin release  \n       方法：  \n       a)  推荐先使用第一种方法，更安全些，先 git fetch  \n       b)  再检测是否有哪些更改或是否有冲突：  \n            git log -p release..orgin/release  \n                 或  \n            git log orgin/release ^release  \n       c)  最后再合并：  \n            git merge origin/release（将 origin/release 合并到当前的分支）\n\n二、基本步骤  \n1、进入 web 端页面，从主仓储派生一个自己仓库  \n2、新建本地系统文件夹  \n3、进入文件夹，右键选择 git bash  \n4、首次下载源码    \n   git clone  派生仓库的地址  \n5、右键选择 git gui > edit > option ，左侧设置名字和邮箱（必须是注册时的邮箱）  \n6、设置远程地址：  \n    先：进入包含.git 的目录，右键选择 git bash  \n    再：git remote add mycode  派生地址  \n7、进入开发工作  \n8、提交代码：  \n   a)提交到本地索引  git add  文件名或点(.)     \n       提示 1：在 add 前，可以用 git status 查看有哪些文件被修改  \n       提示 2：输入\"git add \"  可以不断按两次 tab 键快速定位本地改过的文件，如下图：  \n      ![](file:///D:\\用户目录\\Documents\\QQEIM Files\\2880672274\\Image\\C2C\\%(`I)KVC7%0OY21$YN6`F)3.png)  \n      提示 3：VS2013 自动支持，如下右键提交即可  \n     ![](file:///D:\\用户目录\\Documents\\QQEIM Files\\2880672274\\Image\\C2C\\GKOV)%`WMN{H8XF8XUC1)`Y.png)\n\nb)提交到本地仓库  git commit -m '注释必填'  \n   c)提交到远程服务器的我的派生仓库：  \n      git push mycode release  \n      (注意：本地已经测试小组没问题后执行)  \n9、合并请求  \n     a)进入主仓库  >  合并请求  >  创建合并请求  \n     b)再次确认需要提交的文件及内容无误，最后点提交  \n     注意：从本地的 release 分支   合并到   总的 release 分支\n\nPS：在具体实践中，都用更新提交都使用 release 分支，不用 master  \n\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-  \n三、其它：  \n1、.net 项目开发，需要忽略    /bin/    /obj/   .user   .suo  等文件  \n需要在.git 同级目录（即解决方案目录）添加一个文件，名为  \".gitignore\"  \n内容为：  \n**/bin/  \n**/obj/  \n_.user  \n_.suo  \n![](file:///D:\\用户目录\\Documents\\QQEIM Files\\2880672274\\Image\\C2C\\8PAU4~}VEX3C`KAFT88ID7B.png)\n\n2、本地切换分支：git checkout  分支名称  \n        本地新建分支：git checkout -b  分支名称    \n        查看本地有哪些分支：git branch\n\n3、建议  \n   建议在做新任务时本地新建分支，完成后合并到本地的 resease 分支  \n   若需要开发其它项目，可以切换到其它分支开发。这种方法可能比 git statsh 更好\n\n4、实用命令  \n    a、删除已跟踪（add）的文件  \n        git rm --cached '文件路径'  \n    b、删除已跟踪的文件，并同时删除物理文件  \n        git rm --f '文件路径'  \n    c、查看暂存前后的变化，即查看未暂存的文件更新了哪些部分  \n        git diff  \n    d、查看暂存与上次提交时的快照之间的变化或差异  \n        git diff --cached  \n    e、若不小 add 了一个文件 a.txt，需要撤回：  \n        git reset a.txt  \n    f、查看本地有，远程没有提交  \n        git log  本地分支名称  ^远程分支名称  \n         反之，远程有本地没有  \n        git log  远程分支名称  ^本地分支名称  \n    g、查看本地已添加的远程及地址  \n        git remote -v  \n    h、查看本地所有分支  \n        git branch  \n    i、若显示太多信息，结果很久都不行，可以在按  q  结束  \n    j、显示最近 3 次的更新的文件修改统计信息  \n        git log --stat -n 3  \n    k、从服务端   总的分支 release  更新到   本地仓库分支 release  \n        git checkout release  \n        git fetch origin release  (假设你电脑的 origin 是总的 release 分支)  \n    l、重新定位本地仓库的提交点  \n        git log -n 2 (获取 hash 值)  \n        git reset dc6f6dade019663f2948a83aead8b0c92e1c3fce\n\n删除本地分支：删除本地分支    git branch -d xxxxx\n\n查看  \ngit branch -a  \n删除远程分支 git branch -r -d origin/branch-name  \ngit push origin :branch-name\n","source":"_posts/2017-08-15-Git使用教程及常用命令大全.md","raw":"---\ntitle: Git使用教程及常用命令大全\ntags:\n  - 技术\n  - git\ndate: 2017-08-15 09:14:00\ncategories: 教程\n---\n\n一、git 命令名词解释  \n1、添加/跟踪/暂存：添加到本地索引    \n      git add  文件名  \n2、提交：提交到本地仓库    \n      git commit -m '注释'  \n3、推送：将提交到本地仓库的所有更新提交到服务器    \n      git push mycode release  \n4、更新/拉取：将远程最新的仓库或拉到本地，两种方法  \n      a)  从远程获取最新版本，不会自动合并(merge)：   \n            git checkout release  \n            git fetch origin release  \n      b)  从远程获取最新版本并自动 merge：  \n            git checkout release  \n            git pull origin release  \n       方法：  \n       a)  推荐先使用第一种方法，更安全些，先 git fetch  \n       b)  再检测是否有哪些更改或是否有冲突：  \n            git log -p release..orgin/release  \n                 或  \n            git log orgin/release ^release  \n       c)  最后再合并：  \n            git merge origin/release（将 origin/release 合并到当前的分支）\n\n二、基本步骤  \n1、进入 web 端页面，从主仓储派生一个自己仓库  \n2、新建本地系统文件夹  \n3、进入文件夹，右键选择 git bash  \n4、首次下载源码    \n   git clone  派生仓库的地址  \n5、右键选择 git gui > edit > option ，左侧设置名字和邮箱（必须是注册时的邮箱）  \n6、设置远程地址：  \n    先：进入包含.git 的目录，右键选择 git bash  \n    再：git remote add mycode  派生地址  \n7、进入开发工作  \n8、提交代码：  \n   a)提交到本地索引  git add  文件名或点(.)     \n       提示 1：在 add 前，可以用 git status 查看有哪些文件被修改  \n       提示 2：输入\"git add \"  可以不断按两次 tab 键快速定位本地改过的文件，如下图：  \n      ![](file:///D:\\用户目录\\Documents\\QQEIM Files\\2880672274\\Image\\C2C\\%(`I)KVC7%0OY21$YN6`F)3.png)  \n      提示 3：VS2013 自动支持，如下右键提交即可  \n     ![](file:///D:\\用户目录\\Documents\\QQEIM Files\\2880672274\\Image\\C2C\\GKOV)%`WMN{H8XF8XUC1)`Y.png)\n\nb)提交到本地仓库  git commit -m '注释必填'  \n   c)提交到远程服务器的我的派生仓库：  \n      git push mycode release  \n      (注意：本地已经测试小组没问题后执行)  \n9、合并请求  \n     a)进入主仓库  >  合并请求  >  创建合并请求  \n     b)再次确认需要提交的文件及内容无误，最后点提交  \n     注意：从本地的 release 分支   合并到   总的 release 分支\n\nPS：在具体实践中，都用更新提交都使用 release 分支，不用 master  \n\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-  \n三、其它：  \n1、.net 项目开发，需要忽略    /bin/    /obj/   .user   .suo  等文件  \n需要在.git 同级目录（即解决方案目录）添加一个文件，名为  \".gitignore\"  \n内容为：  \n**/bin/  \n**/obj/  \n_.user  \n_.suo  \n![](file:///D:\\用户目录\\Documents\\QQEIM Files\\2880672274\\Image\\C2C\\8PAU4~}VEX3C`KAFT88ID7B.png)\n\n2、本地切换分支：git checkout  分支名称  \n        本地新建分支：git checkout -b  分支名称    \n        查看本地有哪些分支：git branch\n\n3、建议  \n   建议在做新任务时本地新建分支，完成后合并到本地的 resease 分支  \n   若需要开发其它项目，可以切换到其它分支开发。这种方法可能比 git statsh 更好\n\n4、实用命令  \n    a、删除已跟踪（add）的文件  \n        git rm --cached '文件路径'  \n    b、删除已跟踪的文件，并同时删除物理文件  \n        git rm --f '文件路径'  \n    c、查看暂存前后的变化，即查看未暂存的文件更新了哪些部分  \n        git diff  \n    d、查看暂存与上次提交时的快照之间的变化或差异  \n        git diff --cached  \n    e、若不小 add 了一个文件 a.txt，需要撤回：  \n        git reset a.txt  \n    f、查看本地有，远程没有提交  \n        git log  本地分支名称  ^远程分支名称  \n         反之，远程有本地没有  \n        git log  远程分支名称  ^本地分支名称  \n    g、查看本地已添加的远程及地址  \n        git remote -v  \n    h、查看本地所有分支  \n        git branch  \n    i、若显示太多信息，结果很久都不行，可以在按  q  结束  \n    j、显示最近 3 次的更新的文件修改统计信息  \n        git log --stat -n 3  \n    k、从服务端   总的分支 release  更新到   本地仓库分支 release  \n        git checkout release  \n        git fetch origin release  (假设你电脑的 origin 是总的 release 分支)  \n    l、重新定位本地仓库的提交点  \n        git log -n 2 (获取 hash 值)  \n        git reset dc6f6dade019663f2948a83aead8b0c92e1c3fce\n\n删除本地分支：删除本地分支    git branch -d xxxxx\n\n查看  \ngit branch -a  \n删除远程分支 git branch -r -d origin/branch-name  \ngit push origin :branch-name\n","slug":"2017-08-15-Git使用教程及常用命令大全","published":1,"updated":"2020-03-14T06:45:18.993Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvjl00084k8y4bp020he","content":"<p>一、git 命令名词解释<br>1、添加/跟踪/暂存：添加到本地索引<br>      git add  文件名<br>2、提交：提交到本地仓库<br>      git commit -m ‘注释’<br>3、推送：将提交到本地仓库的所有更新提交到服务器<br>      git push mycode release<br>4、更新/拉取：将远程最新的仓库或拉到本地，两种方法<br>      a)  从远程获取最新版本，不会自动合并(merge)：<br>            git checkout release<br>            git fetch origin release<br>      b)  从远程获取最新版本并自动 merge：<br>            git checkout release<br>            git pull origin release<br>       方法：<br>       a)  推荐先使用第一种方法，更安全些，先 git fetch<br>       b)  再检测是否有哪些更改或是否有冲突：<br>            git log -p release..orgin/release<br>                 或<br>            git log orgin/release ^release<br>       c)  最后再合并：<br>            git merge origin/release（将 origin/release 合并到当前的分支）</p>\n<p>二、基本步骤<br>1、进入 web 端页面，从主仓储派生一个自己仓库<br>2、新建本地系统文件夹<br>3、进入文件夹，右键选择 git bash<br>4、首次下载源码<br>   git clone  派生仓库的地址<br>5、右键选择 git gui &gt; edit &gt; option ，左侧设置名字和邮箱（必须是注册时的邮箱）<br>6、设置远程地址：<br>    先：进入包含.git 的目录，右键选择 git bash<br>    再：git remote add mycode  派生地址<br>7、进入开发工作<br>8、提交代码：<br>   a)提交到本地索引  git add  文件名或点(.)<br>       提示 1：在 add 前，可以用 git status 查看有哪些文件被修改<br>       提示 2：输入”git add “  可以不断按两次 tab 键快速定位本地改过的文件，如下图：<br>      ![](file:///D:\\用户目录\\Documents\\QQEIM Files\\2880672274\\Image\\C2C%(<code>I)KVC7%0OY21$YN6</code>F)3.png)<br>      提示 3：VS2013 自动支持，如下右键提交即可<br>     ![](file:///D:\\用户目录\\Documents\\QQEIM Files\\2880672274\\Image\\C2C\\GKOV)%<code>WMN{H8XF8XUC1)</code>Y.png)</p>\n<p>b)提交到本地仓库  git commit -m ‘注释必填’<br>   c)提交到远程服务器的我的派生仓库：<br>      git push mycode release<br>      (注意：本地已经测试小组没问题后执行)<br>9、合并请求<br>     a)进入主仓库  &gt;  合并请求  &gt;  创建合并请求<br>     b)再次确认需要提交的文件及内容无误，最后点提交<br>     注意：从本地的 release 分支   合并到   总的 release 分支</p>\n<p>PS：在具体实践中，都用更新提交都使用 release 分支，不用 master<br>-------------<br>三、其它：<br>1、.net 项目开发，需要忽略    /bin/    /obj/   .user   .suo  等文件<br>需要在.git 同级目录（即解决方案目录）添加一个文件，名为  “.gitignore”<br>内容为：<br>*<em>/bin/<br>*</em>/obj/<br>_.user<br>_.suo<br>![](file:///D:\\用户目录\\Documents\\QQEIM Files\\2880672274\\Image\\C2C\\8PAU4~}VEX3C`KAFT88ID7B.png)</p>\n<p>2、本地切换分支：git checkout  分支名称<br>        本地新建分支：git checkout -b  分支名称<br>        查看本地有哪些分支：git branch</p>\n<p>3、建议<br>   建议在做新任务时本地新建分支，完成后合并到本地的 resease 分支<br>   若需要开发其它项目，可以切换到其它分支开发。这种方法可能比 git statsh 更好</p>\n<p>4、实用命令<br>    a、删除已跟踪（add）的文件<br>        git rm –cached ‘文件路径’<br>    b、删除已跟踪的文件，并同时删除物理文件<br>        git rm –f ‘文件路径’<br>    c、查看暂存前后的变化，即查看未暂存的文件更新了哪些部分<br>        git diff<br>    d、查看暂存与上次提交时的快照之间的变化或差异<br>        git diff –cached<br>    e、若不小 add 了一个文件 a.txt，需要撤回：<br>        git reset a.txt<br>    f、查看本地有，远程没有提交<br>        git log  本地分支名称  ^远程分支名称<br>         反之，远程有本地没有<br>        git log  远程分支名称  ^本地分支名称<br>    g、查看本地已添加的远程及地址<br>        git remote -v<br>    h、查看本地所有分支<br>        git branch<br>    i、若显示太多信息，结果很久都不行，可以在按  q  结束<br>    j、显示最近 3 次的更新的文件修改统计信息<br>        git log –stat -n 3<br>    k、从服务端   总的分支 release  更新到   本地仓库分支 release<br>        git checkout release<br>        git fetch origin release  (假设你电脑的 origin 是总的 release 分支)<br>    l、重新定位本地仓库的提交点<br>        git log -n 2 (获取 hash 值)<br>        git reset dc6f6dade019663f2948a83aead8b0c92e1c3fce</p>\n<p>删除本地分支：删除本地分支    git branch -d xxxxx</p>\n<p>查看<br>git branch -a<br>删除远程分支 git branch -r -d origin/branch-name<br>git push origin :branch-name</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>一、git 命令名词解释<br>1、添加/跟踪/暂存：添加到本地索引<br>      git add  文件名<br>2、提交：提交到本地仓库<br>      git commit -m ‘注释’<br>3、推送：将提交到本地仓库的所有更新提交到服务器<br>      git push mycode release<br>4、更新/拉取：将远程最新的仓库或拉到本地，两种方法<br>      a)  从远程获取最新版本，不会自动合并(merge)：<br>            git checkout release<br>            git fetch origin release<br>      b)  从远程获取最新版本并自动 merge：<br>            git checkout release<br>            git pull origin release<br>       方法：<br>       a)  推荐先使用第一种方法，更安全些，先 git fetch<br>       b)  再检测是否有哪些更改或是否有冲突：<br>            git log -p release..orgin/release<br>                 或<br>            git log orgin/release ^release<br>       c)  最后再合并：<br>            git merge origin/release（将 origin/release 合并到当前的分支）</p>\n<p>二、基本步骤<br>1、进入 web 端页面，从主仓储派生一个自己仓库<br>2、新建本地系统文件夹<br>3、进入文件夹，右键选择 git bash<br>4、首次下载源码<br>   git clone  派生仓库的地址<br>5、右键选择 git gui &gt; edit &gt; option ，左侧设置名字和邮箱（必须是注册时的邮箱）<br>6、设置远程地址：<br>    先：进入包含.git 的目录，右键选择 git bash<br>    再：git remote add mycode  派生地址<br>7、进入开发工作<br>8、提交代码：<br>   a)提交到本地索引  git add  文件名或点(.)<br>       提示 1：在 add 前，可以用 git status 查看有哪些文件被修改<br>       提示 2：输入”git add “  可以不断按两次 tab 键快速定位本地改过的文件，如下图：<br>      ![](file:///D:\\用户目录\\Documents\\QQEIM Files\\2880672274\\Image\\C2C%(<code>I)KVC7%0OY21$YN6</code>F)3.png)<br>      提示 3：VS2013 自动支持，如下右键提交即可<br>     ![](file:///D:\\用户目录\\Documents\\QQEIM Files\\2880672274\\Image\\C2C\\GKOV)%<code>WMN{H8XF8XUC1)</code>Y.png)</p>\n<p>b)提交到本地仓库  git commit -m ‘注释必填’<br>   c)提交到远程服务器的我的派生仓库：<br>      git push mycode release<br>      (注意：本地已经测试小组没问题后执行)<br>9、合并请求<br>     a)进入主仓库  &gt;  合并请求  &gt;  创建合并请求<br>     b)再次确认需要提交的文件及内容无误，最后点提交<br>     注意：从本地的 release 分支   合并到   总的 release 分支</p>\n<p>PS：在具体实践中，都用更新提交都使用 release 分支，不用 master<br>-------------<br>三、其它：<br>1、.net 项目开发，需要忽略    /bin/    /obj/   .user   .suo  等文件<br>需要在.git 同级目录（即解决方案目录）添加一个文件，名为  “.gitignore”<br>内容为：<br>*<em>/bin/<br>*</em>/obj/<br>_.user<br>_.suo<br>![](file:///D:\\用户目录\\Documents\\QQEIM Files\\2880672274\\Image\\C2C\\8PAU4~}VEX3C`KAFT88ID7B.png)</p>\n<p>2、本地切换分支：git checkout  分支名称<br>        本地新建分支：git checkout -b  分支名称<br>        查看本地有哪些分支：git branch</p>\n<p>3、建议<br>   建议在做新任务时本地新建分支，完成后合并到本地的 resease 分支<br>   若需要开发其它项目，可以切换到其它分支开发。这种方法可能比 git statsh 更好</p>\n<p>4、实用命令<br>    a、删除已跟踪（add）的文件<br>        git rm –cached ‘文件路径’<br>    b、删除已跟踪的文件，并同时删除物理文件<br>        git rm –f ‘文件路径’<br>    c、查看暂存前后的变化，即查看未暂存的文件更新了哪些部分<br>        git diff<br>    d、查看暂存与上次提交时的快照之间的变化或差异<br>        git diff –cached<br>    e、若不小 add 了一个文件 a.txt，需要撤回：<br>        git reset a.txt<br>    f、查看本地有，远程没有提交<br>        git log  本地分支名称  ^远程分支名称<br>         反之，远程有本地没有<br>        git log  远程分支名称  ^本地分支名称<br>    g、查看本地已添加的远程及地址<br>        git remote -v<br>    h、查看本地所有分支<br>        git branch<br>    i、若显示太多信息，结果很久都不行，可以在按  q  结束<br>    j、显示最近 3 次的更新的文件修改统计信息<br>        git log –stat -n 3<br>    k、从服务端   总的分支 release  更新到   本地仓库分支 release<br>        git checkout release<br>        git fetch origin release  (假设你电脑的 origin 是总的 release 分支)<br>    l、重新定位本地仓库的提交点<br>        git log -n 2 (获取 hash 值)<br>        git reset dc6f6dade019663f2948a83aead8b0c92e1c3fce</p>\n<p>删除本地分支：删除本地分支    git branch -d xxxxx</p>\n<p>查看<br>git branch -a<br>删除远程分支 git branch -r -d origin/branch-name<br>git push origin :branch-name</p>\n"},{"title":"mint-ui —— navbar和tab-container的区别","date":"2017-08-17T00:15:00.000Z","_content":"\n# **navbar 的具体实现**\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/ContractedBlock-2.gif)![](http://www.jixiaokang.com/wp-content/uploads/2018/05/ExpandedBlockStart-2.gif)\n\n1 <template>  \n 2 <div class=\"page-navbar\">  \n 3 <div class=\"page-title\">Navbardiv>  \n 4  \n 5 <mt-navbar class=\"page-part\" v-model=\"selected\">  \n 6 <mt-tab-item id=\"1\">选项一 mt-tab-item>  \n 7 <mt-tab-item id=\"2\">选项二 mt-tab-item>  \n 8 <mt-tab-item id=\"3\">选项三 mt-tab-item>  \n 9 mt-navbar>  \n10  \n11 <div>  \n12 <mt-cell class=\"page-part\" title=\"当前选中\">{ { selected }}mt-cell>  \n13 div>  \n14  \n15  \n16 <mt-tab-container v-model=\"selected\">  \n17 <mt-tab-container-item id=\"1\">  \n18 <mt-cell v-for=\"n in 10\" :title=\"'内容 ' \\+ n\" />  \n19 mt-tab-container-item>  \n20 <mt-tab-container-item id=\"2\">  \n21 <mt-cell v-for=\"n in 4\" :title=\"'测试 ' \\+ n\" />  \n22 mt-tab-container-item>  \n23 <mt-tab-container-item id=\"3\">  \n24 <mt-cell v-for=\"n in 6\" :title=\"'选项 ' \\+ n\" />  \n25 mt-tab-container-item>  \n26 mt-tab-container>  \n27 div>  \n28 template>  \n29  \n30 <script>  \n31 export default { 32 name: 'page-navbar', 33  \n34 data() { 35 return { 36 selected: '1'  \n37 }; 38 } 39 }; 40 script>\n\nnavbar.vue\n\n### **Import**\n\n按需引入：\n\nimport { Navbar, TabItem } from 'mint-ui';\n\nVue.component(Navbar.name, Navbar);\n\nVue.component(TabItem.name, TabItem);\n\n全局导入：全局导入后不用再导入\n\nimportMintfrom'mint-ui'\n\nimport'mint-ui/lib/style.css'\n\nVue.use(Mint);\n\n### **API**\n\n## API\n\n### navbar\n\n参数\n\n说明\n\n类型\n\n可选值\n\n默认值\n\nfixed\n\n固定在页面顶部\n\nBoolean\n\nfalse\n\nvalue\n\n返回当前选中的 tab-item 的 id\n\n\\*\n\n### tab-item\n\n参数\n\n说明\n\n类型\n\n可选值\n\n默认值\n\nid\n\n选中后的返回值\n\n\\*\n\n## Slot\n\n### navbar\n\nname\n\n描述\n\n-\n\n内容\n\n### tab-item\n\nname\n\n描述\n\n-\n\n显示文字\n\nicon\n\nicon 图标\n\n**show：**\n\n![](http://img.blog.csdn.net/20170729231112350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWljaGFlbF9vdXlhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n点击选项二\n\n![](http://img.blog.csdn.net/20170729231121127?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWljaGFlbF9vdXlhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n# **navbar 是选项卡之间的切换，可以更改切换后选项卡的样式，因为每一个激活后都会有一个 mint-tab-item is-selected 的一个类，显示被激活，而\\*\\***tab-container 是按钮之间的切换，可以有左右滑动的特效，具体实现如下：\\*\\*\n\n# tab-container 的具体实现\n\n面板，可切换显示子页面。\n\n常与 navbar、tabbar 结合使用\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/ContractedBlock-2.gif)![](http://www.jixiaokang.com/wp-content/uploads/2018/05/ExpandedBlockStart-2.gif)\n\n1 <template>  \n 2 <div>  \n 3 <div class=\"nav\">  \n 4 <mt-button size=\"small\" @click.native.prevent=\"active = 'tab-container1'\">tab 1mt-button>  \n 5 <mt-button size=\"small\" @click.native.prevent=\"active = 'tab-container2'\">tab 2mt-button>  \n 6 <mt-button size=\"small\" @click.native.prevent=\"active = 'tab-container3'\">tab 3mt-button>  \n 7 div>  \n 8  \n 9 <div class=\"page-tab-container\">  \n10 <mt-tab-container class=\"page-tabbar-tab-container\" v-model=\"active\" swipeable>  \n11 <mt-tab-container-item id=\"tab-container1\">  \n12  \n13 <mt-cell v-for=\"n in 10\" title=\"tab-container 1\">mt-cell>  \n14 mt-tab-container-item>  \n15 <mt-tab-container-item id=\"tab-container2\">  \n16  \n17 <mt-cell v-for=\"n in 5\" title=\"tab-container 2\">mt-cell>  \n18 mt-tab-container-item>  \n19 <mt-tab-container-item id=\"tab-container3\">  \n20  \n21 <mt-cell v-for=\"n in 7\" title=\"tab-container 3\">mt-cell>  \n22 mt-tab-container-item>  \n23 mt-tab-container>  \n24 div>  \n25 div>  \n26 template>  \n27  \n28 <script>  \n29 export default { 30 name: 'page-tab-container', 31 data() { 32 return { 33 active: 'tab-container1'  \n34 }; 35 } 36 }; 37 script>  \n38  \n39 <style lang=\"css\" scoped>  \n40 .item {  \n41 display: inline-block;  \n42 }  \n43  \n44 .nav {  \n45 padding: 10px;  \n46 }  \n47  \n48 .link {  \n49 color: inherit;  \n50 padding: 20px;  \n51 display: block;  \n52 }  \n53 style>\n\ntab-container.vue\n\n### **Import**\n\n按需引入：\n\nimport { TabContainer, TabContainerItem } from 'mint-ui';\n\nVue.component(TabContainer.name, TabContainer);\n\nVue.component(TabContainerItem.name, TabContainerItem);\n\n全局导入：全局导入后不用再导入\n\nimportMintfrom'mint-ui'\n\nimport'mint-ui/lib/style.css'\n\nVue.use(Mint);\n\n### **API**\n\n## API\n\n### tab-container\n\n参数\n\n说明\n\n类型\n\n可选值\n\n默认值\n\nvalue\n\n当前激活的 id\n\n\\*\n\nswipeable\n\n显示滑动效果\n\nBoolean\n\nfalse\n\n### tab-container-item\n\n参数\n\n说明\n\n类型\n\n可选值\n\n默认值\n\nid\n\nitem 的 id\n\n\\*\n\n## Slot\n\n### tab-container\n\nname\n\n描述\n\n-\n\n内容\n\n### tab-container-item\n\nname\n\n描述\n\n-\n\n内容\n\nshow**：**\n\n![](http://img.blog.csdn.net/20170803105647087?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWljaGFlbF9vdXlhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n","source":"_posts/2017-08-17-mint-ui —— navbar和tab-container的区别.md","raw":"---\ntitle: mint-ui —— navbar和tab-container的区别\ntags:\n  - 技术\n  - vue\ndate: 2017-08-17 08:15:00\ncategories: 前端\n---\n\n# **navbar 的具体实现**\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/ContractedBlock-2.gif)![](http://www.jixiaokang.com/wp-content/uploads/2018/05/ExpandedBlockStart-2.gif)\n\n1 <template>  \n 2 <div class=\"page-navbar\">  \n 3 <div class=\"page-title\">Navbardiv>  \n 4  \n 5 <mt-navbar class=\"page-part\" v-model=\"selected\">  \n 6 <mt-tab-item id=\"1\">选项一 mt-tab-item>  \n 7 <mt-tab-item id=\"2\">选项二 mt-tab-item>  \n 8 <mt-tab-item id=\"3\">选项三 mt-tab-item>  \n 9 mt-navbar>  \n10  \n11 <div>  \n12 <mt-cell class=\"page-part\" title=\"当前选中\">{ { selected }}mt-cell>  \n13 div>  \n14  \n15  \n16 <mt-tab-container v-model=\"selected\">  \n17 <mt-tab-container-item id=\"1\">  \n18 <mt-cell v-for=\"n in 10\" :title=\"'内容 ' \\+ n\" />  \n19 mt-tab-container-item>  \n20 <mt-tab-container-item id=\"2\">  \n21 <mt-cell v-for=\"n in 4\" :title=\"'测试 ' \\+ n\" />  \n22 mt-tab-container-item>  \n23 <mt-tab-container-item id=\"3\">  \n24 <mt-cell v-for=\"n in 6\" :title=\"'选项 ' \\+ n\" />  \n25 mt-tab-container-item>  \n26 mt-tab-container>  \n27 div>  \n28 template>  \n29  \n30 <script>  \n31 export default { 32 name: 'page-navbar', 33  \n34 data() { 35 return { 36 selected: '1'  \n37 }; 38 } 39 }; 40 script>\n\nnavbar.vue\n\n### **Import**\n\n按需引入：\n\nimport { Navbar, TabItem } from 'mint-ui';\n\nVue.component(Navbar.name, Navbar);\n\nVue.component(TabItem.name, TabItem);\n\n全局导入：全局导入后不用再导入\n\nimportMintfrom'mint-ui'\n\nimport'mint-ui/lib/style.css'\n\nVue.use(Mint);\n\n### **API**\n\n## API\n\n### navbar\n\n参数\n\n说明\n\n类型\n\n可选值\n\n默认值\n\nfixed\n\n固定在页面顶部\n\nBoolean\n\nfalse\n\nvalue\n\n返回当前选中的 tab-item 的 id\n\n\\*\n\n### tab-item\n\n参数\n\n说明\n\n类型\n\n可选值\n\n默认值\n\nid\n\n选中后的返回值\n\n\\*\n\n## Slot\n\n### navbar\n\nname\n\n描述\n\n-\n\n内容\n\n### tab-item\n\nname\n\n描述\n\n-\n\n显示文字\n\nicon\n\nicon 图标\n\n**show：**\n\n![](http://img.blog.csdn.net/20170729231112350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWljaGFlbF9vdXlhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n点击选项二\n\n![](http://img.blog.csdn.net/20170729231121127?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWljaGFlbF9vdXlhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n# **navbar 是选项卡之间的切换，可以更改切换后选项卡的样式，因为每一个激活后都会有一个 mint-tab-item is-selected 的一个类，显示被激活，而\\*\\***tab-container 是按钮之间的切换，可以有左右滑动的特效，具体实现如下：\\*\\*\n\n# tab-container 的具体实现\n\n面板，可切换显示子页面。\n\n常与 navbar、tabbar 结合使用\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/ContractedBlock-2.gif)![](http://www.jixiaokang.com/wp-content/uploads/2018/05/ExpandedBlockStart-2.gif)\n\n1 <template>  \n 2 <div>  \n 3 <div class=\"nav\">  \n 4 <mt-button size=\"small\" @click.native.prevent=\"active = 'tab-container1'\">tab 1mt-button>  \n 5 <mt-button size=\"small\" @click.native.prevent=\"active = 'tab-container2'\">tab 2mt-button>  \n 6 <mt-button size=\"small\" @click.native.prevent=\"active = 'tab-container3'\">tab 3mt-button>  \n 7 div>  \n 8  \n 9 <div class=\"page-tab-container\">  \n10 <mt-tab-container class=\"page-tabbar-tab-container\" v-model=\"active\" swipeable>  \n11 <mt-tab-container-item id=\"tab-container1\">  \n12  \n13 <mt-cell v-for=\"n in 10\" title=\"tab-container 1\">mt-cell>  \n14 mt-tab-container-item>  \n15 <mt-tab-container-item id=\"tab-container2\">  \n16  \n17 <mt-cell v-for=\"n in 5\" title=\"tab-container 2\">mt-cell>  \n18 mt-tab-container-item>  \n19 <mt-tab-container-item id=\"tab-container3\">  \n20  \n21 <mt-cell v-for=\"n in 7\" title=\"tab-container 3\">mt-cell>  \n22 mt-tab-container-item>  \n23 mt-tab-container>  \n24 div>  \n25 div>  \n26 template>  \n27  \n28 <script>  \n29 export default { 30 name: 'page-tab-container', 31 data() { 32 return { 33 active: 'tab-container1'  \n34 }; 35 } 36 }; 37 script>  \n38  \n39 <style lang=\"css\" scoped>  \n40 .item {  \n41 display: inline-block;  \n42 }  \n43  \n44 .nav {  \n45 padding: 10px;  \n46 }  \n47  \n48 .link {  \n49 color: inherit;  \n50 padding: 20px;  \n51 display: block;  \n52 }  \n53 style>\n\ntab-container.vue\n\n### **Import**\n\n按需引入：\n\nimport { TabContainer, TabContainerItem } from 'mint-ui';\n\nVue.component(TabContainer.name, TabContainer);\n\nVue.component(TabContainerItem.name, TabContainerItem);\n\n全局导入：全局导入后不用再导入\n\nimportMintfrom'mint-ui'\n\nimport'mint-ui/lib/style.css'\n\nVue.use(Mint);\n\n### **API**\n\n## API\n\n### tab-container\n\n参数\n\n说明\n\n类型\n\n可选值\n\n默认值\n\nvalue\n\n当前激活的 id\n\n\\*\n\nswipeable\n\n显示滑动效果\n\nBoolean\n\nfalse\n\n### tab-container-item\n\n参数\n\n说明\n\n类型\n\n可选值\n\n默认值\n\nid\n\nitem 的 id\n\n\\*\n\n## Slot\n\n### tab-container\n\nname\n\n描述\n\n-\n\n内容\n\n### tab-container-item\n\nname\n\n描述\n\n-\n\n内容\n\nshow**：**\n\n![](http://img.blog.csdn.net/20170803105647087?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWljaGFlbF9vdXlhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n","slug":"2017-08-17-mint-ui —— navbar和tab-container的区别","published":1,"updated":"2020-03-14T06:45:29.151Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvjn000a4k8y3nuuam3b","content":"<h1 id=\"navbar-的具体实现\"><a href=\"#navbar-的具体实现\" class=\"headerlink\" title=\"navbar 的具体实现\"></a><strong>navbar 的具体实现</strong></h1><p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/ContractedBlock-2.gif\" alt=\"\">)<img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/ExpandedBlockStart-2.gif\" alt=\"\"></p>\n<p>1 <template><br> 2 <div class=\"page-navbar\"><br> 3 <div class=\"page-title\">Navbardiv&gt;<br> 4<br> 5 <mt-navbar class=\"page-part\" v-model=\"selected\"><br> 6 <mt-tab-item id=\"1\">选项一 mt-tab-item&gt;<br> 7 <mt-tab-item id=\"2\">选项二 mt-tab-item&gt;<br> 8 <mt-tab-item id=\"3\">选项三 mt-tab-item&gt;<br> 9 mt-navbar&gt;<br>10<br>11 <div><br>12 <mt-cell class=\"page-part\" title=\"当前选中\">{ { selected }}mt-cell&gt;<br>13 div&gt;<br>14<br>15<br>16 <mt-tab-container v-model=\"selected\"><br>17 <mt-tab-container-item id=\"1\"><br>18 <mt-cell v-for=\"n in 10\" :title=\"'内容 ' \\+ n\" /><br>19 mt-tab-container-item&gt;<br>20 <mt-tab-container-item id=\"2\"><br>21 <mt-cell v-for=\"n in 4\" :title=\"'测试 ' \\+ n\" /><br>22 mt-tab-container-item&gt;<br>23 <mt-tab-container-item id=\"3\"><br>24 <mt-cell v-for=\"n in 6\" :title=\"'选项 ' \\+ n\" /><br>25 mt-tab-container-item&gt;<br>26 mt-tab-container&gt;<br>27 div&gt;<br>28 template&gt;<br>29<br>30 <script><br>31 export default { 32 name: 'page-navbar', 33<br>34 data() { 35 return { 36 selected: '1'<br>37 }; 38 } 39 }; 40 script></p>\n<p>navbar.vue</p>\n<h3 id=\"Import\"><a href=\"#Import\" class=\"headerlink\" title=\"Import\"></a><strong>Import</strong></h3><p>按需引入：</p>\n<p>import { Navbar, TabItem } from 'mint-ui';</p>\n<p>Vue.component(Navbar.name, Navbar);</p>\n<p>Vue.component(TabItem.name, TabItem);</p>\n<p>全局导入：全局导入后不用再导入</p>\n<p>importMintfrom'mint-ui'</p>\n<p>import'mint-ui/lib/style.css'</p>\n<p>Vue.use(Mint);</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a><strong>API</strong></h3><h2 id=\"API-1\"><a href=\"#API-1\" class=\"headerlink\" title=\"API\"></a>API</h2><h3 id=\"navbar\"><a href=\"#navbar\" class=\"headerlink\" title=\"navbar\"></a>navbar</h3><p>参数</p>\n<p>说明</p>\n<p>类型</p>\n<p>可选值</p>\n<p>默认值</p>\n<p>fixed</p>\n<p>固定在页面顶部</p>\n<p>Boolean</p>\n<p>false</p>\n<p>value</p>\n<p>返回当前选中的 tab-item 的 id</p>\n<p>*</p>\n<h3 id=\"tab-item\"><a href=\"#tab-item\" class=\"headerlink\" title=\"tab-item\"></a>tab-item</h3><p>参数</p>\n<p>说明</p>\n<p>类型</p>\n<p>可选值</p>\n<p>默认值</p>\n<p>id</p>\n<p>选中后的返回值</p>\n<p>*</p>\n<h2 id=\"Slot\"><a href=\"#Slot\" class=\"headerlink\" title=\"Slot\"></a>Slot</h2><h3 id=\"navbar-1\"><a href=\"#navbar-1\" class=\"headerlink\" title=\"navbar\"></a>navbar</h3><p>name</p>\n<p>描述</p>\n<p>-</p>\n<p>内容</p>\n<h3 id=\"tab-item-1\"><a href=\"#tab-item-1\" class=\"headerlink\" title=\"tab-item\"></a>tab-item</h3><p>name</p>\n<p>描述</p>\n<p>-</p>\n<p>显示文字</p>\n<p>icon</p>\n<p>icon 图标</p>\n<p><strong>show：</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20170729231112350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWljaGFlbF9vdXlhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>点击选项二</p>\n<p><img src=\"http://img.blog.csdn.net/20170729231121127?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWljaGFlbF9vdXlhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<h1 id=\"navbar-是选项卡之间的切换，可以更改切换后选项卡的样式，因为每一个激活后都会有一个-mint-tab-item-is-selected-的一个类，显示被激活，而-tab-container-是按钮之间的切换，可以有左右滑动的特效，具体实现如下：\"><a href=\"#navbar-是选项卡之间的切换，可以更改切换后选项卡的样式，因为每一个激活后都会有一个-mint-tab-item-is-selected-的一个类，显示被激活，而-tab-container-是按钮之间的切换，可以有左右滑动的特效，具体实现如下：\" class=\"headerlink\" title=\"navbar 是选项卡之间的切换，可以更改切换后选项卡的样式，因为每一个激活后都会有一个 mint-tab-item is-selected 的一个类，显示被激活，而**tab-container 是按钮之间的切换，可以有左右滑动的特效，具体实现如下：**\"></a><strong>navbar 是选项卡之间的切换，可以更改切换后选项卡的样式，因为每一个激活后都会有一个 mint-tab-item is-selected 的一个类，显示被激活，而**</strong>tab-container 是按钮之间的切换，可以有左右滑动的特效，具体实现如下：**</h1><h1 id=\"tab-container-的具体实现\"><a href=\"#tab-container-的具体实现\" class=\"headerlink\" title=\"tab-container 的具体实现\"></a>tab-container 的具体实现</h1><p>面板，可切换显示子页面。</p>\n<p>常与 navbar、tabbar 结合使用</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/ContractedBlock-2.gif\" alt=\"\">)<img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/ExpandedBlockStart-2.gif\" alt=\"\"></p>\n<p>1 <template><br> 2 <div><br> 3 <div class=\"nav\"><br> 4 <mt-button size=\"small\" @click.native.prevent=\"active = 'tab-container1'\">tab 1mt-button><br> 5 <mt-button size=\"small\" @click.native.prevent=\"active = 'tab-container2'\">tab 2mt-button><br> 6 <mt-button size=\"small\" @click.native.prevent=\"active = 'tab-container3'\">tab 3mt-button><br> 7 div><br> 8<br> 9 <div class=\"page-tab-container\"><br>10 <mt-tab-container class=\"page-tabbar-tab-container\" v-model=\"active\" swipeable><br>11 <mt-tab-container-item id=\"tab-container1\"><br>12<br>13 <mt-cell v-for=\"n in 10\" title=\"tab-container 1\">mt-cell><br>14 mt-tab-container-item><br>15 <mt-tab-container-item id=\"tab-container2\"><br>16<br>17 <mt-cell v-for=\"n in 5\" title=\"tab-container 2\">mt-cell><br>18 mt-tab-container-item><br>19 <mt-tab-container-item id=\"tab-container3\"><br>20<br>21 <mt-cell v-for=\"n in 7\" title=\"tab-container 3\">mt-cell><br>22 mt-tab-container-item><br>23 mt-tab-container><br>24 div><br>25 div><br>26 template><br>27<br>28 <script><br>29 export default { 30 name: 'page-tab-container', 31 data() { 32 return { 33 active: 'tab-container1'<br>34 }; 35 } 36 }; 37 script><br>38<br>39 <style lang=\"css\" scoped><br>40 .item {<br>41 display: inline-block;<br>42 }<br>43<br>44 .nav {<br>45 padding: 10px;<br>46 }<br>47<br>48 .link {<br>49 color: inherit;<br>50 padding: 20px;<br>51 display: block;<br>52 }<br>53 style></p>\n<p>tab-container.vue</p>\n<h3 id=\"Import-1\"><a href=\"#Import-1\" class=\"headerlink\" title=\"Import\"></a><strong>Import</strong></h3><p>按需引入：</p>\n<p>import { TabContainer, TabContainerItem } from 'mint-ui';</p>\n<p>Vue.component(TabContainer.name, TabContainer);</p>\n<p>Vue.component(TabContainerItem.name, TabContainerItem);</p>\n<p>全局导入：全局导入后不用再导入</p>\n<p>importMintfrom'mint-ui'</p>\n<p>import'mint-ui/lib/style.css'</p>\n<p>Vue.use(Mint);</p>\n<h3 id=\"API-2\"><a href=\"#API-2\" class=\"headerlink\" title=\"API\"></a><strong>API</strong></h3><h2 id=\"API-3\"><a href=\"#API-3\" class=\"headerlink\" title=\"API\"></a>API</h2><h3 id=\"tab-container\"><a href=\"#tab-container\" class=\"headerlink\" title=\"tab-container\"></a>tab-container</h3><p>参数</p>\n<p>说明</p>\n<p>类型</p>\n<p>可选值</p>\n<p>默认值</p>\n<p>value</p>\n<p>当前激活的 id</p>\n<p>*</p>\n<p>swipeable</p>\n<p>显示滑动效果</p>\n<p>Boolean</p>\n<p>false</p>\n<h3 id=\"tab-container-item\"><a href=\"#tab-container-item\" class=\"headerlink\" title=\"tab-container-item\"></a>tab-container-item</h3><p>参数</p>\n<p>说明</p>\n<p>类型</p>\n<p>可选值</p>\n<p>默认值</p>\n<p>id</p>\n<p>item 的 id</p>\n<p>*</p>\n<h2 id=\"Slot-1\"><a href=\"#Slot-1\" class=\"headerlink\" title=\"Slot\"></a>Slot</h2><h3 id=\"tab-container-1\"><a href=\"#tab-container-1\" class=\"headerlink\" title=\"tab-container\"></a>tab-container</h3><p>name</p>\n<p>描述</p>\n<p>-</p>\n<p>内容</p>\n<h3 id=\"tab-container-item-1\"><a href=\"#tab-container-item-1\" class=\"headerlink\" title=\"tab-container-item\"></a>tab-container-item</h3><p>name</p>\n<p>描述</p>\n<p>-</p>\n<p>内容</p>\n<p>show<strong>：</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20170803105647087?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWljaGFlbF9vdXlhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h1 id=\"navbar-的具体实现\"><a href=\"#navbar-的具体实现\" class=\"headerlink\" title=\"navbar 的具体实现\"></a><strong>navbar 的具体实现</strong></h1><p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/ContractedBlock-2.gif\" alt=\"\">)<img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/ExpandedBlockStart-2.gif\" alt=\"\"></p>\n<p>1 <template><br> 2 <div class=\"page-navbar\"><br> 3 <div class=\"page-title\">Navbardiv&gt;<br> 4<br> 5 <mt-navbar class=\"page-part\" v-model=\"selected\"><br> 6 <mt-tab-item id=\"1\">选项一 mt-tab-item&gt;<br> 7 <mt-tab-item id=\"2\">选项二 mt-tab-item&gt;<br> 8 <mt-tab-item id=\"3\">选项三 mt-tab-item&gt;<br> 9 mt-navbar&gt;<br>10<br>11 <div><br>12 <mt-cell class=\"page-part\" title=\"当前选中\">{ { selected }}mt-cell&gt;<br>13 div&gt;<br>14<br>15<br>16 <mt-tab-container v-model=\"selected\"><br>17 <mt-tab-container-item id=\"1\"><br>18 <mt-cell v-for=\"n in 10\" :title=\"'内容 ' \\+ n\" /><br>19 mt-tab-container-item&gt;<br>20 <mt-tab-container-item id=\"2\"><br>21 <mt-cell v-for=\"n in 4\" :title=\"'测试 ' \\+ n\" /><br>22 mt-tab-container-item&gt;<br>23 <mt-tab-container-item id=\"3\"><br>24 <mt-cell v-for=\"n in 6\" :title=\"'选项 ' \\+ n\" /><br>25 mt-tab-container-item&gt;<br>26 mt-tab-container&gt;<br>27 div&gt;<br>28 template&gt;<br>29<br>30 <script><br>31 export default { 32 name: 'page-navbar', 33<br>34 data() { 35 return { 36 selected: '1'<br>37 }; 38 } 39 }; 40 script></p>\n<p>navbar.vue</p>\n<h3 id=\"Import\"><a href=\"#Import\" class=\"headerlink\" title=\"Import\"></a><strong>Import</strong></h3><p>按需引入：</p>\n<p>import { Navbar, TabItem } from 'mint-ui';</p>\n<p>Vue.component(Navbar.name, Navbar);</p>\n<p>Vue.component(TabItem.name, TabItem);</p>\n<p>全局导入：全局导入后不用再导入</p>\n<p>importMintfrom'mint-ui'</p>\n<p>import'mint-ui/lib/style.css'</p>\n<p>Vue.use(Mint);</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a><strong>API</strong></h3><h2 id=\"API-1\"><a href=\"#API-1\" class=\"headerlink\" title=\"API\"></a>API</h2><h3 id=\"navbar\"><a href=\"#navbar\" class=\"headerlink\" title=\"navbar\"></a>navbar</h3><p>参数</p>\n<p>说明</p>\n<p>类型</p>\n<p>可选值</p>\n<p>默认值</p>\n<p>fixed</p>\n<p>固定在页面顶部</p>\n<p>Boolean</p>\n<p>false</p>\n<p>value</p>\n<p>返回当前选中的 tab-item 的 id</p>\n<p>*</p>\n<h3 id=\"tab-item\"><a href=\"#tab-item\" class=\"headerlink\" title=\"tab-item\"></a>tab-item</h3><p>参数</p>\n<p>说明</p>\n<p>类型</p>\n<p>可选值</p>\n<p>默认值</p>\n<p>id</p>\n<p>选中后的返回值</p>\n<p>*</p>\n<h2 id=\"Slot\"><a href=\"#Slot\" class=\"headerlink\" title=\"Slot\"></a>Slot</h2><h3 id=\"navbar-1\"><a href=\"#navbar-1\" class=\"headerlink\" title=\"navbar\"></a>navbar</h3><p>name</p>\n<p>描述</p>\n<p>-</p>\n<p>内容</p>\n<h3 id=\"tab-item-1\"><a href=\"#tab-item-1\" class=\"headerlink\" title=\"tab-item\"></a>tab-item</h3><p>name</p>\n<p>描述</p>\n<p>-</p>\n<p>显示文字</p>\n<p>icon</p>\n<p>icon 图标</p>\n<p><strong>show：</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20170729231112350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWljaGFlbF9vdXlhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<p>点击选项二</p>\n<p><img src=\"http://img.blog.csdn.net/20170729231121127?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWljaGFlbF9vdXlhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n<h1 id=\"navbar-是选项卡之间的切换，可以更改切换后选项卡的样式，因为每一个激活后都会有一个-mint-tab-item-is-selected-的一个类，显示被激活，而-tab-container-是按钮之间的切换，可以有左右滑动的特效，具体实现如下：\"><a href=\"#navbar-是选项卡之间的切换，可以更改切换后选项卡的样式，因为每一个激活后都会有一个-mint-tab-item-is-selected-的一个类，显示被激活，而-tab-container-是按钮之间的切换，可以有左右滑动的特效，具体实现如下：\" class=\"headerlink\" title=\"navbar 是选项卡之间的切换，可以更改切换后选项卡的样式，因为每一个激活后都会有一个 mint-tab-item is-selected 的一个类，显示被激活，而**tab-container 是按钮之间的切换，可以有左右滑动的特效，具体实现如下：**\"></a><strong>navbar 是选项卡之间的切换，可以更改切换后选项卡的样式，因为每一个激活后都会有一个 mint-tab-item is-selected 的一个类，显示被激活，而**</strong>tab-container 是按钮之间的切换，可以有左右滑动的特效，具体实现如下：**</h1><h1 id=\"tab-container-的具体实现\"><a href=\"#tab-container-的具体实现\" class=\"headerlink\" title=\"tab-container 的具体实现\"></a>tab-container 的具体实现</h1><p>面板，可切换显示子页面。</p>\n<p>常与 navbar、tabbar 结合使用</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/ContractedBlock-2.gif\" alt=\"\">)<img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/ExpandedBlockStart-2.gif\" alt=\"\"></p>\n<p>1 <template><br> 2 <div><br> 3 <div class=\"nav\"><br> 4 <mt-button size=\"small\" @click.native.prevent=\"active = 'tab-container1'\">tab 1mt-button><br> 5 <mt-button size=\"small\" @click.native.prevent=\"active = 'tab-container2'\">tab 2mt-button><br> 6 <mt-button size=\"small\" @click.native.prevent=\"active = 'tab-container3'\">tab 3mt-button><br> 7 div><br> 8<br> 9 <div class=\"page-tab-container\"><br>10 <mt-tab-container class=\"page-tabbar-tab-container\" v-model=\"active\" swipeable><br>11 <mt-tab-container-item id=\"tab-container1\"><br>12<br>13 <mt-cell v-for=\"n in 10\" title=\"tab-container 1\">mt-cell><br>14 mt-tab-container-item><br>15 <mt-tab-container-item id=\"tab-container2\"><br>16<br>17 <mt-cell v-for=\"n in 5\" title=\"tab-container 2\">mt-cell><br>18 mt-tab-container-item><br>19 <mt-tab-container-item id=\"tab-container3\"><br>20<br>21 <mt-cell v-for=\"n in 7\" title=\"tab-container 3\">mt-cell><br>22 mt-tab-container-item><br>23 mt-tab-container><br>24 div><br>25 div><br>26 template><br>27<br>28 <script><br>29 export default { 30 name: 'page-tab-container', 31 data() { 32 return { 33 active: 'tab-container1'<br>34 }; 35 } 36 }; 37 script><br>38<br>39 <style lang=\"css\" scoped><br>40 .item {<br>41 display: inline-block;<br>42 }<br>43<br>44 .nav {<br>45 padding: 10px;<br>46 }<br>47<br>48 .link {<br>49 color: inherit;<br>50 padding: 20px;<br>51 display: block;<br>52 }<br>53 style></p>\n<p>tab-container.vue</p>\n<h3 id=\"Import-1\"><a href=\"#Import-1\" class=\"headerlink\" title=\"Import\"></a><strong>Import</strong></h3><p>按需引入：</p>\n<p>import { TabContainer, TabContainerItem } from 'mint-ui';</p>\n<p>Vue.component(TabContainer.name, TabContainer);</p>\n<p>Vue.component(TabContainerItem.name, TabContainerItem);</p>\n<p>全局导入：全局导入后不用再导入</p>\n<p>importMintfrom'mint-ui'</p>\n<p>import'mint-ui/lib/style.css'</p>\n<p>Vue.use(Mint);</p>\n<h3 id=\"API-2\"><a href=\"#API-2\" class=\"headerlink\" title=\"API\"></a><strong>API</strong></h3><h2 id=\"API-3\"><a href=\"#API-3\" class=\"headerlink\" title=\"API\"></a>API</h2><h3 id=\"tab-container\"><a href=\"#tab-container\" class=\"headerlink\" title=\"tab-container\"></a>tab-container</h3><p>参数</p>\n<p>说明</p>\n<p>类型</p>\n<p>可选值</p>\n<p>默认值</p>\n<p>value</p>\n<p>当前激活的 id</p>\n<p>*</p>\n<p>swipeable</p>\n<p>显示滑动效果</p>\n<p>Boolean</p>\n<p>false</p>\n<h3 id=\"tab-container-item\"><a href=\"#tab-container-item\" class=\"headerlink\" title=\"tab-container-item\"></a>tab-container-item</h3><p>参数</p>\n<p>说明</p>\n<p>类型</p>\n<p>可选值</p>\n<p>默认值</p>\n<p>id</p>\n<p>item 的 id</p>\n<p>*</p>\n<h2 id=\"Slot-1\"><a href=\"#Slot-1\" class=\"headerlink\" title=\"Slot\"></a>Slot</h2><h3 id=\"tab-container-1\"><a href=\"#tab-container-1\" class=\"headerlink\" title=\"tab-container\"></a>tab-container</h3><p>name</p>\n<p>描述</p>\n<p>-</p>\n<p>内容</p>\n<h3 id=\"tab-container-item-1\"><a href=\"#tab-container-item-1\" class=\"headerlink\" title=\"tab-container-item\"></a>tab-container-item</h3><p>name</p>\n<p>描述</p>\n<p>-</p>\n<p>内容</p>\n<p>show<strong>：</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20170803105647087?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWljaGFlbF9vdXlhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></p>\n"},{"title":"公司Git实用记录","date":"2017-08-23T02:38:00.000Z","_content":"\n**一、git 命令名词解释**\n\n1、添加/跟踪/暂存：添加到本地索引\n\ngit add 文件名\n\n2、提交：提交到本地仓库\n\ngit commit -m '注释'\n\n3、推送：将提交到本地仓库的所有更新提交到服务器\n\ngit push mycode release\n\n4、更新/拉取：将远程最新的仓库或拉到本地，两种方法  \na) 从远程获取最新版本，不会自动合并(merge)：\n\ngit checkout release\n\ngit fetch origin release\n\nb) 从远程获取最新版本并自动 merge：\n\ngit checkout release\n\ngit pull origin release\n\n方法：\n\na) 推荐先使用第一种方法，更安全些，先 git fetch\n\nb) 再检测是否有哪些更改或是否有冲突：\n\ngit log -p release..orgin/release\n\n或\n\ngit log orgin/release ^release\n\nc) 最后再合并：\n\ngit merge origin/release（将 origin/release 合并到当前的分支）\n\n**二、基本步骤**\n\n1、进入 web 端页面，从主仓储派生一个自己仓库\n\n2、新建本地系统文件夹\n\n3、进入文件夹，右键选择 git bash\n\n4、首次下载源码\n\ngit clone 派生仓库的地址\n\n5、右键选择 git gui > edit > option ，左侧设置名字和邮箱（必须是注册时的邮箱）\n\n6、设置远程地址：\n\n先：进入包含.git 的目录，右键选择 git bash\n\n再：git remote add mycode 派生地址\n\n7、进入开发工作\n\n8、提交代码：\n\na)提交到本地索引 git add 文件名或点(.)\n\n提示 1：在 add 前，可以用 git status 查看有哪些文件被修改\n\n提示 2：输入\"git add \" 可以不断按两次 tab 键快速定位本地改过的文件，如下图：\n\n![](http://note.youdao.com/yws/public/resource/bfdf6863b921ed753d6a3f93b19bb513/6DAFFB28BAF04F01B94CF290865B5974)\n\n提示 3：VS2013 自动支持，如下右键提交即可\n\n![](http://note.youdao.com/yws/public/resource/bfdf6863b921ed753d6a3f93b19bb513/AED5D15984704D3E989D27B4463B9289)\n\nb)提交到本地仓库 git commit -m '注释必填'\n\nc)提交到远程服务器的我的派生仓库：\n\ngit push mycode release\n\n(注意：本地已经测试小组没问题后执行)\n\n9、合并请求\n\na)进入主仓库 >  合并请求 > 创建合并请求\n\nb)再次确认需要提交的文件及内容无误，最后点提交\n\n注意：从本地的 release 分支 合并到 总的 release 分支\n\n**PS：在具体实践中，都用更新提交都使用 release 分支，不用 master**\n\n\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\n\n**三、其它：**\n\n**1、.net 项目开发，需要忽略  /bin/ /obj/ .user .suo  等文件**\n\n**需要在.git 同级目录（即解决方案目录）添加一个文件，名为 \".gitignore\"**\n\n内容为：\n\n\\*\\*/bin/\n\n\\*\\*/obj/\n\n\\*.user\n\n\\*.suo\n\n![](http://note.youdao.com/yws/public/resource/bfdf6863b921ed753d6a3f93b19bb513/3EFE59705E6845F99CDF66D88164485E)\n\n2、本地切换分支：git checkout 分支名称\n\n本地新建分支：git checkout -b 分支名称\n\n查看本地有哪些分支：git branch\n\n3、建议\n\n建议在做新任务时本地新建分支，完成后合并到本地的 resease 分支\n\n若需要开发其它项目，可以切换到其它分支开发。这种方法可能比 git statsh 更好\n\n4、实用命令\n\na、删除已跟踪（add）的文件\n\ngit rm --cached '文件路径'\n\nb、删除已跟踪的文件，并同时删除物理文件\n\ngit rm --f '文件路径'\n\nc、查看暂存前后的变化，即查看未暂存的文件更新了哪些部分\n\ngit diff\n\nd、查看暂存与上次提交时的快照之间的变化或差异\n\ngit diff --cached\n\ne、若不小 add 了一个文件 a.txt，需要撤回：\n\ngit reset a.txt\n\nf、查看本地有，远程没有提交\n\ngit log 本地分支名称 ^远程分支名称\n\n反之，远程有本地没有\n\ngit log  远程分支名称 ^本地分支名称\n\ng、查看本地已添加的远程及地址\n\ngit remote -v\n\nh、查看本地所有分支\n\ngit branch\n\ni、若显示太多信息，结果很久都不行，可以在按 q 结束\n\nj、显示最近 3 次的更新的文件修改统计信息\n\ngit log --stat -n 3\n\nk、从服务端 总的分支 release 更新到 本地仓库分支 release\n\ngit checkout release\n\ngit fetch origin release (假设你电脑的 origin 是总的 release 分支)\n\nl、重新定位本地仓库的提交点\n\ngit log -n 2 (获取 hash 值)\n\ngit reset dc6f6dade019663f2948a83aead8b0c92e1c3fce\n","source":"_posts/2017-08-23-git使用记录.md","raw":"---\ntitle: 公司Git实用记录\ntags:\n  - git\ndate: 2017-08-23 10:38:00\ncategories: 教程\n---\n\n**一、git 命令名词解释**\n\n1、添加/跟踪/暂存：添加到本地索引\n\ngit add 文件名\n\n2、提交：提交到本地仓库\n\ngit commit -m '注释'\n\n3、推送：将提交到本地仓库的所有更新提交到服务器\n\ngit push mycode release\n\n4、更新/拉取：将远程最新的仓库或拉到本地，两种方法  \na) 从远程获取最新版本，不会自动合并(merge)：\n\ngit checkout release\n\ngit fetch origin release\n\nb) 从远程获取最新版本并自动 merge：\n\ngit checkout release\n\ngit pull origin release\n\n方法：\n\na) 推荐先使用第一种方法，更安全些，先 git fetch\n\nb) 再检测是否有哪些更改或是否有冲突：\n\ngit log -p release..orgin/release\n\n或\n\ngit log orgin/release ^release\n\nc) 最后再合并：\n\ngit merge origin/release（将 origin/release 合并到当前的分支）\n\n**二、基本步骤**\n\n1、进入 web 端页面，从主仓储派生一个自己仓库\n\n2、新建本地系统文件夹\n\n3、进入文件夹，右键选择 git bash\n\n4、首次下载源码\n\ngit clone 派生仓库的地址\n\n5、右键选择 git gui > edit > option ，左侧设置名字和邮箱（必须是注册时的邮箱）\n\n6、设置远程地址：\n\n先：进入包含.git 的目录，右键选择 git bash\n\n再：git remote add mycode 派生地址\n\n7、进入开发工作\n\n8、提交代码：\n\na)提交到本地索引 git add 文件名或点(.)\n\n提示 1：在 add 前，可以用 git status 查看有哪些文件被修改\n\n提示 2：输入\"git add \" 可以不断按两次 tab 键快速定位本地改过的文件，如下图：\n\n![](http://note.youdao.com/yws/public/resource/bfdf6863b921ed753d6a3f93b19bb513/6DAFFB28BAF04F01B94CF290865B5974)\n\n提示 3：VS2013 自动支持，如下右键提交即可\n\n![](http://note.youdao.com/yws/public/resource/bfdf6863b921ed753d6a3f93b19bb513/AED5D15984704D3E989D27B4463B9289)\n\nb)提交到本地仓库 git commit -m '注释必填'\n\nc)提交到远程服务器的我的派生仓库：\n\ngit push mycode release\n\n(注意：本地已经测试小组没问题后执行)\n\n9、合并请求\n\na)进入主仓库 >  合并请求 > 创建合并请求\n\nb)再次确认需要提交的文件及内容无误，最后点提交\n\n注意：从本地的 release 分支 合并到 总的 release 分支\n\n**PS：在具体实践中，都用更新提交都使用 release 分支，不用 master**\n\n\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\n\n**三、其它：**\n\n**1、.net 项目开发，需要忽略  /bin/ /obj/ .user .suo  等文件**\n\n**需要在.git 同级目录（即解决方案目录）添加一个文件，名为 \".gitignore\"**\n\n内容为：\n\n\\*\\*/bin/\n\n\\*\\*/obj/\n\n\\*.user\n\n\\*.suo\n\n![](http://note.youdao.com/yws/public/resource/bfdf6863b921ed753d6a3f93b19bb513/3EFE59705E6845F99CDF66D88164485E)\n\n2、本地切换分支：git checkout 分支名称\n\n本地新建分支：git checkout -b 分支名称\n\n查看本地有哪些分支：git branch\n\n3、建议\n\n建议在做新任务时本地新建分支，完成后合并到本地的 resease 分支\n\n若需要开发其它项目，可以切换到其它分支开发。这种方法可能比 git statsh 更好\n\n4、实用命令\n\na、删除已跟踪（add）的文件\n\ngit rm --cached '文件路径'\n\nb、删除已跟踪的文件，并同时删除物理文件\n\ngit rm --f '文件路径'\n\nc、查看暂存前后的变化，即查看未暂存的文件更新了哪些部分\n\ngit diff\n\nd、查看暂存与上次提交时的快照之间的变化或差异\n\ngit diff --cached\n\ne、若不小 add 了一个文件 a.txt，需要撤回：\n\ngit reset a.txt\n\nf、查看本地有，远程没有提交\n\ngit log 本地分支名称 ^远程分支名称\n\n反之，远程有本地没有\n\ngit log  远程分支名称 ^本地分支名称\n\ng、查看本地已添加的远程及地址\n\ngit remote -v\n\nh、查看本地所有分支\n\ngit branch\n\ni、若显示太多信息，结果很久都不行，可以在按 q 结束\n\nj、显示最近 3 次的更新的文件修改统计信息\n\ngit log --stat -n 3\n\nk、从服务端 总的分支 release 更新到 本地仓库分支 release\n\ngit checkout release\n\ngit fetch origin release (假设你电脑的 origin 是总的 release 分支)\n\nl、重新定位本地仓库的提交点\n\ngit log -n 2 (获取 hash 值)\n\ngit reset dc6f6dade019663f2948a83aead8b0c92e1c3fce\n","slug":"2017-08-23-git使用记录","published":1,"updated":"2020-03-14T06:45:47.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvjp000e4k8y4fzc1pjp","content":"<p><strong>一、git 命令名词解释</strong></p>\n<p>1、添加/跟踪/暂存：添加到本地索引</p>\n<p>git add 文件名</p>\n<p>2、提交：提交到本地仓库</p>\n<p>git commit -m ‘注释’</p>\n<p>3、推送：将提交到本地仓库的所有更新提交到服务器</p>\n<p>git push mycode release</p>\n<p>4、更新/拉取：将远程最新的仓库或拉到本地，两种方法<br>a) 从远程获取最新版本，不会自动合并(merge)：</p>\n<p>git checkout release</p>\n<p>git fetch origin release</p>\n<p>b) 从远程获取最新版本并自动 merge：</p>\n<p>git checkout release</p>\n<p>git pull origin release</p>\n<p>方法：</p>\n<p>a) 推荐先使用第一种方法，更安全些，先 git fetch</p>\n<p>b) 再检测是否有哪些更改或是否有冲突：</p>\n<p>git log -p release..orgin/release</p>\n<p>或</p>\n<p>git log orgin/release ^release</p>\n<p>c) 最后再合并：</p>\n<p>git merge origin/release（将 origin/release 合并到当前的分支）</p>\n<p><strong>二、基本步骤</strong></p>\n<p>1、进入 web 端页面，从主仓储派生一个自己仓库</p>\n<p>2、新建本地系统文件夹</p>\n<p>3、进入文件夹，右键选择 git bash</p>\n<p>4、首次下载源码</p>\n<p>git clone 派生仓库的地址</p>\n<p>5、右键选择 git gui &gt; edit &gt; option ，左侧设置名字和邮箱（必须是注册时的邮箱）</p>\n<p>6、设置远程地址：</p>\n<p>先：进入包含.git 的目录，右键选择 git bash</p>\n<p>再：git remote add mycode 派生地址</p>\n<p>7、进入开发工作</p>\n<p>8、提交代码：</p>\n<p>a)提交到本地索引 git add 文件名或点(.)</p>\n<p>提示 1：在 add 前，可以用 git status 查看有哪些文件被修改</p>\n<p>提示 2：输入”git add “ 可以不断按两次 tab 键快速定位本地改过的文件，如下图：</p>\n<p><img src=\"http://note.youdao.com/yws/public/resource/bfdf6863b921ed753d6a3f93b19bb513/6DAFFB28BAF04F01B94CF290865B5974\" alt=\"\"></p>\n<p>提示 3：VS2013 自动支持，如下右键提交即可</p>\n<p><img src=\"http://note.youdao.com/yws/public/resource/bfdf6863b921ed753d6a3f93b19bb513/AED5D15984704D3E989D27B4463B9289\" alt=\"\"></p>\n<p>b)提交到本地仓库 git commit -m ‘注释必填’</p>\n<p>c)提交到远程服务器的我的派生仓库：</p>\n<p>git push mycode release</p>\n<p>(注意：本地已经测试小组没问题后执行)</p>\n<p>9、合并请求</p>\n<p>a)进入主仓库 &gt;  合并请求 &gt; 创建合并请求</p>\n<p>b)再次确认需要提交的文件及内容无误，最后点提交</p>\n<p>注意：从本地的 release 分支 合并到 总的 release 分支</p>\n<p><strong>PS：在具体实践中，都用更新提交都使用 release 分支，不用 master</strong></p>\n<p>-------------</p>\n<p><strong>三、其它：</strong></p>\n<p><strong>1、.net 项目开发，需要忽略  /bin/ /obj/ .user .suo  等文件</strong></p>\n<p><strong>需要在.git 同级目录（即解决方案目录）添加一个文件，名为 “.gitignore”</strong></p>\n<p>内容为：</p>\n<p>**/bin/</p>\n<p>**/obj/</p>\n<p>*.user</p>\n<p>*.suo</p>\n<p><img src=\"http://note.youdao.com/yws/public/resource/bfdf6863b921ed753d6a3f93b19bb513/3EFE59705E6845F99CDF66D88164485E\" alt=\"\"></p>\n<p>2、本地切换分支：git checkout 分支名称</p>\n<p>本地新建分支：git checkout -b 分支名称</p>\n<p>查看本地有哪些分支：git branch</p>\n<p>3、建议</p>\n<p>建议在做新任务时本地新建分支，完成后合并到本地的 resease 分支</p>\n<p>若需要开发其它项目，可以切换到其它分支开发。这种方法可能比 git statsh 更好</p>\n<p>4、实用命令</p>\n<p>a、删除已跟踪（add）的文件</p>\n<p>git rm –cached ‘文件路径’</p>\n<p>b、删除已跟踪的文件，并同时删除物理文件</p>\n<p>git rm –f ‘文件路径’</p>\n<p>c、查看暂存前后的变化，即查看未暂存的文件更新了哪些部分</p>\n<p>git diff</p>\n<p>d、查看暂存与上次提交时的快照之间的变化或差异</p>\n<p>git diff –cached</p>\n<p>e、若不小 add 了一个文件 a.txt，需要撤回：</p>\n<p>git reset a.txt</p>\n<p>f、查看本地有，远程没有提交</p>\n<p>git log 本地分支名称 ^远程分支名称</p>\n<p>反之，远程有本地没有</p>\n<p>git log  远程分支名称 ^本地分支名称</p>\n<p>g、查看本地已添加的远程及地址</p>\n<p>git remote -v</p>\n<p>h、查看本地所有分支</p>\n<p>git branch</p>\n<p>i、若显示太多信息，结果很久都不行，可以在按 q 结束</p>\n<p>j、显示最近 3 次的更新的文件修改统计信息</p>\n<p>git log –stat -n 3</p>\n<p>k、从服务端 总的分支 release 更新到 本地仓库分支 release</p>\n<p>git checkout release</p>\n<p>git fetch origin release (假设你电脑的 origin 是总的 release 分支)</p>\n<p>l、重新定位本地仓库的提交点</p>\n<p>git log -n 2 (获取 hash 值)</p>\n<p>git reset dc6f6dade019663f2948a83aead8b0c92e1c3fce</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p><strong>一、git 命令名词解释</strong></p>\n<p>1、添加/跟踪/暂存：添加到本地索引</p>\n<p>git add 文件名</p>\n<p>2、提交：提交到本地仓库</p>\n<p>git commit -m ‘注释’</p>\n<p>3、推送：将提交到本地仓库的所有更新提交到服务器</p>\n<p>git push mycode release</p>\n<p>4、更新/拉取：将远程最新的仓库或拉到本地，两种方法<br>a) 从远程获取最新版本，不会自动合并(merge)：</p>\n<p>git checkout release</p>\n<p>git fetch origin release</p>\n<p>b) 从远程获取最新版本并自动 merge：</p>\n<p>git checkout release</p>\n<p>git pull origin release</p>\n<p>方法：</p>\n<p>a) 推荐先使用第一种方法，更安全些，先 git fetch</p>\n<p>b) 再检测是否有哪些更改或是否有冲突：</p>\n<p>git log -p release..orgin/release</p>\n<p>或</p>\n<p>git log orgin/release ^release</p>\n<p>c) 最后再合并：</p>\n<p>git merge origin/release（将 origin/release 合并到当前的分支）</p>\n<p><strong>二、基本步骤</strong></p>\n<p>1、进入 web 端页面，从主仓储派生一个自己仓库</p>\n<p>2、新建本地系统文件夹</p>\n<p>3、进入文件夹，右键选择 git bash</p>\n<p>4、首次下载源码</p>\n<p>git clone 派生仓库的地址</p>\n<p>5、右键选择 git gui &gt; edit &gt; option ，左侧设置名字和邮箱（必须是注册时的邮箱）</p>\n<p>6、设置远程地址：</p>\n<p>先：进入包含.git 的目录，右键选择 git bash</p>\n<p>再：git remote add mycode 派生地址</p>\n<p>7、进入开发工作</p>\n<p>8、提交代码：</p>\n<p>a)提交到本地索引 git add 文件名或点(.)</p>\n<p>提示 1：在 add 前，可以用 git status 查看有哪些文件被修改</p>\n<p>提示 2：输入”git add “ 可以不断按两次 tab 键快速定位本地改过的文件，如下图：</p>\n<p><img src=\"http://note.youdao.com/yws/public/resource/bfdf6863b921ed753d6a3f93b19bb513/6DAFFB28BAF04F01B94CF290865B5974\" alt=\"\"></p>\n<p>提示 3：VS2013 自动支持，如下右键提交即可</p>\n<p><img src=\"http://note.youdao.com/yws/public/resource/bfdf6863b921ed753d6a3f93b19bb513/AED5D15984704D3E989D27B4463B9289\" alt=\"\"></p>\n<p>b)提交到本地仓库 git commit -m ‘注释必填’</p>\n<p>c)提交到远程服务器的我的派生仓库：</p>\n<p>git push mycode release</p>\n<p>(注意：本地已经测试小组没问题后执行)</p>\n<p>9、合并请求</p>\n<p>a)进入主仓库 &gt;  合并请求 &gt; 创建合并请求</p>\n<p>b)再次确认需要提交的文件及内容无误，最后点提交</p>\n<p>注意：从本地的 release 分支 合并到 总的 release 分支</p>\n<p><strong>PS：在具体实践中，都用更新提交都使用 release 分支，不用 master</strong></p>\n<p>-------------</p>\n<p><strong>三、其它：</strong></p>\n<p><strong>1、.net 项目开发，需要忽略  /bin/ /obj/ .user .suo  等文件</strong></p>\n<p><strong>需要在.git 同级目录（即解决方案目录）添加一个文件，名为 “.gitignore”</strong></p>\n<p>内容为：</p>\n<p>**/bin/</p>\n<p>**/obj/</p>\n<p>*.user</p>\n<p>*.suo</p>\n<p><img src=\"http://note.youdao.com/yws/public/resource/bfdf6863b921ed753d6a3f93b19bb513/3EFE59705E6845F99CDF66D88164485E\" alt=\"\"></p>\n<p>2、本地切换分支：git checkout 分支名称</p>\n<p>本地新建分支：git checkout -b 分支名称</p>\n<p>查看本地有哪些分支：git branch</p>\n<p>3、建议</p>\n<p>建议在做新任务时本地新建分支，完成后合并到本地的 resease 分支</p>\n<p>若需要开发其它项目，可以切换到其它分支开发。这种方法可能比 git statsh 更好</p>\n<p>4、实用命令</p>\n<p>a、删除已跟踪（add）的文件</p>\n<p>git rm –cached ‘文件路径’</p>\n<p>b、删除已跟踪的文件，并同时删除物理文件</p>\n<p>git rm –f ‘文件路径’</p>\n<p>c、查看暂存前后的变化，即查看未暂存的文件更新了哪些部分</p>\n<p>git diff</p>\n<p>d、查看暂存与上次提交时的快照之间的变化或差异</p>\n<p>git diff –cached</p>\n<p>e、若不小 add 了一个文件 a.txt，需要撤回：</p>\n<p>git reset a.txt</p>\n<p>f、查看本地有，远程没有提交</p>\n<p>git log 本地分支名称 ^远程分支名称</p>\n<p>反之，远程有本地没有</p>\n<p>git log  远程分支名称 ^本地分支名称</p>\n<p>g、查看本地已添加的远程及地址</p>\n<p>git remote -v</p>\n<p>h、查看本地所有分支</p>\n<p>git branch</p>\n<p>i、若显示太多信息，结果很久都不行，可以在按 q 结束</p>\n<p>j、显示最近 3 次的更新的文件修改统计信息</p>\n<p>git log –stat -n 3</p>\n<p>k、从服务端 总的分支 release 更新到 本地仓库分支 release</p>\n<p>git checkout release</p>\n<p>git fetch origin release (假设你电脑的 origin 是总的 release 分支)</p>\n<p>l、重新定位本地仓库的提交点</p>\n<p>git log -n 2 (获取 hash 值)</p>\n<p>git reset dc6f6dade019663f2948a83aead8b0c92e1c3fce</p>\n"},{"title":"推荐大家使用的CSS书写规范、顺序","date":"2017-08-27T18:22:00.000Z","_content":"\n写了这么久的[CSS](http://www.shejidaren.com/category/css/css-learn)，但大部分前端 er 都没有按照良好的 CSS 书写规范来写 CSS 代码，这样会影响代码的阅读体验，这里设计达人网总结一个 CSS 书写规范、CSS 书写顺序供大家参考，这些是参考了国外一些文章以及我的个人经验总结出来，我想对写 CSS 的前端用户来说是值得学习的。\n\n## CSS 书写顺序\n\n1.位置属性(position, top, right, z-index, display, float 等)  \n2.大小(width, height, padding, margin)  \n3.文字系列(font, line-height, letter-spacing, color- text-align 等)  \n4.背景(background, border 等)  \n5.其他(animation, transition 等)\n\n![css-written-order](http://www.jixiaokang.com/wp-content/uploads/2018/05/css-written-order.png)\n\n## CSS 书写规范\n\n### 使用 CSS 缩写属性\n\nCSS 有些属性是可以缩写的，比如 padding,margin,font 等等，这样精简代码同时又能提高用户的阅读体验。\n\n![abbreviation](http://www.jixiaokang.com/wp-content/uploads/2018/05/abbreviation.png)\n\n### 去掉小数点前的“0”\n\n![del-zero](http://www.jixiaokang.com/wp-content/uploads/2018/05/del-zero.png)\n\n### 简写命名\n\n很多用户都喜欢简写类名，但前提是要让人看懂你的命名才能简写哦！\n\n![name](http://www.jixiaokang.com/wp-content/uploads/2018/05/name.png)\n\n### 16 进制颜色代码缩写\n\n有些颜色代码是可以缩写的，我们就尽量缩写吧，提高用户体验为主。\n\n![color-abb](http://www.jixiaokang.com/wp-content/uploads/2018/05/color-abb.png)\n\n### 连字符 CSS 选择器命名规范\n\n1.长名称或词组可以使用中横线来为选择器命名。\n\n2.不建议使用“\\_”下划线来命名 CSS 选择器，为什么呢？\n\n- 输入的时候少按一个 shift 键；\n- 浏览器兼容问题 （比如使用\\_tips 的选择器命名，在 IE6 是无效的）\n- 能良好区分 JavaScript 变量命名（JS 变量命名是用“\\_”）\n\n这里有一篇破折号与下划线的详细讨论，英文：[点击查看](http://stackoverflow.com/questions/7560813/why-are-dashes-preferred-for-css-selectors-html-attributes)  中文篇：[点击查看](http://www.cnblogs.com/kaiye/archive/2011/06/13/3039046.html)\n\n![underline](http://www.jixiaokang.com/wp-content/uploads/2018/05/underline.png)\n\n### 不要随意使用 Id\n\nid 在 JS 是唯一的，不能多次使用，而使用 class 类选择器却可以重复使用，另外 id 的优先级优先与 class，所以 id 应该按需使用，而不能滥用。\n\n![css-id](http://www.jixiaokang.com/wp-content/uploads/2018/05/css-id.png)\n\n### 为选择器添加状态前缀\n\n有时候可以给选择器添加一个表示状态的前缀，让语义更明了，比如下图是添加了“.is-”前缀。\n\n![status-select](http://www.jixiaokang.com/wp-content/uploads/2018/05/status-select.png)\n\n## CSS 命名规范（规则）\n\n### 常用的 CSS 命名规则\n\n头：header  \n内容：content/container  \n尾：footer  \n导航：nav  \n侧栏：sidebar  \n栏目：column  \n页面外围控制整体佈局宽度：wrapper  \n左右中：left right center  \n登录条：loginbar  \n标志：logo  \n广告：banner  \n页面主体：main  \n热点：hot  \n新闻：news  \n下载：download  \n子导航：subnav  \n菜单：menu  \n子菜单：submenu  \n搜索：search  \n友情链接：friendlink  \n页脚：footer  \n版权：copyright  \n滚动：scroll  \n内容：content  \n标签：tags  \n文章列表：list  \n提示信息：msg  \n小技巧：tips  \n栏目标题：title  \n加入：joinus  \n指南：guide  \n服务：service  \n注册：regsiter  \n状态：status  \n投票：vote  \n合作伙伴：partner\n\n### 注释的写法:\n\n/\\* Header _/  \n内容区  \n/\\* End Header _/\n\n### Id 的命名:\n\n**1)页面结构**\n\n容器: container  \n页头：header  \n内容：content/container  \n页面主体：main  \n页尾：footer  \n导航：nav  \n侧栏：sidebar  \n栏目：column  \n页面外围控制整体佈局宽度：wrapper  \n左右中：left right center\n\n**(2)导航**\n\n导航：nav  \n主导航：mainnav  \n子导航：subnav  \n顶导航：topnav  \n边导航：sidebar  \n左导航：leftsidebar  \n右导航：rightsidebar  \n菜单：menu  \n子菜单：submenu  \n标题: title  \n摘要: summary\n\n**(3)功能**\n\n标志：logo  \n广告：banner  \n登陆：login  \n登录条：loginbar  \n注册：register  \n搜索：search  \n功能区：shop  \n标题：title  \n加入：joinus  \n状态：status  \n按钮：btn  \n滚动：scroll  \n标籤页：tab  \n文章列表：list  \n提示信息：msg  \n当前的: current  \n小技巧：tips  \n图标: icon  \n注释：note  \n指南：guild  \n服务：service  \n热点：hot  \n新闻：news  \n下载：download  \n投票：vote  \n合作伙伴：partner  \n友情链接：link  \n版权：copyright\n\n### 注意事项::\n\n1.一律小写;  \n2.尽量用英文;  \n3.不加中槓和下划线;  \n4.尽量不缩写，除非一看就明白的单词。\n\n### CSS 样式表文件命名\n\n主要的 master.css  \n模块 module.css  \n基本共用 base.css  \n布局、版面 layout.css  \n主题 themes.css  \n专栏 columns.css  \n文字 font.css  \n表单 forms.css  \n补丁 mend.css  \n打印 print.css\n","source":"_posts/2017-08-28-推荐大家使用的CSS书写规范、顺序.md","raw":"---\ntitle: 推荐大家使用的CSS书写规范、顺序\ntags:\n  - CSS\ndate: 2017-08-28 02:22:00\ncategories: 前端\n---\n\n写了这么久的[CSS](http://www.shejidaren.com/category/css/css-learn)，但大部分前端 er 都没有按照良好的 CSS 书写规范来写 CSS 代码，这样会影响代码的阅读体验，这里设计达人网总结一个 CSS 书写规范、CSS 书写顺序供大家参考，这些是参考了国外一些文章以及我的个人经验总结出来，我想对写 CSS 的前端用户来说是值得学习的。\n\n## CSS 书写顺序\n\n1.位置属性(position, top, right, z-index, display, float 等)  \n2.大小(width, height, padding, margin)  \n3.文字系列(font, line-height, letter-spacing, color- text-align 等)  \n4.背景(background, border 等)  \n5.其他(animation, transition 等)\n\n![css-written-order](http://www.jixiaokang.com/wp-content/uploads/2018/05/css-written-order.png)\n\n## CSS 书写规范\n\n### 使用 CSS 缩写属性\n\nCSS 有些属性是可以缩写的，比如 padding,margin,font 等等，这样精简代码同时又能提高用户的阅读体验。\n\n![abbreviation](http://www.jixiaokang.com/wp-content/uploads/2018/05/abbreviation.png)\n\n### 去掉小数点前的“0”\n\n![del-zero](http://www.jixiaokang.com/wp-content/uploads/2018/05/del-zero.png)\n\n### 简写命名\n\n很多用户都喜欢简写类名，但前提是要让人看懂你的命名才能简写哦！\n\n![name](http://www.jixiaokang.com/wp-content/uploads/2018/05/name.png)\n\n### 16 进制颜色代码缩写\n\n有些颜色代码是可以缩写的，我们就尽量缩写吧，提高用户体验为主。\n\n![color-abb](http://www.jixiaokang.com/wp-content/uploads/2018/05/color-abb.png)\n\n### 连字符 CSS 选择器命名规范\n\n1.长名称或词组可以使用中横线来为选择器命名。\n\n2.不建议使用“\\_”下划线来命名 CSS 选择器，为什么呢？\n\n- 输入的时候少按一个 shift 键；\n- 浏览器兼容问题 （比如使用\\_tips 的选择器命名，在 IE6 是无效的）\n- 能良好区分 JavaScript 变量命名（JS 变量命名是用“\\_”）\n\n这里有一篇破折号与下划线的详细讨论，英文：[点击查看](http://stackoverflow.com/questions/7560813/why-are-dashes-preferred-for-css-selectors-html-attributes)  中文篇：[点击查看](http://www.cnblogs.com/kaiye/archive/2011/06/13/3039046.html)\n\n![underline](http://www.jixiaokang.com/wp-content/uploads/2018/05/underline.png)\n\n### 不要随意使用 Id\n\nid 在 JS 是唯一的，不能多次使用，而使用 class 类选择器却可以重复使用，另外 id 的优先级优先与 class，所以 id 应该按需使用，而不能滥用。\n\n![css-id](http://www.jixiaokang.com/wp-content/uploads/2018/05/css-id.png)\n\n### 为选择器添加状态前缀\n\n有时候可以给选择器添加一个表示状态的前缀，让语义更明了，比如下图是添加了“.is-”前缀。\n\n![status-select](http://www.jixiaokang.com/wp-content/uploads/2018/05/status-select.png)\n\n## CSS 命名规范（规则）\n\n### 常用的 CSS 命名规则\n\n头：header  \n内容：content/container  \n尾：footer  \n导航：nav  \n侧栏：sidebar  \n栏目：column  \n页面外围控制整体佈局宽度：wrapper  \n左右中：left right center  \n登录条：loginbar  \n标志：logo  \n广告：banner  \n页面主体：main  \n热点：hot  \n新闻：news  \n下载：download  \n子导航：subnav  \n菜单：menu  \n子菜单：submenu  \n搜索：search  \n友情链接：friendlink  \n页脚：footer  \n版权：copyright  \n滚动：scroll  \n内容：content  \n标签：tags  \n文章列表：list  \n提示信息：msg  \n小技巧：tips  \n栏目标题：title  \n加入：joinus  \n指南：guide  \n服务：service  \n注册：regsiter  \n状态：status  \n投票：vote  \n合作伙伴：partner\n\n### 注释的写法:\n\n/\\* Header _/  \n内容区  \n/\\* End Header _/\n\n### Id 的命名:\n\n**1)页面结构**\n\n容器: container  \n页头：header  \n内容：content/container  \n页面主体：main  \n页尾：footer  \n导航：nav  \n侧栏：sidebar  \n栏目：column  \n页面外围控制整体佈局宽度：wrapper  \n左右中：left right center\n\n**(2)导航**\n\n导航：nav  \n主导航：mainnav  \n子导航：subnav  \n顶导航：topnav  \n边导航：sidebar  \n左导航：leftsidebar  \n右导航：rightsidebar  \n菜单：menu  \n子菜单：submenu  \n标题: title  \n摘要: summary\n\n**(3)功能**\n\n标志：logo  \n广告：banner  \n登陆：login  \n登录条：loginbar  \n注册：register  \n搜索：search  \n功能区：shop  \n标题：title  \n加入：joinus  \n状态：status  \n按钮：btn  \n滚动：scroll  \n标籤页：tab  \n文章列表：list  \n提示信息：msg  \n当前的: current  \n小技巧：tips  \n图标: icon  \n注释：note  \n指南：guild  \n服务：service  \n热点：hot  \n新闻：news  \n下载：download  \n投票：vote  \n合作伙伴：partner  \n友情链接：link  \n版权：copyright\n\n### 注意事项::\n\n1.一律小写;  \n2.尽量用英文;  \n3.不加中槓和下划线;  \n4.尽量不缩写，除非一看就明白的单词。\n\n### CSS 样式表文件命名\n\n主要的 master.css  \n模块 module.css  \n基本共用 base.css  \n布局、版面 layout.css  \n主题 themes.css  \n专栏 columns.css  \n文字 font.css  \n表单 forms.css  \n补丁 mend.css  \n打印 print.css\n","slug":"2017-08-28-推荐大家使用的CSS书写规范、顺序","published":1,"updated":"2020-03-14T06:47:00.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvjs000f4k8y310o6m8o","content":"<p>写了这么久的<a href=\"http://www.shejidaren.com/category/css/css-learn\" target=\"_blank\" rel=\"noopener\">CSS</a>，但大部分前端 er 都没有按照良好的 CSS 书写规范来写 CSS 代码，这样会影响代码的阅读体验，这里设计达人网总结一个 CSS 书写规范、CSS 书写顺序供大家参考，这些是参考了国外一些文章以及我的个人经验总结出来，我想对写 CSS 的前端用户来说是值得学习的。</p>\n<h2 id=\"CSS-书写顺序\"><a href=\"#CSS-书写顺序\" class=\"headerlink\" title=\"CSS 书写顺序\"></a>CSS 书写顺序</h2><p>1.位置属性(position, top, right, z-index, display, float 等)<br>2.大小(width, height, padding, margin)<br>3.文字系列(font, line-height, letter-spacing, color- text-align 等)<br>4.背景(background, border 等)<br>5.其他(animation, transition 等)</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/css-written-order.png\" alt=\"css-written-order\"></p>\n<h2 id=\"CSS-书写规范\"><a href=\"#CSS-书写规范\" class=\"headerlink\" title=\"CSS 书写规范\"></a>CSS 书写规范</h2><h3 id=\"使用-CSS-缩写属性\"><a href=\"#使用-CSS-缩写属性\" class=\"headerlink\" title=\"使用 CSS 缩写属性\"></a>使用 CSS 缩写属性</h3><p>CSS 有些属性是可以缩写的，比如 padding,margin,font 等等，这样精简代码同时又能提高用户的阅读体验。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/abbreviation.png\" alt=\"abbreviation\"></p>\n<h3 id=\"去掉小数点前的“0”\"><a href=\"#去掉小数点前的“0”\" class=\"headerlink\" title=\"去掉小数点前的“0”\"></a>去掉小数点前的“0”</h3><p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/del-zero.png\" alt=\"del-zero\"></p>\n<h3 id=\"简写命名\"><a href=\"#简写命名\" class=\"headerlink\" title=\"简写命名\"></a>简写命名</h3><p>很多用户都喜欢简写类名，但前提是要让人看懂你的命名才能简写哦！</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/name.png\" alt=\"name\"></p>\n<h3 id=\"16-进制颜色代码缩写\"><a href=\"#16-进制颜色代码缩写\" class=\"headerlink\" title=\"16 进制颜色代码缩写\"></a>16 进制颜色代码缩写</h3><p>有些颜色代码是可以缩写的，我们就尽量缩写吧，提高用户体验为主。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/color-abb.png\" alt=\"color-abb\"></p>\n<h3 id=\"连字符-CSS-选择器命名规范\"><a href=\"#连字符-CSS-选择器命名规范\" class=\"headerlink\" title=\"连字符 CSS 选择器命名规范\"></a>连字符 CSS 选择器命名规范</h3><p>1.长名称或词组可以使用中横线来为选择器命名。</p>\n<p>2.不建议使用“_”下划线来命名 CSS 选择器，为什么呢？</p>\n<ul>\n<li>输入的时候少按一个 shift 键；</li>\n<li>浏览器兼容问题 （比如使用_tips 的选择器命名，在 IE6 是无效的）</li>\n<li>能良好区分 JavaScript 变量命名（JS 变量命名是用“_”）</li>\n</ul>\n<p>这里有一篇破折号与下划线的详细讨论，英文：<a href=\"http://stackoverflow.com/questions/7560813/why-are-dashes-preferred-for-css-selectors-html-attributes\" target=\"_blank\" rel=\"noopener\">点击查看</a>  中文篇：<a href=\"http://www.cnblogs.com/kaiye/archive/2011/06/13/3039046.html\" target=\"_blank\" rel=\"noopener\">点击查看</a></p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/underline.png\" alt=\"underline\"></p>\n<h3 id=\"不要随意使用-Id\"><a href=\"#不要随意使用-Id\" class=\"headerlink\" title=\"不要随意使用 Id\"></a>不要随意使用 Id</h3><p>id 在 JS 是唯一的，不能多次使用，而使用 class 类选择器却可以重复使用，另外 id 的优先级优先与 class，所以 id 应该按需使用，而不能滥用。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/css-id.png\" alt=\"css-id\"></p>\n<h3 id=\"为选择器添加状态前缀\"><a href=\"#为选择器添加状态前缀\" class=\"headerlink\" title=\"为选择器添加状态前缀\"></a>为选择器添加状态前缀</h3><p>有时候可以给选择器添加一个表示状态的前缀，让语义更明了，比如下图是添加了“.is-”前缀。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/status-select.png\" alt=\"status-select\"></p>\n<h2 id=\"CSS-命名规范（规则）\"><a href=\"#CSS-命名规范（规则）\" class=\"headerlink\" title=\"CSS 命名规范（规则）\"></a>CSS 命名规范（规则）</h2><h3 id=\"常用的-CSS-命名规则\"><a href=\"#常用的-CSS-命名规则\" class=\"headerlink\" title=\"常用的 CSS 命名规则\"></a>常用的 CSS 命名规则</h3><p>头：header<br>内容：content/container<br>尾：footer<br>导航：nav<br>侧栏：sidebar<br>栏目：column<br>页面外围控制整体佈局宽度：wrapper<br>左右中：left right center<br>登录条：loginbar<br>标志：logo<br>广告：banner<br>页面主体：main<br>热点：hot<br>新闻：news<br>下载：download<br>子导航：subnav<br>菜单：menu<br>子菜单：submenu<br>搜索：search<br>友情链接：friendlink<br>页脚：footer<br>版权：copyright<br>滚动：scroll<br>内容：content<br>标签：tags<br>文章列表：list<br>提示信息：msg<br>小技巧：tips<br>栏目标题：title<br>加入：joinus<br>指南：guide<br>服务：service<br>注册：regsiter<br>状态：status<br>投票：vote<br>合作伙伴：partner</p>\n<h3 id=\"注释的写法\"><a href=\"#注释的写法\" class=\"headerlink\" title=\"注释的写法:\"></a>注释的写法:</h3><p>/* Header _/<br>内容区<br>/* End Header _/</p>\n<h3 id=\"Id-的命名\"><a href=\"#Id-的命名\" class=\"headerlink\" title=\"Id 的命名:\"></a>Id 的命名:</h3><p><strong>1)页面结构</strong></p>\n<p>容器: container<br>页头：header<br>内容：content/container<br>页面主体：main<br>页尾：footer<br>导航：nav<br>侧栏：sidebar<br>栏目：column<br>页面外围控制整体佈局宽度：wrapper<br>左右中：left right center</p>\n<p><strong>(2)导航</strong></p>\n<p>导航：nav<br>主导航：mainnav<br>子导航：subnav<br>顶导航：topnav<br>边导航：sidebar<br>左导航：leftsidebar<br>右导航：rightsidebar<br>菜单：menu<br>子菜单：submenu<br>标题: title<br>摘要: summary</p>\n<p><strong>(3)功能</strong></p>\n<p>标志：logo<br>广告：banner<br>登陆：login<br>登录条：loginbar<br>注册：register<br>搜索：search<br>功能区：shop<br>标题：title<br>加入：joinus<br>状态：status<br>按钮：btn<br>滚动：scroll<br>标籤页：tab<br>文章列表：list<br>提示信息：msg<br>当前的: current<br>小技巧：tips<br>图标: icon<br>注释：note<br>指南：guild<br>服务：service<br>热点：hot<br>新闻：news<br>下载：download<br>投票：vote<br>合作伙伴：partner<br>友情链接：link<br>版权：copyright</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项::\"></a>注意事项::</h3><p>1.一律小写;<br>2.尽量用英文;<br>3.不加中槓和下划线;<br>4.尽量不缩写，除非一看就明白的单词。</p>\n<h3 id=\"CSS-样式表文件命名\"><a href=\"#CSS-样式表文件命名\" class=\"headerlink\" title=\"CSS 样式表文件命名\"></a>CSS 样式表文件命名</h3><p>主要的 master.css<br>模块 module.css<br>基本共用 base.css<br>布局、版面 layout.css<br>主题 themes.css<br>专栏 columns.css<br>文字 font.css<br>表单 forms.css<br>补丁 mend.css<br>打印 print.css</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>写了这么久的<a href=\"http://www.shejidaren.com/category/css/css-learn\" target=\"_blank\" rel=\"noopener\">CSS</a>，但大部分前端 er 都没有按照良好的 CSS 书写规范来写 CSS 代码，这样会影响代码的阅读体验，这里设计达人网总结一个 CSS 书写规范、CSS 书写顺序供大家参考，这些是参考了国外一些文章以及我的个人经验总结出来，我想对写 CSS 的前端用户来说是值得学习的。</p>\n<h2 id=\"CSS-书写顺序\"><a href=\"#CSS-书写顺序\" class=\"headerlink\" title=\"CSS 书写顺序\"></a>CSS 书写顺序</h2><p>1.位置属性(position, top, right, z-index, display, float 等)<br>2.大小(width, height, padding, margin)<br>3.文字系列(font, line-height, letter-spacing, color- text-align 等)<br>4.背景(background, border 等)<br>5.其他(animation, transition 等)</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/css-written-order.png\" alt=\"css-written-order\"></p>\n<h2 id=\"CSS-书写规范\"><a href=\"#CSS-书写规范\" class=\"headerlink\" title=\"CSS 书写规范\"></a>CSS 书写规范</h2><h3 id=\"使用-CSS-缩写属性\"><a href=\"#使用-CSS-缩写属性\" class=\"headerlink\" title=\"使用 CSS 缩写属性\"></a>使用 CSS 缩写属性</h3><p>CSS 有些属性是可以缩写的，比如 padding,margin,font 等等，这样精简代码同时又能提高用户的阅读体验。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/abbreviation.png\" alt=\"abbreviation\"></p>\n<h3 id=\"去掉小数点前的“0”\"><a href=\"#去掉小数点前的“0”\" class=\"headerlink\" title=\"去掉小数点前的“0”\"></a>去掉小数点前的“0”</h3><p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/del-zero.png\" alt=\"del-zero\"></p>\n<h3 id=\"简写命名\"><a href=\"#简写命名\" class=\"headerlink\" title=\"简写命名\"></a>简写命名</h3><p>很多用户都喜欢简写类名，但前提是要让人看懂你的命名才能简写哦！</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/name.png\" alt=\"name\"></p>\n<h3 id=\"16-进制颜色代码缩写\"><a href=\"#16-进制颜色代码缩写\" class=\"headerlink\" title=\"16 进制颜色代码缩写\"></a>16 进制颜色代码缩写</h3><p>有些颜色代码是可以缩写的，我们就尽量缩写吧，提高用户体验为主。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/color-abb.png\" alt=\"color-abb\"></p>\n<h3 id=\"连字符-CSS-选择器命名规范\"><a href=\"#连字符-CSS-选择器命名规范\" class=\"headerlink\" title=\"连字符 CSS 选择器命名规范\"></a>连字符 CSS 选择器命名规范</h3><p>1.长名称或词组可以使用中横线来为选择器命名。</p>\n<p>2.不建议使用“_”下划线来命名 CSS 选择器，为什么呢？</p>\n<ul>\n<li>输入的时候少按一个 shift 键；</li>\n<li>浏览器兼容问题 （比如使用_tips 的选择器命名，在 IE6 是无效的）</li>\n<li>能良好区分 JavaScript 变量命名（JS 变量命名是用“_”）</li>\n</ul>\n<p>这里有一篇破折号与下划线的详细讨论，英文：<a href=\"http://stackoverflow.com/questions/7560813/why-are-dashes-preferred-for-css-selectors-html-attributes\" target=\"_blank\" rel=\"noopener\">点击查看</a>  中文篇：<a href=\"http://www.cnblogs.com/kaiye/archive/2011/06/13/3039046.html\" target=\"_blank\" rel=\"noopener\">点击查看</a></p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/underline.png\" alt=\"underline\"></p>\n<h3 id=\"不要随意使用-Id\"><a href=\"#不要随意使用-Id\" class=\"headerlink\" title=\"不要随意使用 Id\"></a>不要随意使用 Id</h3><p>id 在 JS 是唯一的，不能多次使用，而使用 class 类选择器却可以重复使用，另外 id 的优先级优先与 class，所以 id 应该按需使用，而不能滥用。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/css-id.png\" alt=\"css-id\"></p>\n<h3 id=\"为选择器添加状态前缀\"><a href=\"#为选择器添加状态前缀\" class=\"headerlink\" title=\"为选择器添加状态前缀\"></a>为选择器添加状态前缀</h3><p>有时候可以给选择器添加一个表示状态的前缀，让语义更明了，比如下图是添加了“.is-”前缀。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/status-select.png\" alt=\"status-select\"></p>\n<h2 id=\"CSS-命名规范（规则）\"><a href=\"#CSS-命名规范（规则）\" class=\"headerlink\" title=\"CSS 命名规范（规则）\"></a>CSS 命名规范（规则）</h2><h3 id=\"常用的-CSS-命名规则\"><a href=\"#常用的-CSS-命名规则\" class=\"headerlink\" title=\"常用的 CSS 命名规则\"></a>常用的 CSS 命名规则</h3><p>头：header<br>内容：content/container<br>尾：footer<br>导航：nav<br>侧栏：sidebar<br>栏目：column<br>页面外围控制整体佈局宽度：wrapper<br>左右中：left right center<br>登录条：loginbar<br>标志：logo<br>广告：banner<br>页面主体：main<br>热点：hot<br>新闻：news<br>下载：download<br>子导航：subnav<br>菜单：menu<br>子菜单：submenu<br>搜索：search<br>友情链接：friendlink<br>页脚：footer<br>版权：copyright<br>滚动：scroll<br>内容：content<br>标签：tags<br>文章列表：list<br>提示信息：msg<br>小技巧：tips<br>栏目标题：title<br>加入：joinus<br>指南：guide<br>服务：service<br>注册：regsiter<br>状态：status<br>投票：vote<br>合作伙伴：partner</p>\n<h3 id=\"注释的写法\"><a href=\"#注释的写法\" class=\"headerlink\" title=\"注释的写法:\"></a>注释的写法:</h3><p>/* Header _/<br>内容区<br>/* End Header _/</p>\n<h3 id=\"Id-的命名\"><a href=\"#Id-的命名\" class=\"headerlink\" title=\"Id 的命名:\"></a>Id 的命名:</h3><p><strong>1)页面结构</strong></p>\n<p>容器: container<br>页头：header<br>内容：content/container<br>页面主体：main<br>页尾：footer<br>导航：nav<br>侧栏：sidebar<br>栏目：column<br>页面外围控制整体佈局宽度：wrapper<br>左右中：left right center</p>\n<p><strong>(2)导航</strong></p>\n<p>导航：nav<br>主导航：mainnav<br>子导航：subnav<br>顶导航：topnav<br>边导航：sidebar<br>左导航：leftsidebar<br>右导航：rightsidebar<br>菜单：menu<br>子菜单：submenu<br>标题: title<br>摘要: summary</p>\n<p><strong>(3)功能</strong></p>\n<p>标志：logo<br>广告：banner<br>登陆：login<br>登录条：loginbar<br>注册：register<br>搜索：search<br>功能区：shop<br>标题：title<br>加入：joinus<br>状态：status<br>按钮：btn<br>滚动：scroll<br>标籤页：tab<br>文章列表：list<br>提示信息：msg<br>当前的: current<br>小技巧：tips<br>图标: icon<br>注释：note<br>指南：guild<br>服务：service<br>热点：hot<br>新闻：news<br>下载：download<br>投票：vote<br>合作伙伴：partner<br>友情链接：link<br>版权：copyright</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项::\"></a>注意事项::</h3><p>1.一律小写;<br>2.尽量用英文;<br>3.不加中槓和下划线;<br>4.尽量不缩写，除非一看就明白的单词。</p>\n<h3 id=\"CSS-样式表文件命名\"><a href=\"#CSS-样式表文件命名\" class=\"headerlink\" title=\"CSS 样式表文件命名\"></a>CSS 样式表文件命名</h3><p>主要的 master.css<br>模块 module.css<br>基本共用 base.css<br>布局、版面 layout.css<br>主题 themes.css<br>专栏 columns.css<br>文字 font.css<br>表单 forms.css<br>补丁 mend.css<br>打印 print.css</p>\n"},{"title":"解决导航下图片不能按需加载的问题减少对资源请求数量","date":"2017-08-26T23:32:00.000Z","_content":"\n**问题描述：**在一个三段式的 navbar 中，各段下面有一个长图（类似这样的）\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/1213869-20170827152714949-194066703.png)\n\n在优化之前需要加载三张大图这无疑增加了资源请求数量\n\n因此，我想到了将图片转换为背景以此减少请求没想到方案是可行的，上代码\n\n  <div class=\"page-navbar\">  \n      \n    <mt-navbar class=\"page-part\" v-model=\"selected\" swipeable>  \n      <mt-tab-item id=\"1\">平台介绍mt-tab-item>  \n      <mt-tab-item id=\"2\">雇佣模式mt-tab-item>  \n      <mt-tab-item id=\"3\">3天试用mt-tab-item>  \n    mt-navbar>   \n  \n      \n    <mt-tab-container v-model=\"selected\" class=\"imgadapt\">  \n      <mt-tab-container-item id=\"1\">  \n      <div class=\"sprite1\">div>  \n    \n      mt-tab-container-item>  \n      <mt-tab-container-item id=\"2\">\n      <div class=\"sprite2\">div>  \n      mt-tab-container-item>  \n      <mt-tab-container-item id=\"3\">  \n    \n    <div class=\"sprite3\">div>  \n      mt-tab-container-item>  \n    mt-tab-container>  \n  div>\n\n重点来了\n\n.sprite1 {\nbackground: url('../assets/1.jpg') no-repeat;\nwidth: 5.25rem;\nheight: 14.77rem;\nbackground-size:100% 100%;\n\n}\n.sprite2 {\nbackground: url('../assets/2.jpg') no-repeat ;\nwidth: 5.25rem;\nheight: 14.77rem;\nbackground-size:100% 100%;\n}\n.sprite3 {\nbackground: url('../assets/3.jpg') no-repeat;\nwidth: 5.25rem;\nheight: 14.77rem;\nbackground-size:100% 100%;\n}\n\n完美解决\n","source":"_posts/2017-08-27-解决导航下图片不能按需加载的问题减少对资源请求数量.md","raw":"---\ntitle: 解决导航下图片不能按需加载的问题减少对资源请求数量\ntags:\n  - 技术\ndate: 2017-08-27 07:32:00\ncategories: 前端\n---\n\n**问题描述：**在一个三段式的 navbar 中，各段下面有一个长图（类似这样的）\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/1213869-20170827152714949-194066703.png)\n\n在优化之前需要加载三张大图这无疑增加了资源请求数量\n\n因此，我想到了将图片转换为背景以此减少请求没想到方案是可行的，上代码\n\n  <div class=\"page-navbar\">  \n      \n    <mt-navbar class=\"page-part\" v-model=\"selected\" swipeable>  \n      <mt-tab-item id=\"1\">平台介绍mt-tab-item>  \n      <mt-tab-item id=\"2\">雇佣模式mt-tab-item>  \n      <mt-tab-item id=\"3\">3天试用mt-tab-item>  \n    mt-navbar>   \n  \n      \n    <mt-tab-container v-model=\"selected\" class=\"imgadapt\">  \n      <mt-tab-container-item id=\"1\">  \n      <div class=\"sprite1\">div>  \n    \n      mt-tab-container-item>  \n      <mt-tab-container-item id=\"2\">\n      <div class=\"sprite2\">div>  \n      mt-tab-container-item>  \n      <mt-tab-container-item id=\"3\">  \n    \n    <div class=\"sprite3\">div>  \n      mt-tab-container-item>  \n    mt-tab-container>  \n  div>\n\n重点来了\n\n.sprite1 {\nbackground: url('../assets/1.jpg') no-repeat;\nwidth: 5.25rem;\nheight: 14.77rem;\nbackground-size:100% 100%;\n\n}\n.sprite2 {\nbackground: url('../assets/2.jpg') no-repeat ;\nwidth: 5.25rem;\nheight: 14.77rem;\nbackground-size:100% 100%;\n}\n.sprite3 {\nbackground: url('../assets/3.jpg') no-repeat;\nwidth: 5.25rem;\nheight: 14.77rem;\nbackground-size:100% 100%;\n}\n\n完美解决\n","slug":"2017-08-27-解决导航下图片不能按需加载的问题减少对资源请求数量","published":1,"updated":"2020-03-14T06:46:39.767Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvju000j4k8y93b99707","content":"<p><strong>问题描述：</strong>在一个三段式的 navbar 中，各段下面有一个长图（类似这样的）</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1213869-20170827152714949-194066703.png\" alt=\"\"></p>\n<p>在优化之前需要加载三张大图这无疑增加了资源请求数量</p>\n<p>因此，我想到了将图片转换为背景以此减少请求没想到方案是可行的，上代码</p>\n  <div class=\"page-navbar\">  \n\n<pre><code>&lt;mt-navbar class=&quot;page-part&quot; v-model=&quot;selected&quot; swipeable&gt;  \n  &lt;mt-tab-item id=&quot;1&quot;&gt;平台介绍mt-tab-item&gt;  \n  &lt;mt-tab-item id=&quot;2&quot;&gt;雇佣模式mt-tab-item&gt;  \n  &lt;mt-tab-item id=&quot;3&quot;&gt;3天试用mt-tab-item&gt;  \nmt-navbar&gt;   \n\n\n&lt;mt-tab-container v-model=&quot;selected&quot; class=&quot;imgadapt&quot;&gt;  \n  &lt;mt-tab-container-item id=&quot;1&quot;&gt;  \n  &lt;div class=&quot;sprite1&quot;&gt;div&gt;  \n\n  mt-tab-container-item&gt;  \n  &lt;mt-tab-container-item id=&quot;2&quot;&gt;\n  &lt;div class=&quot;sprite2&quot;&gt;div&gt;  \n  mt-tab-container-item&gt;  \n  &lt;mt-tab-container-item id=&quot;3&quot;&gt;  \n\n&lt;div class=&quot;sprite3&quot;&gt;div&gt;  \n  mt-tab-container-item&gt;  \nmt-tab-container&gt;  </code></pre><p>  div&gt;</p>\n<p>重点来了</p>\n<p>.sprite1 {<br>background: url(‘../assets/1.jpg’) no-repeat;<br>width: 5.25rem;<br>height: 14.77rem;<br>background-size:100% 100%;</p>\n<p>}<br>.sprite2 {<br>background: url(‘../assets/2.jpg’) no-repeat ;<br>width: 5.25rem;<br>height: 14.77rem;<br>background-size:100% 100%;<br>}<br>.sprite3 {<br>background: url(‘../assets/3.jpg’) no-repeat;<br>width: 5.25rem;<br>height: 14.77rem;<br>background-size:100% 100%;<br>}</p>\n<p>完美解决</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p><strong>问题描述：</strong>在一个三段式的 navbar 中，各段下面有一个长图（类似这样的）</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1213869-20170827152714949-194066703.png\" alt=\"\"></p>\n<p>在优化之前需要加载三张大图这无疑增加了资源请求数量</p>\n<p>因此，我想到了将图片转换为背景以此减少请求没想到方案是可行的，上代码</p>\n  <div class=\"page-navbar\">  \n\n<pre><code>&lt;mt-navbar class=&quot;page-part&quot; v-model=&quot;selected&quot; swipeable&gt;  \n  &lt;mt-tab-item id=&quot;1&quot;&gt;平台介绍mt-tab-item&gt;  \n  &lt;mt-tab-item id=&quot;2&quot;&gt;雇佣模式mt-tab-item&gt;  \n  &lt;mt-tab-item id=&quot;3&quot;&gt;3天试用mt-tab-item&gt;  \nmt-navbar&gt;   \n\n\n&lt;mt-tab-container v-model=&quot;selected&quot; class=&quot;imgadapt&quot;&gt;  \n  &lt;mt-tab-container-item id=&quot;1&quot;&gt;  \n  &lt;div class=&quot;sprite1&quot;&gt;div&gt;  \n\n  mt-tab-container-item&gt;  \n  &lt;mt-tab-container-item id=&quot;2&quot;&gt;\n  &lt;div class=&quot;sprite2&quot;&gt;div&gt;  \n  mt-tab-container-item&gt;  \n  &lt;mt-tab-container-item id=&quot;3&quot;&gt;  \n\n&lt;div class=&quot;sprite3&quot;&gt;div&gt;  \n  mt-tab-container-item&gt;  \nmt-tab-container&gt;  </code></pre><p>  div&gt;</p>\n<p>重点来了</p>\n<p>.sprite1 {<br>background: url(‘../assets/1.jpg’) no-repeat;<br>width: 5.25rem;<br>height: 14.77rem;<br>background-size:100% 100%;</p>\n<p>}<br>.sprite2 {<br>background: url(‘../assets/2.jpg’) no-repeat ;<br>width: 5.25rem;<br>height: 14.77rem;<br>background-size:100% 100%;<br>}<br>.sprite3 {<br>background: url(‘../assets/3.jpg’) no-repeat;<br>width: 5.25rem;<br>height: 14.77rem;<br>background-size:100% 100%;<br>}</p>\n<p>完美解决</p>\n"},{"title":"Vimium~让您的Chrome起飞","date":"2017-09-09T07:13:00.000Z","_content":"\n工欲善其事，必先利其器！撸起 Vimium,我的 Chrome 就这么起飞了。\n\n如今 PC 和 Mac 端安装的 Chrome 插件(偏前端)：  \nVimium：黑客级别的 Chrome 插件，此文主记载的主角~(The Hacker’s Browser )；  \nABP： 有她在，WEB 的世界就可以清静点了.  \ninfinity：没有最好，只有更好，此款新标签页，如今最爱。  \ncrxMouse: 如果用鼠标操作 Chrome,必备=充分发掘鼠标的所有操作。  \nJASN-handle：Json 解析，所用之中综合体验最优者；  \nOK 记： 一键记录你想记载的，体验一流！  \nPocket: 轻松保存文章，视频等供以后查看。  \nQR 码生成器： PC 阅读-URL 转移手机的桥梁，用的不多。  \nWEB 前端助手： 功能虽不少，用的却也少。  \nWebsite Ip Option：获取了每个网页 Ip 显示于屏幕下方。  \nWeb Design Tester：Installed,web Devolop，暂时用的不多。  \nWeb Developer：Installed,web Devolop，暂时用的不多。  \nCssViewer：Installed,web Devolop，暂时用的不多。  \nPerfectPixel+EmmetLiveStyle: 更便捷精准还原设计图于网页设计，利弊兼有，偶尔用。\n\n更多插件请参见知乎[你极力推荐的 Chrome 扩展有哪些？](http://www.zhihu.com/question/19594682)问题的各种回复。\n\n---\n\n学起(了解几个快捷键即可)And 撸起 Vimium,想黑客一般在 Chrome 上飞起。  \nVimium 常用快捷键(注：区分大小写)  \nj,: 向下移动 Scroll down  \nk,: 向上移动 Scroll upi  \nh : 左移 Scroll left  \nl : 右移 Scroll right\n\nH：回到上一个历史页面  \nL：回到下一个历史页面  \nJ：跳到左边标签页  \nK：跳到右边标签页  \nt：创建新的标签页（ctrl+t）\n\nd : 向下移动一个页面 Scroll a page down  \nu : 向上移动一个页面 Scroll a page up\n\ngg : 移到页面顶部 Scroll to the top of the page  \nG : 移到页面底部 Scroll to the bottom of the page\n\nx：关闭当前标签页  \nX：恢复关闭的标签页\n\nr : 刷新 Reload the page  \ngs : 查看网页源码 View page source  \nyy : copy 当前页面 url Copy the current URL to the clipboard  \nyf : 拷贝当前页面的连接到剪切板 Copy a link URL to the clipboard  \nyt : 创建当前页面的一个副本(copy 当前路径在新 Tab 中打开)-Duplicate current tab  \nYT : 罗列出当前所有 Tab 页(并提供索引)，可任你选择性跳转，帅；\n\np : 在当前标签页中打开剪切板中的链接 Open the clipboard’s URL in the current tab  \nP : 在新的标签页中打开剪切板中的链接 Open the clipboard’s URL in a new tab\n\ngu : Go up the URL hierarchy（例如，URL 为[http://blog.net/article/8021689](http://blog.net/article/8021689) ，按下 gu 后，转到[http://blog.net/article/，回到该网站该访问者主页）](http://blog.net/article/%EF%BC%8C%E5%9B%9E%E5%88%B0%E8%AF%A5%E7%BD%91%E7%AB%99%E8%AF%A5%E8%AE%BF%E9%97%AE%E8%80%85%E4%B8%BB%E9%A1%B5%EF%BC%89)  \ngU : Go to root of current URL hierarchy (类似 gu，回到根 URL 页  [http://blog.net](http://blog.net/))\n\n---\n\nf : 在当前标签页中打开链接 Open a link in the current tab  \nF : 在新标签页中打开链接 Open a link in a new tab\n\nYES: (几乎)所有的操作都是通过键盘的快捷键来操作。如果想点击页面上的某个连接时，在命令模式下，按 f 键之后就会对页面上所有可点击的连接或按钮进行编码，然后再输入相应的编码完成点击或者复制连接操作，包含常见的 a 标签，button 标签，input 标签中 type=button/submit/reset，不过有些也无法识别（flash); 见证如下图：。  \n[![Vimium-F-Link](http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/viumclik.png)](http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/viumclik.png \"Vimium-F-Link\")Vimium-F-Link\n\n---\n\no : 在当前页面中打开 URL，书签和历史记录 Open URL, bookmark, or history entry  \nO : 在新标签页中打开 URL，书签和历史记录 Open URL, bookmark, history entry, in a new tab  \nT : 搜索打开的标签页 Search through your open tabs\n\nb : 打开书签 Open a bookmark  \nB : 在新标签中打开书签 Open a bookmark in a new tab  \n在命令行模式，按下 b(B)，可以对标签进行检索，检索结果通过 tab 键进行选择，回车即可打开标签。\n\n[![Vimium-bB](http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/vimbookmap.png)](http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/vimbookmap.png \"Vimium-bB\")Vimium-bB\n\n/：查找（ctrl+f）  \ni : 进入输入模式 Enter insert mode  \nesc：退出\n\n---\n\n还有些还不怎么常用的，比如：  \nzH : Scroll all the way to the left  \nzL : Scroll all the way to the right  \nm : Create a new mark\n\n最后，任何时候你需要帮助的时候可以按？(shilft+/)来调出帮助菜单，同时显示了所有快捷键的说明,again(shilft+/)即可 Close 之，如下图：  \n[![vimium-help](http://www.jixiaokang.com/wp-content/uploads/2018/05/141813348554340.png)](http://www.jixiaokang.com/wp-content/uploads/2018/05/141813348554340.png \"vimium-help\")vimium-help\n\n切记(to myself)：熟能生巧，至巧了，即可夺天之工。\n","source":"_posts/2017-09-09-Vimium~让您的Chrome起飞.md","raw":"---\ntitle: Vimium~让您的Chrome起飞\ntags:\n  - 技术\ndate: 2017-09-09 15:13:00\ncategories: 工具\n---\n\n工欲善其事，必先利其器！撸起 Vimium,我的 Chrome 就这么起飞了。\n\n如今 PC 和 Mac 端安装的 Chrome 插件(偏前端)：  \nVimium：黑客级别的 Chrome 插件，此文主记载的主角~(The Hacker’s Browser )；  \nABP： 有她在，WEB 的世界就可以清静点了.  \ninfinity：没有最好，只有更好，此款新标签页，如今最爱。  \ncrxMouse: 如果用鼠标操作 Chrome,必备=充分发掘鼠标的所有操作。  \nJASN-handle：Json 解析，所用之中综合体验最优者；  \nOK 记： 一键记录你想记载的，体验一流！  \nPocket: 轻松保存文章，视频等供以后查看。  \nQR 码生成器： PC 阅读-URL 转移手机的桥梁，用的不多。  \nWEB 前端助手： 功能虽不少，用的却也少。  \nWebsite Ip Option：获取了每个网页 Ip 显示于屏幕下方。  \nWeb Design Tester：Installed,web Devolop，暂时用的不多。  \nWeb Developer：Installed,web Devolop，暂时用的不多。  \nCssViewer：Installed,web Devolop，暂时用的不多。  \nPerfectPixel+EmmetLiveStyle: 更便捷精准还原设计图于网页设计，利弊兼有，偶尔用。\n\n更多插件请参见知乎[你极力推荐的 Chrome 扩展有哪些？](http://www.zhihu.com/question/19594682)问题的各种回复。\n\n---\n\n学起(了解几个快捷键即可)And 撸起 Vimium,想黑客一般在 Chrome 上飞起。  \nVimium 常用快捷键(注：区分大小写)  \nj,: 向下移动 Scroll down  \nk,: 向上移动 Scroll upi  \nh : 左移 Scroll left  \nl : 右移 Scroll right\n\nH：回到上一个历史页面  \nL：回到下一个历史页面  \nJ：跳到左边标签页  \nK：跳到右边标签页  \nt：创建新的标签页（ctrl+t）\n\nd : 向下移动一个页面 Scroll a page down  \nu : 向上移动一个页面 Scroll a page up\n\ngg : 移到页面顶部 Scroll to the top of the page  \nG : 移到页面底部 Scroll to the bottom of the page\n\nx：关闭当前标签页  \nX：恢复关闭的标签页\n\nr : 刷新 Reload the page  \ngs : 查看网页源码 View page source  \nyy : copy 当前页面 url Copy the current URL to the clipboard  \nyf : 拷贝当前页面的连接到剪切板 Copy a link URL to the clipboard  \nyt : 创建当前页面的一个副本(copy 当前路径在新 Tab 中打开)-Duplicate current tab  \nYT : 罗列出当前所有 Tab 页(并提供索引)，可任你选择性跳转，帅；\n\np : 在当前标签页中打开剪切板中的链接 Open the clipboard’s URL in the current tab  \nP : 在新的标签页中打开剪切板中的链接 Open the clipboard’s URL in a new tab\n\ngu : Go up the URL hierarchy（例如，URL 为[http://blog.net/article/8021689](http://blog.net/article/8021689) ，按下 gu 后，转到[http://blog.net/article/，回到该网站该访问者主页）](http://blog.net/article/%EF%BC%8C%E5%9B%9E%E5%88%B0%E8%AF%A5%E7%BD%91%E7%AB%99%E8%AF%A5%E8%AE%BF%E9%97%AE%E8%80%85%E4%B8%BB%E9%A1%B5%EF%BC%89)  \ngU : Go to root of current URL hierarchy (类似 gu，回到根 URL 页  [http://blog.net](http://blog.net/))\n\n---\n\nf : 在当前标签页中打开链接 Open a link in the current tab  \nF : 在新标签页中打开链接 Open a link in a new tab\n\nYES: (几乎)所有的操作都是通过键盘的快捷键来操作。如果想点击页面上的某个连接时，在命令模式下，按 f 键之后就会对页面上所有可点击的连接或按钮进行编码，然后再输入相应的编码完成点击或者复制连接操作，包含常见的 a 标签，button 标签，input 标签中 type=button/submit/reset，不过有些也无法识别（flash); 见证如下图：。  \n[![Vimium-F-Link](http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/viumclik.png)](http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/viumclik.png \"Vimium-F-Link\")Vimium-F-Link\n\n---\n\no : 在当前页面中打开 URL，书签和历史记录 Open URL, bookmark, or history entry  \nO : 在新标签页中打开 URL，书签和历史记录 Open URL, bookmark, history entry, in a new tab  \nT : 搜索打开的标签页 Search through your open tabs\n\nb : 打开书签 Open a bookmark  \nB : 在新标签中打开书签 Open a bookmark in a new tab  \n在命令行模式，按下 b(B)，可以对标签进行检索，检索结果通过 tab 键进行选择，回车即可打开标签。\n\n[![Vimium-bB](http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/vimbookmap.png)](http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/vimbookmap.png \"Vimium-bB\")Vimium-bB\n\n/：查找（ctrl+f）  \ni : 进入输入模式 Enter insert mode  \nesc：退出\n\n---\n\n还有些还不怎么常用的，比如：  \nzH : Scroll all the way to the left  \nzL : Scroll all the way to the right  \nm : Create a new mark\n\n最后，任何时候你需要帮助的时候可以按？(shilft+/)来调出帮助菜单，同时显示了所有快捷键的说明,again(shilft+/)即可 Close 之，如下图：  \n[![vimium-help](http://www.jixiaokang.com/wp-content/uploads/2018/05/141813348554340.png)](http://www.jixiaokang.com/wp-content/uploads/2018/05/141813348554340.png \"vimium-help\")vimium-help\n\n切记(to myself)：熟能生巧，至巧了，即可夺天之工。\n","slug":"2017-09-09-Vimium~让您的Chrome起飞","published":1,"updated":"2020-03-14T06:47:40.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvjw000k4k8ybnye4inp","content":"<p>工欲善其事，必先利其器！撸起 Vimium,我的 Chrome 就这么起飞了。</p>\n<p>如今 PC 和 Mac 端安装的 Chrome 插件(偏前端)：<br>Vimium：黑客级别的 Chrome 插件，此文主记载的主角~(The Hacker’s Browser )；<br>ABP： 有她在，WEB 的世界就可以清静点了.<br>infinity：没有最好，只有更好，此款新标签页，如今最爱。<br>crxMouse: 如果用鼠标操作 Chrome,必备=充分发掘鼠标的所有操作。<br>JASN-handle：Json 解析，所用之中综合体验最优者；<br>OK 记： 一键记录你想记载的，体验一流！<br>Pocket: 轻松保存文章，视频等供以后查看。<br>QR 码生成器： PC 阅读-URL 转移手机的桥梁，用的不多。<br>WEB 前端助手： 功能虽不少，用的却也少。<br>Website Ip Option：获取了每个网页 Ip 显示于屏幕下方。<br>Web Design Tester：Installed,web Devolop，暂时用的不多。<br>Web Developer：Installed,web Devolop，暂时用的不多。<br>CssViewer：Installed,web Devolop，暂时用的不多。<br>PerfectPixel+EmmetLiveStyle: 更便捷精准还原设计图于网页设计，利弊兼有，偶尔用。</p>\n<p>更多插件请参见知乎<a href=\"http://www.zhihu.com/question/19594682\" target=\"_blank\" rel=\"noopener\">你极力推荐的 Chrome 扩展有哪些？</a>问题的各种回复。</p>\n<hr>\n<p>学起(了解几个快捷键即可)And 撸起 Vimium,想黑客一般在 Chrome 上飞起。<br>Vimium 常用快捷键(注：区分大小写)<br>j,: 向下移动 Scroll down<br>k,: 向上移动 Scroll upi<br>h : 左移 Scroll left<br>l : 右移 Scroll right</p>\n<p>H：回到上一个历史页面<br>L：回到下一个历史页面<br>J：跳到左边标签页<br>K：跳到右边标签页<br>t：创建新的标签页（ctrl+t）</p>\n<p>d : 向下移动一个页面 Scroll a page down<br>u : 向上移动一个页面 Scroll a page up</p>\n<p>gg : 移到页面顶部 Scroll to the top of the page<br>G : 移到页面底部 Scroll to the bottom of the page</p>\n<p>x：关闭当前标签页<br>X：恢复关闭的标签页</p>\n<p>r : 刷新 Reload the page<br>gs : 查看网页源码 View page source<br>yy : copy 当前页面 url Copy the current URL to the clipboard<br>yf : 拷贝当前页面的连接到剪切板 Copy a link URL to the clipboard<br>yt : 创建当前页面的一个副本(copy 当前路径在新 Tab 中打开)-Duplicate current tab<br>YT : 罗列出当前所有 Tab 页(并提供索引)，可任你选择性跳转，帅；</p>\n<p>p : 在当前标签页中打开剪切板中的链接 Open the clipboard’s URL in the current tab<br>P : 在新的标签页中打开剪切板中的链接 Open the clipboard’s URL in a new tab</p>\n<p>gu : Go up the URL hierarchy（例如，URL 为<a href=\"http://blog.net/article/8021689\" target=\"_blank\" rel=\"noopener\">http://blog.net/article/8021689</a> ，按下 gu 后，转到<a href=\"http://blog.net/article/%EF%BC%8C%E5%9B%9E%E5%88%B0%E8%AF%A5%E7%BD%91%E7%AB%99%E8%AF%A5%E8%AE%BF%E9%97%AE%E8%80%85%E4%B8%BB%E9%A1%B5%EF%BC%89\" target=\"_blank\" rel=\"noopener\">http://blog.net/article/，回到该网站该访问者主页）</a><br>gU : Go to root of current URL hierarchy (类似 gu，回到根 URL 页  <a href=\"http://blog.net/\" target=\"_blank\" rel=\"noopener\">http://blog.net</a>)</p>\n<hr>\n<p>f : 在当前标签页中打开链接 Open a link in the current tab<br>F : 在新标签页中打开链接 Open a link in a new tab</p>\n<p>YES: (几乎)所有的操作都是通过键盘的快捷键来操作。如果想点击页面上的某个连接时，在命令模式下，按 f 键之后就会对页面上所有可点击的连接或按钮进行编码，然后再输入相应的编码完成点击或者复制连接操作，包含常见的 a 标签，button 标签，input 标签中 type=button/submit/reset，不过有些也无法识别（flash); 见证如下图：。<br><a href=\"http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/viumclik.png\" target=\"_blank\" rel=\"noopener\" title=\"Vimium-F-Link\"><img src=\"http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/viumclik.png\" alt=\"Vimium-F-Link\"></a>Vimium-F-Link</p>\n<hr>\n<p>o : 在当前页面中打开 URL，书签和历史记录 Open URL, bookmark, or history entry<br>O : 在新标签页中打开 URL，书签和历史记录 Open URL, bookmark, history entry, in a new tab<br>T : 搜索打开的标签页 Search through your open tabs</p>\n<p>b : 打开书签 Open a bookmark<br>B : 在新标签中打开书签 Open a bookmark in a new tab<br>在命令行模式，按下 b(B)，可以对标签进行检索，检索结果通过 tab 键进行选择，回车即可打开标签。</p>\n<p><a href=\"http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/vimbookmap.png\" target=\"_blank\" rel=\"noopener\" title=\"Vimium-bB\"><img src=\"http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/vimbookmap.png\" alt=\"Vimium-bB\"></a>Vimium-bB</p>\n<p>/：查找（ctrl+f）<br>i : 进入输入模式 Enter insert mode<br>esc：退出</p>\n<hr>\n<p>还有些还不怎么常用的，比如：<br>zH : Scroll all the way to the left<br>zL : Scroll all the way to the right<br>m : Create a new mark</p>\n<p>最后，任何时候你需要帮助的时候可以按？(shilft+/)来调出帮助菜单，同时显示了所有快捷键的说明,again(shilft+/)即可 Close 之，如下图：<br><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/141813348554340.png\" target=\"_blank\" rel=\"noopener\" title=\"vimium-help\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/141813348554340.png\" alt=\"vimium-help\"></a>vimium-help</p>\n<p>切记(to myself)：熟能生巧，至巧了，即可夺天之工。</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>工欲善其事，必先利其器！撸起 Vimium,我的 Chrome 就这么起飞了。</p>\n<p>如今 PC 和 Mac 端安装的 Chrome 插件(偏前端)：<br>Vimium：黑客级别的 Chrome 插件，此文主记载的主角~(The Hacker’s Browser )；<br>ABP： 有她在，WEB 的世界就可以清静点了.<br>infinity：没有最好，只有更好，此款新标签页，如今最爱。<br>crxMouse: 如果用鼠标操作 Chrome,必备=充分发掘鼠标的所有操作。<br>JASN-handle：Json 解析，所用之中综合体验最优者；<br>OK 记： 一键记录你想记载的，体验一流！<br>Pocket: 轻松保存文章，视频等供以后查看。<br>QR 码生成器： PC 阅读-URL 转移手机的桥梁，用的不多。<br>WEB 前端助手： 功能虽不少，用的却也少。<br>Website Ip Option：获取了每个网页 Ip 显示于屏幕下方。<br>Web Design Tester：Installed,web Devolop，暂时用的不多。<br>Web Developer：Installed,web Devolop，暂时用的不多。<br>CssViewer：Installed,web Devolop，暂时用的不多。<br>PerfectPixel+EmmetLiveStyle: 更便捷精准还原设计图于网页设计，利弊兼有，偶尔用。</p>\n<p>更多插件请参见知乎<a href=\"http://www.zhihu.com/question/19594682\" target=\"_blank\" rel=\"noopener\">你极力推荐的 Chrome 扩展有哪些？</a>问题的各种回复。</p>\n<hr>\n<p>学起(了解几个快捷键即可)And 撸起 Vimium,想黑客一般在 Chrome 上飞起。<br>Vimium 常用快捷键(注：区分大小写)<br>j,: 向下移动 Scroll down<br>k,: 向上移动 Scroll upi<br>h : 左移 Scroll left<br>l : 右移 Scroll right</p>\n<p>H：回到上一个历史页面<br>L：回到下一个历史页面<br>J：跳到左边标签页<br>K：跳到右边标签页<br>t：创建新的标签页（ctrl+t）</p>\n<p>d : 向下移动一个页面 Scroll a page down<br>u : 向上移动一个页面 Scroll a page up</p>\n<p>gg : 移到页面顶部 Scroll to the top of the page<br>G : 移到页面底部 Scroll to the bottom of the page</p>\n<p>x：关闭当前标签页<br>X：恢复关闭的标签页</p>\n<p>r : 刷新 Reload the page<br>gs : 查看网页源码 View page source<br>yy : copy 当前页面 url Copy the current URL to the clipboard<br>yf : 拷贝当前页面的连接到剪切板 Copy a link URL to the clipboard<br>yt : 创建当前页面的一个副本(copy 当前路径在新 Tab 中打开)-Duplicate current tab<br>YT : 罗列出当前所有 Tab 页(并提供索引)，可任你选择性跳转，帅；</p>\n<p>p : 在当前标签页中打开剪切板中的链接 Open the clipboard’s URL in the current tab<br>P : 在新的标签页中打开剪切板中的链接 Open the clipboard’s URL in a new tab</p>\n<p>gu : Go up the URL hierarchy（例如，URL 为<a href=\"http://blog.net/article/8021689\" target=\"_blank\" rel=\"noopener\">http://blog.net/article/8021689</a> ，按下 gu 后，转到<a href=\"http://blog.net/article/%EF%BC%8C%E5%9B%9E%E5%88%B0%E8%AF%A5%E7%BD%91%E7%AB%99%E8%AF%A5%E8%AE%BF%E9%97%AE%E8%80%85%E4%B8%BB%E9%A1%B5%EF%BC%89\" target=\"_blank\" rel=\"noopener\">http://blog.net/article/，回到该网站该访问者主页）</a><br>gU : Go to root of current URL hierarchy (类似 gu，回到根 URL 页  <a href=\"http://blog.net/\" target=\"_blank\" rel=\"noopener\">http://blog.net</a>)</p>\n<hr>\n<p>f : 在当前标签页中打开链接 Open a link in the current tab<br>F : 在新标签页中打开链接 Open a link in a new tab</p>\n<p>YES: (几乎)所有的操作都是通过键盘的快捷键来操作。如果想点击页面上的某个连接时，在命令模式下，按 f 键之后就会对页面上所有可点击的连接或按钮进行编码，然后再输入相应的编码完成点击或者复制连接操作，包含常见的 a 标签，button 标签，input 标签中 type=button/submit/reset，不过有些也无法识别（flash); 见证如下图：。<br><a href=\"http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/viumclik.png\" target=\"_blank\" rel=\"noopener\" title=\"Vimium-F-Link\"><img src=\"http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/viumclik.png\" alt=\"Vimium-F-Link\"></a>Vimium-F-Link</p>\n<hr>\n<p>o : 在当前页面中打开 URL，书签和历史记录 Open URL, bookmark, or history entry<br>O : 在新标签页中打开 URL，书签和历史记录 Open URL, bookmark, history entry, in a new tab<br>T : 搜索打开的标签页 Search through your open tabs</p>\n<p>b : 打开书签 Open a bookmark<br>B : 在新标签中打开书签 Open a bookmark in a new tab<br>在命令行模式，按下 b(B)，可以对标签进行检索，检索结果通过 tab 键进行选择，回车即可打开标签。</p>\n<p><a href=\"http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/vimbookmap.png\" target=\"_blank\" rel=\"noopener\" title=\"Vimium-bB\"><img src=\"http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/vimbookmap.png\" alt=\"Vimium-bB\"></a>Vimium-bB</p>\n<p>/：查找（ctrl+f）<br>i : 进入输入模式 Enter insert mode<br>esc：退出</p>\n<hr>\n<p>还有些还不怎么常用的，比如：<br>zH : Scroll all the way to the left<br>zL : Scroll all the way to the right<br>m : Create a new mark</p>\n<p>最后，任何时候你需要帮助的时候可以按？(shilft+/)来调出帮助菜单，同时显示了所有快捷键的说明,again(shilft+/)即可 Close 之，如下图：<br><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/141813348554340.png\" target=\"_blank\" rel=\"noopener\" title=\"vimium-help\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/141813348554340.png\" alt=\"vimium-help\"></a>vimium-help</p>\n<p>切记(to myself)：熟能生巧，至巧了，即可夺天之工。</p>\n"},{"title":"移动端或者pc端不允许点击返回按钮","date":"2017-08-30T21:11:00.000Z","_content":"\n公司做移动端，支付成功之后摁返回按钮导致短信再次发送或者接口再次请求，只想让他点击页面指定的返回按钮，但是由于移动端不好监听手机的物理返回键以及微信左上角的返回按钮，经公司大牛研究好久出来下面代码\n\nhistory.pushState({}, \"\", window.location.href);\n\nwindow.addEventListener(\"popstate\", function() {\n\nhistory.pushState({}, \"\", window.location.href);\n\n});\n\n大概意思就是把当前的页面地址添加到 history 后退的那个参数里，导致点击后退的时候还是当前这个地址\n","source":"_posts/2017-08-31-移动端不允许点击返回按钮.md","raw":"---\ntitle: 移动端或者pc端不允许点击返回按钮\ntags:\n  - 技术\ndate: 2017-08-31 05:11:00\ncategories: 前端\n---\n\n公司做移动端，支付成功之后摁返回按钮导致短信再次发送或者接口再次请求，只想让他点击页面指定的返回按钮，但是由于移动端不好监听手机的物理返回键以及微信左上角的返回按钮，经公司大牛研究好久出来下面代码\n\nhistory.pushState({}, \"\", window.location.href);\n\nwindow.addEventListener(\"popstate\", function() {\n\nhistory.pushState({}, \"\", window.location.href);\n\n});\n\n大概意思就是把当前的页面地址添加到 history 后退的那个参数里，导致点击后退的时候还是当前这个地址\n","slug":"2017-08-31-移动端不允许点击返回按钮","published":1,"updated":"2020-03-14T06:47:04.802Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvjz000p4k8ygkm2etna","content":"<p>公司做移动端，支付成功之后摁返回按钮导致短信再次发送或者接口再次请求，只想让他点击页面指定的返回按钮，但是由于移动端不好监听手机的物理返回键以及微信左上角的返回按钮，经公司大牛研究好久出来下面代码</p>\n<p>history.pushState({}, “”, window.location.href);</p>\n<p>window.addEventListener(“popstate”, function() {</p>\n<p>history.pushState({}, “”, window.location.href);</p>\n<p>});</p>\n<p>大概意思就是把当前的页面地址添加到 history 后退的那个参数里，导致点击后退的时候还是当前这个地址</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>公司做移动端，支付成功之后摁返回按钮导致短信再次发送或者接口再次请求，只想让他点击页面指定的返回按钮，但是由于移动端不好监听手机的物理返回键以及微信左上角的返回按钮，经公司大牛研究好久出来下面代码</p>\n<p>history.pushState({}, “”, window.location.href);</p>\n<p>window.addEventListener(“popstate”, function() {</p>\n<p>history.pushState({}, “”, window.location.href);</p>\n<p>});</p>\n<p>大概意思就是把当前的页面地址添加到 history 后退的那个参数里，导致点击后退的时候还是当前这个地址</p>\n"},{"title":"vue中过滤器比较两个数组取相同值","date":"2017-09-14T17:47:00.000Z","_content":"\n在 vue 中需要比较两个数组取相同值\n\n一个大数组一个 小数组，小数组是大数组的一部分取相同 ID 的不同 name 值\n\n有两种写法，两个 for 循环和 map 写法\n\nconst toName = (ids, arr) => {\nlet a = \\[\\];\nids = String(ids) && String(ids).split(',') || \\[\\]; for (let i = 0, length = arr.length; i < length; i++) { for (let j = 0, l = ids.length; j < l; j++) { if (ids\\[j\\] == arr\\[i\\].id) {\na.push(arr\\[i\\].name)\n}\n}\n} return a.join();\n}\n\nconst toName = (ids, arr) => {\nlet list = \\[\\]\nids = String(ids) && String(ids).split(',') || \\[\\];\nids.map((x) => { this.arr.map((k) => { if (k.id == x) { return list.push(k.name)\n}\n})\n})\nids = list.join(\"、\")\n}\n\n在 vue 中就可以使用了\n\n{ {78 | toName(“78,456,78”)}}//数字可以转字符串\n{ {“78”| toName(“78,456,78”)}}//直接使用\n\n{ {“87，78，80”| toName(“78,456,78”)}}//直接使用\n","source":"_posts/2017-09-15-vue中过滤器比较两个数组取相同值.md","raw":"---\ntitle: vue中过滤器比较两个数组取相同值\ntags:\n  - 技术\n  - vue\ndate: 2017-09-15 01:47:00\ncategories: 前端\n---\n\n在 vue 中需要比较两个数组取相同值\n\n一个大数组一个 小数组，小数组是大数组的一部分取相同 ID 的不同 name 值\n\n有两种写法，两个 for 循环和 map 写法\n\nconst toName = (ids, arr) => {\nlet a = \\[\\];\nids = String(ids) && String(ids).split(',') || \\[\\]; for (let i = 0, length = arr.length; i < length; i++) { for (let j = 0, l = ids.length; j < l; j++) { if (ids\\[j\\] == arr\\[i\\].id) {\na.push(arr\\[i\\].name)\n}\n}\n} return a.join();\n}\n\nconst toName = (ids, arr) => {\nlet list = \\[\\]\nids = String(ids) && String(ids).split(',') || \\[\\];\nids.map((x) => { this.arr.map((k) => { if (k.id == x) { return list.push(k.name)\n}\n})\n})\nids = list.join(\"、\")\n}\n\n在 vue 中就可以使用了\n\n{ {78 | toName(“78,456,78”)}}//数字可以转字符串\n{ {“78”| toName(“78,456,78”)}}//直接使用\n\n{ {“87，78，80”| toName(“78,456,78”)}}//直接使用\n","slug":"2017-09-15-vue中过滤器比较两个数组取相同值","published":1,"updated":"2020-03-14T06:48:01.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvk1000s4k8y1n6jfm29","content":"<p>在 vue 中需要比较两个数组取相同值</p>\n<p>一个大数组一个 小数组，小数组是大数组的一部分取相同 ID 的不同 name 值</p>\n<p>有两种写法，两个 for 循环和 map 写法</p>\n<p>const toName = (ids, arr) =&gt; {<br>let a = [];<br>ids = String(ids) &amp;&amp; String(ids).split(‘,’) || []; for (let i = 0, length = arr.length; i &lt; length; i++) { for (let j = 0, l = ids.length; j &lt; l; j++) { if (ids[j] == arr[i].id) {<br>a.push(arr[i].name)<br>}<br>}<br>} return a.join();<br>}</p>\n<p>const toName = (ids, arr) =&gt; {<br>let list = []<br>ids = String(ids) &amp;&amp; String(ids).split(‘,’) || [];<br>ids.map((x) =&gt; { this.arr.map((k) =&gt; { if (k.id == x) { return list.push(k.name)<br>}<br>})<br>})<br>ids = list.join(“、”)<br>}</p>\n<p>在 vue 中就可以使用了</p>\n<p>{ {78 | toName(“78,456,78”)}}//数字可以转字符串<br>{ {“78”| toName(“78,456,78”)}}//直接使用</p>\n<p>{ {“87，78，80”| toName(“78,456,78”)}}//直接使用</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>在 vue 中需要比较两个数组取相同值</p>\n<p>一个大数组一个 小数组，小数组是大数组的一部分取相同 ID 的不同 name 值</p>\n<p>有两种写法，两个 for 循环和 map 写法</p>\n<p>const toName = (ids, arr) =&gt; {<br>let a = [];<br>ids = String(ids) &amp;&amp; String(ids).split(‘,’) || []; for (let i = 0, length = arr.length; i &lt; length; i++) { for (let j = 0, l = ids.length; j &lt; l; j++) { if (ids[j] == arr[i].id) {<br>a.push(arr[i].name)<br>}<br>}<br>} return a.join();<br>}</p>\n<p>const toName = (ids, arr) =&gt; {<br>let list = []<br>ids = String(ids) &amp;&amp; String(ids).split(‘,’) || [];<br>ids.map((x) =&gt; { this.arr.map((k) =&gt; { if (k.id == x) { return list.push(k.name)<br>}<br>})<br>})<br>ids = list.join(“、”)<br>}</p>\n<p>在 vue 中就可以使用了</p>\n<p>{ {78 | toName(“78,456,78”)}}//数字可以转字符串<br>{ {“78”| toName(“78,456,78”)}}//直接使用</p>\n<p>{ {“87，78，80”| toName(“78,456,78”)}}//直接使用</p>\n"},{"title":"iview中使用Tag时进行数据的变化和实现将输入内容转化为标签输出数组","date":"2017-09-11T07:26:00.000Z","_content":"\n**上代码**\n\nDOCTYPE html>\n\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>iview exampletitle>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"http://unpkg.com/iview/dist/styles/iview.css\">\n    <script type=\"text/javascript\" src=\"http://vuejs.org/js/vue.min.js\">script>\n    <script type=\"text/javascript\" src=\"http://unpkg.com/iview/dist/iview.min.js\">script>\nhead>\n<body>\n<div id=\"app\">\n    <Input v-model=\"value\" placeholder=\"请输入...\" style=\"width: 300px\" @on-enter=\"handleAdd\">Input>\n    <Button icon=\"ios-plus-empty\" type=\"dashed\" size=\"big\" @click=\"handleAdd\" shape=\"circal\">添加标签Button>\n     <Tag v-for=\"item in count\" :key=\"item\" :name=\"item\" closable @on-close=\"handleClose2\">{ { item }}Tag>\n    <Button size=\"big\" @click=\"change\" shape=\"circal\">数组转化字符串Button>\n    <Button size=\"big\" @click=\"change1\" shape=\"circal\">字符串转化数组Button>\n    \ndiv>\n<script>\n    new Vue({\n        el: '#app',\n        data () { return {\n                count:\\[1,2,23\\],\n                value:'' }\n        },\n        methods: {\n             handleAdd () { if (this.value!==\"\") { this.count.push(this.value); this.value=\"\" } else { this.$Message.info('不能为空');\n                }\n            },\n            handleClose2 (event, name) {\n                const index = this.count.indexOf(name); this.count.splice(index, 1);\n            },\n            change(){\n                console.log(this.count.join(\",\"));\n                \n            },\n            change1(){\n                let string=this.count.join(\",\")\n                console.log(string)\n                console.log(typeof(string))\n                let arry=string.split(\",\")\n                console.log(typeof(arry))\n                console.log(arry)\n                console.log(typeof(this.count))\n            }\n        }\n    }) script>\nbody>\nhtml>\n\n相关演示（翻墙可看）：[youtube](https://youtu.be/D3SVyMgY5q4 \"翻墙可看\")\n","source":"_posts/2017-09-11-iview中使用Tag时进行数据的变化.md","raw":"---\ntitle: iview中使用Tag时进行数据的变化和实现将输入内容转化为标签输出数组\ntags:\n  - 技术\n  - vue\ndate: 2017-09-11 15:26:00\ncategories: 前端\n---\n\n**上代码**\n\nDOCTYPE html>\n\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>iview exampletitle>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"http://unpkg.com/iview/dist/styles/iview.css\">\n    <script type=\"text/javascript\" src=\"http://vuejs.org/js/vue.min.js\">script>\n    <script type=\"text/javascript\" src=\"http://unpkg.com/iview/dist/iview.min.js\">script>\nhead>\n<body>\n<div id=\"app\">\n    <Input v-model=\"value\" placeholder=\"请输入...\" style=\"width: 300px\" @on-enter=\"handleAdd\">Input>\n    <Button icon=\"ios-plus-empty\" type=\"dashed\" size=\"big\" @click=\"handleAdd\" shape=\"circal\">添加标签Button>\n     <Tag v-for=\"item in count\" :key=\"item\" :name=\"item\" closable @on-close=\"handleClose2\">{ { item }}Tag>\n    <Button size=\"big\" @click=\"change\" shape=\"circal\">数组转化字符串Button>\n    <Button size=\"big\" @click=\"change1\" shape=\"circal\">字符串转化数组Button>\n    \ndiv>\n<script>\n    new Vue({\n        el: '#app',\n        data () { return {\n                count:\\[1,2,23\\],\n                value:'' }\n        },\n        methods: {\n             handleAdd () { if (this.value!==\"\") { this.count.push(this.value); this.value=\"\" } else { this.$Message.info('不能为空');\n                }\n            },\n            handleClose2 (event, name) {\n                const index = this.count.indexOf(name); this.count.splice(index, 1);\n            },\n            change(){\n                console.log(this.count.join(\",\"));\n                \n            },\n            change1(){\n                let string=this.count.join(\",\")\n                console.log(string)\n                console.log(typeof(string))\n                let arry=string.split(\",\")\n                console.log(typeof(arry))\n                console.log(arry)\n                console.log(typeof(this.count))\n            }\n        }\n    }) script>\nbody>\nhtml>\n\n相关演示（翻墙可看）：[youtube](https://youtu.be/D3SVyMgY5q4 \"翻墙可看\")\n","slug":"2017-09-11-iview中使用Tag时进行数据的变化","published":1,"updated":"2020-03-14T06:47:52.013Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvk3000x4k8y95cf3ox5","content":"<p><strong>上代码</strong></p>\n<p>DOCTYPE html&gt;</p>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>iview exampletitle>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"http://unpkg.com/iview/dist/styles/iview.css\">\n    <script type=\"text/javascript\" src=\"http://vuejs.org/js/vue.min.js\">script>\n    <script type=\"text/javascript\" src=\"http://unpkg.com/iview/dist/iview.min.js\">script>\nhead>\n<body>\n<div id=\"app\">\n    <Input v-model=\"value\" placeholder=\"请输入...\" style=\"width: 300px\" @on-enter=\"handleAdd\">Input>\n    <Button icon=\"ios-plus-empty\" type=\"dashed\" size=\"big\" @click=\"handleAdd\" shape=\"circal\">添加标签Button>\n     <Tag v-for=\"item in count\" :key=\"item\" :name=\"item\" closable @on-close=\"handleClose2\">{ { item }}Tag>\n    <Button size=\"big\" @click=\"change\" shape=\"circal\">数组转化字符串Button>\n    <Button size=\"big\" @click=\"change1\" shape=\"circal\">字符串转化数组Button>\n\n<p>div&gt;</p>\n<script>\n    new Vue({\n        el: '#app',\n        data () { return {\n                count:\\[1,2,23\\],\n                value:'' }\n        },\n        methods: {\n             handleAdd () { if (this.value!==\"\") { this.count.push(this.value); this.value=\"\" } else { this.$Message.info('不能为空');\n                }\n            },\n            handleClose2 (event, name) {\n                const index = this.count.indexOf(name); this.count.splice(index, 1);\n            },\n            change(){\n                console.log(this.count.join(\",\"));\n\n            },\n            change1(){\n                let string=this.count.join(\",\")\n                console.log(string)\n                console.log(typeof(string))\n                let arry=string.split(\",\")\n                console.log(typeof(arry))\n                console.log(arry)\n                console.log(typeof(this.count))\n            }\n        }\n    }) script>\nbody>\nhtml>\n\n相关演示（翻墙可看）：[youtube](https://youtu.be/D3SVyMgY5q4 \"翻墙可看\")\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p><strong>上代码</strong></p>\n<p>DOCTYPE html&gt;</p>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>iview exampletitle>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"http://unpkg.com/iview/dist/styles/iview.css\">\n    <script type=\"text/javascript\" src=\"http://vuejs.org/js/vue.min.js\">script>\n    <script type=\"text/javascript\" src=\"http://unpkg.com/iview/dist/iview.min.js\">script>\nhead>\n<body>\n<div id=\"app\">\n    <Input v-model=\"value\" placeholder=\"请输入...\" style=\"width: 300px\" @on-enter=\"handleAdd\">Input>\n    <Button icon=\"ios-plus-empty\" type=\"dashed\" size=\"big\" @click=\"handleAdd\" shape=\"circal\">添加标签Button>\n     <Tag v-for=\"item in count\" :key=\"item\" :name=\"item\" closable @on-close=\"handleClose2\">{ { item }}Tag>\n    <Button size=\"big\" @click=\"change\" shape=\"circal\">数组转化字符串Button>\n    <Button size=\"big\" @click=\"change1\" shape=\"circal\">字符串转化数组Button>\n\n<p>div&gt;</p>\n<script>\n    new Vue({\n        el: '#app',\n        data () { return {\n                count:\\[1,2,23\\],\n                value:'' }\n        },\n        methods: {\n             handleAdd () { if (this.value!==\"\") { this.count.push(this.value); this.value=\"\" } else { this.$Message.info('不能为空');\n                }\n            },\n            handleClose2 (event, name) {\n                const index = this.count.indexOf(name); this.count.splice(index, 1);\n            },\n            change(){\n                console.log(this.count.join(\",\"));\n\n            },\n            change1(){\n                let string=this.count.join(\",\")\n                console.log(string)\n                console.log(typeof(string))\n                let arry=string.split(\",\")\n                console.log(typeof(arry))\n                console.log(arry)\n                console.log(typeof(this.count))\n            }\n        }\n    }) script>\nbody>\nhtml>\n\n相关演示（翻墙可看）：[youtube](https://youtu.be/D3SVyMgY5q4 \"翻墙可看\")\n"},{"title":"前端模板Nunjucks简介","date":"2017-09-19T21:41:00.000Z","_content":"\n参考资料: [https://mozilla.github.io/nunjucks/](https://mozilla.github.io/nunjucks/)\n\n[https://mozilla.github.io/nunjucks/templating.html](https://mozilla.github.io/nunjucks/templating.html)\n\n[https://mozilla.github.io/nunjucks/api.html](https://mozilla.github.io/nunjucks/api.html)\n\n## [](https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#%E5%B8%B8%E7%94%A8api)常用 API\n\n### [](https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#render)render\n\nnunjucks.render(name, \\[context\\], \\[callback\\])\n\nvar res = nunjucks.render('foo.html');\nvar res = nunjucks.render('foo.html', { username: 'James' });  \nnunjucks.render('async.html', function(err, res) {\n});\n\n### [](https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#renderstring)renderString\n\nnunjucks.renderString(str, context, \\[callback\\]) 返回渲染后的原始字符串。\n\nvar res = nunjucks.renderString('Hello { { username }}', { username: 'James' }); //输出 Hello James\n\n### [](https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#configure)configure\n\nnunjucks.configure(\\[path\\], \\[opts\\]); path 默认当前路径,模板文件所在的路径。\n\nnunjucks.configure('views', { //views 为模板文件所在的目录\nautoescape: true,\nexpress: app,\nwatch: true\n});\n\n### [](https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#gettemplate)getTemplate\n\nenv.getTemplate(name, \\[eagerCompile\\], \\[callback\\]) Retrieve the template named name\n\nvar tmpl = env.getTemplate('page.html', true); //返回模板文件 page.html 的内容\n\n### [](https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#express)express\n\nenv.express(app) 用做服务端渲染\n\n![复制代码](http://www.jixiaokang.com/wp-content/uploads/2018/05/copycode-1.gif)\n\nvar app = express();\nenv.express(app);\n\napp.get('/', function(req, res) {\nres.render('index.html');\n});\n\n![复制代码](http://www.jixiaokang.com/wp-content/uploads/2018/05/copycode-1.gif)\n\n### [](https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#constructor)constructor\n\nnew Template(src, \\[env\\], \\[path\\], \\[eagerCompile\\])\n\nvar tmpl = new nunjucks.Template('Hello { { username }}');\ntmpl.render({ username: \"James\" }); // -> \"Hello James\"\n","source":"_posts/2017-09-20-前端模板Nunjucks简介.md","raw":"---\ntitle: 前端模板Nunjucks简介\ntags:\n  - 前端\ndate: 2017-09-20 05:41:00\ncategories: 前端\n---\n\n参考资料: [https://mozilla.github.io/nunjucks/](https://mozilla.github.io/nunjucks/)\n\n[https://mozilla.github.io/nunjucks/templating.html](https://mozilla.github.io/nunjucks/templating.html)\n\n[https://mozilla.github.io/nunjucks/api.html](https://mozilla.github.io/nunjucks/api.html)\n\n## [](https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#%E5%B8%B8%E7%94%A8api)常用 API\n\n### [](https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#render)render\n\nnunjucks.render(name, \\[context\\], \\[callback\\])\n\nvar res = nunjucks.render('foo.html');\nvar res = nunjucks.render('foo.html', { username: 'James' });  \nnunjucks.render('async.html', function(err, res) {\n});\n\n### [](https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#renderstring)renderString\n\nnunjucks.renderString(str, context, \\[callback\\]) 返回渲染后的原始字符串。\n\nvar res = nunjucks.renderString('Hello { { username }}', { username: 'James' }); //输出 Hello James\n\n### [](https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#configure)configure\n\nnunjucks.configure(\\[path\\], \\[opts\\]); path 默认当前路径,模板文件所在的路径。\n\nnunjucks.configure('views', { //views 为模板文件所在的目录\nautoescape: true,\nexpress: app,\nwatch: true\n});\n\n### [](https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#gettemplate)getTemplate\n\nenv.getTemplate(name, \\[eagerCompile\\], \\[callback\\]) Retrieve the template named name\n\nvar tmpl = env.getTemplate('page.html', true); //返回模板文件 page.html 的内容\n\n### [](https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#express)express\n\nenv.express(app) 用做服务端渲染\n\n![复制代码](http://www.jixiaokang.com/wp-content/uploads/2018/05/copycode-1.gif)\n\nvar app = express();\nenv.express(app);\n\napp.get('/', function(req, res) {\nres.render('index.html');\n});\n\n![复制代码](http://www.jixiaokang.com/wp-content/uploads/2018/05/copycode-1.gif)\n\n### [](https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#constructor)constructor\n\nnew Template(src, \\[env\\], \\[path\\], \\[eagerCompile\\])\n\nvar tmpl = new nunjucks.Template('Hello { { username }}');\ntmpl.render({ username: \"James\" }); // -> \"Hello James\"\n","slug":"2017-09-20-前端模板Nunjucks简介","published":1,"updated":"2020-03-14T06:48:35.188Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvk500104k8yh1q8eiju","content":"<p>参考资料: <a href=\"https://mozilla.github.io/nunjucks/\" target=\"_blank\" rel=\"noopener\">https://mozilla.github.io/nunjucks/</a></p>\n<p><a href=\"https://mozilla.github.io/nunjucks/templating.html\" target=\"_blank\" rel=\"noopener\">https://mozilla.github.io/nunjucks/templating.html</a></p>\n<p><a href=\"https://mozilla.github.io/nunjucks/api.html\" target=\"_blank\" rel=\"noopener\">https://mozilla.github.io/nunjucks/api.html</a></p>\n<h2 id=\"常用-API\"><a href=\"#常用-API\" class=\"headerlink\" title=\"常用 API\"></a><a href=\"https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#%E5%B8%B8%E7%94%A8api\" target=\"_blank\" rel=\"noopener\"></a>常用 API</h2><h3 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a><a href=\"https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#render\" target=\"_blank\" rel=\"noopener\"></a>render</h3><p>nunjucks.render(name, [context], [callback])</p>\n<p>var res = nunjucks.render(‘foo.html’);<br>var res = nunjucks.render(‘foo.html’, { username: ‘James’ });<br>nunjucks.render(‘async.html’, function(err, res) {<br>});</p>\n<h3 id=\"renderString\"><a href=\"#renderString\" class=\"headerlink\" title=\"renderString\"></a><a href=\"https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#renderstring\" target=\"_blank\" rel=\"noopener\"></a>renderString</h3><p>nunjucks.renderString(str, context, [callback]) 返回渲染后的原始字符串。</p>\n<p>var res = nunjucks.renderString(‘Hello { { username }}’, { username: ‘James’ }); //输出 Hello James</p>\n<h3 id=\"configure\"><a href=\"#configure\" class=\"headerlink\" title=\"configure\"></a><a href=\"https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#configure\" target=\"_blank\" rel=\"noopener\"></a>configure</h3><p>nunjucks.configure([path], [opts]); path 默认当前路径,模板文件所在的路径。</p>\n<p>nunjucks.configure(‘views’, { //views 为模板文件所在的目录<br>autoescape: true,<br>express: app,<br>watch: true<br>});</p>\n<h3 id=\"getTemplate\"><a href=\"#getTemplate\" class=\"headerlink\" title=\"getTemplate\"></a><a href=\"https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#gettemplate\" target=\"_blank\" rel=\"noopener\"></a>getTemplate</h3><p>env.getTemplate(name, [eagerCompile], [callback]) Retrieve the template named name</p>\n<p>var tmpl = env.getTemplate(‘page.html’, true); //返回模板文件 page.html 的内容</p>\n<h3 id=\"express\"><a href=\"#express\" class=\"headerlink\" title=\"express\"></a><a href=\"https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#express\" target=\"_blank\" rel=\"noopener\"></a>express</h3><p>env.express(app) 用做服务端渲染</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/copycode-1.gif\" alt=\"复制代码\"></p>\n<p>var app = express();<br>env.express(app);</p>\n<p>app.get(‘/‘, function(req, res) {<br>res.render(‘index.html’);<br>});</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/copycode-1.gif\" alt=\"复制代码\"></p>\n<h3 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a><a href=\"https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#constructor\" target=\"_blank\" rel=\"noopener\"></a>constructor</h3><p>new Template(src, [env], [path], [eagerCompile])</p>\n<p>var tmpl = new nunjucks.Template(‘Hello { { username }}’);<br>tmpl.render({ username: “James” }); // -&gt; “Hello James”</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>参考资料: <a href=\"https://mozilla.github.io/nunjucks/\" target=\"_blank\" rel=\"noopener\">https://mozilla.github.io/nunjucks/</a></p>\n<p><a href=\"https://mozilla.github.io/nunjucks/templating.html\" target=\"_blank\" rel=\"noopener\">https://mozilla.github.io/nunjucks/templating.html</a></p>\n<p><a href=\"https://mozilla.github.io/nunjucks/api.html\" target=\"_blank\" rel=\"noopener\">https://mozilla.github.io/nunjucks/api.html</a></p>\n<h2 id=\"常用-API\"><a href=\"#常用-API\" class=\"headerlink\" title=\"常用 API\"></a><a href=\"https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#%E5%B8%B8%E7%94%A8api\" target=\"_blank\" rel=\"noopener\"></a>常用 API</h2><h3 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a><a href=\"https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#render\" target=\"_blank\" rel=\"noopener\"></a>render</h3><p>nunjucks.render(name, [context], [callback])</p>\n<p>var res = nunjucks.render(‘foo.html’);<br>var res = nunjucks.render(‘foo.html’, { username: ‘James’ });<br>nunjucks.render(‘async.html’, function(err, res) {<br>});</p>\n<h3 id=\"renderString\"><a href=\"#renderString\" class=\"headerlink\" title=\"renderString\"></a><a href=\"https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#renderstring\" target=\"_blank\" rel=\"noopener\"></a>renderString</h3><p>nunjucks.renderString(str, context, [callback]) 返回渲染后的原始字符串。</p>\n<p>var res = nunjucks.renderString(‘Hello { { username }}’, { username: ‘James’ }); //输出 Hello James</p>\n<h3 id=\"configure\"><a href=\"#configure\" class=\"headerlink\" title=\"configure\"></a><a href=\"https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#configure\" target=\"_blank\" rel=\"noopener\"></a>configure</h3><p>nunjucks.configure([path], [opts]); path 默认当前路径,模板文件所在的路径。</p>\n<p>nunjucks.configure(‘views’, { //views 为模板文件所在的目录<br>autoescape: true,<br>express: app,<br>watch: true<br>});</p>\n<h3 id=\"getTemplate\"><a href=\"#getTemplate\" class=\"headerlink\" title=\"getTemplate\"></a><a href=\"https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#gettemplate\" target=\"_blank\" rel=\"noopener\"></a>getTemplate</h3><p>env.getTemplate(name, [eagerCompile], [callback]) Retrieve the template named name</p>\n<p>var tmpl = env.getTemplate(‘page.html’, true); //返回模板文件 page.html 的内容</p>\n<h3 id=\"express\"><a href=\"#express\" class=\"headerlink\" title=\"express\"></a><a href=\"https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#express\" target=\"_blank\" rel=\"noopener\"></a>express</h3><p>env.express(app) 用做服务端渲染</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/copycode-1.gif\" alt=\"复制代码\"></p>\n<p>var app = express();<br>env.express(app);</p>\n<p>app.get(‘/‘, function(req, res) {<br>res.render(‘index.html’);<br>});</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/copycode-1.gif\" alt=\"复制代码\"></p>\n<h3 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a><a href=\"https://github.com/rainnaZR/svg-animations/blob/master/doc/Nunjucks.md#constructor\" target=\"_blank\" rel=\"noopener\"></a>constructor</h3><p>new Template(src, [env], [path], [eagerCompile])</p>\n<p>var tmpl = new nunjucks.Template(‘Hello { { username }}’);<br>tmpl.render({ username: “James” }); // -&gt; “Hello James”</p>\n"},{"title":"2017 Google hosts 持续更新【更新于:2017-09-20】","toc":false,"date":"2017-09-19T06:26:00.000Z","_content":"\n- **转载请注明：**[  老 D 博客](https://laod.cn \"本文固定链接 https://laod.cn/hosts/android-hosts.html\")\n\n本页面长期更新最新[Google](https://laod.cn/tag/google \"浏览关于“Google”的文章\")、谷歌学术、维基百科、ccFox.info、ProjectH、Battle.NET 、WordPress、Microsoft Live、GitHub、Amazon、Archive、Box.com、Disqus、SoundCloud、inoreader、Feedly、FlipBoard、Twitter、Tumblr、Facebook、Flickr、imgur、Instagram、DuckDuckGo、Ixquick、Yahoo、Google Services、Google apis、Android、Youtube、Google Drive、UpLoad、Appspot、Googl eusercontent、Gstatic、Gmail、Google other、Google Play 等[hosts](https://laod.cn/tag/hosts \"浏览关于“hosts”的文章\")。\n\n致谢：  \n[Github 项目](https://laod.cn/go.php?url=https://github.com/racaljk/hosts)维护者 @racaljk @andytimes @Too-Naive @laodcn @lrinQVQ @K-Guan @imcaffrey @smounives @lautis0503 @aofall @davymai  @Ignotus-CN @cw881014 等等…  \n感谢那些帮助、支持、以及批评、指责、攻击过老 D 博客的人们！\n\n> hosts 是一个没有扩展名的系统文件，它并不是软件或者工具。\n\n[![2017 Google hosts 持续更新【更新于:2017-09-18】](http://www.jixiaokang.com/wp-content/uploads/2018/05/hosts-1.png)](http://www.jixiaokang.com/wp-content/uploads/2018/05/hosts-1.png)\n\n#### [hosts](https://laod.cn/tag/hosts \"浏览关于“hosts”的文章\")所在文件夹：\n\n- **Windows**  系统[host](https://laod.cn/tag/host \"浏览关于“host”的文章\")s 位于  C:\\\\Windows\\\\System32\\\\drivers\\\\etc\\\\hosts\n- **Android**（安卓）系统 hosts 位于  /etc/hosts\n- **Mac**（苹果电脑）系统 hosts 位于  /etc/hosts\n- **iPhone**（iOS）系统 hosts 位于  /etc/hosts\n- **Linux**系统 hosts 位于  /etc/hosts\n- 绝大多数 Unix 系统都是在  /etc/hosts\n\n你也可以用 Notepad++  自行转换文本编码和换行符格式。当然，老 D 分享的都转换好了。\n\n**注意**： 若更新后，hosts 没有立即生效，请重置网络：  \n在系统设置内开关网络，或启用禁用飞行模式，或者重启、刷新 DNS 缓存、浏览器缓存。\n\n**更新于：2017-09-19**\n\n本次更新：修复谷歌、Gmail、YouTube 等...\n\n**注意：**  \nGoogle、Gmail、维基百科、Twitter、Facebook 等必须请用**https**加密方式打开。  \n一般这些网站都是 SSL 加密链接，如：\n\n谷歌学术：[https://scholar.google.com/](https://laod.cn/go.php?url=https://scholar.google.com/)  \n谷歌：[https://www.google.com/ncr](https://laod.cn/go.php?url=https://www.google.com/ncr)  \n谷歌香港：[https://www.google.com.hk/ncr](https://laod.cn/go.php?url=https://www.google.com.hk/ncr)  \nTwitter：[https://twitter.com/?lang=zh-cn](https://laod.cn/go.php?url=https://twitter.com/?lang=zh-cn)\n\n另外可能有的地区&网络（铁通、联通）hosts 无法正常使用，这个不是你我能左右的！  \n建议不要使用国产浏览器，国产软件也是，特别是 360，因为国产浏览器即使你使用 https  \n它也会强制你使用默认 http，还有就是会上传用户数据，尽可能使用 Chrome  \n下载&修改 hosts 安全软件可能会“报毒”（误报）你可以暂时退出或者添加信任即可！\n\n#### **我的 hosts 下载（\\***没有压缩密码**\\*）：**\n\n# [文件下载](https://files.cnblogs.com/files/xkloveme/windows%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86.zip \"下载链接\")\n\n里面包含 Windows & Mac 、Android & Linux 请对号入座。  \n另外 windows 可以直接运行批处理命令，hosts 会自动替换（如果无法自动替换，请用管理员身份权限手动修改）  \n注意：批处理命令会直接覆盖现有 hosts，如现有 hosts 内容重要的话请备份后再使用，或者手动修改！\n\n老 D 所提供的 hosts 仅限于学习使用！hosts 里不会添加屏蔽广告条目，也不会劫持任何网站。\n\n### 修改 hosts 后生效方法：\n\n- Windows  \n  开始 -> 运行 -\\> 输入 cmd -> 在 CMD 窗口输入\n- ipconfig /flushdns\n\n- Linux  \n  终端输入\n\n  sudo rcnscd restart\n\n  对于 systemd 发行版，请使用命令\n\n  sudo systemctl restart NetworkManager\n\n  如果不懂请都尝试下 Mac OS X 终端输入\n\n- sudo killall -HUP mDNSResponder\n\n- Android  \n  开启飞行模式 -\\> 关闭飞行模式\n- **通用方法**  \n  拔网线(断网) -\\> 插网线(重新连接网络)\n- 如不行请清空浏览器缓存（老 D 建议不要使用国产浏览器，请使用谷歌 Chrome 浏览器）\n\n修改 hosts 支持文档：\n\n[Windows 修改 hosts 方法](https://laod.cn/hosts/windows7-8-10-mac-iphone-hosts.html)\n\n[苹果 Mac OS 系统修改 Hosts 文件的方法](https://laod.cn/hosts/mac-os-xiugai-hosts.html)\n\n[iPhone iPad 等 iOS 设备上配置修改 hosts 方法](https://laod.cn/hosts/iphone-ipad-ios-hosts.html)\n\n[Android 修改 hosts 文件的方法介绍](https://laod.cn/hosts/android-hosts.html)\n\n[![2017 Google hosts 持续更新【更新于:2017-09-18】](http://www.jixiaokang.com/wp-content/uploads/2018/05/20170111022240.png)](http://www.jixiaokang.com/wp-content/uploads/2018/05/20170111022240.png)\n","source":"_posts/2017-09-19-googlehosts.md","raw":"---\ntitle: 2017 Google hosts 持续更新【更新于:2017-09-20】\ntags:\n  - host\ntoc: false\ndate: 2017-09-19 14:26:00\ncategories: 工具\n---\n\n- **转载请注明：**[  老 D 博客](https://laod.cn \"本文固定链接 https://laod.cn/hosts/android-hosts.html\")\n\n本页面长期更新最新[Google](https://laod.cn/tag/google \"浏览关于“Google”的文章\")、谷歌学术、维基百科、ccFox.info、ProjectH、Battle.NET 、WordPress、Microsoft Live、GitHub、Amazon、Archive、Box.com、Disqus、SoundCloud、inoreader、Feedly、FlipBoard、Twitter、Tumblr、Facebook、Flickr、imgur、Instagram、DuckDuckGo、Ixquick、Yahoo、Google Services、Google apis、Android、Youtube、Google Drive、UpLoad、Appspot、Googl eusercontent、Gstatic、Gmail、Google other、Google Play 等[hosts](https://laod.cn/tag/hosts \"浏览关于“hosts”的文章\")。\n\n致谢：  \n[Github 项目](https://laod.cn/go.php?url=https://github.com/racaljk/hosts)维护者 @racaljk @andytimes @Too-Naive @laodcn @lrinQVQ @K-Guan @imcaffrey @smounives @lautis0503 @aofall @davymai  @Ignotus-CN @cw881014 等等…  \n感谢那些帮助、支持、以及批评、指责、攻击过老 D 博客的人们！\n\n> hosts 是一个没有扩展名的系统文件，它并不是软件或者工具。\n\n[![2017 Google hosts 持续更新【更新于:2017-09-18】](http://www.jixiaokang.com/wp-content/uploads/2018/05/hosts-1.png)](http://www.jixiaokang.com/wp-content/uploads/2018/05/hosts-1.png)\n\n#### [hosts](https://laod.cn/tag/hosts \"浏览关于“hosts”的文章\")所在文件夹：\n\n- **Windows**  系统[host](https://laod.cn/tag/host \"浏览关于“host”的文章\")s 位于  C:\\\\Windows\\\\System32\\\\drivers\\\\etc\\\\hosts\n- **Android**（安卓）系统 hosts 位于  /etc/hosts\n- **Mac**（苹果电脑）系统 hosts 位于  /etc/hosts\n- **iPhone**（iOS）系统 hosts 位于  /etc/hosts\n- **Linux**系统 hosts 位于  /etc/hosts\n- 绝大多数 Unix 系统都是在  /etc/hosts\n\n你也可以用 Notepad++  自行转换文本编码和换行符格式。当然，老 D 分享的都转换好了。\n\n**注意**： 若更新后，hosts 没有立即生效，请重置网络：  \n在系统设置内开关网络，或启用禁用飞行模式，或者重启、刷新 DNS 缓存、浏览器缓存。\n\n**更新于：2017-09-19**\n\n本次更新：修复谷歌、Gmail、YouTube 等...\n\n**注意：**  \nGoogle、Gmail、维基百科、Twitter、Facebook 等必须请用**https**加密方式打开。  \n一般这些网站都是 SSL 加密链接，如：\n\n谷歌学术：[https://scholar.google.com/](https://laod.cn/go.php?url=https://scholar.google.com/)  \n谷歌：[https://www.google.com/ncr](https://laod.cn/go.php?url=https://www.google.com/ncr)  \n谷歌香港：[https://www.google.com.hk/ncr](https://laod.cn/go.php?url=https://www.google.com.hk/ncr)  \nTwitter：[https://twitter.com/?lang=zh-cn](https://laod.cn/go.php?url=https://twitter.com/?lang=zh-cn)\n\n另外可能有的地区&网络（铁通、联通）hosts 无法正常使用，这个不是你我能左右的！  \n建议不要使用国产浏览器，国产软件也是，特别是 360，因为国产浏览器即使你使用 https  \n它也会强制你使用默认 http，还有就是会上传用户数据，尽可能使用 Chrome  \n下载&修改 hosts 安全软件可能会“报毒”（误报）你可以暂时退出或者添加信任即可！\n\n#### **我的 hosts 下载（\\***没有压缩密码**\\*）：**\n\n# [文件下载](https://files.cnblogs.com/files/xkloveme/windows%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86.zip \"下载链接\")\n\n里面包含 Windows & Mac 、Android & Linux 请对号入座。  \n另外 windows 可以直接运行批处理命令，hosts 会自动替换（如果无法自动替换，请用管理员身份权限手动修改）  \n注意：批处理命令会直接覆盖现有 hosts，如现有 hosts 内容重要的话请备份后再使用，或者手动修改！\n\n老 D 所提供的 hosts 仅限于学习使用！hosts 里不会添加屏蔽广告条目，也不会劫持任何网站。\n\n### 修改 hosts 后生效方法：\n\n- Windows  \n  开始 -> 运行 -\\> 输入 cmd -> 在 CMD 窗口输入\n- ipconfig /flushdns\n\n- Linux  \n  终端输入\n\n  sudo rcnscd restart\n\n  对于 systemd 发行版，请使用命令\n\n  sudo systemctl restart NetworkManager\n\n  如果不懂请都尝试下 Mac OS X 终端输入\n\n- sudo killall -HUP mDNSResponder\n\n- Android  \n  开启飞行模式 -\\> 关闭飞行模式\n- **通用方法**  \n  拔网线(断网) -\\> 插网线(重新连接网络)\n- 如不行请清空浏览器缓存（老 D 建议不要使用国产浏览器，请使用谷歌 Chrome 浏览器）\n\n修改 hosts 支持文档：\n\n[Windows 修改 hosts 方法](https://laod.cn/hosts/windows7-8-10-mac-iphone-hosts.html)\n\n[苹果 Mac OS 系统修改 Hosts 文件的方法](https://laod.cn/hosts/mac-os-xiugai-hosts.html)\n\n[iPhone iPad 等 iOS 设备上配置修改 hosts 方法](https://laod.cn/hosts/iphone-ipad-ios-hosts.html)\n\n[Android 修改 hosts 文件的方法介绍](https://laod.cn/hosts/android-hosts.html)\n\n[![2017 Google hosts 持续更新【更新于:2017-09-18】](http://www.jixiaokang.com/wp-content/uploads/2018/05/20170111022240.png)](http://www.jixiaokang.com/wp-content/uploads/2018/05/20170111022240.png)\n","slug":"2017-09-19-googlehosts","published":1,"updated":"2020-03-14T06:48:16.562Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvk700154k8yczgcaol6","content":"<ul>\n<li><strong>转载请注明：</strong><a href=\"https://laod.cn\" target=\"_blank\" rel=\"noopener\" title=\"本文固定链接 https://laod.cn/hosts/android-hosts.html\">  老 D 博客</a></li>\n</ul>\n<p>本页面长期更新最新<a href=\"https://laod.cn/tag/google\" target=\"_blank\" rel=\"noopener\" title=\"浏览关于“Google”的文章\">Google</a>、谷歌学术、维基百科、ccFox.info、ProjectH、Battle.NET 、WordPress、Microsoft Live、GitHub、Amazon、Archive、Box.com、Disqus、SoundCloud、inoreader、Feedly、FlipBoard、Twitter、Tumblr、Facebook、Flickr、imgur、Instagram、DuckDuckGo、Ixquick、Yahoo、Google Services、Google apis、Android、Youtube、Google Drive、UpLoad、Appspot、Googl eusercontent、Gstatic、Gmail、Google other、Google Play 等<a href=\"https://laod.cn/tag/hosts\" target=\"_blank\" rel=\"noopener\" title=\"浏览关于“hosts”的文章\">hosts</a>。</p>\n<p>致谢：<br><a href=\"https://laod.cn/go.php?url=https://github.com/racaljk/hosts\" target=\"_blank\" rel=\"noopener\">Github 项目</a>维护者 @racaljk @andytimes @Too-Naive @laodcn @lrinQVQ @K-Guan @imcaffrey @smounives @lautis0503 @aofall @davymai  @Ignotus-CN @cw881014 等等…<br>感谢那些帮助、支持、以及批评、指责、攻击过老 D 博客的人们！</p>\n<blockquote>\n<p>hosts 是一个没有扩展名的系统文件，它并不是软件或者工具。</p>\n</blockquote>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/hosts-1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/hosts-1.png\" alt=\"2017 Google hosts 持续更新【更新于:2017-09-18】\"></a></p>\n<h4 id=\"hosts所在文件夹：\"><a href=\"#hosts所在文件夹：\" class=\"headerlink\" title=\"hosts所在文件夹：\"></a><a href=\"https://laod.cn/tag/hosts\" target=\"_blank\" rel=\"noopener\" title=\"浏览关于“hosts”的文章\">hosts</a>所在文件夹：</h4><ul>\n<li><strong>Windows</strong>  系统<a href=\"https://laod.cn/tag/host\" target=\"_blank\" rel=\"noopener\" title=\"浏览关于“host”的文章\">host</a>s 位于  C:\\Windows\\System32\\drivers\\etc\\hosts</li>\n<li><strong>Android</strong>（安卓）系统 hosts 位于  /etc/hosts</li>\n<li><strong>Mac</strong>（苹果电脑）系统 hosts 位于  /etc/hosts</li>\n<li><strong>iPhone</strong>（iOS）系统 hosts 位于  /etc/hosts</li>\n<li><strong>Linux</strong>系统 hosts 位于  /etc/hosts</li>\n<li>绝大多数 Unix 系统都是在  /etc/hosts</li>\n</ul>\n<p>你也可以用 Notepad++  自行转换文本编码和换行符格式。当然，老 D 分享的都转换好了。</p>\n<p><strong>注意</strong>： 若更新后，hosts 没有立即生效，请重置网络：<br>在系统设置内开关网络，或启用禁用飞行模式，或者重启、刷新 DNS 缓存、浏览器缓存。</p>\n<p><strong>更新于：2017-09-19</strong></p>\n<p>本次更新：修复谷歌、Gmail、YouTube 等…</p>\n<p><strong>注意：</strong><br>Google、Gmail、维基百科、Twitter、Facebook 等必须请用<strong>https</strong>加密方式打开。<br>一般这些网站都是 SSL 加密链接，如：</p>\n<p>谷歌学术：<a href=\"https://laod.cn/go.php?url=https://scholar.google.com/\" target=\"_blank\" rel=\"noopener\">https://scholar.google.com/</a><br>谷歌：<a href=\"https://laod.cn/go.php?url=https://www.google.com/ncr\" target=\"_blank\" rel=\"noopener\">https://www.google.com/ncr</a><br>谷歌香港：<a href=\"https://laod.cn/go.php?url=https://www.google.com.hk/ncr\" target=\"_blank\" rel=\"noopener\">https://www.google.com.hk/ncr</a><br>Twitter：<a href=\"https://laod.cn/go.php?url=https://twitter.com/?lang=zh-cn\" target=\"_blank\" rel=\"noopener\">https://twitter.com/?lang=zh-cn</a></p>\n<p>另外可能有的地区&amp;网络（铁通、联通）hosts 无法正常使用，这个不是你我能左右的！<br>建议不要使用国产浏览器，国产软件也是，特别是 360，因为国产浏览器即使你使用 https<br>它也会强制你使用默认 http，还有就是会上传用户数据，尽可能使用 Chrome<br>下载&amp;修改 hosts 安全软件可能会“报毒”（误报）你可以暂时退出或者添加信任即可！</p>\n<h4 id=\"我的-hosts-下载（-没有压缩密码-）：\"><a href=\"#我的-hosts-下载（-没有压缩密码-）：\" class=\"headerlink\" title=\"我的 hosts 下载（*没有压缩密码*）：\"></a><strong>我的 hosts 下载（*</strong>没有压缩密码<strong>*）：</strong></h4><h1 id=\"文件下载\"><a href=\"#文件下载\" class=\"headerlink\" title=\"文件下载\"></a><a href=\"https://files.cnblogs.com/files/xkloveme/windows%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86.zip\" target=\"_blank\" rel=\"noopener\" title=\"下载链接\">文件下载</a></h1><p>里面包含 Windows &amp; Mac 、Android &amp; Linux 请对号入座。<br>另外 windows 可以直接运行批处理命令，hosts 会自动替换（如果无法自动替换，请用管理员身份权限手动修改）<br>注意：批处理命令会直接覆盖现有 hosts，如现有 hosts 内容重要的话请备份后再使用，或者手动修改！</p>\n<p>老 D 所提供的 hosts 仅限于学习使用！hosts 里不会添加屏蔽广告条目，也不会劫持任何网站。</p>\n<h3 id=\"修改-hosts-后生效方法：\"><a href=\"#修改-hosts-后生效方法：\" class=\"headerlink\" title=\"修改 hosts 后生效方法：\"></a>修改 hosts 后生效方法：</h3><ul>\n<li><p>Windows<br>开始 -&gt; 运行 -&gt; 输入 cmd -&gt; 在 CMD 窗口输入</p>\n</li>\n<li><p>ipconfig /flushdns</p>\n</li>\n<li><p>Linux<br>终端输入</p>\n<p>sudo rcnscd restart</p>\n<p>对于 systemd 发行版，请使用命令</p>\n<p>sudo systemctl restart NetworkManager</p>\n<p>如果不懂请都尝试下 Mac OS X 终端输入</p>\n</li>\n<li><p>sudo killall -HUP mDNSResponder</p>\n</li>\n<li><p>Android<br>开启飞行模式 -&gt; 关闭飞行模式</p>\n</li>\n<li><p><strong>通用方法</strong><br>拔网线(断网) -&gt; 插网线(重新连接网络)</p>\n</li>\n<li><p>如不行请清空浏览器缓存（老 D 建议不要使用国产浏览器，请使用谷歌 Chrome 浏览器）</p>\n</li>\n</ul>\n<p>修改 hosts 支持文档：</p>\n<p><a href=\"https://laod.cn/hosts/windows7-8-10-mac-iphone-hosts.html\" target=\"_blank\" rel=\"noopener\">Windows 修改 hosts 方法</a></p>\n<p><a href=\"https://laod.cn/hosts/mac-os-xiugai-hosts.html\" target=\"_blank\" rel=\"noopener\">苹果 Mac OS 系统修改 Hosts 文件的方法</a></p>\n<p><a href=\"https://laod.cn/hosts/iphone-ipad-ios-hosts.html\" target=\"_blank\" rel=\"noopener\">iPhone iPad 等 iOS 设备上配置修改 hosts 方法</a></p>\n<p><a href=\"https://laod.cn/hosts/android-hosts.html\" target=\"_blank\" rel=\"noopener\">Android 修改 hosts 文件的方法介绍</a></p>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/20170111022240.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/20170111022240.png\" alt=\"2017 Google hosts 持续更新【更新于:2017-09-18】\"></a></p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<ul>\n<li><strong>转载请注明：</strong><a href=\"https://laod.cn\" target=\"_blank\" rel=\"noopener\" title=\"本文固定链接 https://laod.cn/hosts/android-hosts.html\">  老 D 博客</a></li>\n</ul>\n<p>本页面长期更新最新<a href=\"https://laod.cn/tag/google\" target=\"_blank\" rel=\"noopener\" title=\"浏览关于“Google”的文章\">Google</a>、谷歌学术、维基百科、ccFox.info、ProjectH、Battle.NET 、WordPress、Microsoft Live、GitHub、Amazon、Archive、Box.com、Disqus、SoundCloud、inoreader、Feedly、FlipBoard、Twitter、Tumblr、Facebook、Flickr、imgur、Instagram、DuckDuckGo、Ixquick、Yahoo、Google Services、Google apis、Android、Youtube、Google Drive、UpLoad、Appspot、Googl eusercontent、Gstatic、Gmail、Google other、Google Play 等<a href=\"https://laod.cn/tag/hosts\" target=\"_blank\" rel=\"noopener\" title=\"浏览关于“hosts”的文章\">hosts</a>。</p>\n<p>致谢：<br><a href=\"https://laod.cn/go.php?url=https://github.com/racaljk/hosts\" target=\"_blank\" rel=\"noopener\">Github 项目</a>维护者 @racaljk @andytimes @Too-Naive @laodcn @lrinQVQ @K-Guan @imcaffrey @smounives @lautis0503 @aofall @davymai  @Ignotus-CN @cw881014 等等…<br>感谢那些帮助、支持、以及批评、指责、攻击过老 D 博客的人们！</p>\n<blockquote>\n<p>hosts 是一个没有扩展名的系统文件，它并不是软件或者工具。</p>\n</blockquote>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/hosts-1.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/hosts-1.png\" alt=\"2017 Google hosts 持续更新【更新于:2017-09-18】\"></a></p>\n<h4 id=\"hosts所在文件夹：\"><a href=\"#hosts所在文件夹：\" class=\"headerlink\" title=\"hosts所在文件夹：\"></a><a href=\"https://laod.cn/tag/hosts\" target=\"_blank\" rel=\"noopener\" title=\"浏览关于“hosts”的文章\">hosts</a>所在文件夹：</h4><ul>\n<li><strong>Windows</strong>  系统<a href=\"https://laod.cn/tag/host\" target=\"_blank\" rel=\"noopener\" title=\"浏览关于“host”的文章\">host</a>s 位于  C:\\Windows\\System32\\drivers\\etc\\hosts</li>\n<li><strong>Android</strong>（安卓）系统 hosts 位于  /etc/hosts</li>\n<li><strong>Mac</strong>（苹果电脑）系统 hosts 位于  /etc/hosts</li>\n<li><strong>iPhone</strong>（iOS）系统 hosts 位于  /etc/hosts</li>\n<li><strong>Linux</strong>系统 hosts 位于  /etc/hosts</li>\n<li>绝大多数 Unix 系统都是在  /etc/hosts</li>\n</ul>\n<p>你也可以用 Notepad++  自行转换文本编码和换行符格式。当然，老 D 分享的都转换好了。</p>\n<p><strong>注意</strong>： 若更新后，hosts 没有立即生效，请重置网络：<br>在系统设置内开关网络，或启用禁用飞行模式，或者重启、刷新 DNS 缓存、浏览器缓存。</p>\n<p><strong>更新于：2017-09-19</strong></p>\n<p>本次更新：修复谷歌、Gmail、YouTube 等…</p>\n<p><strong>注意：</strong><br>Google、Gmail、维基百科、Twitter、Facebook 等必须请用<strong>https</strong>加密方式打开。<br>一般这些网站都是 SSL 加密链接，如：</p>\n<p>谷歌学术：<a href=\"https://laod.cn/go.php?url=https://scholar.google.com/\" target=\"_blank\" rel=\"noopener\">https://scholar.google.com/</a><br>谷歌：<a href=\"https://laod.cn/go.php?url=https://www.google.com/ncr\" target=\"_blank\" rel=\"noopener\">https://www.google.com/ncr</a><br>谷歌香港：<a href=\"https://laod.cn/go.php?url=https://www.google.com.hk/ncr\" target=\"_blank\" rel=\"noopener\">https://www.google.com.hk/ncr</a><br>Twitter：<a href=\"https://laod.cn/go.php?url=https://twitter.com/?lang=zh-cn\" target=\"_blank\" rel=\"noopener\">https://twitter.com/?lang=zh-cn</a></p>\n<p>另外可能有的地区&amp;网络（铁通、联通）hosts 无法正常使用，这个不是你我能左右的！<br>建议不要使用国产浏览器，国产软件也是，特别是 360，因为国产浏览器即使你使用 https<br>它也会强制你使用默认 http，还有就是会上传用户数据，尽可能使用 Chrome<br>下载&amp;修改 hosts 安全软件可能会“报毒”（误报）你可以暂时退出或者添加信任即可！</p>\n<h4 id=\"我的-hosts-下载（-没有压缩密码-）：\"><a href=\"#我的-hosts-下载（-没有压缩密码-）：\" class=\"headerlink\" title=\"我的 hosts 下载（*没有压缩密码*）：\"></a><strong>我的 hosts 下载（*</strong>没有压缩密码<strong>*）：</strong></h4><h1 id=\"文件下载\"><a href=\"#文件下载\" class=\"headerlink\" title=\"文件下载\"></a><a href=\"https://files.cnblogs.com/files/xkloveme/windows%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86.zip\" target=\"_blank\" rel=\"noopener\" title=\"下载链接\">文件下载</a></h1><p>里面包含 Windows &amp; Mac 、Android &amp; Linux 请对号入座。<br>另外 windows 可以直接运行批处理命令，hosts 会自动替换（如果无法自动替换，请用管理员身份权限手动修改）<br>注意：批处理命令会直接覆盖现有 hosts，如现有 hosts 内容重要的话请备份后再使用，或者手动修改！</p>\n<p>老 D 所提供的 hosts 仅限于学习使用！hosts 里不会添加屏蔽广告条目，也不会劫持任何网站。</p>\n<h3 id=\"修改-hosts-后生效方法：\"><a href=\"#修改-hosts-后生效方法：\" class=\"headerlink\" title=\"修改 hosts 后生效方法：\"></a>修改 hosts 后生效方法：</h3><ul>\n<li><p>Windows<br>开始 -&gt; 运行 -&gt; 输入 cmd -&gt; 在 CMD 窗口输入</p>\n</li>\n<li><p>ipconfig /flushdns</p>\n</li>\n<li><p>Linux<br>终端输入</p>\n<p>sudo rcnscd restart</p>\n<p>对于 systemd 发行版，请使用命令</p>\n<p>sudo systemctl restart NetworkManager</p>\n<p>如果不懂请都尝试下 Mac OS X 终端输入</p>\n</li>\n<li><p>sudo killall -HUP mDNSResponder</p>\n</li>\n<li><p>Android<br>开启飞行模式 -&gt; 关闭飞行模式</p>\n</li>\n<li><p><strong>通用方法</strong><br>拔网线(断网) -&gt; 插网线(重新连接网络)</p>\n</li>\n<li><p>如不行请清空浏览器缓存（老 D 建议不要使用国产浏览器，请使用谷歌 Chrome 浏览器）</p>\n</li>\n</ul>\n<p>修改 hosts 支持文档：</p>\n<p><a href=\"https://laod.cn/hosts/windows7-8-10-mac-iphone-hosts.html\" target=\"_blank\" rel=\"noopener\">Windows 修改 hosts 方法</a></p>\n<p><a href=\"https://laod.cn/hosts/mac-os-xiugai-hosts.html\" target=\"_blank\" rel=\"noopener\">苹果 Mac OS 系统修改 Hosts 文件的方法</a></p>\n<p><a href=\"https://laod.cn/hosts/iphone-ipad-ios-hosts.html\" target=\"_blank\" rel=\"noopener\">iPhone iPad 等 iOS 设备上配置修改 hosts 方法</a></p>\n<p><a href=\"https://laod.cn/hosts/android-hosts.html\" target=\"_blank\" rel=\"noopener\">Android 修改 hosts 文件的方法介绍</a></p>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/20170111022240.png\" target=\"_blank\" rel=\"noopener\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/20170111022240.png\" alt=\"2017 Google hosts 持续更新【更新于:2017-09-18】\"></a></p>\n"},{"title":"常用正则表达式总结","date":"2017-09-19T06:20:00.000Z","_content":"\n### 一、校验数字的表达式\n\n- 数字：^\\[0-9\\]\\\\*\\$\n- n 位的数字：^\\\\d{n}\\$\n- 至少 n 位的数字：^\\\\d{n,}\\$\n- m-n 位的数字：^\\\\d{m,n}\\$\n- 零和非零开头的数字：^(0|\\[1-9\\]\\[0-9\\]\\\\*)\\$\n- 非零开头的最多带两位小数的数字：^(\\[1-9\\]\\[0-9\\]\\\\*)+(.\\[0-9\\]{1,2})?\\$\n- 带 1-2 位小数的正数或负数：^(\\\\-)?\\\\d+(\\\\.\\\\d{1,2})?\\$\n- 正数、负数、和小数：^(\\\\-|\\\\+)?\\\\d+(\\\\.\\\\d+)?\\$\n- 有两位小数的正实数：^\\[0-9\\]+(.\\[0-9\\]{2})?\\$\n- 有 1~3 位小数的正实数：^\\[0-9\\]+(.\\[0-9\\]{1,3})?\\$\n- 非零的正整数：^\\[1-9\\]\\\\d*\\$ 或 ^(\\[1-9\\]\\[0-9\\]*){1,3}$ 或 ^\\\\+?\\[1-9\\]\\[0-9\\]*$\n- 非零的负整数：^\\\\-\\[1-9\\]\\[\\]0-9″\\_\\\\$ 或 ^-\\[1-9\\]\\\\d\\_\\$\n- 非负整数：^\\\\d+$ 或 ^\\[1-9\\]\\\\d*|0$\n- 非正整数：^-\\[1-9\\]\\\\d\\*|0$ 或 ^((-\\\\d+)|(0+))$\n- 非负浮点数：^\\\\d+(\\\\.\\\\d+)?$ 或 ^\\[1-9\\]\\\\d*\\\\.\\\\d*|0\\\\.\\\\d*\\[1-9\\]\\\\d*|0?\\\\.0+|0$\n- 非正浮点数：^((-\\\\d+(\\\\.\\\\d+)?)|(0+(\\\\.0+)?))$ 或 ^(-(\\[1-9\\]\\\\d*\\\\.\\\\d*|0\\\\.\\\\d*\\[1-9\\]\\\\d*))|0?\\\\.0+|0$\n- 正浮点数：^\\[1-9\\]\\\\d*\\\\.\\\\d*|0\\\\.\\\\d*\\[1-9\\]\\\\d*$ 或 ^((\\[0-9\\]+\\\\.\\[0-9\\]*\\[1-9\\]\\[0-9\\]*)|(\\[0-9\\]*\\[1-9\\]\\[0-9\\]*\\\\.\\[0-9\\]+)|(\\[0-9\\]*\\[1-9\\]\\[0-9\\]*))$\n- 负浮点数：^-(\\[1-9\\]\\\\d*\\\\.\\\\d*|0\\\\.\\\\d*\\[1-9\\]\\\\d*)$ 或 ^(-((\\[0-9\\]+\\\\.\\[0-9\\]*\\[1-9\\]\\[0-9\\]*)|(\\[0-9\\]*\\[1-9\\]\\[0-9\\]*\\\\.\\[0-9\\]+)|(\\[0-9\\]*\\[1-9\\]\\[0-9\\]*)))$\n- 浮点数：^(-?\\\\d+)(\\\\.\\\\d+)?$ 或 ^-?(\\[1-9\\]\\\\d*\\\\.\\\\d*|0\\\\.\\\\d*\\[1-9\\]\\\\d*|0?\\\\.0+|0)$\n\n### 二、校验字符的表达式\n\n- 汉字：^\\[\\\\u4e00-\\\\u9fa5\\]{0,}\\$\n- 英文和数字：^\\[A-Za-z0-9\\]+$ 或 ^\\[A-Za-z0-9\\]{4,40}$\n- 长度为 3-20 的所有字符：^.{3,20}\\$\n- 由 26 个英文字母组成的字符串：^\\[A-Za-z\\]+\\$\n- 由 26 个大写英文字母组成的字符串：^\\[A-Z\\]+\\$\n- 由 26 个小写英文字母组成的字符串：^\\[a-z\\]+\\$\n- 由数字和 26 个英文字母组成的字符串：^\\[A-Za-z0-9\\]+\\$\n- 由数字、26 个英文字母或者下划线组成的字符串：^\\\\w+$ 或 ^\\\\w{3,20}$\n- 中文、英文、数字包括下划线：^\\[\\\\u4E00-\\\\u9FA5A-Za-z0-9\\\\_\\]+\\$\n- 中文、英文、数字但不包括下划线等符号：^\\[\\\\u4E00-\\\\u9FA5A-Za-z0-9\\]+$ 或 ^\\[\\\\u4E00-\\\\u9FA5A-Za-z0-9\\]{2,20}$\n- 可以输入含有^%&’,;=?$\\\\”等字符：\\[^%&’,;=?$\\\\x22\\]+\n- 禁止输入含有~的字符：\\[^~\\\\x22\\]+\n\n### 三、特殊需求表达式\n\n- Email 地址：^\\\\w+(\\[-+.\\]\\\\w+)\\_@\\\\w+(\\[-.\\]\\\\w+)\\_\\\\.\\\\w+(\\[-.\\]\\\\w+)\\\\*\\$\n- 域名：\\[a-zA-Z0-9\\]\\[-a-zA-Z0-9\\]{0,62}(/.\\[a-zA-Z0-9\\]\\[-a-zA-Z0-9\\]{0,62})+/.?\n- InternetURL：\\[a-zA-z\\]+://\\[^\\\\s\\]\\_ 或 ^http://(\\[\\\\w-\\]+\\\\.)+\\[\\\\w-\\]+(/\\[\\\\w-./?%&=\\]\\_)?\\$\n- 手机号码：^(13\\[0-9\\]|14\\[5|7\\]|15\\[0|1|2|3|5|6|7|8|9\\]|18\\[0|1|2|3|5|6|7|8|9\\])\\\\d{8}\\$\n- 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^(\\$$\\\\d{3,4}-)|\\\\d{3.4}-)?\\\\d{7,8}$\n- 国内电话号码(0511-4405222、021-87888822)：\\\\d{3}-\\\\d{8}|\\\\d{4}-\\\\d{7}\n- 身份证号(15 位、18 位数字)：^\\\\d{15}|\\\\d{18}\\$\n- 短身份证号码(数字、字母 x 结尾)：^(\\[0-9\\]){7,18}(x|X)?$ 或 ^\\\\d{8,18}|\\[0-9x\\]{8,18}|\\[0-9X\\]{8,18}?$\n- 帐号是否合法(字母开头，允许 5-16 字节，允许字母数字下划线)：^\\[a-zA-Z\\]\\[a-zA-Z0-9\\\\_\\]{4,15}\\$\n- 密码(以字母开头，长度在 6~18 之间，只能包含字母、数字和下划线)：^\\[a-zA-Z\\]\\\\w{5,17}\\$\n- 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=.\\_\\\\d)(?=.\\_\\[a-z\\])(?=.\\\\*\\[A-Z\\]).{8,10}\\$\n- 日期格式：^\\\\d{4}-\\\\d{1,2}-\\\\d{1,2}\n- 一年的 12 个月(01 ～ 09 和 1 ～ 12)：^(0?\\[1-9\\]|1\\[0-2\\])\\$\n- 一个月的 31 天(01 ～ 09 和 1 ～ 31)：^((0?\\[1-9\\])|((1|2)\\[0-9\\])|30|31)\\$\n- 钱的输入格式：\n  - 有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00”, 和没有 “分” 的 “10000”#8221; 和 “10,000”：^\\[1-9\\]\\[0-9\\]\\\\*\\$\n  - 这表示任意一个不以 0 开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式：^(0|\\[1-9\\]\\[0-9\\]\\\\*)\\$\n  - 一个 0 或者一个不以 0 开头的数字.我们还可以允许开头有一个负号：^(0|-?\\[1-9\\]\\[0-9\\]\\\\*)\\$\n  - 这表示一个 0 或者一个可能为负的开头不为 0 的数字.让用户以 0 开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^\\[0-9\\]+(.\\[0-9\\]+)?\\$\n  - 必须说明的是，小数点后面至少应该有 1 位数，所以”10.”是不通过的，但是 “10” 和 “10.2” 是通过的：^\\[0-9\\]+(.\\[0-9\\]{2})?\\$\n  - 这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：^\\[0-9\\]+(.\\[0-9\\]{1,2})?\\$\n  - 这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样：^\\[0-9\\]{1,3}(,\\[0-9\\]{3})\\\\*(.\\[0-9\\]{1,2})?\\$\n  - 1 到 3 个数字，后面跟着任意个 逗号+3 个数字，逗号成为可选，而不是必须：^(\\[0-9\\]+|\\[0-9\\]{1,3}(,\\[0-9\\]{3})\\\\*)(.\\[0-9\\]{1,2})?\\$\n  - 备注：这就是最终结果了，别忘了”+”可以用”\\*”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里\n- xml 文件：^(\\[a-zA-Z\\]+-?)+\\[a-zA-Z0-9\\]+\\\\\\.\\[x|X\\]\\[m|M\\]\\[l|L\\]\\$\n- 中文字符的正则表达式：\\[\\\\u4e00-\\\\u9fa5\\]\n- 双字节字符：\\[^\\\\x00-\\\\xff\\] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计 2，ASCII 字符计 1))\n- 空白行的正则表达式：\\\\n\\\\s\\*\\\\r (可以用来删除空白行)\n- HTML 标记的正则表达式：<(\\\\S*?)\\[^>\\]*>._?|<._? /\\> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)\n- 首尾空白字符的正则表达式：^\\\\s*|\\\\s*$或(^\\\\s*)|(\\\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)\n- 腾讯 QQ 号：\\[1-9\\]\\[0-9\\]{4,} (腾讯 QQ 号从 10000 开始)\n- 中国邮政编码：\\[1-9\\]\\\\d{5}(?!\\\\d) (中国邮政编码为 6 位数字)\n- IP 地址：\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+ (提取 IP 地址时有用)\n- IP 地址：((?:(?:25\\[0-5\\]|2\\[0-4\\]\\\\\\d|\\[01\\]?\\\\\\d?\\\\\\d)\\\\\\.){3}(?:25\\[0-5\\]|2\\[0-4\\]\\\\\\d|\\[01\\]?\\\\\\d?\\\\\\d))\n","source":"_posts/2017-09-19-常用正则表达式总结.md","raw":"---\ntitle: 常用正则表达式总结\ntags:\n  - 技术\ndate: 2017-09-19 14:20:00\ncategories: 前端\n---\n\n### 一、校验数字的表达式\n\n- 数字：^\\[0-9\\]\\\\*\\$\n- n 位的数字：^\\\\d{n}\\$\n- 至少 n 位的数字：^\\\\d{n,}\\$\n- m-n 位的数字：^\\\\d{m,n}\\$\n- 零和非零开头的数字：^(0|\\[1-9\\]\\[0-9\\]\\\\*)\\$\n- 非零开头的最多带两位小数的数字：^(\\[1-9\\]\\[0-9\\]\\\\*)+(.\\[0-9\\]{1,2})?\\$\n- 带 1-2 位小数的正数或负数：^(\\\\-)?\\\\d+(\\\\.\\\\d{1,2})?\\$\n- 正数、负数、和小数：^(\\\\-|\\\\+)?\\\\d+(\\\\.\\\\d+)?\\$\n- 有两位小数的正实数：^\\[0-9\\]+(.\\[0-9\\]{2})?\\$\n- 有 1~3 位小数的正实数：^\\[0-9\\]+(.\\[0-9\\]{1,3})?\\$\n- 非零的正整数：^\\[1-9\\]\\\\d*\\$ 或 ^(\\[1-9\\]\\[0-9\\]*){1,3}$ 或 ^\\\\+?\\[1-9\\]\\[0-9\\]*$\n- 非零的负整数：^\\\\-\\[1-9\\]\\[\\]0-9″\\_\\\\$ 或 ^-\\[1-9\\]\\\\d\\_\\$\n- 非负整数：^\\\\d+$ 或 ^\\[1-9\\]\\\\d*|0$\n- 非正整数：^-\\[1-9\\]\\\\d\\*|0$ 或 ^((-\\\\d+)|(0+))$\n- 非负浮点数：^\\\\d+(\\\\.\\\\d+)?$ 或 ^\\[1-9\\]\\\\d*\\\\.\\\\d*|0\\\\.\\\\d*\\[1-9\\]\\\\d*|0?\\\\.0+|0$\n- 非正浮点数：^((-\\\\d+(\\\\.\\\\d+)?)|(0+(\\\\.0+)?))$ 或 ^(-(\\[1-9\\]\\\\d*\\\\.\\\\d*|0\\\\.\\\\d*\\[1-9\\]\\\\d*))|0?\\\\.0+|0$\n- 正浮点数：^\\[1-9\\]\\\\d*\\\\.\\\\d*|0\\\\.\\\\d*\\[1-9\\]\\\\d*$ 或 ^((\\[0-9\\]+\\\\.\\[0-9\\]*\\[1-9\\]\\[0-9\\]*)|(\\[0-9\\]*\\[1-9\\]\\[0-9\\]*\\\\.\\[0-9\\]+)|(\\[0-9\\]*\\[1-9\\]\\[0-9\\]*))$\n- 负浮点数：^-(\\[1-9\\]\\\\d*\\\\.\\\\d*|0\\\\.\\\\d*\\[1-9\\]\\\\d*)$ 或 ^(-((\\[0-9\\]+\\\\.\\[0-9\\]*\\[1-9\\]\\[0-9\\]*)|(\\[0-9\\]*\\[1-9\\]\\[0-9\\]*\\\\.\\[0-9\\]+)|(\\[0-9\\]*\\[1-9\\]\\[0-9\\]*)))$\n- 浮点数：^(-?\\\\d+)(\\\\.\\\\d+)?$ 或 ^-?(\\[1-9\\]\\\\d*\\\\.\\\\d*|0\\\\.\\\\d*\\[1-9\\]\\\\d*|0?\\\\.0+|0)$\n\n### 二、校验字符的表达式\n\n- 汉字：^\\[\\\\u4e00-\\\\u9fa5\\]{0,}\\$\n- 英文和数字：^\\[A-Za-z0-9\\]+$ 或 ^\\[A-Za-z0-9\\]{4,40}$\n- 长度为 3-20 的所有字符：^.{3,20}\\$\n- 由 26 个英文字母组成的字符串：^\\[A-Za-z\\]+\\$\n- 由 26 个大写英文字母组成的字符串：^\\[A-Z\\]+\\$\n- 由 26 个小写英文字母组成的字符串：^\\[a-z\\]+\\$\n- 由数字和 26 个英文字母组成的字符串：^\\[A-Za-z0-9\\]+\\$\n- 由数字、26 个英文字母或者下划线组成的字符串：^\\\\w+$ 或 ^\\\\w{3,20}$\n- 中文、英文、数字包括下划线：^\\[\\\\u4E00-\\\\u9FA5A-Za-z0-9\\\\_\\]+\\$\n- 中文、英文、数字但不包括下划线等符号：^\\[\\\\u4E00-\\\\u9FA5A-Za-z0-9\\]+$ 或 ^\\[\\\\u4E00-\\\\u9FA5A-Za-z0-9\\]{2,20}$\n- 可以输入含有^%&’,;=?$\\\\”等字符：\\[^%&’,;=?$\\\\x22\\]+\n- 禁止输入含有~的字符：\\[^~\\\\x22\\]+\n\n### 三、特殊需求表达式\n\n- Email 地址：^\\\\w+(\\[-+.\\]\\\\w+)\\_@\\\\w+(\\[-.\\]\\\\w+)\\_\\\\.\\\\w+(\\[-.\\]\\\\w+)\\\\*\\$\n- 域名：\\[a-zA-Z0-9\\]\\[-a-zA-Z0-9\\]{0,62}(/.\\[a-zA-Z0-9\\]\\[-a-zA-Z0-9\\]{0,62})+/.?\n- InternetURL：\\[a-zA-z\\]+://\\[^\\\\s\\]\\_ 或 ^http://(\\[\\\\w-\\]+\\\\.)+\\[\\\\w-\\]+(/\\[\\\\w-./?%&=\\]\\_)?\\$\n- 手机号码：^(13\\[0-9\\]|14\\[5|7\\]|15\\[0|1|2|3|5|6|7|8|9\\]|18\\[0|1|2|3|5|6|7|8|9\\])\\\\d{8}\\$\n- 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^(\\$$\\\\d{3,4}-)|\\\\d{3.4}-)?\\\\d{7,8}$\n- 国内电话号码(0511-4405222、021-87888822)：\\\\d{3}-\\\\d{8}|\\\\d{4}-\\\\d{7}\n- 身份证号(15 位、18 位数字)：^\\\\d{15}|\\\\d{18}\\$\n- 短身份证号码(数字、字母 x 结尾)：^(\\[0-9\\]){7,18}(x|X)?$ 或 ^\\\\d{8,18}|\\[0-9x\\]{8,18}|\\[0-9X\\]{8,18}?$\n- 帐号是否合法(字母开头，允许 5-16 字节，允许字母数字下划线)：^\\[a-zA-Z\\]\\[a-zA-Z0-9\\\\_\\]{4,15}\\$\n- 密码(以字母开头，长度在 6~18 之间，只能包含字母、数字和下划线)：^\\[a-zA-Z\\]\\\\w{5,17}\\$\n- 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=.\\_\\\\d)(?=.\\_\\[a-z\\])(?=.\\\\*\\[A-Z\\]).{8,10}\\$\n- 日期格式：^\\\\d{4}-\\\\d{1,2}-\\\\d{1,2}\n- 一年的 12 个月(01 ～ 09 和 1 ～ 12)：^(0?\\[1-9\\]|1\\[0-2\\])\\$\n- 一个月的 31 天(01 ～ 09 和 1 ～ 31)：^((0?\\[1-9\\])|((1|2)\\[0-9\\])|30|31)\\$\n- 钱的输入格式：\n  - 有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00”, 和没有 “分” 的 “10000”#8221; 和 “10,000”：^\\[1-9\\]\\[0-9\\]\\\\*\\$\n  - 这表示任意一个不以 0 开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式：^(0|\\[1-9\\]\\[0-9\\]\\\\*)\\$\n  - 一个 0 或者一个不以 0 开头的数字.我们还可以允许开头有一个负号：^(0|-?\\[1-9\\]\\[0-9\\]\\\\*)\\$\n  - 这表示一个 0 或者一个可能为负的开头不为 0 的数字.让用户以 0 开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^\\[0-9\\]+(.\\[0-9\\]+)?\\$\n  - 必须说明的是，小数点后面至少应该有 1 位数，所以”10.”是不通过的，但是 “10” 和 “10.2” 是通过的：^\\[0-9\\]+(.\\[0-9\\]{2})?\\$\n  - 这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：^\\[0-9\\]+(.\\[0-9\\]{1,2})?\\$\n  - 这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样：^\\[0-9\\]{1,3}(,\\[0-9\\]{3})\\\\*(.\\[0-9\\]{1,2})?\\$\n  - 1 到 3 个数字，后面跟着任意个 逗号+3 个数字，逗号成为可选，而不是必须：^(\\[0-9\\]+|\\[0-9\\]{1,3}(,\\[0-9\\]{3})\\\\*)(.\\[0-9\\]{1,2})?\\$\n  - 备注：这就是最终结果了，别忘了”+”可以用”\\*”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里\n- xml 文件：^(\\[a-zA-Z\\]+-?)+\\[a-zA-Z0-9\\]+\\\\\\.\\[x|X\\]\\[m|M\\]\\[l|L\\]\\$\n- 中文字符的正则表达式：\\[\\\\u4e00-\\\\u9fa5\\]\n- 双字节字符：\\[^\\\\x00-\\\\xff\\] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计 2，ASCII 字符计 1))\n- 空白行的正则表达式：\\\\n\\\\s\\*\\\\r (可以用来删除空白行)\n- HTML 标记的正则表达式：<(\\\\S*?)\\[^>\\]*>._?|<._? /\\> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)\n- 首尾空白字符的正则表达式：^\\\\s*|\\\\s*$或(^\\\\s*)|(\\\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)\n- 腾讯 QQ 号：\\[1-9\\]\\[0-9\\]{4,} (腾讯 QQ 号从 10000 开始)\n- 中国邮政编码：\\[1-9\\]\\\\d{5}(?!\\\\d) (中国邮政编码为 6 位数字)\n- IP 地址：\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+ (提取 IP 地址时有用)\n- IP 地址：((?:(?:25\\[0-5\\]|2\\[0-4\\]\\\\\\d|\\[01\\]?\\\\\\d?\\\\\\d)\\\\\\.){3}(?:25\\[0-5\\]|2\\[0-4\\]\\\\\\d|\\[01\\]?\\\\\\d?\\\\\\d))\n","slug":"2017-09-19-常用正则表达式总结","published":1,"updated":"2020-03-14T06:48:12.198Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvk900184k8yggk18v2d","content":"<h3 id=\"一、校验数字的表达式\"><a href=\"#一、校验数字的表达式\" class=\"headerlink\" title=\"一、校验数字的表达式\"></a>一、校验数字的表达式</h3><ul>\n<li>数字：^[0-9]\\*$</li>\n<li>n 位的数字：^\\d{n}$</li>\n<li>至少 n 位的数字：^\\d{n,}$</li>\n<li>m-n 位的数字：^\\d{m,n}$</li>\n<li>零和非零开头的数字：^(0|[1-9][0-9]\\*)$</li>\n<li>非零开头的最多带两位小数的数字：^([1-9][0-9]\\*)+(.[0-9]{1,2})?$</li>\n<li>带 1-2 位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$</li>\n<li>正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$</li>\n<li>有两位小数的正实数：^[0-9]+(.[0-9]{2})?$</li>\n<li>有 1~3 位小数的正实数：^[0-9]+(.[0-9]{1,3})?$</li>\n<li>非零的正整数：^[1-9]\\d<em>$ 或 ^([1-9][0-9]</em>){1,3}$ 或 ^\\+?[1-9][0-9]*$</li>\n<li>非零的负整数：^\\-[1-9][]0-9″_\\$ 或 ^-[1-9]\\d_$</li>\n<li>非负整数：^\\d+$ 或 ^[1-9]\\d*|0$</li>\n<li>非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$</li>\n<li>非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d<em>\\.\\d</em>|0\\.\\d<em>[1-9]\\d</em>|0?\\.0+|0$</li>\n<li>非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d<em>\\.\\d</em>|0\\.\\d<em>[1-9]\\d</em>))|0?\\.0+|0$</li>\n<li>正浮点数：^[1-9]\\d<em>\\.\\d</em>|0\\.\\d<em>[1-9]\\d</em>$ 或 ^(([0-9]+\\.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]<em>\\.[0-9]+)|([0-9]</em>[1-9][0-9]</em>))$</li>\n<li>负浮点数：^-([1-9]\\d<em>\\.\\d</em>|0\\.\\d<em>[1-9]\\d</em>)$ 或 ^(-(([0-9]+\\.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]<em>\\.[0-9]+)|([0-9]</em>[1-9][0-9]</em>)))$</li>\n<li>浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d<em>\\.\\d</em>|0\\.\\d<em>[1-9]\\d</em>|0?\\.0+|0)$</li>\n</ul>\n<h3 id=\"二、校验字符的表达式\"><a href=\"#二、校验字符的表达式\" class=\"headerlink\" title=\"二、校验字符的表达式\"></a>二、校验字符的表达式</h3><ul>\n<li>汉字：^[\\u4e00-\\u9fa5]{0,}$</li>\n<li>英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$</li>\n<li>长度为 3-20 的所有字符：^.{3,20}$</li>\n<li>由 26 个英文字母组成的字符串：^[A-Za-z]+$</li>\n<li>由 26 个大写英文字母组成的字符串：^[A-Z]+$</li>\n<li>由 26 个小写英文字母组成的字符串：^[a-z]+$</li>\n<li>由数字和 26 个英文字母组成的字符串：^[A-Za-z0-9]+$</li>\n<li>由数字、26 个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$</li>\n<li>中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9\\_]+$</li>\n<li>中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$</li>\n<li>可以输入含有^%&amp;’,;=?$\\”等字符：[^%&amp;’,;=?$\\x22]+</li>\n<li>禁止输入含有<del>的字符：[^</del>\\x22]+</li>\n</ul>\n<h3 id=\"三、特殊需求表达式\"><a href=\"#三、特殊需求表达式\" class=\"headerlink\" title=\"三、特殊需求表达式\"></a>三、特殊需求表达式</h3><ul>\n<li>Email 地址：^\\w+([-+.]\\w+)_@\\w+([-.]\\w+)_\\.\\w+([-.]\\w+)\\*$</li>\n<li>域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?</li>\n<li>InternetURL：[a-zA-z]+://[^\\s]_ 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]_)?$</li>\n<li>手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$</li>\n<li>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^($$\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$</li>\n<li>国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7}</li>\n<li>身份证号(15 位、18 位数字)：^\\d{15}|\\d{18}$</li>\n<li>短身份证号码(数字、字母 x 结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$</li>\n<li>帐号是否合法(字母开头，允许 5-16 字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9\\_]{4,15}$</li>\n<li>密码(以字母开头，长度在 6~18 之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$</li>\n<li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=._\\d)(?=._[a-z])(?=.\\*[A-Z]).{8,10}$</li>\n<li>日期格式：^\\d{4}-\\d{1,2}-\\d{1,2}</li>\n<li>一年的 12 个月(01 ～ 09 和 1 ～ 12)：^(0?[1-9]|1[0-2])$</li>\n<li>一个月的 31 天(01 ～ 09 和 1 ～ 31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</li>\n<li>钱的输入格式：<ul>\n<li>有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00”, 和没有 “分” 的 “10000”#8221; 和 “10,000”：^[1-9][0-9]\\*$</li>\n<li>这表示任意一个不以 0 开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式：^(0|[1-9][0-9]\\*)$</li>\n<li>一个 0 或者一个不以 0 开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]\\*)$</li>\n<li>这表示一个 0 或者一个可能为负的开头不为 0 的数字.让用户以 0 开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$</li>\n<li>必须说明的是，小数点后面至少应该有 1 位数，所以”10.”是不通过的，但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$</li>\n<li>这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：^[0-9]+(.[0-9]{1,2})?$</li>\n<li>这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样：^[0-9]{1,3}(,[0-9]{3})\\*(.[0-9]{1,2})?$</li>\n<li>1 到 3 个数字，后面跟着任意个 逗号+3 个数字，逗号成为可选，而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})\\*)(.[0-9]{1,2})?$</li>\n<li>备注：这就是最终结果了，别忘了”+”可以用”*”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里</li>\n</ul>\n</li>\n<li>xml 文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</li>\n<li>中文字符的正则表达式：[\\u4e00-\\u9fa5]</li>\n<li>双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计 2，ASCII 字符计 1))</li>\n<li>空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行)</li>\n<li>HTML 标记的正则表达式：&lt;(\\S<em>?)[^&gt;]</em>&gt;.<em>?|&lt;.</em>? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</li>\n<li>首尾空白字符的正则表达式：^\\s<em>|\\s</em>$或(^\\s<em>)|(\\s</em>$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</li>\n<li>腾讯 QQ 号：[1-9][0-9]{4,} (腾讯 QQ 号从 10000 开始)</li>\n<li>中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为 6 位数字)</li>\n<li>IP 地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取 IP 地址时有用)</li>\n<li>IP 地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h3 id=\"一、校验数字的表达式\"><a href=\"#一、校验数字的表达式\" class=\"headerlink\" title=\"一、校验数字的表达式\"></a>一、校验数字的表达式</h3><ul>\n<li>数字：^[0-9]\\*$</li>\n<li>n 位的数字：^\\d{n}$</li>\n<li>至少 n 位的数字：^\\d{n,}$</li>\n<li>m-n 位的数字：^\\d{m,n}$</li>\n<li>零和非零开头的数字：^(0|[1-9][0-9]\\*)$</li>\n<li>非零开头的最多带两位小数的数字：^([1-9][0-9]\\*)+(.[0-9]{1,2})?$</li>\n<li>带 1-2 位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$</li>\n<li>正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$</li>\n<li>有两位小数的正实数：^[0-9]+(.[0-9]{2})?$</li>\n<li>有 1~3 位小数的正实数：^[0-9]+(.[0-9]{1,3})?$</li>\n<li>非零的正整数：^[1-9]\\d<em>$ 或 ^([1-9][0-9]</em>){1,3}$ 或 ^\\+?[1-9][0-9]*$</li>\n<li>非零的负整数：^\\-[1-9][]0-9″_\\$ 或 ^-[1-9]\\d_$</li>\n<li>非负整数：^\\d+$ 或 ^[1-9]\\d*|0$</li>\n<li>非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$</li>\n<li>非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d<em>\\.\\d</em>|0\\.\\d<em>[1-9]\\d</em>|0?\\.0+|0$</li>\n<li>非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d<em>\\.\\d</em>|0\\.\\d<em>[1-9]\\d</em>))|0?\\.0+|0$</li>\n<li>正浮点数：^[1-9]\\d<em>\\.\\d</em>|0\\.\\d<em>[1-9]\\d</em>$ 或 ^(([0-9]+\\.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]<em>\\.[0-9]+)|([0-9]</em>[1-9][0-9]</em>))$</li>\n<li>负浮点数：^-([1-9]\\d<em>\\.\\d</em>|0\\.\\d<em>[1-9]\\d</em>)$ 或 ^(-(([0-9]+\\.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]<em>\\.[0-9]+)|([0-9]</em>[1-9][0-9]</em>)))$</li>\n<li>浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d<em>\\.\\d</em>|0\\.\\d<em>[1-9]\\d</em>|0?\\.0+|0)$</li>\n</ul>\n<h3 id=\"二、校验字符的表达式\"><a href=\"#二、校验字符的表达式\" class=\"headerlink\" title=\"二、校验字符的表达式\"></a>二、校验字符的表达式</h3><ul>\n<li>汉字：^[\\u4e00-\\u9fa5]{0,}$</li>\n<li>英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$</li>\n<li>长度为 3-20 的所有字符：^.{3,20}$</li>\n<li>由 26 个英文字母组成的字符串：^[A-Za-z]+$</li>\n<li>由 26 个大写英文字母组成的字符串：^[A-Z]+$</li>\n<li>由 26 个小写英文字母组成的字符串：^[a-z]+$</li>\n<li>由数字和 26 个英文字母组成的字符串：^[A-Za-z0-9]+$</li>\n<li>由数字、26 个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$</li>\n<li>中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9\\_]+$</li>\n<li>中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$</li>\n<li>可以输入含有^%&amp;’,;=?$\\”等字符：[^%&amp;’,;=?$\\x22]+</li>\n<li>禁止输入含有<del>的字符：[^</del>\\x22]+</li>\n</ul>\n<h3 id=\"三、特殊需求表达式\"><a href=\"#三、特殊需求表达式\" class=\"headerlink\" title=\"三、特殊需求表达式\"></a>三、特殊需求表达式</h3><ul>\n<li>Email 地址：^\\w+([-+.]\\w+)_@\\w+([-.]\\w+)_\\.\\w+([-.]\\w+)\\*$</li>\n<li>域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?</li>\n<li>InternetURL：[a-zA-z]+://[^\\s]_ 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]_)?$</li>\n<li>手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$</li>\n<li>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^($$\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$</li>\n<li>国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7}</li>\n<li>身份证号(15 位、18 位数字)：^\\d{15}|\\d{18}$</li>\n<li>短身份证号码(数字、字母 x 结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$</li>\n<li>帐号是否合法(字母开头，允许 5-16 字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9\\_]{4,15}$</li>\n<li>密码(以字母开头，长度在 6~18 之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$</li>\n<li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=._\\d)(?=._[a-z])(?=.\\*[A-Z]).{8,10}$</li>\n<li>日期格式：^\\d{4}-\\d{1,2}-\\d{1,2}</li>\n<li>一年的 12 个月(01 ～ 09 和 1 ～ 12)：^(0?[1-9]|1[0-2])$</li>\n<li>一个月的 31 天(01 ～ 09 和 1 ～ 31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</li>\n<li>钱的输入格式：<ul>\n<li>有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00”, 和没有 “分” 的 “10000”#8221; 和 “10,000”：^[1-9][0-9]\\*$</li>\n<li>这表示任意一个不以 0 开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式：^(0|[1-9][0-9]\\*)$</li>\n<li>一个 0 或者一个不以 0 开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]\\*)$</li>\n<li>这表示一个 0 或者一个可能为负的开头不为 0 的数字.让用户以 0 开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$</li>\n<li>必须说明的是，小数点后面至少应该有 1 位数，所以”10.”是不通过的，但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$</li>\n<li>这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：^[0-9]+(.[0-9]{1,2})?$</li>\n<li>这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样：^[0-9]{1,3}(,[0-9]{3})\\*(.[0-9]{1,2})?$</li>\n<li>1 到 3 个数字，后面跟着任意个 逗号+3 个数字，逗号成为可选，而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})\\*)(.[0-9]{1,2})?$</li>\n<li>备注：这就是最终结果了，别忘了”+”可以用”*”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里</li>\n</ul>\n</li>\n<li>xml 文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</li>\n<li>中文字符的正则表达式：[\\u4e00-\\u9fa5]</li>\n<li>双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计 2，ASCII 字符计 1))</li>\n<li>空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行)</li>\n<li>HTML 标记的正则表达式：&lt;(\\S<em>?)[^&gt;]</em>&gt;.<em>?|&lt;.</em>? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</li>\n<li>首尾空白字符的正则表达式：^\\s<em>|\\s</em>$或(^\\s<em>)|(\\s</em>$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</li>\n<li>腾讯 QQ 号：[1-9][0-9]{4,} (腾讯 QQ 号从 10000 开始)</li>\n<li>中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为 6 位数字)</li>\n<li>IP 地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取 IP 地址时有用)</li>\n<li>IP 地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))</li>\n</ul>\n"},{"title":"node.js的request模块","date":"2017-09-19T21:40:00.000Z","_content":"\nrequest 模块让 http 请求变的更加简单。最简单的一个示例：\n\n1: var request = require('request');\n\n2:\n\n3: request('http://www.google.com', function (error, response, body) {\n\n4: if (!error && response.statusCode == 200) {\n\n5: console.log(body);\n\n6: }\n\n7: })\n\n安装：\n\nnpm install request\n\n可以用 request 的 pipe 方法很方便的获取图片的文件流\n\n1: var request = require('request'),\n\n2: fs = require('fs');\n\n3:\n\n4: request('https://www.google.com.hk/images/srpr/logo3w.png').pipe(fs.createWriteStream('doodle.png'));\n\nrequest 也支持 OAuth 的签名请求\n\n更多使用方法和说明可点击这里继续阅读：[https://github.com/mikeal/request/](https://github.com/mikeal/request/)\n\n这里写了一个很简单的示例，用来抓取去哪儿网的酒店查询数据（获取酒店某一时间段内各房型的价格排名）：\n\n1: var request = require('request'),\n\n2: fs = require('fs');\n\n3:\n\n4:\n\n5: var reqUrl = 'http://hotel.qunar.com/price/detail.jsp?fromDate=2012-08-18&toDate=2012-08-19&cityurl=shanghai\\_city&HotelSEQ=shanghai\\_city_2856&cn=5';\n\n6:\n\n7: request({uri:reqUrl}, function(err, response, body) {\n\n8:\n\n9: //console.log(response.statusCode);\n\n10: //console.log(response);\n\n11:\n\n12: //如果数据量比较大，就需要对返回的数据根据日期、酒店 ID 进行存储，如果获取数据进行对比的时候直接读文件\n\n13: var filePath = \\_\\_dirname + '/data/data.js';\n\n14:\n\n15: if (fs.exists(filePath)) {\n\n16: fs.unlinkSync(filePath);\n\n17:\n\n18: console.log('Del file ' + filePath);\n\n19: }\n\n20:\n\n21: fs.writeFile(filePath, body, 'utf8', function(err) {\n\n22: if (err) {\n\n23: throw err;\n\n24: }\n\n25:\n\n26: console.log('Save ' + filePath + ' ok~');\n\n27: });\n\n28:\n\n29: console.log('Fetch ' + reqUrl + ' ok~');\n\n30: });\n\n这个例子源于一个做酒店业务的朋友，想知道自己在网站上提供给客户的价格的竞争力：\n\n1、如果提供的价格过低，自己赚到的钱就会少了，所以如果自己价格是最低了，就需要看第二低是多少，然后决定是否调整；\n\n2、如果提供的价格过高，那么被搜索出来的排名结果就比较靠后，没什么客户来预订酒店，业务就没有了\n\n因为做的酒店预订业务很多，比如超过 2 千家以上，如果一个一个依赖人工去查询排名就比较被动，而且很难再做大，所以他的这个需求我分析了一下是可行的，而且可以做成一个很好的实时预警系统（当然数据 5~10 分钟会自动在页面刷新一次）。这样才能保障利润最大化，提高销售、客户部门的工作效率，加快酒店的合作数量和公司的人员扩张：\n\n1、不亏本，亏本的买卖不做；\n\n2、如果发现提供的价格过低或是过高，需要支持调用平台的 api 接口，直接修改价格；\n\n3、有自动生成分析报表功能，分析竞争对手在价格调整策略上的变化情况；\n","source":"_posts/2017-09-20-node.js的request模块.md","raw":"---\ntitle: node.js的request模块\ntags:\n  - 技术\n  - node\ndate: 2017-09-20 05:40:00\ncategories: 前端\n---\n\nrequest 模块让 http 请求变的更加简单。最简单的一个示例：\n\n1: var request = require('request');\n\n2:\n\n3: request('http://www.google.com', function (error, response, body) {\n\n4: if (!error && response.statusCode == 200) {\n\n5: console.log(body);\n\n6: }\n\n7: })\n\n安装：\n\nnpm install request\n\n可以用 request 的 pipe 方法很方便的获取图片的文件流\n\n1: var request = require('request'),\n\n2: fs = require('fs');\n\n3:\n\n4: request('https://www.google.com.hk/images/srpr/logo3w.png').pipe(fs.createWriteStream('doodle.png'));\n\nrequest 也支持 OAuth 的签名请求\n\n更多使用方法和说明可点击这里继续阅读：[https://github.com/mikeal/request/](https://github.com/mikeal/request/)\n\n这里写了一个很简单的示例，用来抓取去哪儿网的酒店查询数据（获取酒店某一时间段内各房型的价格排名）：\n\n1: var request = require('request'),\n\n2: fs = require('fs');\n\n3:\n\n4:\n\n5: var reqUrl = 'http://hotel.qunar.com/price/detail.jsp?fromDate=2012-08-18&toDate=2012-08-19&cityurl=shanghai\\_city&HotelSEQ=shanghai\\_city_2856&cn=5';\n\n6:\n\n7: request({uri:reqUrl}, function(err, response, body) {\n\n8:\n\n9: //console.log(response.statusCode);\n\n10: //console.log(response);\n\n11:\n\n12: //如果数据量比较大，就需要对返回的数据根据日期、酒店 ID 进行存储，如果获取数据进行对比的时候直接读文件\n\n13: var filePath = \\_\\_dirname + '/data/data.js';\n\n14:\n\n15: if (fs.exists(filePath)) {\n\n16: fs.unlinkSync(filePath);\n\n17:\n\n18: console.log('Del file ' + filePath);\n\n19: }\n\n20:\n\n21: fs.writeFile(filePath, body, 'utf8', function(err) {\n\n22: if (err) {\n\n23: throw err;\n\n24: }\n\n25:\n\n26: console.log('Save ' + filePath + ' ok~');\n\n27: });\n\n28:\n\n29: console.log('Fetch ' + reqUrl + ' ok~');\n\n30: });\n\n这个例子源于一个做酒店业务的朋友，想知道自己在网站上提供给客户的价格的竞争力：\n\n1、如果提供的价格过低，自己赚到的钱就会少了，所以如果自己价格是最低了，就需要看第二低是多少，然后决定是否调整；\n\n2、如果提供的价格过高，那么被搜索出来的排名结果就比较靠后，没什么客户来预订酒店，业务就没有了\n\n因为做的酒店预订业务很多，比如超过 2 千家以上，如果一个一个依赖人工去查询排名就比较被动，而且很难再做大，所以他的这个需求我分析了一下是可行的，而且可以做成一个很好的实时预警系统（当然数据 5~10 分钟会自动在页面刷新一次）。这样才能保障利润最大化，提高销售、客户部门的工作效率，加快酒店的合作数量和公司的人员扩张：\n\n1、不亏本，亏本的买卖不做；\n\n2、如果发现提供的价格过低或是过高，需要支持调用平台的 api 接口，直接修改价格；\n\n3、有自动生成分析报表功能，分析竞争对手在价格调整策略上的变化情况；\n","slug":"2017-09-20-node.js的request模块","published":1,"updated":"2020-03-14T06:48:39.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvkd001d4k8yej4b455y","content":"<p>request 模块让 http 请求变的更加简单。最简单的一个示例：</p>\n<p>1: var request = require(‘request’);</p>\n<p>2:</p>\n<p>3: request(‘<a href=\"http://www.google.com&#39;\" target=\"_blank\" rel=\"noopener\">http://www.google.com&#39;</a>, function (error, response, body) {</p>\n<p>4: if (!error &amp;&amp; response.statusCode == 200) {</p>\n<p>5: console.log(body);</p>\n<p>6: }</p>\n<p>7: })</p>\n<p>安装：</p>\n<p>npm install request</p>\n<p>可以用 request 的 pipe 方法很方便的获取图片的文件流</p>\n<p>1: var request = require(‘request’),</p>\n<p>2: fs = require(‘fs’);</p>\n<p>3:</p>\n<p>4: request(‘<a href=\"https://www.google.com.hk/images/srpr/logo3w.png&#39;).pipe(fs.createWriteStream(&#39;doodle.png&#39;)\" target=\"_blank\" rel=\"noopener\">https://www.google.com.hk/images/srpr/logo3w.png&#39;).pipe(fs.createWriteStream(&#39;doodle.png&#39;)</a>);</p>\n<p>request 也支持 OAuth 的签名请求</p>\n<p>更多使用方法和说明可点击这里继续阅读：<a href=\"https://github.com/mikeal/request/\" target=\"_blank\" rel=\"noopener\">https://github.com/mikeal/request/</a></p>\n<p>这里写了一个很简单的示例，用来抓取去哪儿网的酒店查询数据（获取酒店某一时间段内各房型的价格排名）：</p>\n<p>1: var request = require(‘request’),</p>\n<p>2: fs = require(‘fs’);</p>\n<p>3:</p>\n<p>4:</p>\n<p>5: var reqUrl = ‘<a href=\"http://hotel.qunar.com/price/detail.jsp?fromDate=2012-08-18&amp;toDate=2012-08-19&amp;cityurl=shanghai\\_city&amp;HotelSEQ=shanghai\\_city_2856&amp;cn=5&#39;\" target=\"_blank\" rel=\"noopener\">http://hotel.qunar.com/price/detail.jsp?fromDate=2012-08-18&amp;toDate=2012-08-19&amp;cityurl=shanghai\\_city&amp;HotelSEQ=shanghai\\_city_2856&amp;cn=5&#39;</a>;</p>\n<p>6:</p>\n<p>7: request({uri:reqUrl}, function(err, response, body) {</p>\n<p>8:</p>\n<p>9: //console.log(response.statusCode);</p>\n<p>10: //console.log(response);</p>\n<p>11:</p>\n<p>12: //如果数据量比较大，就需要对返回的数据根据日期、酒店 ID 进行存储，如果获取数据进行对比的时候直接读文件</p>\n<p>13: var filePath = __dirname + ‘/data/data.js’;</p>\n<p>14:</p>\n<p>15: if (fs.exists(filePath)) {</p>\n<p>16: fs.unlinkSync(filePath);</p>\n<p>17:</p>\n<p>18: console.log(‘Del file ‘ + filePath);</p>\n<p>19: }</p>\n<p>20:</p>\n<p>21: fs.writeFile(filePath, body, ‘utf8’, function(err) {</p>\n<p>22: if (err) {</p>\n<p>23: throw err;</p>\n<p>24: }</p>\n<p>25:</p>\n<p>26: console.log(‘Save ‘ + filePath + ‘ ok~’);</p>\n<p>27: });</p>\n<p>28:</p>\n<p>29: console.log(‘Fetch ‘ + reqUrl + ‘ ok~’);</p>\n<p>30: });</p>\n<p>这个例子源于一个做酒店业务的朋友，想知道自己在网站上提供给客户的价格的竞争力：</p>\n<p>1、如果提供的价格过低，自己赚到的钱就会少了，所以如果自己价格是最低了，就需要看第二低是多少，然后决定是否调整；</p>\n<p>2、如果提供的价格过高，那么被搜索出来的排名结果就比较靠后，没什么客户来预订酒店，业务就没有了</p>\n<p>因为做的酒店预订业务很多，比如超过 2 千家以上，如果一个一个依赖人工去查询排名就比较被动，而且很难再做大，所以他的这个需求我分析了一下是可行的，而且可以做成一个很好的实时预警系统（当然数据 5~10 分钟会自动在页面刷新一次）。这样才能保障利润最大化，提高销售、客户部门的工作效率，加快酒店的合作数量和公司的人员扩张：</p>\n<p>1、不亏本，亏本的买卖不做；</p>\n<p>2、如果发现提供的价格过低或是过高，需要支持调用平台的 api 接口，直接修改价格；</p>\n<p>3、有自动生成分析报表功能，分析竞争对手在价格调整策略上的变化情况；</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>request 模块让 http 请求变的更加简单。最简单的一个示例：</p>\n<p>1: var request = require(‘request’);</p>\n<p>2:</p>\n<p>3: request(‘<a href=\"http://www.google.com&#39;\" target=\"_blank\" rel=\"noopener\">http://www.google.com&#39;</a>, function (error, response, body) {</p>\n<p>4: if (!error &amp;&amp; response.statusCode == 200) {</p>\n<p>5: console.log(body);</p>\n<p>6: }</p>\n<p>7: })</p>\n<p>安装：</p>\n<p>npm install request</p>\n<p>可以用 request 的 pipe 方法很方便的获取图片的文件流</p>\n<p>1: var request = require(‘request’),</p>\n<p>2: fs = require(‘fs’);</p>\n<p>3:</p>\n<p>4: request(‘<a href=\"https://www.google.com.hk/images/srpr/logo3w.png&#39;).pipe(fs.createWriteStream(&#39;doodle.png&#39;)\" target=\"_blank\" rel=\"noopener\">https://www.google.com.hk/images/srpr/logo3w.png&#39;).pipe(fs.createWriteStream(&#39;doodle.png&#39;)</a>);</p>\n<p>request 也支持 OAuth 的签名请求</p>\n<p>更多使用方法和说明可点击这里继续阅读：<a href=\"https://github.com/mikeal/request/\" target=\"_blank\" rel=\"noopener\">https://github.com/mikeal/request/</a></p>\n<p>这里写了一个很简单的示例，用来抓取去哪儿网的酒店查询数据（获取酒店某一时间段内各房型的价格排名）：</p>\n<p>1: var request = require(‘request’),</p>\n<p>2: fs = require(‘fs’);</p>\n<p>3:</p>\n<p>4:</p>\n<p>5: var reqUrl = ‘<a href=\"http://hotel.qunar.com/price/detail.jsp?fromDate=2012-08-18&amp;toDate=2012-08-19&amp;cityurl=shanghai\\_city&amp;HotelSEQ=shanghai\\_city_2856&amp;cn=5&#39;\" target=\"_blank\" rel=\"noopener\">http://hotel.qunar.com/price/detail.jsp?fromDate=2012-08-18&amp;toDate=2012-08-19&amp;cityurl=shanghai\\_city&amp;HotelSEQ=shanghai\\_city_2856&amp;cn=5&#39;</a>;</p>\n<p>6:</p>\n<p>7: request({uri:reqUrl}, function(err, response, body) {</p>\n<p>8:</p>\n<p>9: //console.log(response.statusCode);</p>\n<p>10: //console.log(response);</p>\n<p>11:</p>\n<p>12: //如果数据量比较大，就需要对返回的数据根据日期、酒店 ID 进行存储，如果获取数据进行对比的时候直接读文件</p>\n<p>13: var filePath = __dirname + ‘/data/data.js’;</p>\n<p>14:</p>\n<p>15: if (fs.exists(filePath)) {</p>\n<p>16: fs.unlinkSync(filePath);</p>\n<p>17:</p>\n<p>18: console.log(‘Del file ‘ + filePath);</p>\n<p>19: }</p>\n<p>20:</p>\n<p>21: fs.writeFile(filePath, body, ‘utf8’, function(err) {</p>\n<p>22: if (err) {</p>\n<p>23: throw err;</p>\n<p>24: }</p>\n<p>25:</p>\n<p>26: console.log(‘Save ‘ + filePath + ‘ ok~’);</p>\n<p>27: });</p>\n<p>28:</p>\n<p>29: console.log(‘Fetch ‘ + reqUrl + ‘ ok~’);</p>\n<p>30: });</p>\n<p>这个例子源于一个做酒店业务的朋友，想知道自己在网站上提供给客户的价格的竞争力：</p>\n<p>1、如果提供的价格过低，自己赚到的钱就会少了，所以如果自己价格是最低了，就需要看第二低是多少，然后决定是否调整；</p>\n<p>2、如果提供的价格过高，那么被搜索出来的排名结果就比较靠后，没什么客户来预订酒店，业务就没有了</p>\n<p>因为做的酒店预订业务很多，比如超过 2 千家以上，如果一个一个依赖人工去查询排名就比较被动，而且很难再做大，所以他的这个需求我分析了一下是可行的，而且可以做成一个很好的实时预警系统（当然数据 5~10 分钟会自动在页面刷新一次）。这样才能保障利润最大化，提高销售、客户部门的工作效率，加快酒店的合作数量和公司的人员扩张：</p>\n<p>1、不亏本，亏本的买卖不做；</p>\n<p>2、如果发现提供的价格过低或是过高，需要支持调用平台的 api 接口，直接修改价格；</p>\n<p>3、有自动生成分析报表功能，分析竞争对手在价格调整策略上的变化情况；</p>\n"},{"title":"js中字符串的替换","date":"2017-09-19T06:16:00.000Z","_content":"\n**定义和用法**\n\nreplace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\n\n**语法**\n\nstringObject.replace(regexp/substr,replacement)参数 描述    \nregexp/substr 必需。规定子字符串或要替换的模式的 RegExp 对象。\n\n请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。\n\nreplacement 必需。一个字符串值。规定了替换文本或生成替换文本的函数。\n\n**返回值**\n\n一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。\n\n**说明  \n**字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。\n\nreplacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 \\$ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。\n\n**字符 替换文本    \n**$1、$2、...、$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。   \n$& 与 regexp 相匹配的子串。   \n$` 位于匹配子串左侧的文本。   \n$' 位于匹配子串右侧的文本。\n\n$$\n注意：ECMAScript v3 规定，replace() 方法的参数 replacement 可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。\n实例\n\ni、replace方法\n\n    该方法的作用是替换字符串中所有指定的字符，然后生成一个新的字符串。经过该方法调用以后，原来的字符串不发生改变。例如：\n\n    String s = “abcat”；\n\n    String s1 = s.replace（‘a’，‘1’）；\n\n    该代码的作用是将字符串s中所有的字符a替换成字符1，生成的新字符串s1的值是“1bc1t”，而字符串s的内容不发生改变。\n\n    如果需要将字符串中某个指定的字符串替换为其它字符串，则可以使用replaceAll方法，例如：\n\n    String s = “abatbac”；\n\n    String s1 = s.replaceAll（“ba”，“12”）；\n\n    该代码的作用是将字符串s中所有的字符串“ab”替换为“12”，生成新的字符串“a12t12c”，而字符串s的内容也不发生改变。\n\n    如果只需要替换第一个出现的指定字符串时，可以使用replaceFirst方法，例如：\n\n    String s = “abatbac”；\n\n    String s1 = s. replaceFirst （“ba”，“12”）；\n\n    该代码的作用是只将字符串s中全局出现的字符串“,”替换为字符串“/”。\n\n  var str = \"Is,is,the,cost,of,of,gasoline,going,up,up\";\n\n_document.write(str.replace(/\\\\,/g,'/'));_\n\n    运用正则进行全局匹配将全局的“,”替换为“/”。\n\n**例子 1\n**在本例中，我们将使用 \"jb51.net\" 替换字符串中的 \"Microsoft\"：\n\n[?](http://www.jb51.net/article/28009.htm#)\n\n1\n\n2\n\n3\n\n4\n\n`<code class=\"js string\">\"text/javascript\"</code><code class=\"js plain\">></code></div> <div class=\"line number2 index1 alt1\"><code class=\"js keyword\">var</code> <code class=\"js plain\">str=</code><code class=\"js string\">\"Visit Microsoft!\"</code></div> <div class=\"line number3 index2 alt2\"><code class=\"js plain\">document.write(str.replace(/Microsoft/, </code><code class=\"js string\">\"jb51.net\"</code><code class=\"js plain\">))</code></div> <div class=\"line number4 index3 alt1\"><code class=\"js plain\">`\n\n输出：\n\nVisit jb51.net!\n\n**例子 2\n**在本例中，我们将执行一次全局替换，每当 \"Microsoft\" 被找到，它就被替换为 \"jb51.net\"：\n\n[?](http://www.jb51.net/article/28009.htm#)\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n`<code class=\"js string\">\"text/javascript\"</code><code class=\"js plain\">></code></div> <div class=\"line number2 index1 alt1\"><code class=\"js keyword\">var</code> <code class=\"js plain\">str=</code><code class=\"js string\">\"Welcome to Microsoft! \"</code></div> <div class=\"line number3 index2 alt2\"><code class=\"js plain\">str=str + </code><code class=\"js string\">\"We are proud to announce that Microsoft has \"</code></div> <div class=\"line number4 index3 alt1\"><code class=\"js plain\">str=str + </code><code class=\"js string\">\"one of the largest Web Developers sites in the world.\"</code></div> <div class=\"line number5 index4 alt2\"><code class=\"js plain\">document.write(str.replace(/Microsoft/g, </code><code class=\"js string\">\"jb51.net\"</code><code class=\"js plain\">))</code></div> <div class=\"line number6 index5 alt1\"><code class=\"js plain\">`\n\n输出：\n\nWelcome to jb51.net! We are proud to announce that jb51.net\nhas one of the largest Web Developers sites in the world.\n\n**例子 3\n**您可以使用本例提供的代码来确保匹配字符串大写字符的正确：\n\n[?](http://www.jb51.net/article/28009.htm#)\n\n1\n\n2\n\n`text =` `\"javascript Tutorial\"``;`\n\n`text.replace(/javascript/i,` `\"JavaScript\"``);`\n\n**例子 4\n**在本例中，我们将把 \"Doe, John\" 转换为 \"John Doe\" 的形式：\n\n[?](http://www.jb51.net/article/28009.htm#)\n\n1\n\n2\n\n`name =` `\"Doe, John\"``;`\n\n`name.replace(/(\\w+)\\s*, \\s*(\\w+)/,` `\"$2 $1\"``);`\n\n**例子 5\n**在本例中，我们将把所有的花引号替换为直引号：\n\n[?](http://www.jb51.net/article/28009.htm#)\n\n1\n\n2\n\n`name =` `'\"a\", \"b\"'``;`\n\n`name.replace(/``\"([^\"``]*)``\"/g, \"``'$1'``\");`\n\n**例子 6\n**在本例中，我们将把字符串中所有单词的首字母都转换为大写：\n\n[?](http://www.jb51.net/article/28009.htm#)\n\n1\n\n2\n\n3\n\n4\n\n`name =` `'aaa bbb ccc'``;`\n\n`uw=name.replace(/\\b\\w+\\b/g,` `function``(word){`\n\n`return` `word.substring(0,1).toUpperCase()+word.substring(1);}`\n\n`);`\n$$\n","source":"_posts/2017-09-19-js中字符串的替换.md","raw":"---\ntitle: js中字符串的替换\ntags:\n  - 技术\ndate: 2017-09-19 14:16:00\ncategories: 前端\n---\n\n**定义和用法**\n\nreplace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\n\n**语法**\n\nstringObject.replace(regexp/substr,replacement)参数 描述    \nregexp/substr 必需。规定子字符串或要替换的模式的 RegExp 对象。\n\n请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。\n\nreplacement 必需。一个字符串值。规定了替换文本或生成替换文本的函数。\n\n**返回值**\n\n一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。\n\n**说明  \n**字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。\n\nreplacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 \\$ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。\n\n**字符 替换文本    \n**$1、$2、...、$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。   \n$& 与 regexp 相匹配的子串。   \n$` 位于匹配子串左侧的文本。   \n$' 位于匹配子串右侧的文本。\n\n$$\n注意：ECMAScript v3 规定，replace() 方法的参数 replacement 可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。\n实例\n\ni、replace方法\n\n    该方法的作用是替换字符串中所有指定的字符，然后生成一个新的字符串。经过该方法调用以后，原来的字符串不发生改变。例如：\n\n    String s = “abcat”；\n\n    String s1 = s.replace（‘a’，‘1’）；\n\n    该代码的作用是将字符串s中所有的字符a替换成字符1，生成的新字符串s1的值是“1bc1t”，而字符串s的内容不发生改变。\n\n    如果需要将字符串中某个指定的字符串替换为其它字符串，则可以使用replaceAll方法，例如：\n\n    String s = “abatbac”；\n\n    String s1 = s.replaceAll（“ba”，“12”）；\n\n    该代码的作用是将字符串s中所有的字符串“ab”替换为“12”，生成新的字符串“a12t12c”，而字符串s的内容也不发生改变。\n\n    如果只需要替换第一个出现的指定字符串时，可以使用replaceFirst方法，例如：\n\n    String s = “abatbac”；\n\n    String s1 = s. replaceFirst （“ba”，“12”）；\n\n    该代码的作用是只将字符串s中全局出现的字符串“,”替换为字符串“/”。\n\n  var str = \"Is,is,the,cost,of,of,gasoline,going,up,up\";\n\n_document.write(str.replace(/\\\\,/g,'/'));_\n\n    运用正则进行全局匹配将全局的“,”替换为“/”。\n\n**例子 1\n**在本例中，我们将使用 \"jb51.net\" 替换字符串中的 \"Microsoft\"：\n\n[?](http://www.jb51.net/article/28009.htm#)\n\n1\n\n2\n\n3\n\n4\n\n`<code class=\"js string\">\"text/javascript\"</code><code class=\"js plain\">></code></div> <div class=\"line number2 index1 alt1\"><code class=\"js keyword\">var</code> <code class=\"js plain\">str=</code><code class=\"js string\">\"Visit Microsoft!\"</code></div> <div class=\"line number3 index2 alt2\"><code class=\"js plain\">document.write(str.replace(/Microsoft/, </code><code class=\"js string\">\"jb51.net\"</code><code class=\"js plain\">))</code></div> <div class=\"line number4 index3 alt1\"><code class=\"js plain\">`\n\n输出：\n\nVisit jb51.net!\n\n**例子 2\n**在本例中，我们将执行一次全局替换，每当 \"Microsoft\" 被找到，它就被替换为 \"jb51.net\"：\n\n[?](http://www.jb51.net/article/28009.htm#)\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n`<code class=\"js string\">\"text/javascript\"</code><code class=\"js plain\">></code></div> <div class=\"line number2 index1 alt1\"><code class=\"js keyword\">var</code> <code class=\"js plain\">str=</code><code class=\"js string\">\"Welcome to Microsoft! \"</code></div> <div class=\"line number3 index2 alt2\"><code class=\"js plain\">str=str + </code><code class=\"js string\">\"We are proud to announce that Microsoft has \"</code></div> <div class=\"line number4 index3 alt1\"><code class=\"js plain\">str=str + </code><code class=\"js string\">\"one of the largest Web Developers sites in the world.\"</code></div> <div class=\"line number5 index4 alt2\"><code class=\"js plain\">document.write(str.replace(/Microsoft/g, </code><code class=\"js string\">\"jb51.net\"</code><code class=\"js plain\">))</code></div> <div class=\"line number6 index5 alt1\"><code class=\"js plain\">`\n\n输出：\n\nWelcome to jb51.net! We are proud to announce that jb51.net\nhas one of the largest Web Developers sites in the world.\n\n**例子 3\n**您可以使用本例提供的代码来确保匹配字符串大写字符的正确：\n\n[?](http://www.jb51.net/article/28009.htm#)\n\n1\n\n2\n\n`text =` `\"javascript Tutorial\"``;`\n\n`text.replace(/javascript/i,` `\"JavaScript\"``);`\n\n**例子 4\n**在本例中，我们将把 \"Doe, John\" 转换为 \"John Doe\" 的形式：\n\n[?](http://www.jb51.net/article/28009.htm#)\n\n1\n\n2\n\n`name =` `\"Doe, John\"``;`\n\n`name.replace(/(\\w+)\\s*, \\s*(\\w+)/,` `\"$2 $1\"``);`\n\n**例子 5\n**在本例中，我们将把所有的花引号替换为直引号：\n\n[?](http://www.jb51.net/article/28009.htm#)\n\n1\n\n2\n\n`name =` `'\"a\", \"b\"'``;`\n\n`name.replace(/``\"([^\"``]*)``\"/g, \"``'$1'``\");`\n\n**例子 6\n**在本例中，我们将把字符串中所有单词的首字母都转换为大写：\n\n[?](http://www.jb51.net/article/28009.htm#)\n\n1\n\n2\n\n3\n\n4\n\n`name =` `'aaa bbb ccc'``;`\n\n`uw=name.replace(/\\b\\w+\\b/g,` `function``(word){`\n\n`return` `word.substring(0,1).toUpperCase()+word.substring(1);}`\n\n`);`\n$$\n","slug":"2017-09-19-js中字符串的替换","published":1,"updated":"2020-03-14T06:48:28.673Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvkf001g4k8y6ej1abme","content":"<p><strong>定义和用法</strong></p>\n<p>replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p>\n<p><strong>语法</strong></p>\n<p>stringObject.replace(regexp/substr,replacement)参数 描述<br>regexp/substr 必需。规定子字符串或要替换的模式的 RegExp 对象。</p>\n<p>请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。</p>\n<p>replacement 必需。一个字符串值。规定了替换文本或生成替换文本的函数。</p>\n<p><strong>返回值</strong></p>\n<p>一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。</p>\n<p>*<em>说明<br>*</em>字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。</p>\n<p>replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。</p>\n<p>*<em>字符 替换文本<br>*</em>$1、$2、…、$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。<br>$&amp; 与 regexp 相匹配的子串。<br>$` 位于匹配子串左侧的文本。<br>$’ 位于匹配子串右侧的文本。</p>\n<p>$$<br>注意：ECMAScript v3 规定，replace() 方法的参数 replacement 可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。<br>实例</p>\n<p>i、replace方法</p>\n<pre><code>该方法的作用是替换字符串中所有指定的字符，然后生成一个新的字符串。经过该方法调用以后，原来的字符串不发生改变。例如：\n\nString s = “abcat”；\n\nString s1 = s.replace（‘a’，‘1’）；\n\n该代码的作用是将字符串s中所有的字符a替换成字符1，生成的新字符串s1的值是“1bc1t”，而字符串s的内容不发生改变。\n\n如果需要将字符串中某个指定的字符串替换为其它字符串，则可以使用replaceAll方法，例如：\n\nString s = “abatbac”；\n\nString s1 = s.replaceAll（“ba”，“12”）；\n\n该代码的作用是将字符串s中所有的字符串“ab”替换为“12”，生成新的字符串“a12t12c”，而字符串s的内容也不发生改变。\n\n如果只需要替换第一个出现的指定字符串时，可以使用replaceFirst方法，例如：\n\nString s = “abatbac”；\n\nString s1 = s. replaceFirst （“ba”，“12”）；\n\n该代码的作用是只将字符串s中全局出现的字符串“,”替换为字符串“/”。</code></pre><p>  var str = “Is,is,the,cost,of,of,gasoline,going,up,up”;</p>\n<p><em>document.write(str.replace(/\\,/g,’/‘));</em></p>\n<pre><code>运用正则进行全局匹配将全局的“,”替换为“/”。</code></pre><p>*<em>例子 1<br>*</em>在本例中，我们将使用 “jb51.net” 替换字符串中的 “Microsoft”：</p>\n<p><a href=\"http://www.jb51.net/article/28009.htm#\" target=\"_blank\" rel=\"noopener\">?</a></p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p><code>&lt;code class=&quot;js string&quot;&gt;&quot;text/javascript&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;&gt;&lt;/code&gt;&lt;/div&gt; &lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;str=&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;Visit Microsoft!&quot;&lt;/code&gt;&lt;/div&gt; &lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;js plain&quot;&gt;document.write(str.replace(/Microsoft/, &lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;jb51.net&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;))&lt;/code&gt;&lt;/div&gt; &lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;js plain&quot;&gt;</code></p>\n<p>输出：</p>\n<p>Visit jb51.net!</p>\n<p>*<em>例子 2<br>*</em>在本例中，我们将执行一次全局替换，每当 “Microsoft” 被找到，它就被替换为 “jb51.net”：</p>\n<p><a href=\"http://www.jb51.net/article/28009.htm#\" target=\"_blank\" rel=\"noopener\">?</a></p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p><code>&lt;code class=&quot;js string&quot;&gt;&quot;text/javascript&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;&gt;&lt;/code&gt;&lt;/div&gt; &lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;str=&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;Welcome to Microsoft! &quot;&lt;/code&gt;&lt;/div&gt; &lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;js plain&quot;&gt;str=str + &lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;We are proud to announce that Microsoft has &quot;&lt;/code&gt;&lt;/div&gt; &lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;js plain&quot;&gt;str=str + &lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;one of the largest Web Developers sites in the world.&quot;&lt;/code&gt;&lt;/div&gt; &lt;div class=&quot;line number5 index4 alt2&quot;&gt;&lt;code class=&quot;js plain&quot;&gt;document.write(str.replace(/Microsoft/g, &lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;jb51.net&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;))&lt;/code&gt;&lt;/div&gt; &lt;div class=&quot;line number6 index5 alt1&quot;&gt;&lt;code class=&quot;js plain&quot;&gt;</code></p>\n<p>输出：</p>\n<p>Welcome to jb51.net! We are proud to announce that jb51.net<br>has one of the largest Web Developers sites in the world.</p>\n<p>*<em>例子 3<br>*</em>您可以使用本例提供的代码来确保匹配字符串大写字符的正确：</p>\n<p><a href=\"http://www.jb51.net/article/28009.htm#\" target=\"_blank\" rel=\"noopener\">?</a></p>\n<p>1</p>\n<p>2</p>\n<p><code>text =</code> <code>&quot;javascript Tutorial&quot;``;</code></p>\n<p><code>text.replace(/javascript/i,</code> <code>&quot;JavaScript&quot;``);</code></p>\n<p>*<em>例子 4<br>*</em>在本例中，我们将把 “Doe, John” 转换为 “John Doe” 的形式：</p>\n<p><a href=\"http://www.jb51.net/article/28009.htm#\" target=\"_blank\" rel=\"noopener\">?</a></p>\n<p>1</p>\n<p>2</p>\n<p><code>name =</code> <code>&quot;Doe, John&quot;``;</code></p>\n<p><code>name.replace(/(\\w+)\\s*, \\s*(\\w+)/,</code> <code>&quot;$2 $1&quot;``);</code></p>\n<p>*<em>例子 5<br>*</em>在本例中，我们将把所有的花引号替换为直引号：</p>\n<p><a href=\"http://www.jb51.net/article/28009.htm#\" target=\"_blank\" rel=\"noopener\">?</a></p>\n<p>1</p>\n<p>2</p>\n<p><code>name =</code> <code>&#39;&quot;a&quot;, &quot;b&quot;&#39;``;</code></p>\n<p><code>name.replace(/``&quot;([^&quot;``]*)``&quot;/g, &quot;``&#39;$1&#39;``&quot;);</code></p>\n<p>*<em>例子 6<br>*</em>在本例中，我们将把字符串中所有单词的首字母都转换为大写：</p>\n<p><a href=\"http://www.jb51.net/article/28009.htm#\" target=\"_blank\" rel=\"noopener\">?</a></p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p><code>name =</code> <code>&#39;aaa bbb ccc&#39;``;</code></p>\n<p><code>uw=name.replace(/\\b\\w+\\b/g,</code> <code>function``(word){</code></p>\n<p><code>return</code> <code>word.substring(0,1).toUpperCase()+word.substring(1);}</code></p>\n<p><code>);</code><br>$$</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p><strong>定义和用法</strong></p>\n<p>replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p>\n<p><strong>语法</strong></p>\n<p>stringObject.replace(regexp/substr,replacement)参数 描述<br>regexp/substr 必需。规定子字符串或要替换的模式的 RegExp 对象。</p>\n<p>请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。</p>\n<p>replacement 必需。一个字符串值。规定了替换文本或生成替换文本的函数。</p>\n<p><strong>返回值</strong></p>\n<p>一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。</p>\n<p>*<em>说明<br>*</em>字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。</p>\n<p>replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。</p>\n<p>*<em>字符 替换文本<br>*</em>$1、$2、…、$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。<br>$&amp; 与 regexp 相匹配的子串。<br>$` 位于匹配子串左侧的文本。<br>$’ 位于匹配子串右侧的文本。</p>\n<p>$$<br>注意：ECMAScript v3 规定，replace() 方法的参数 replacement 可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。<br>实例</p>\n<p>i、replace方法</p>\n<pre><code>该方法的作用是替换字符串中所有指定的字符，然后生成一个新的字符串。经过该方法调用以后，原来的字符串不发生改变。例如：\n\nString s = “abcat”；\n\nString s1 = s.replace（‘a’，‘1’）；\n\n该代码的作用是将字符串s中所有的字符a替换成字符1，生成的新字符串s1的值是“1bc1t”，而字符串s的内容不发生改变。\n\n如果需要将字符串中某个指定的字符串替换为其它字符串，则可以使用replaceAll方法，例如：\n\nString s = “abatbac”；\n\nString s1 = s.replaceAll（“ba”，“12”）；\n\n该代码的作用是将字符串s中所有的字符串“ab”替换为“12”，生成新的字符串“a12t12c”，而字符串s的内容也不发生改变。\n\n如果只需要替换第一个出现的指定字符串时，可以使用replaceFirst方法，例如：\n\nString s = “abatbac”；\n\nString s1 = s. replaceFirst （“ba”，“12”）；\n\n该代码的作用是只将字符串s中全局出现的字符串“,”替换为字符串“/”。</code></pre><p>  var str = “Is,is,the,cost,of,of,gasoline,going,up,up”;</p>\n<p><em>document.write(str.replace(/\\,/g,’/‘));</em></p>\n<pre><code>运用正则进行全局匹配将全局的“,”替换为“/”。</code></pre><p>*<em>例子 1<br>*</em>在本例中，我们将使用 “jb51.net” 替换字符串中的 “Microsoft”：</p>\n<p><a href=\"http://www.jb51.net/article/28009.htm#\" target=\"_blank\" rel=\"noopener\">?</a></p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p><code>&lt;code class=&quot;js string&quot;&gt;&quot;text/javascript&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;&gt;&lt;/code&gt;&lt;/div&gt; &lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;str=&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;Visit Microsoft!&quot;&lt;/code&gt;&lt;/div&gt; &lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;js plain&quot;&gt;document.write(str.replace(/Microsoft/, &lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;jb51.net&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;))&lt;/code&gt;&lt;/div&gt; &lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;js plain&quot;&gt;</code></p>\n<p>输出：</p>\n<p>Visit jb51.net!</p>\n<p>*<em>例子 2<br>*</em>在本例中，我们将执行一次全局替换，每当 “Microsoft” 被找到，它就被替换为 “jb51.net”：</p>\n<p><a href=\"http://www.jb51.net/article/28009.htm#\" target=\"_blank\" rel=\"noopener\">?</a></p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p><code>&lt;code class=&quot;js string&quot;&gt;&quot;text/javascript&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;&gt;&lt;/code&gt;&lt;/div&gt; &lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;str=&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;Welcome to Microsoft! &quot;&lt;/code&gt;&lt;/div&gt; &lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;js plain&quot;&gt;str=str + &lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;We are proud to announce that Microsoft has &quot;&lt;/code&gt;&lt;/div&gt; &lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;js plain&quot;&gt;str=str + &lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;one of the largest Web Developers sites in the world.&quot;&lt;/code&gt;&lt;/div&gt; &lt;div class=&quot;line number5 index4 alt2&quot;&gt;&lt;code class=&quot;js plain&quot;&gt;document.write(str.replace(/Microsoft/g, &lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;jb51.net&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;))&lt;/code&gt;&lt;/div&gt; &lt;div class=&quot;line number6 index5 alt1&quot;&gt;&lt;code class=&quot;js plain&quot;&gt;</code></p>\n<p>输出：</p>\n<p>Welcome to jb51.net! We are proud to announce that jb51.net<br>has one of the largest Web Developers sites in the world.</p>\n<p>*<em>例子 3<br>*</em>您可以使用本例提供的代码来确保匹配字符串大写字符的正确：</p>\n<p><a href=\"http://www.jb51.net/article/28009.htm#\" target=\"_blank\" rel=\"noopener\">?</a></p>\n<p>1</p>\n<p>2</p>\n<p><code>text =</code> <code>&quot;javascript Tutorial&quot;``;</code></p>\n<p><code>text.replace(/javascript/i,</code> <code>&quot;JavaScript&quot;``);</code></p>\n<p>*<em>例子 4<br>*</em>在本例中，我们将把 “Doe, John” 转换为 “John Doe” 的形式：</p>\n<p><a href=\"http://www.jb51.net/article/28009.htm#\" target=\"_blank\" rel=\"noopener\">?</a></p>\n<p>1</p>\n<p>2</p>\n<p><code>name =</code> <code>&quot;Doe, John&quot;``;</code></p>\n<p><code>name.replace(/(\\w+)\\s*, \\s*(\\w+)/,</code> <code>&quot;$2 $1&quot;``);</code></p>\n<p>*<em>例子 5<br>*</em>在本例中，我们将把所有的花引号替换为直引号：</p>\n<p><a href=\"http://www.jb51.net/article/28009.htm#\" target=\"_blank\" rel=\"noopener\">?</a></p>\n<p>1</p>\n<p>2</p>\n<p><code>name =</code> <code>&#39;&quot;a&quot;, &quot;b&quot;&#39;``;</code></p>\n<p><code>name.replace(/``&quot;([^&quot;``]*)``&quot;/g, &quot;``&#39;$1&#39;``&quot;);</code></p>\n<p>*<em>例子 6<br>*</em>在本例中，我们将把字符串中所有单词的首字母都转换为大写：</p>\n<p><a href=\"http://www.jb51.net/article/28009.htm#\" target=\"_blank\" rel=\"noopener\">?</a></p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p><code>name =</code> <code>&#39;aaa bbb ccc&#39;``;</code></p>\n<p><code>uw=name.replace(/\\b\\w+\\b/g,</code> <code>function``(word){</code></p>\n<p><code>return</code> <code>word.substring(0,1).toUpperCase()+word.substring(1);}</code></p>\n<p><code>);</code><br>$$</p>\n"},{"title":"一些常用文件夹和类的一些命名","date":"2017-10-09T07:08:00.000Z","_content":"\n头：header\n\n内容：content/container\n\n尾：footer\n\n导航：nav\n\n侧栏：sidebar\n\n栏目：column\n\n页面外围控制整体佈局宽度：wrapper\n\n左右中：left right center\n\n登录条：loginbar\n\n标志：logo\n\n广告：banner\n\n页面主体：main\n\n热点：hot\n\n新闻：news\n\n下载：download\n\n子导航：subnav\n\n菜单：menu\n\n子菜单：submenu\n\n搜索：search\n\n友情链接：friendlink\n\n页脚：footer\n\n版权：copyright\n\n滚动：scroll\n\n内容：content\n\n标签：tags\n\n文章列表：list\n\n提示信息：msg\n\n小技巧：tips\n\n栏目标题：title\n\n加入：joinus\n\n指南：guide\n\n服务：service\n\n注册：regsiter\n\n状态：status\n\n投票：vote\n\n合作伙伴：partner\n\nId 的命名:\n\n1)页面结构\n\n容器: container\n\n页头：header\n\n内容：content/container\n\n页面主体：main\n\n页尾：footer\n\n导航：nav\n\n侧栏：sidebar\n\n栏目：column\n\n页面外围控制整体佈局宽度：wrapper\n\n左右中：left right center\n\n(2)导航\n\n导航：nav\n\n主导航：mainnav\n\n子导航：subnav\n\n顶导航：topnav\n\n边导航：sidebar\n\n左导航：leftsidebar\n\n右导航：rightsidebar\n\n菜单：menu\n\n子菜单：submenu\n\n标题: title\n\n摘要: summary\n\n(3)功能\n\n标志：logo\n\n广告：banner\n\n登陆：login\n\n登录条：loginbar\n\n注册：register\n\n搜索：search\n\n功能区：shop\n\n标题：title\n\n加入：joinus\n\n状态：status\n\n按钮：btn\n\n滚动：scroll\n\n标籤页：tab\n\n文章列表：list\n\n提示信息：msg\n\n当前的: current\n\n小技巧：tips\n\n图标: icon\n\n注释：note\n\n指南：guild\n\n服务：service\n\n热点：hot\n\n新闻：news\n\n下载：download\n\n投票：vote\n\n合作伙伴：partner\n\n友情链接：link\n\n版权：copyright\n","source":"_posts/2017-10-09-命名规范.md","raw":"---\ntitle: 一些常用文件夹和类的一些命名\ntags:\n  - 技术\ndate: 2017-10-09 15:08:00\ncategories: 前端\n---\n\n头：header\n\n内容：content/container\n\n尾：footer\n\n导航：nav\n\n侧栏：sidebar\n\n栏目：column\n\n页面外围控制整体佈局宽度：wrapper\n\n左右中：left right center\n\n登录条：loginbar\n\n标志：logo\n\n广告：banner\n\n页面主体：main\n\n热点：hot\n\n新闻：news\n\n下载：download\n\n子导航：subnav\n\n菜单：menu\n\n子菜单：submenu\n\n搜索：search\n\n友情链接：friendlink\n\n页脚：footer\n\n版权：copyright\n\n滚动：scroll\n\n内容：content\n\n标签：tags\n\n文章列表：list\n\n提示信息：msg\n\n小技巧：tips\n\n栏目标题：title\n\n加入：joinus\n\n指南：guide\n\n服务：service\n\n注册：regsiter\n\n状态：status\n\n投票：vote\n\n合作伙伴：partner\n\nId 的命名:\n\n1)页面结构\n\n容器: container\n\n页头：header\n\n内容：content/container\n\n页面主体：main\n\n页尾：footer\n\n导航：nav\n\n侧栏：sidebar\n\n栏目：column\n\n页面外围控制整体佈局宽度：wrapper\n\n左右中：left right center\n\n(2)导航\n\n导航：nav\n\n主导航：mainnav\n\n子导航：subnav\n\n顶导航：topnav\n\n边导航：sidebar\n\n左导航：leftsidebar\n\n右导航：rightsidebar\n\n菜单：menu\n\n子菜单：submenu\n\n标题: title\n\n摘要: summary\n\n(3)功能\n\n标志：logo\n\n广告：banner\n\n登陆：login\n\n登录条：loginbar\n\n注册：register\n\n搜索：search\n\n功能区：shop\n\n标题：title\n\n加入：joinus\n\n状态：status\n\n按钮：btn\n\n滚动：scroll\n\n标籤页：tab\n\n文章列表：list\n\n提示信息：msg\n\n当前的: current\n\n小技巧：tips\n\n图标: icon\n\n注释：note\n\n指南：guild\n\n服务：service\n\n热点：hot\n\n新闻：news\n\n下载：download\n\n投票：vote\n\n合作伙伴：partner\n\n友情链接：link\n\n版权：copyright\n","slug":"2017-10-09-命名规范","published":1,"updated":"2020-03-14T06:48:47.588Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvkh001l4k8ya8yy95wv","content":"<p>头：header</p>\n<p>内容：content/container</p>\n<p>尾：footer</p>\n<p>导航：nav</p>\n<p>侧栏：sidebar</p>\n<p>栏目：column</p>\n<p>页面外围控制整体佈局宽度：wrapper</p>\n<p>左右中：left right center</p>\n<p>登录条：loginbar</p>\n<p>标志：logo</p>\n<p>广告：banner</p>\n<p>页面主体：main</p>\n<p>热点：hot</p>\n<p>新闻：news</p>\n<p>下载：download</p>\n<p>子导航：subnav</p>\n<p>菜单：menu</p>\n<p>子菜单：submenu</p>\n<p>搜索：search</p>\n<p>友情链接：friendlink</p>\n<p>页脚：footer</p>\n<p>版权：copyright</p>\n<p>滚动：scroll</p>\n<p>内容：content</p>\n<p>标签：tags</p>\n<p>文章列表：list</p>\n<p>提示信息：msg</p>\n<p>小技巧：tips</p>\n<p>栏目标题：title</p>\n<p>加入：joinus</p>\n<p>指南：guide</p>\n<p>服务：service</p>\n<p>注册：regsiter</p>\n<p>状态：status</p>\n<p>投票：vote</p>\n<p>合作伙伴：partner</p>\n<p>Id 的命名:</p>\n<p>1)页面结构</p>\n<p>容器: container</p>\n<p>页头：header</p>\n<p>内容：content/container</p>\n<p>页面主体：main</p>\n<p>页尾：footer</p>\n<p>导航：nav</p>\n<p>侧栏：sidebar</p>\n<p>栏目：column</p>\n<p>页面外围控制整体佈局宽度：wrapper</p>\n<p>左右中：left right center</p>\n<p>(2)导航</p>\n<p>导航：nav</p>\n<p>主导航：mainnav</p>\n<p>子导航：subnav</p>\n<p>顶导航：topnav</p>\n<p>边导航：sidebar</p>\n<p>左导航：leftsidebar</p>\n<p>右导航：rightsidebar</p>\n<p>菜单：menu</p>\n<p>子菜单：submenu</p>\n<p>标题: title</p>\n<p>摘要: summary</p>\n<p>(3)功能</p>\n<p>标志：logo</p>\n<p>广告：banner</p>\n<p>登陆：login</p>\n<p>登录条：loginbar</p>\n<p>注册：register</p>\n<p>搜索：search</p>\n<p>功能区：shop</p>\n<p>标题：title</p>\n<p>加入：joinus</p>\n<p>状态：status</p>\n<p>按钮：btn</p>\n<p>滚动：scroll</p>\n<p>标籤页：tab</p>\n<p>文章列表：list</p>\n<p>提示信息：msg</p>\n<p>当前的: current</p>\n<p>小技巧：tips</p>\n<p>图标: icon</p>\n<p>注释：note</p>\n<p>指南：guild</p>\n<p>服务：service</p>\n<p>热点：hot</p>\n<p>新闻：news</p>\n<p>下载：download</p>\n<p>投票：vote</p>\n<p>合作伙伴：partner</p>\n<p>友情链接：link</p>\n<p>版权：copyright</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>头：header</p>\n<p>内容：content/container</p>\n<p>尾：footer</p>\n<p>导航：nav</p>\n<p>侧栏：sidebar</p>\n<p>栏目：column</p>\n<p>页面外围控制整体佈局宽度：wrapper</p>\n<p>左右中：left right center</p>\n<p>登录条：loginbar</p>\n<p>标志：logo</p>\n<p>广告：banner</p>\n<p>页面主体：main</p>\n<p>热点：hot</p>\n<p>新闻：news</p>\n<p>下载：download</p>\n<p>子导航：subnav</p>\n<p>菜单：menu</p>\n<p>子菜单：submenu</p>\n<p>搜索：search</p>\n<p>友情链接：friendlink</p>\n<p>页脚：footer</p>\n<p>版权：copyright</p>\n<p>滚动：scroll</p>\n<p>内容：content</p>\n<p>标签：tags</p>\n<p>文章列表：list</p>\n<p>提示信息：msg</p>\n<p>小技巧：tips</p>\n<p>栏目标题：title</p>\n<p>加入：joinus</p>\n<p>指南：guide</p>\n<p>服务：service</p>\n<p>注册：regsiter</p>\n<p>状态：status</p>\n<p>投票：vote</p>\n<p>合作伙伴：partner</p>\n<p>Id 的命名:</p>\n<p>1)页面结构</p>\n<p>容器: container</p>\n<p>页头：header</p>\n<p>内容：content/container</p>\n<p>页面主体：main</p>\n<p>页尾：footer</p>\n<p>导航：nav</p>\n<p>侧栏：sidebar</p>\n<p>栏目：column</p>\n<p>页面外围控制整体佈局宽度：wrapper</p>\n<p>左右中：left right center</p>\n<p>(2)导航</p>\n<p>导航：nav</p>\n<p>主导航：mainnav</p>\n<p>子导航：subnav</p>\n<p>顶导航：topnav</p>\n<p>边导航：sidebar</p>\n<p>左导航：leftsidebar</p>\n<p>右导航：rightsidebar</p>\n<p>菜单：menu</p>\n<p>子菜单：submenu</p>\n<p>标题: title</p>\n<p>摘要: summary</p>\n<p>(3)功能</p>\n<p>标志：logo</p>\n<p>广告：banner</p>\n<p>登陆：login</p>\n<p>登录条：loginbar</p>\n<p>注册：register</p>\n<p>搜索：search</p>\n<p>功能区：shop</p>\n<p>标题：title</p>\n<p>加入：joinus</p>\n<p>状态：status</p>\n<p>按钮：btn</p>\n<p>滚动：scroll</p>\n<p>标籤页：tab</p>\n<p>文章列表：list</p>\n<p>提示信息：msg</p>\n<p>当前的: current</p>\n<p>小技巧：tips</p>\n<p>图标: icon</p>\n<p>注释：note</p>\n<p>指南：guild</p>\n<p>服务：service</p>\n<p>热点：hot</p>\n<p>新闻：news</p>\n<p>下载：download</p>\n<p>投票：vote</p>\n<p>合作伙伴：partner</p>\n<p>友情链接：link</p>\n<p>版权：copyright</p>\n"},{"title":"页面重载的几种方法","date":"2017-11-21T22:33:00.000Z","_content":"\n```js\nlocation.reload(true);\nhistory.go(0);\nlocation.reload();\nlocation = location;\nlocation.assign(location);\ndocument.execCommand(\"Refresh\");\nwindow.navigate(location);\nlocation.replace(location);\ndocument.URL = location.href;\n```\n","source":"_posts/2017-11-22-页面重载的几种方法.md","raw":"---\ntitle: 页面重载的几种方法\ntags:\n  - 技术\ndate: 2017-11-22 06:33:00\ncategories: 前端\n---\n\n```js\nlocation.reload(true);\nhistory.go(0);\nlocation.reload();\nlocation = location;\nlocation.assign(location);\ndocument.execCommand(\"Refresh\");\nwindow.navigate(location);\nlocation.replace(location);\ndocument.URL = location.href;\n```\n","slug":"2017-11-22-页面重载的几种方法","published":1,"updated":"2020-03-14T06:49:10.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvkj001o4k8yfl2c9b8r","content":"<pre class=\" language-js\"><code class=\"language-js\">location<span class=\"token punctuation\">.</span><span class=\"token function\">reload</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nhistory<span class=\"token punctuation\">.</span><span class=\"token function\">go</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlocation<span class=\"token punctuation\">.</span><span class=\"token function\">reload</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlocation <span class=\"token operator\">=</span> location<span class=\"token punctuation\">;</span>\nlocation<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ndocument<span class=\"token punctuation\">.</span><span class=\"token function\">execCommand</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Refresh\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nwindow<span class=\"token punctuation\">.</span><span class=\"token function\">navigate</span><span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlocation<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span>location<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ndocument<span class=\"token punctuation\">.</span>URL <span class=\"token operator\">=</span> location<span class=\"token punctuation\">.</span>href<span class=\"token punctuation\">;</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<pre><code class=\"js\">location.reload(true);\nhistory.go(0);\nlocation.reload();\nlocation = location;\nlocation.assign(location);\ndocument.execCommand(&quot;Refresh&quot;);\nwindow.navigate(location);\nlocation.replace(location);\ndocument.URL = location.href;</code></pre>\n"},{"title":"nuxt踩过的坑","date":"2017-12-29T01:10:00.000Z","_content":"\n# nuxt.js 简单介绍\n\nnuxt 官网：[https://zh.nuxtjs.org/](https://zh.nuxtjs.org/)\n\n### 1、nuxt.js 的原理图：\n\n具体的原理介绍官网有详细的解释，欢迎移步官网，这里不再复述。\n\n### 2、nuxt.js 的优势\n\n1）就是我们无需为了路由划分而烦恼，你只需要按照对应的文件夹层级创建 .vue 文件就行\n\n2）无需考虑数据传输问题，nuxt 会在模板输出之前异步请求数据（需要引入 axios 库），而且对 vuex 有进一步的封装\n\n3）内置了 webpack，省去了配置 webpack 的步骤，nuxt 会根据配置打包对应的文件\n\n# 技术栈选型\n\n\"axios\": \"^0.17.1\",\n\n\"css-loader\": \"^0.28.7\",\n\n\"element-ui\": \"^2.0.7\",\n\n\"moment\": \"^2.20.0\",\n\n\"nuxt\": \"^1.0.0-rc11\",\n\n\"postcss-loader\": \"^2.0.9\",\n\n\"sass-resources-loader\": \"^1.3.1\",\n\n\"scss\": \"^0.2.4\",\n\n\"style-loader\": \"^0.19.0\",\n\n\"vue\": \"2.5.9\",\n\n\"vue-server-renderer\": \"2.5.9\",\n\n\"vue-template-compiler\": \"2.5.9\"\n\n# 实施方案\n\n使用 vue 插件 - elementUI\n\n1.  首先我们需要在 plugins 文件夹中添加插件文件，element-ui.js\n\n2.  在 nuxt.config.js 中配置 plugins 字段\n\n3.  由于 elementUI 是第三方库，我们需要把它打包到库文件里面以获得更好的缓存效果。在 nuxt.config.js 中配置 element-ui 即可。\n4.  同时 nuxt 还支持区分只在浏览器中运行和只在服务端运行的插件。\n\n1)  只在浏览器运行：配置 nuxt.config.js 中 plugins 字段，将引入的插件属性设置为 ssr： false\n\n2)  只在服务端运行：直接在 webpack 打包 server.bundle.js 文件中，将 process.SERVER_BUILD 设置为 true 即可 layout 布局\n\n# layout 布局\n\nnuxt.js 实现了一个新的概念，layout 布局，我们可以通过 layout 布局方便的实现页面的多个布局之间方便的切换。本项目中实现了三种常用的布局，即：1）两栏布局，左栏固定，右栏动态宽度；2、错误页提示，页面中间一个提示框的布局方案；3、纯白页面布局。\n\n结合 elementUI 可以进行快速布局\n\n# 页面路由\n\nnuxt 框架的页面路由使用了 vue-router，但是我们不需要对页面的路由进行过多的操心，因为我们只要按照 nuxt 规范的页面文件目录结构进行设计，就可以自动生成 vue-router 文件。或者说我们存放页面的目录结构会直接影响最终生成的路由配置。\n\n# 总结\n\n也是正因为这点导致小白上手快，开发难度降低了一个等级，而这对需求大的功能构成 l 挑战，因为此框架面世比较早，早期从而导致奇妙的错误，官方文档已经警告过你了，线下试试还可以，如果运用生产环境就惨很多。要填各种坑。路由跳转问题，路由传参，\n\n滚动条问题，vue-router 存在各种问题而且没有一个统一的 main 入口，只能在配置里面运用，总之是不大推荐生产的。\n","source":"_posts/2017-12-29-nuxt踩过的坑.md","raw":"---\ntitle: nuxt踩过的坑\ntags:\n  - 技术\n  - vue\ndate: 2017-12-29 09:10:00\ncategories: 前端\n---\n\n# nuxt.js 简单介绍\n\nnuxt 官网：[https://zh.nuxtjs.org/](https://zh.nuxtjs.org/)\n\n### 1、nuxt.js 的原理图：\n\n具体的原理介绍官网有详细的解释，欢迎移步官网，这里不再复述。\n\n### 2、nuxt.js 的优势\n\n1）就是我们无需为了路由划分而烦恼，你只需要按照对应的文件夹层级创建 .vue 文件就行\n\n2）无需考虑数据传输问题，nuxt 会在模板输出之前异步请求数据（需要引入 axios 库），而且对 vuex 有进一步的封装\n\n3）内置了 webpack，省去了配置 webpack 的步骤，nuxt 会根据配置打包对应的文件\n\n# 技术栈选型\n\n\"axios\": \"^0.17.1\",\n\n\"css-loader\": \"^0.28.7\",\n\n\"element-ui\": \"^2.0.7\",\n\n\"moment\": \"^2.20.0\",\n\n\"nuxt\": \"^1.0.0-rc11\",\n\n\"postcss-loader\": \"^2.0.9\",\n\n\"sass-resources-loader\": \"^1.3.1\",\n\n\"scss\": \"^0.2.4\",\n\n\"style-loader\": \"^0.19.0\",\n\n\"vue\": \"2.5.9\",\n\n\"vue-server-renderer\": \"2.5.9\",\n\n\"vue-template-compiler\": \"2.5.9\"\n\n# 实施方案\n\n使用 vue 插件 - elementUI\n\n1.  首先我们需要在 plugins 文件夹中添加插件文件，element-ui.js\n\n2.  在 nuxt.config.js 中配置 plugins 字段\n\n3.  由于 elementUI 是第三方库，我们需要把它打包到库文件里面以获得更好的缓存效果。在 nuxt.config.js 中配置 element-ui 即可。\n4.  同时 nuxt 还支持区分只在浏览器中运行和只在服务端运行的插件。\n\n1)  只在浏览器运行：配置 nuxt.config.js 中 plugins 字段，将引入的插件属性设置为 ssr： false\n\n2)  只在服务端运行：直接在 webpack 打包 server.bundle.js 文件中，将 process.SERVER_BUILD 设置为 true 即可 layout 布局\n\n# layout 布局\n\nnuxt.js 实现了一个新的概念，layout 布局，我们可以通过 layout 布局方便的实现页面的多个布局之间方便的切换。本项目中实现了三种常用的布局，即：1）两栏布局，左栏固定，右栏动态宽度；2、错误页提示，页面中间一个提示框的布局方案；3、纯白页面布局。\n\n结合 elementUI 可以进行快速布局\n\n# 页面路由\n\nnuxt 框架的页面路由使用了 vue-router，但是我们不需要对页面的路由进行过多的操心，因为我们只要按照 nuxt 规范的页面文件目录结构进行设计，就可以自动生成 vue-router 文件。或者说我们存放页面的目录结构会直接影响最终生成的路由配置。\n\n# 总结\n\n也是正因为这点导致小白上手快，开发难度降低了一个等级，而这对需求大的功能构成 l 挑战，因为此框架面世比较早，早期从而导致奇妙的错误，官方文档已经警告过你了，线下试试还可以，如果运用生产环境就惨很多。要填各种坑。路由跳转问题，路由传参，\n\n滚动条问题，vue-router 存在各种问题而且没有一个统一的 main 入口，只能在配置里面运用，总之是不大推荐生产的。\n","slug":"2017-12-29-nuxt踩过的坑","published":1,"updated":"2020-03-14T06:49:36.213Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvkl001s4k8y5juj8i1g","content":"<h1 id=\"nuxt-js-简单介绍\"><a href=\"#nuxt-js-简单介绍\" class=\"headerlink\" title=\"nuxt.js 简单介绍\"></a>nuxt.js 简单介绍</h1><p>nuxt 官网：<a href=\"https://zh.nuxtjs.org/\" target=\"_blank\" rel=\"noopener\">https://zh.nuxtjs.org/</a></p>\n<h3 id=\"1、nuxt-js-的原理图：\"><a href=\"#1、nuxt-js-的原理图：\" class=\"headerlink\" title=\"1、nuxt.js 的原理图：\"></a>1、nuxt.js 的原理图：</h3><p>具体的原理介绍官网有详细的解释，欢迎移步官网，这里不再复述。</p>\n<h3 id=\"2、nuxt-js-的优势\"><a href=\"#2、nuxt-js-的优势\" class=\"headerlink\" title=\"2、nuxt.js 的优势\"></a>2、nuxt.js 的优势</h3><p>1）就是我们无需为了路由划分而烦恼，你只需要按照对应的文件夹层级创建 .vue 文件就行</p>\n<p>2）无需考虑数据传输问题，nuxt 会在模板输出之前异步请求数据（需要引入 axios 库），而且对 vuex 有进一步的封装</p>\n<p>3）内置了 webpack，省去了配置 webpack 的步骤，nuxt 会根据配置打包对应的文件</p>\n<h1 id=\"技术栈选型\"><a href=\"#技术栈选型\" class=\"headerlink\" title=\"技术栈选型\"></a>技术栈选型</h1><p>“axios”: “^0.17.1”,</p>\n<p>“css-loader”: “^0.28.7”,</p>\n<p>“element-ui”: “^2.0.7”,</p>\n<p>“moment”: “^2.20.0”,</p>\n<p>“nuxt”: “^1.0.0-rc11”,</p>\n<p>“postcss-loader”: “^2.0.9”,</p>\n<p>“sass-resources-loader”: “^1.3.1”,</p>\n<p>“scss”: “^0.2.4”,</p>\n<p>“style-loader”: “^0.19.0”,</p>\n<p>“vue”: “2.5.9”,</p>\n<p>“vue-server-renderer”: “2.5.9”,</p>\n<p>“vue-template-compiler”: “2.5.9”</p>\n<h1 id=\"实施方案\"><a href=\"#实施方案\" class=\"headerlink\" title=\"实施方案\"></a>实施方案</h1><p>使用 vue 插件 - elementUI</p>\n<ol>\n<li><p>首先我们需要在 plugins 文件夹中添加插件文件，element-ui.js</p>\n</li>\n<li><p>在 nuxt.config.js 中配置 plugins 字段</p>\n</li>\n<li><p>由于 elementUI 是第三方库，我们需要把它打包到库文件里面以获得更好的缓存效果。在 nuxt.config.js 中配置 element-ui 即可。</p>\n</li>\n<li><p>同时 nuxt 还支持区分只在浏览器中运行和只在服务端运行的插件。</p>\n</li>\n</ol>\n<p>1)  只在浏览器运行：配置 nuxt.config.js 中 plugins 字段，将引入的插件属性设置为 ssr： false</p>\n<p>2)  只在服务端运行：直接在 webpack 打包 server.bundle.js 文件中，将 process.SERVER_BUILD 设置为 true 即可 layout 布局</p>\n<h1 id=\"layout-布局\"><a href=\"#layout-布局\" class=\"headerlink\" title=\"layout 布局\"></a>layout 布局</h1><p>nuxt.js 实现了一个新的概念，layout 布局，我们可以通过 layout 布局方便的实现页面的多个布局之间方便的切换。本项目中实现了三种常用的布局，即：1）两栏布局，左栏固定，右栏动态宽度；2、错误页提示，页面中间一个提示框的布局方案；3、纯白页面布局。</p>\n<p>结合 elementUI 可以进行快速布局</p>\n<h1 id=\"页面路由\"><a href=\"#页面路由\" class=\"headerlink\" title=\"页面路由\"></a>页面路由</h1><p>nuxt 框架的页面路由使用了 vue-router，但是我们不需要对页面的路由进行过多的操心，因为我们只要按照 nuxt 规范的页面文件目录结构进行设计，就可以自动生成 vue-router 文件。或者说我们存放页面的目录结构会直接影响最终生成的路由配置。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>也是正因为这点导致小白上手快，开发难度降低了一个等级，而这对需求大的功能构成 l 挑战，因为此框架面世比较早，早期从而导致奇妙的错误，官方文档已经警告过你了，线下试试还可以，如果运用生产环境就惨很多。要填各种坑。路由跳转问题，路由传参，</p>\n<p>滚动条问题，vue-router 存在各种问题而且没有一个统一的 main 入口，只能在配置里面运用，总之是不大推荐生产的。</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h1 id=\"nuxt-js-简单介绍\"><a href=\"#nuxt-js-简单介绍\" class=\"headerlink\" title=\"nuxt.js 简单介绍\"></a>nuxt.js 简单介绍</h1><p>nuxt 官网：<a href=\"https://zh.nuxtjs.org/\" target=\"_blank\" rel=\"noopener\">https://zh.nuxtjs.org/</a></p>\n<h3 id=\"1、nuxt-js-的原理图：\"><a href=\"#1、nuxt-js-的原理图：\" class=\"headerlink\" title=\"1、nuxt.js 的原理图：\"></a>1、nuxt.js 的原理图：</h3><p>具体的原理介绍官网有详细的解释，欢迎移步官网，这里不再复述。</p>\n<h3 id=\"2、nuxt-js-的优势\"><a href=\"#2、nuxt-js-的优势\" class=\"headerlink\" title=\"2、nuxt.js 的优势\"></a>2、nuxt.js 的优势</h3><p>1）就是我们无需为了路由划分而烦恼，你只需要按照对应的文件夹层级创建 .vue 文件就行</p>\n<p>2）无需考虑数据传输问题，nuxt 会在模板输出之前异步请求数据（需要引入 axios 库），而且对 vuex 有进一步的封装</p>\n<p>3）内置了 webpack，省去了配置 webpack 的步骤，nuxt 会根据配置打包对应的文件</p>\n<h1 id=\"技术栈选型\"><a href=\"#技术栈选型\" class=\"headerlink\" title=\"技术栈选型\"></a>技术栈选型</h1><p>“axios”: “^0.17.1”,</p>\n<p>“css-loader”: “^0.28.7”,</p>\n<p>“element-ui”: “^2.0.7”,</p>\n<p>“moment”: “^2.20.0”,</p>\n<p>“nuxt”: “^1.0.0-rc11”,</p>\n<p>“postcss-loader”: “^2.0.9”,</p>\n<p>“sass-resources-loader”: “^1.3.1”,</p>\n<p>“scss”: “^0.2.4”,</p>\n<p>“style-loader”: “^0.19.0”,</p>\n<p>“vue”: “2.5.9”,</p>\n<p>“vue-server-renderer”: “2.5.9”,</p>\n<p>“vue-template-compiler”: “2.5.9”</p>\n<h1 id=\"实施方案\"><a href=\"#实施方案\" class=\"headerlink\" title=\"实施方案\"></a>实施方案</h1><p>使用 vue 插件 - elementUI</p>\n<ol>\n<li><p>首先我们需要在 plugins 文件夹中添加插件文件，element-ui.js</p>\n</li>\n<li><p>在 nuxt.config.js 中配置 plugins 字段</p>\n</li>\n<li><p>由于 elementUI 是第三方库，我们需要把它打包到库文件里面以获得更好的缓存效果。在 nuxt.config.js 中配置 element-ui 即可。</p>\n</li>\n<li><p>同时 nuxt 还支持区分只在浏览器中运行和只在服务端运行的插件。</p>\n</li>\n</ol>\n<p>1)  只在浏览器运行：配置 nuxt.config.js 中 plugins 字段，将引入的插件属性设置为 ssr： false</p>\n<p>2)  只在服务端运行：直接在 webpack 打包 server.bundle.js 文件中，将 process.SERVER_BUILD 设置为 true 即可 layout 布局</p>\n<h1 id=\"layout-布局\"><a href=\"#layout-布局\" class=\"headerlink\" title=\"layout 布局\"></a>layout 布局</h1><p>nuxt.js 实现了一个新的概念，layout 布局，我们可以通过 layout 布局方便的实现页面的多个布局之间方便的切换。本项目中实现了三种常用的布局，即：1）两栏布局，左栏固定，右栏动态宽度；2、错误页提示，页面中间一个提示框的布局方案；3、纯白页面布局。</p>\n<p>结合 elementUI 可以进行快速布局</p>\n<h1 id=\"页面路由\"><a href=\"#页面路由\" class=\"headerlink\" title=\"页面路由\"></a>页面路由</h1><p>nuxt 框架的页面路由使用了 vue-router，但是我们不需要对页面的路由进行过多的操心，因为我们只要按照 nuxt 规范的页面文件目录结构进行设计，就可以自动生成 vue-router 文件。或者说我们存放页面的目录结构会直接影响最终生成的路由配置。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>也是正因为这点导致小白上手快，开发难度降低了一个等级，而这对需求大的功能构成 l 挑战，因为此框架面世比较早，早期从而导致奇妙的错误，官方文档已经警告过你了，线下试试还可以，如果运用生产环境就惨很多。要填各种坑。路由跳转问题，路由传参，</p>\n<p>滚动条问题，vue-router 存在各种问题而且没有一个统一的 main 入口，只能在配置里面运用，总之是不大推荐生产的。</p>\n"},{"title":"下载谷歌浏览器(Chrome)扩展crx文件最简单的方法～","date":"2018-01-24T17:55:00.000Z","_content":"\n**下载谷歌浏览器(Chrome)扩展 crx 文件最简单的方法**\n\n先找到扩展的 id,进入[http://yurl.sinaapp.com/crx.php](http://yurl.sinaapp.com/crx.php)**粘贴扩展 ID，点击生成按钮**。\n\n[Chrome 商店 Crx 离线安装包下载](http://yurl.sinaapp.com/crx.php \"CRX下载\")\n\n第一步：输入应用 ID\n\n第二步：[在这里右键另存为](https://clients2.google.com/service/update2/crx?response=redirect&x=id%3D219.246.61.64%26uc \"右键》连接另存为》保存\")  即可下载\n\n© Alyzq 　[使用说明](http://alyzq.com/?p=627#step \"不会用？点这里\")\n\n如果不会使用，请看下面的操作步骤：\n\n![](http://img.blog.csdn.net/20140407195940046)\n\n**引言**：\n\n下面介绍一下，下载谷歌浏览器(Google Chrome)扩展的离线安装包 crx 文件最简单的方法！真的是再简单不过了！  \n　　[谷歌浏览器](http://www.google.com/chrome)(Google Chrome)的扩展功能让谷歌浏览器变的无比强大，需要特殊功能的时候去[Chrome Web Store](https://chrome.google.com/webstore)找一下，基本都可以找到合适的扩展。但是随着 Chrome 浏览器使用的时间越来越长，积累下来的扩展也越来越多，备份这些扩展就成了一个新的问题。  \n　　比如出于由于某些众所周知的原因，在给 MM(或朋友、爸妈等)装机的时候可能上不去扩展安装页面。有时候一个一个安装、同步又显得比较耗时。当然还有很多其他的原因。  \n　　那么我们如果提前将扩展下载好放在 U 盘里，那样在需要的时候安全快捷的安装上。  \n　　在 Chrome Web Store 里面点击安装以后，扩展默认是下载完毕后立即删除，不给你时间保存安装包，要保存扩展就成了一个难题，以下提供一个保存扩展的简便方法！\n\n**操作步骤**：\n\n1.**打开扩展管理页面**(在三道杠图标>工具>扩展程序里相应扩展的\"访问网站\"处也可以获得)，比如：\"https://chrome.google.com/webstore/detail/gighmmpiobklfepjocnamgkkbiglidom\"\n\n2.**复制扩展 ID**(扩展地址里面的那个 32 位的字符串，比如第一步地址里面 ↑ 红颜色 ↑ 的那部分)\n\n3.进入  [http://yurl.sinaapp.com/crx.php](http://yurl.sinaapp.com/crx.php) ([http://cooal.cn/crx.php](http://cooal.cn/crx.php)**之前失效了，已恢复！**) **粘贴扩展 ID，点击生成按钮**。\n\n当然使用**这个也行**的：[http://chrome-extension-downloader.com/](http://chrome-extension-downloader.com/)\n\n[http://crx.zhuzhu.org/](http://crx.zhuzhu.org/)\n\n4.**右键另存为**下面那行暗红色连接即可(不要直接点击，防止谷歌浏览器直接安装)。\n\n怎么样，很简单吧？\n\n附上**安装离线.crx 扩展包**的方法：\n\n等到以后重装系统或者其他原因，需要重新安装扩展时，在谷歌浏览器中**打开扩展管理页面**，然后直接把那个后缀是.crx 的扩展安装包**拖拽到扩展管理页面**的**中间部位**里就可以了。\n\n[附谷歌服务插件\\[插件\\]](https://files.cnblogs.com/files/xkloveme/%E8%B0%B7%E6%AD%8C%E4%B8%8A%E7%BD%91%E6%9C%8D%E5%8A%A1.zip)\n\nhttps://files.cnblogs.com/files/xkloveme/%E8%B0%B7%E6%AD%8C%E4%B8%8A%E7%BD%91%E6%9C%8D%E5%8A%A1.zip\n","source":"_posts/2018-01-25-(Chrome)扩展crx文件.md","raw":"---\ntitle: 下载谷歌浏览器(Chrome)扩展crx文件最简单的方法～\ntags:\n  - 工具\ndate: 2018-01-25 01:55:00\ncategories: 教程\n---\n\n**下载谷歌浏览器(Chrome)扩展 crx 文件最简单的方法**\n\n先找到扩展的 id,进入[http://yurl.sinaapp.com/crx.php](http://yurl.sinaapp.com/crx.php)**粘贴扩展 ID，点击生成按钮**。\n\n[Chrome 商店 Crx 离线安装包下载](http://yurl.sinaapp.com/crx.php \"CRX下载\")\n\n第一步：输入应用 ID\n\n第二步：[在这里右键另存为](https://clients2.google.com/service/update2/crx?response=redirect&x=id%3D219.246.61.64%26uc \"右键》连接另存为》保存\")  即可下载\n\n© Alyzq 　[使用说明](http://alyzq.com/?p=627#step \"不会用？点这里\")\n\n如果不会使用，请看下面的操作步骤：\n\n![](http://img.blog.csdn.net/20140407195940046)\n\n**引言**：\n\n下面介绍一下，下载谷歌浏览器(Google Chrome)扩展的离线安装包 crx 文件最简单的方法！真的是再简单不过了！  \n　　[谷歌浏览器](http://www.google.com/chrome)(Google Chrome)的扩展功能让谷歌浏览器变的无比强大，需要特殊功能的时候去[Chrome Web Store](https://chrome.google.com/webstore)找一下，基本都可以找到合适的扩展。但是随着 Chrome 浏览器使用的时间越来越长，积累下来的扩展也越来越多，备份这些扩展就成了一个新的问题。  \n　　比如出于由于某些众所周知的原因，在给 MM(或朋友、爸妈等)装机的时候可能上不去扩展安装页面。有时候一个一个安装、同步又显得比较耗时。当然还有很多其他的原因。  \n　　那么我们如果提前将扩展下载好放在 U 盘里，那样在需要的时候安全快捷的安装上。  \n　　在 Chrome Web Store 里面点击安装以后，扩展默认是下载完毕后立即删除，不给你时间保存安装包，要保存扩展就成了一个难题，以下提供一个保存扩展的简便方法！\n\n**操作步骤**：\n\n1.**打开扩展管理页面**(在三道杠图标>工具>扩展程序里相应扩展的\"访问网站\"处也可以获得)，比如：\"https://chrome.google.com/webstore/detail/gighmmpiobklfepjocnamgkkbiglidom\"\n\n2.**复制扩展 ID**(扩展地址里面的那个 32 位的字符串，比如第一步地址里面 ↑ 红颜色 ↑ 的那部分)\n\n3.进入  [http://yurl.sinaapp.com/crx.php](http://yurl.sinaapp.com/crx.php) ([http://cooal.cn/crx.php](http://cooal.cn/crx.php)**之前失效了，已恢复！**) **粘贴扩展 ID，点击生成按钮**。\n\n当然使用**这个也行**的：[http://chrome-extension-downloader.com/](http://chrome-extension-downloader.com/)\n\n[http://crx.zhuzhu.org/](http://crx.zhuzhu.org/)\n\n4.**右键另存为**下面那行暗红色连接即可(不要直接点击，防止谷歌浏览器直接安装)。\n\n怎么样，很简单吧？\n\n附上**安装离线.crx 扩展包**的方法：\n\n等到以后重装系统或者其他原因，需要重新安装扩展时，在谷歌浏览器中**打开扩展管理页面**，然后直接把那个后缀是.crx 的扩展安装包**拖拽到扩展管理页面**的**中间部位**里就可以了。\n\n[附谷歌服务插件\\[插件\\]](https://files.cnblogs.com/files/xkloveme/%E8%B0%B7%E6%AD%8C%E4%B8%8A%E7%BD%91%E6%9C%8D%E5%8A%A1.zip)\n\nhttps://files.cnblogs.com/files/xkloveme/%E8%B0%B7%E6%AD%8C%E4%B8%8A%E7%BD%91%E6%9C%8D%E5%8A%A1.zip\n","slug":"2018-01-25-(Chrome)扩展crx文件","published":1,"updated":"2020-03-14T06:49:51.368Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvku001v4k8y6v85g6e7","content":"<p><strong>下载谷歌浏览器(Chrome)扩展 crx 文件最简单的方法</strong></p>\n<p>先找到扩展的 id,进入<a href=\"http://yurl.sinaapp.com/crx.php\" target=\"_blank\" rel=\"noopener\">http://yurl.sinaapp.com/crx.php</a><strong>粘贴扩展 ID，点击生成按钮</strong>。</p>\n<p><a href=\"http://yurl.sinaapp.com/crx.php\" target=\"_blank\" rel=\"noopener\" title=\"CRX下载\">Chrome 商店 Crx 离线安装包下载</a></p>\n<p>第一步：输入应用 ID</p>\n<p>第二步：<a href=\"https://clients2.google.com/service/update2/crx?response=redirect&x=id%3D219.246.61.64%26uc\" target=\"_blank\" rel=\"noopener\" title=\"右键》连接另存为》保存\">在这里右键另存为</a>  即可下载</p>\n<p>© Alyzq 　<a href=\"http://alyzq.com/?p=627#step\" target=\"_blank\" rel=\"noopener\" title=\"不会用？点这里\">使用说明</a></p>\n<p>如果不会使用，请看下面的操作步骤：</p>\n<p><img src=\"http://img.blog.csdn.net/20140407195940046\" alt=\"\"></p>\n<p><strong>引言</strong>：</p>\n<p>下面介绍一下，下载谷歌浏览器(Google Chrome)扩展的离线安装包 crx 文件最简单的方法！真的是再简单不过了！<br>　　<a href=\"http://www.google.com/chrome\" target=\"_blank\" rel=\"noopener\">谷歌浏览器</a>(Google Chrome)的扩展功能让谷歌浏览器变的无比强大，需要特殊功能的时候去<a href=\"https://chrome.google.com/webstore\" target=\"_blank\" rel=\"noopener\">Chrome Web Store</a>找一下，基本都可以找到合适的扩展。但是随着 Chrome 浏览器使用的时间越来越长，积累下来的扩展也越来越多，备份这些扩展就成了一个新的问题。<br>　　比如出于由于某些众所周知的原因，在给 MM(或朋友、爸妈等)装机的时候可能上不去扩展安装页面。有时候一个一个安装、同步又显得比较耗时。当然还有很多其他的原因。<br>　　那么我们如果提前将扩展下载好放在 U 盘里，那样在需要的时候安全快捷的安装上。<br>　　在 Chrome Web Store 里面点击安装以后，扩展默认是下载完毕后立即删除，不给你时间保存安装包，要保存扩展就成了一个难题，以下提供一个保存扩展的简便方法！</p>\n<p><strong>操作步骤</strong>：</p>\n<p>1.<strong>打开扩展管理页面</strong>(在三道杠图标&gt;工具&gt;扩展程序里相应扩展的”访问网站”处也可以获得)，比如：”<a href=\"https://chrome.google.com/webstore/detail/gighmmpiobklfepjocnamgkkbiglidom&quot;\" target=\"_blank\" rel=\"noopener\">https://chrome.google.com/webstore/detail/gighmmpiobklfepjocnamgkkbiglidom&quot;</a></p>\n<p>2.<strong>复制扩展 ID</strong>(扩展地址里面的那个 32 位的字符串，比如第一步地址里面 ↑ 红颜色 ↑ 的那部分)</p>\n<p>3.进入  <a href=\"http://yurl.sinaapp.com/crx.php\" target=\"_blank\" rel=\"noopener\">http://yurl.sinaapp.com/crx.php</a> (<a href=\"http://cooal.cn/crx.php\" target=\"_blank\" rel=\"noopener\">http://cooal.cn/crx.php</a><strong>之前失效了，已恢复！</strong>) <strong>粘贴扩展 ID，点击生成按钮</strong>。</p>\n<p>当然使用<strong>这个也行</strong>的：<a href=\"http://chrome-extension-downloader.com/\" target=\"_blank\" rel=\"noopener\">http://chrome-extension-downloader.com/</a></p>\n<p><a href=\"http://crx.zhuzhu.org/\" target=\"_blank\" rel=\"noopener\">http://crx.zhuzhu.org/</a></p>\n<p>4.<strong>右键另存为</strong>下面那行暗红色连接即可(不要直接点击，防止谷歌浏览器直接安装)。</p>\n<p>怎么样，很简单吧？</p>\n<p>附上<strong>安装离线.crx 扩展包</strong>的方法：</p>\n<p>等到以后重装系统或者其他原因，需要重新安装扩展时，在谷歌浏览器中<strong>打开扩展管理页面</strong>，然后直接把那个后缀是.crx 的扩展安装包<strong>拖拽到扩展管理页面</strong>的<strong>中间部位</strong>里就可以了。</p>\n<p><a href=\"https://files.cnblogs.com/files/xkloveme/%E8%B0%B7%E6%AD%8C%E4%B8%8A%E7%BD%91%E6%9C%8D%E5%8A%A1.zip\" target=\"_blank\" rel=\"noopener\">附谷歌服务插件[插件]</a></p>\n<p><a href=\"https://files.cnblogs.com/files/xkloveme/%E8%B0%B7%E6%AD%8C%E4%B8%8A%E7%BD%91%E6%9C%8D%E5%8A%A1.zip\" target=\"_blank\" rel=\"noopener\">https://files.cnblogs.com/files/xkloveme/%E8%B0%B7%E6%AD%8C%E4%B8%8A%E7%BD%91%E6%9C%8D%E5%8A%A1.zip</a></p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p><strong>下载谷歌浏览器(Chrome)扩展 crx 文件最简单的方法</strong></p>\n<p>先找到扩展的 id,进入<a href=\"http://yurl.sinaapp.com/crx.php\" target=\"_blank\" rel=\"noopener\">http://yurl.sinaapp.com/crx.php</a><strong>粘贴扩展 ID，点击生成按钮</strong>。</p>\n<p><a href=\"http://yurl.sinaapp.com/crx.php\" target=\"_blank\" rel=\"noopener\" title=\"CRX下载\">Chrome 商店 Crx 离线安装包下载</a></p>\n<p>第一步：输入应用 ID</p>\n<p>第二步：<a href=\"https://clients2.google.com/service/update2/crx?response=redirect&x=id%3D219.246.61.64%26uc\" target=\"_blank\" rel=\"noopener\" title=\"右键》连接另存为》保存\">在这里右键另存为</a>  即可下载</p>\n<p>© Alyzq 　<a href=\"http://alyzq.com/?p=627#step\" target=\"_blank\" rel=\"noopener\" title=\"不会用？点这里\">使用说明</a></p>\n<p>如果不会使用，请看下面的操作步骤：</p>\n<p><img src=\"http://img.blog.csdn.net/20140407195940046\" alt=\"\"></p>\n<p><strong>引言</strong>：</p>\n<p>下面介绍一下，下载谷歌浏览器(Google Chrome)扩展的离线安装包 crx 文件最简单的方法！真的是再简单不过了！<br>　　<a href=\"http://www.google.com/chrome\" target=\"_blank\" rel=\"noopener\">谷歌浏览器</a>(Google Chrome)的扩展功能让谷歌浏览器变的无比强大，需要特殊功能的时候去<a href=\"https://chrome.google.com/webstore\" target=\"_blank\" rel=\"noopener\">Chrome Web Store</a>找一下，基本都可以找到合适的扩展。但是随着 Chrome 浏览器使用的时间越来越长，积累下来的扩展也越来越多，备份这些扩展就成了一个新的问题。<br>　　比如出于由于某些众所周知的原因，在给 MM(或朋友、爸妈等)装机的时候可能上不去扩展安装页面。有时候一个一个安装、同步又显得比较耗时。当然还有很多其他的原因。<br>　　那么我们如果提前将扩展下载好放在 U 盘里，那样在需要的时候安全快捷的安装上。<br>　　在 Chrome Web Store 里面点击安装以后，扩展默认是下载完毕后立即删除，不给你时间保存安装包，要保存扩展就成了一个难题，以下提供一个保存扩展的简便方法！</p>\n<p><strong>操作步骤</strong>：</p>\n<p>1.<strong>打开扩展管理页面</strong>(在三道杠图标&gt;工具&gt;扩展程序里相应扩展的”访问网站”处也可以获得)，比如：”<a href=\"https://chrome.google.com/webstore/detail/gighmmpiobklfepjocnamgkkbiglidom&quot;\" target=\"_blank\" rel=\"noopener\">https://chrome.google.com/webstore/detail/gighmmpiobklfepjocnamgkkbiglidom&quot;</a></p>\n<p>2.<strong>复制扩展 ID</strong>(扩展地址里面的那个 32 位的字符串，比如第一步地址里面 ↑ 红颜色 ↑ 的那部分)</p>\n<p>3.进入  <a href=\"http://yurl.sinaapp.com/crx.php\" target=\"_blank\" rel=\"noopener\">http://yurl.sinaapp.com/crx.php</a> (<a href=\"http://cooal.cn/crx.php\" target=\"_blank\" rel=\"noopener\">http://cooal.cn/crx.php</a><strong>之前失效了，已恢复！</strong>) <strong>粘贴扩展 ID，点击生成按钮</strong>。</p>\n<p>当然使用<strong>这个也行</strong>的：<a href=\"http://chrome-extension-downloader.com/\" target=\"_blank\" rel=\"noopener\">http://chrome-extension-downloader.com/</a></p>\n<p><a href=\"http://crx.zhuzhu.org/\" target=\"_blank\" rel=\"noopener\">http://crx.zhuzhu.org/</a></p>\n<p>4.<strong>右键另存为</strong>下面那行暗红色连接即可(不要直接点击，防止谷歌浏览器直接安装)。</p>\n<p>怎么样，很简单吧？</p>\n<p>附上<strong>安装离线.crx 扩展包</strong>的方法：</p>\n<p>等到以后重装系统或者其他原因，需要重新安装扩展时，在谷歌浏览器中<strong>打开扩展管理页面</strong>，然后直接把那个后缀是.crx 的扩展安装包<strong>拖拽到扩展管理页面</strong>的<strong>中间部位</strong>里就可以了。</p>\n<p><a href=\"https://files.cnblogs.com/files/xkloveme/%E8%B0%B7%E6%AD%8C%E4%B8%8A%E7%BD%91%E6%9C%8D%E5%8A%A1.zip\" target=\"_blank\" rel=\"noopener\">附谷歌服务插件[插件]</a></p>\n<p><a href=\"https://files.cnblogs.com/files/xkloveme/%E8%B0%B7%E6%AD%8C%E4%B8%8A%E7%BD%91%E6%9C%8D%E5%8A%A1.zip\" target=\"_blank\" rel=\"noopener\">https://files.cnblogs.com/files/xkloveme/%E8%B0%B7%E6%AD%8C%E4%B8%8A%E7%BD%91%E6%9C%8D%E5%8A%A1.zip</a></p>\n"},{"title":"在 Google platform 上架設 ShadowSocks(SS) + BBR","date":"2018-02-08T23:06:00.000Z","_content":"\n### 建立 VPS\n\nGoogle cloud platform 有免費 12 個月 300USD 的額度可以使用\n\n- 註冊  [Google Clund Platform](https://cloud.google.com/)  服務\n- 點擊左上角三條線漢堡，下拉選單到 「Compute Engine」 -> 「VM 執行個體」\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/ny3aKkXQTOOwP59kDLEB_E89EA2E5B995E5BFABE785A7202017-08-1220E4B88BE58D8811.54.09.png)\n\n- 點擊 「建立執行個體」\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/1W8aYkspRQas9QXMs6O9_E89EA2E5B995E5BFABE785A7202017-08-1220E4B88BE58D8811.57.59.png)\n\n**名稱**：自定義，這是你的機器名稱  \n**區域**：請選 asia-east1-c 或是 asia-northeast1-b (亞洲區)  \n**機器類型**：由於做個人翻牆工具，可以只選「微型」就好，規格選越高錢扣越快  \n**開機磁碟**：請選作業系統 Ubuntu 14.04 LTS  \n**防火牆**：將「允許 HTTP 流量」和「允許 HTTPS 流量」皆設為開啟\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/AR1NUHtmQvOzEatPQ0xA_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.04.53.png)\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/WOXE1PfhQYbUkCGIoQpG_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.06.21.png)\n\n建立後，用瀏覽器打開 SSH 並輸入以下指令\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/PxSfuiYNTxC9dNeJYPxc_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.11.45.png)\n\n每筆指令輸入後記得按 Enter\n\n### 先安裝 BBR 加速\n\nBBR 是  [Google 官方開源](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwj_he7Lj9LVAhVB2LwKHaLiAVEQFggnMAA&url=https%3A%2F%2Fgithub.com%2Fgoogle%2Fbbr&usg=AFQjCNGIK2TzybkL1laoWJd6BiRDTrRjOg)的擁塞算法來加速 TCP\n\n也因為裝這個要重開機，所以先裝 XD\n\n依序輸入\n\n`wget –no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh`\n\n`chmod +x bbr.sh`\n\n`sudo ./bbr.sh`\n\n輸入任意鍵執行\n\n過程會需要一些時間約三分鐘，最後他會問你要不要重啟機器（Do you want to reboot?）輸入  `y`  同意\n\n之後會斷開連線，請在重複之前打開這個視窗的動作「SSH」-> 「在瀏覽器視窗中開啟」\n\n輸入  `sysctl net.ipv4.tcp_available_congestion_control`\n\n如果有出現  `bbr`  字眼，就是安裝成功了\n\n### 安裝 ShadowSocks(SS)\n\n`sudo apt-get install python-pip -y`\n\n`sudo pip install shadowsocks`\n\n**重要！！！**  以下指令中的 password 請務必改成自己要使用的\n\n`sudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start`\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/wwtPB5QjSm27fQdEUkWF_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.16.43.png)\n\n將服務停止\n\n`sudo ssserver -d stop`\n\n再次運行\n\n`sudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start`\n\n大功告成，你已經有一台 SS + BBR 來做翻牆的機器了!\n\n機器詳細資訊\n\n- IP 位置是你架設機器在上面寫的「外部 IP」\n- 密碼是剛剛你自行替換的「password」\n- 加密規則是 aes-256-cfb\n- port 通道 443\n\n### 翻牆工具\n\n我這邊是用 Surge ，不管手機跟電腦都是，要付費就是了，聽說也有免費的可以用，這部份就在[另一篇教程: **在 iphone 上透過 Shadowsocks(SS) 在大陸翻牆**](http://blog.niclin.tw/posts/2163079-wall-on-the-iphone-via-shadowsocks-ss-in-the-city-over-the-wall)講吧！\n\n### 結果\n\n這是用 surge 跑 benchmark 出來的結果，圖中的 GoogleTest 是邊敲本文章邊隨著架設的機器，可以看出速度還 OK\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/1Bm6YgbTHqmQAyHUUzI1_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.51.41.png)\n\nYoutube 1080P Test\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/gJP7K5vCRi0V5ZJbmQiK_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.54.51.png)\n","source":"_posts/2018-02-09-架設 ShadowSocks(SS) + BBR.md","raw":"---\ntitle: 在 Google platform 上架設 ShadowSocks(SS) + BBR\ntags:\n  - 翻墙\ndate: 2018-02-09 07:06:00\ncategories: 教程\n---\n\n### 建立 VPS\n\nGoogle cloud platform 有免費 12 個月 300USD 的額度可以使用\n\n- 註冊  [Google Clund Platform](https://cloud.google.com/)  服務\n- 點擊左上角三條線漢堡，下拉選單到 「Compute Engine」 -> 「VM 執行個體」\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/ny3aKkXQTOOwP59kDLEB_E89EA2E5B995E5BFABE785A7202017-08-1220E4B88BE58D8811.54.09.png)\n\n- 點擊 「建立執行個體」\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/1W8aYkspRQas9QXMs6O9_E89EA2E5B995E5BFABE785A7202017-08-1220E4B88BE58D8811.57.59.png)\n\n**名稱**：自定義，這是你的機器名稱  \n**區域**：請選 asia-east1-c 或是 asia-northeast1-b (亞洲區)  \n**機器類型**：由於做個人翻牆工具，可以只選「微型」就好，規格選越高錢扣越快  \n**開機磁碟**：請選作業系統 Ubuntu 14.04 LTS  \n**防火牆**：將「允許 HTTP 流量」和「允許 HTTPS 流量」皆設為開啟\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/AR1NUHtmQvOzEatPQ0xA_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.04.53.png)\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/WOXE1PfhQYbUkCGIoQpG_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.06.21.png)\n\n建立後，用瀏覽器打開 SSH 並輸入以下指令\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/PxSfuiYNTxC9dNeJYPxc_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.11.45.png)\n\n每筆指令輸入後記得按 Enter\n\n### 先安裝 BBR 加速\n\nBBR 是  [Google 官方開源](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwj_he7Lj9LVAhVB2LwKHaLiAVEQFggnMAA&url=https%3A%2F%2Fgithub.com%2Fgoogle%2Fbbr&usg=AFQjCNGIK2TzybkL1laoWJd6BiRDTrRjOg)的擁塞算法來加速 TCP\n\n也因為裝這個要重開機，所以先裝 XD\n\n依序輸入\n\n`wget –no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh`\n\n`chmod +x bbr.sh`\n\n`sudo ./bbr.sh`\n\n輸入任意鍵執行\n\n過程會需要一些時間約三分鐘，最後他會問你要不要重啟機器（Do you want to reboot?）輸入  `y`  同意\n\n之後會斷開連線，請在重複之前打開這個視窗的動作「SSH」-> 「在瀏覽器視窗中開啟」\n\n輸入  `sysctl net.ipv4.tcp_available_congestion_control`\n\n如果有出現  `bbr`  字眼，就是安裝成功了\n\n### 安裝 ShadowSocks(SS)\n\n`sudo apt-get install python-pip -y`\n\n`sudo pip install shadowsocks`\n\n**重要！！！**  以下指令中的 password 請務必改成自己要使用的\n\n`sudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start`\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/wwtPB5QjSm27fQdEUkWF_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.16.43.png)\n\n將服務停止\n\n`sudo ssserver -d stop`\n\n再次運行\n\n`sudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start`\n\n大功告成，你已經有一台 SS + BBR 來做翻牆的機器了!\n\n機器詳細資訊\n\n- IP 位置是你架設機器在上面寫的「外部 IP」\n- 密碼是剛剛你自行替換的「password」\n- 加密規則是 aes-256-cfb\n- port 通道 443\n\n### 翻牆工具\n\n我這邊是用 Surge ，不管手機跟電腦都是，要付費就是了，聽說也有免費的可以用，這部份就在[另一篇教程: **在 iphone 上透過 Shadowsocks(SS) 在大陸翻牆**](http://blog.niclin.tw/posts/2163079-wall-on-the-iphone-via-shadowsocks-ss-in-the-city-over-the-wall)講吧！\n\n### 結果\n\n這是用 surge 跑 benchmark 出來的結果，圖中的 GoogleTest 是邊敲本文章邊隨著架設的機器，可以看出速度還 OK\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/1Bm6YgbTHqmQAyHUUzI1_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.51.41.png)\n\nYoutube 1080P Test\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/gJP7K5vCRi0V5ZJbmQiK_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.54.51.png)\n","slug":"2018-02-09-架設 ShadowSocks(SS) + BBR","published":1,"updated":"2020-03-14T06:50:08.352Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvkv001y4k8y0gyo53rn","content":"<h3 id=\"建立-VPS\"><a href=\"#建立-VPS\" class=\"headerlink\" title=\"建立 VPS\"></a>建立 VPS</h3><p>Google cloud platform 有免費 12 個月 300USD 的額度可以使用</p>\n<ul>\n<li>註冊  <a href=\"https://cloud.google.com/\" target=\"_blank\" rel=\"noopener\">Google Clund Platform</a>  服務</li>\n<li>點擊左上角三條線漢堡，下拉選單到 「Compute Engine」 -&gt; 「VM 執行個體」</li>\n</ul>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/ny3aKkXQTOOwP59kDLEB_E89EA2E5B995E5BFABE785A7202017-08-1220E4B88BE58D8811.54.09.png\" alt=\"\"></p>\n<ul>\n<li>點擊 「建立執行個體」</li>\n</ul>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1W8aYkspRQas9QXMs6O9_E89EA2E5B995E5BFABE785A7202017-08-1220E4B88BE58D8811.57.59.png\" alt=\"\"></p>\n<p><strong>名稱</strong>：自定義，這是你的機器名稱<br><strong>區域</strong>：請選 asia-east1-c 或是 asia-northeast1-b (亞洲區)<br><strong>機器類型</strong>：由於做個人翻牆工具，可以只選「微型」就好，規格選越高錢扣越快<br><strong>開機磁碟</strong>：請選作業系統 Ubuntu 14.04 LTS<br><strong>防火牆</strong>：將「允許 HTTP 流量」和「允許 HTTPS 流量」皆設為開啟</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/AR1NUHtmQvOzEatPQ0xA_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.04.53.png\" alt=\"\"></p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/WOXE1PfhQYbUkCGIoQpG_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.06.21.png\" alt=\"\"></p>\n<p>建立後，用瀏覽器打開 SSH 並輸入以下指令</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/PxSfuiYNTxC9dNeJYPxc_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.11.45.png\" alt=\"\"></p>\n<p>每筆指令輸入後記得按 Enter</p>\n<h3 id=\"先安裝-BBR-加速\"><a href=\"#先安裝-BBR-加速\" class=\"headerlink\" title=\"先安裝 BBR 加速\"></a>先安裝 BBR 加速</h3><p>BBR 是  <a href=\"https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwj_he7Lj9LVAhVB2LwKHaLiAVEQFggnMAA&url=https%3A%2F%2Fgithub.com%2Fgoogle%2Fbbr&usg=AFQjCNGIK2TzybkL1laoWJd6BiRDTrRjOg\" target=\"_blank\" rel=\"noopener\">Google 官方開源</a>的擁塞算法來加速 TCP</p>\n<p>也因為裝這個要重開機，所以先裝 XD</p>\n<p>依序輸入</p>\n<p><code>wget –no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</code></p>\n<p><code>chmod +x bbr.sh</code></p>\n<p><code>sudo ./bbr.sh</code></p>\n<p>輸入任意鍵執行</p>\n<p>過程會需要一些時間約三分鐘，最後他會問你要不要重啟機器（Do you want to reboot?）輸入  <code>y</code>  同意</p>\n<p>之後會斷開連線，請在重複之前打開這個視窗的動作「SSH」-&gt; 「在瀏覽器視窗中開啟」</p>\n<p>輸入  <code>sysctl net.ipv4.tcp_available_congestion_control</code></p>\n<p>如果有出現  <code>bbr</code>  字眼，就是安裝成功了</p>\n<h3 id=\"安裝-ShadowSocks-SS\"><a href=\"#安裝-ShadowSocks-SS\" class=\"headerlink\" title=\"安裝 ShadowSocks(SS)\"></a>安裝 ShadowSocks(SS)</h3><p><code>sudo apt-get install python-pip -y</code></p>\n<p><code>sudo pip install shadowsocks</code></p>\n<p><strong>重要！！！</strong>  以下指令中的 password 請務必改成自己要使用的</p>\n<p><code>sudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start</code></p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/wwtPB5QjSm27fQdEUkWF_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.16.43.png\" alt=\"\"></p>\n<p>將服務停止</p>\n<p><code>sudo ssserver -d stop</code></p>\n<p>再次運行</p>\n<p><code>sudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start</code></p>\n<p>大功告成，你已經有一台 SS + BBR 來做翻牆的機器了!</p>\n<p>機器詳細資訊</p>\n<ul>\n<li>IP 位置是你架設機器在上面寫的「外部 IP」</li>\n<li>密碼是剛剛你自行替換的「password」</li>\n<li>加密規則是 aes-256-cfb</li>\n<li>port 通道 443</li>\n</ul>\n<h3 id=\"翻牆工具\"><a href=\"#翻牆工具\" class=\"headerlink\" title=\"翻牆工具\"></a>翻牆工具</h3><p>我這邊是用 Surge ，不管手機跟電腦都是，要付費就是了，聽說也有免費的可以用，這部份就在<a href=\"http://blog.niclin.tw/posts/2163079-wall-on-the-iphone-via-shadowsocks-ss-in-the-city-over-the-wall\" target=\"_blank\" rel=\"noopener\">另一篇教程: <strong>在 iphone 上透過 Shadowsocks(SS) 在大陸翻牆</strong></a>講吧！</p>\n<h3 id=\"結果\"><a href=\"#結果\" class=\"headerlink\" title=\"結果\"></a>結果</h3><p>這是用 surge 跑 benchmark 出來的結果，圖中的 GoogleTest 是邊敲本文章邊隨著架設的機器，可以看出速度還 OK</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1Bm6YgbTHqmQAyHUUzI1_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.51.41.png\" alt=\"\"></p>\n<p>Youtube 1080P Test</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/gJP7K5vCRi0V5ZJbmQiK_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.54.51.png\" alt=\"\"></p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h3 id=\"建立-VPS\"><a href=\"#建立-VPS\" class=\"headerlink\" title=\"建立 VPS\"></a>建立 VPS</h3><p>Google cloud platform 有免費 12 個月 300USD 的額度可以使用</p>\n<ul>\n<li>註冊  <a href=\"https://cloud.google.com/\" target=\"_blank\" rel=\"noopener\">Google Clund Platform</a>  服務</li>\n<li>點擊左上角三條線漢堡，下拉選單到 「Compute Engine」 -&gt; 「VM 執行個體」</li>\n</ul>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/ny3aKkXQTOOwP59kDLEB_E89EA2E5B995E5BFABE785A7202017-08-1220E4B88BE58D8811.54.09.png\" alt=\"\"></p>\n<ul>\n<li>點擊 「建立執行個體」</li>\n</ul>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1W8aYkspRQas9QXMs6O9_E89EA2E5B995E5BFABE785A7202017-08-1220E4B88BE58D8811.57.59.png\" alt=\"\"></p>\n<p><strong>名稱</strong>：自定義，這是你的機器名稱<br><strong>區域</strong>：請選 asia-east1-c 或是 asia-northeast1-b (亞洲區)<br><strong>機器類型</strong>：由於做個人翻牆工具，可以只選「微型」就好，規格選越高錢扣越快<br><strong>開機磁碟</strong>：請選作業系統 Ubuntu 14.04 LTS<br><strong>防火牆</strong>：將「允許 HTTP 流量」和「允許 HTTPS 流量」皆設為開啟</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/AR1NUHtmQvOzEatPQ0xA_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.04.53.png\" alt=\"\"></p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/WOXE1PfhQYbUkCGIoQpG_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.06.21.png\" alt=\"\"></p>\n<p>建立後，用瀏覽器打開 SSH 並輸入以下指令</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/PxSfuiYNTxC9dNeJYPxc_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.11.45.png\" alt=\"\"></p>\n<p>每筆指令輸入後記得按 Enter</p>\n<h3 id=\"先安裝-BBR-加速\"><a href=\"#先安裝-BBR-加速\" class=\"headerlink\" title=\"先安裝 BBR 加速\"></a>先安裝 BBR 加速</h3><p>BBR 是  <a href=\"https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwj_he7Lj9LVAhVB2LwKHaLiAVEQFggnMAA&url=https%3A%2F%2Fgithub.com%2Fgoogle%2Fbbr&usg=AFQjCNGIK2TzybkL1laoWJd6BiRDTrRjOg\" target=\"_blank\" rel=\"noopener\">Google 官方開源</a>的擁塞算法來加速 TCP</p>\n<p>也因為裝這個要重開機，所以先裝 XD</p>\n<p>依序輸入</p>\n<p><code>wget –no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</code></p>\n<p><code>chmod +x bbr.sh</code></p>\n<p><code>sudo ./bbr.sh</code></p>\n<p>輸入任意鍵執行</p>\n<p>過程會需要一些時間約三分鐘，最後他會問你要不要重啟機器（Do you want to reboot?）輸入  <code>y</code>  同意</p>\n<p>之後會斷開連線，請在重複之前打開這個視窗的動作「SSH」-&gt; 「在瀏覽器視窗中開啟」</p>\n<p>輸入  <code>sysctl net.ipv4.tcp_available_congestion_control</code></p>\n<p>如果有出現  <code>bbr</code>  字眼，就是安裝成功了</p>\n<h3 id=\"安裝-ShadowSocks-SS\"><a href=\"#安裝-ShadowSocks-SS\" class=\"headerlink\" title=\"安裝 ShadowSocks(SS)\"></a>安裝 ShadowSocks(SS)</h3><p><code>sudo apt-get install python-pip -y</code></p>\n<p><code>sudo pip install shadowsocks</code></p>\n<p><strong>重要！！！</strong>  以下指令中的 password 請務必改成自己要使用的</p>\n<p><code>sudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start</code></p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/wwtPB5QjSm27fQdEUkWF_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.16.43.png\" alt=\"\"></p>\n<p>將服務停止</p>\n<p><code>sudo ssserver -d stop</code></p>\n<p>再次運行</p>\n<p><code>sudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start</code></p>\n<p>大功告成，你已經有一台 SS + BBR 來做翻牆的機器了!</p>\n<p>機器詳細資訊</p>\n<ul>\n<li>IP 位置是你架設機器在上面寫的「外部 IP」</li>\n<li>密碼是剛剛你自行替換的「password」</li>\n<li>加密規則是 aes-256-cfb</li>\n<li>port 通道 443</li>\n</ul>\n<h3 id=\"翻牆工具\"><a href=\"#翻牆工具\" class=\"headerlink\" title=\"翻牆工具\"></a>翻牆工具</h3><p>我這邊是用 Surge ，不管手機跟電腦都是，要付費就是了，聽說也有免費的可以用，這部份就在<a href=\"http://blog.niclin.tw/posts/2163079-wall-on-the-iphone-via-shadowsocks-ss-in-the-city-over-the-wall\" target=\"_blank\" rel=\"noopener\">另一篇教程: <strong>在 iphone 上透過 Shadowsocks(SS) 在大陸翻牆</strong></a>講吧！</p>\n<h3 id=\"結果\"><a href=\"#結果\" class=\"headerlink\" title=\"結果\"></a>結果</h3><p>這是用 surge 跑 benchmark 出來的結果，圖中的 GoogleTest 是邊敲本文章邊隨著架設的機器，可以看出速度還 OK</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1Bm6YgbTHqmQAyHUUzI1_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.51.41.png\" alt=\"\"></p>\n<p>Youtube 1080P Test</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/gJP7K5vCRi0V5ZJbmQiK_E89EA2E5B995E5BFABE785A7202017-08-1320E4B88AE58D8812.54.51.png\" alt=\"\"></p>\n"},{"title":"chrome浏览器下 , webVPN 离线安装教程","toc":false,"date":"2018-02-08T19:33:00.000Z","_content":"\n# chrome 浏览器下 , webVPN 离线安装教程\n\n## 方法 1：解压安装(推荐，保险的安装方式，安装之后，建议你点击下面的应用商店链接，从应用商店中安装一次,然后删除这个离线安装 webVPN)\n\n## 步骤 1\n\n- 下载  [webVPN.2.5.crx](https://jiasuqi.xyz/downloads/webVPN.2.5.crx)\n- 把下载的文件 webVPN.2.5.crx  名字改为 webVPN.2.5.zip\n- 新建文件夹 webVPN.2.5, 解压 webVPN.2.5.zip 到 \"webVPN.2.5\" 目录\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/step1.jpg)\n\n## 步骤 2\n\n在浏览器地址栏输入 \"chrome://extensions\", 然后回车, 进入 chrome extensions 管理页面 e;  \n在页面[ chrome://extensions ](chrome://extensions/),选择开发者模式 \"developer mode\",\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/step2.jpg)\n\n## step 3\n\n此时在[chrome://extensions](chrome://extensions/)  页面,会多出一个\"加载未打包的 extension\"(load unpacked extension)的按钮, 点击该按钮，弹出打开文件对话框，选择 webVPN2.5 所在的文件夹, 点击确定，就可以完成安装了\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/step3.jpg)\n\n从文件 webVPN.2.5 文件夹中安装\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/step4.jpg)\n\n## 安装成功之后\n\n在浏览网页的过程中如果遇到不能访问的网站，或者需要代理的网站（有些视屏网站，对不同地区的ｉｐ有限制),点击浏览器右上角的狐狸图标，  \n在弹出的小窗里选择代理服务器 即可\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/step5.jpg)\n\n在你完成上面的离线安装之后，　我们强烈的建议您点击下面的在线安装地址，从ｃｈｒｏｍｅ应用商店在线安装(此时您应该已经能访问 google 了)   \n[click here, to do online install ](https://chrome.google.com/webstore/detail/webvpnproxy-selected-webs/hcohobfmhkabhpcedpbiddhoeeihcgpp)  \n使用在线安装，您的将自动的获取 webVPN 在线跟新  \n[![](http://www.jixiaokang.com/wp-content/uploads/2018/05/ChromeWebStore_Badge_v2_496x150.png)   \nclick, to instal](https://chrome.google.com/webstore/detail/webvpnproxy-selected-webs/hcohobfmhkabhpcedpbiddhoeeihcgpp)\n\n## 方法 2：拖动安装( 不推荐，高版本的 chrome 浏览器在安装完成之后会报错，这是因为 google 不想支持这种安装方式了，ｇｏｏｇｌｅ希望用户都能直接从应用商店安装）　\n\n### 点击下载  [webVPN.2.5.crx](https://jiasuqi.xyz/downloads/webVPN.2.5.crx) \n\n在浏览器中输入 chrome://extensions , 进入浏览器扩展管理界面  \n鼠标移动到下载的 webVPN.2.5.crx 文件上,鼠标左键下压拖动 webVPN.2.5.crx 到 chrome://extensions 界面中,松开鼠标左键, 如下图所示\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/drag.jpg)\n\n### 安装提示弹出, 选择确认, 安装完成\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/drag_ok.png)\n\n### 第一次使用，您需要注册点击　 chrome 浏览器右上角的狐狸图标弹出如下所示的注册连接\n\n### ![](http://www.jixiaokang.com/wp-content/uploads/2018/05/loginwebvpn.png)\n\n### 注册完成后，点击激活连接，会自动登录, 如果没有自动登录，输入邮箱　密码登录(仅第一次使用需要登录，以后就不需要了)\n\n### 登录之后，在浏览网页过程中，如果遇到海外网页加载慢，可以点击狐狸图标在服务器列表中 点击　选择代理服务器\n\n### ![](http://www.jixiaokang.com/wp-content/uploads/2018/05/usewebvpn.jpg)\n\n离线安装之后, 建议点击下面的连接, 从 chrome webstore 中做一次在线安装( 此时你应该能够访问 google webstore )   \n[![](http://www.jixiaokang.com/wp-content/uploads/2018/05/ChromeWebStore_Badge_v2_496x150.png)   \nclick, to instal](https://chrome.google.com/webstore/detail/webvpnproxy-selected-webs/hcohobfmhkabhpcedpbiddhoeeihcgpp)\n","source":"_posts/2018-02-09-webVPN离线安装.md","raw":"---\ntitle: \"chrome浏览器下 , webVPN 离线安装教程\"\ntags:\n  - 工具\ntoc: false\ndate: 2018-02-09 03:33:00\ncategories: 教程\n---\n\n# chrome 浏览器下 , webVPN 离线安装教程\n\n## 方法 1：解压安装(推荐，保险的安装方式，安装之后，建议你点击下面的应用商店链接，从应用商店中安装一次,然后删除这个离线安装 webVPN)\n\n## 步骤 1\n\n- 下载  [webVPN.2.5.crx](https://jiasuqi.xyz/downloads/webVPN.2.5.crx)\n- 把下载的文件 webVPN.2.5.crx  名字改为 webVPN.2.5.zip\n- 新建文件夹 webVPN.2.5, 解压 webVPN.2.5.zip 到 \"webVPN.2.5\" 目录\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/step1.jpg)\n\n## 步骤 2\n\n在浏览器地址栏输入 \"chrome://extensions\", 然后回车, 进入 chrome extensions 管理页面 e;  \n在页面[ chrome://extensions ](chrome://extensions/),选择开发者模式 \"developer mode\",\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/step2.jpg)\n\n## step 3\n\n此时在[chrome://extensions](chrome://extensions/)  页面,会多出一个\"加载未打包的 extension\"(load unpacked extension)的按钮, 点击该按钮，弹出打开文件对话框，选择 webVPN2.5 所在的文件夹, 点击确定，就可以完成安装了\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/step3.jpg)\n\n从文件 webVPN.2.5 文件夹中安装\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/step4.jpg)\n\n## 安装成功之后\n\n在浏览网页的过程中如果遇到不能访问的网站，或者需要代理的网站（有些视屏网站，对不同地区的ｉｐ有限制),点击浏览器右上角的狐狸图标，  \n在弹出的小窗里选择代理服务器 即可\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/step5.jpg)\n\n在你完成上面的离线安装之后，　我们强烈的建议您点击下面的在线安装地址，从ｃｈｒｏｍｅ应用商店在线安装(此时您应该已经能访问 google 了)   \n[click here, to do online install ](https://chrome.google.com/webstore/detail/webvpnproxy-selected-webs/hcohobfmhkabhpcedpbiddhoeeihcgpp)  \n使用在线安装，您的将自动的获取 webVPN 在线跟新  \n[![](http://www.jixiaokang.com/wp-content/uploads/2018/05/ChromeWebStore_Badge_v2_496x150.png)   \nclick, to instal](https://chrome.google.com/webstore/detail/webvpnproxy-selected-webs/hcohobfmhkabhpcedpbiddhoeeihcgpp)\n\n## 方法 2：拖动安装( 不推荐，高版本的 chrome 浏览器在安装完成之后会报错，这是因为 google 不想支持这种安装方式了，ｇｏｏｇｌｅ希望用户都能直接从应用商店安装）　\n\n### 点击下载  [webVPN.2.5.crx](https://jiasuqi.xyz/downloads/webVPN.2.5.crx) \n\n在浏览器中输入 chrome://extensions , 进入浏览器扩展管理界面  \n鼠标移动到下载的 webVPN.2.5.crx 文件上,鼠标左键下压拖动 webVPN.2.5.crx 到 chrome://extensions 界面中,松开鼠标左键, 如下图所示\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/drag.jpg)\n\n### 安装提示弹出, 选择确认, 安装完成\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/drag_ok.png)\n\n### 第一次使用，您需要注册点击　 chrome 浏览器右上角的狐狸图标弹出如下所示的注册连接\n\n### ![](http://www.jixiaokang.com/wp-content/uploads/2018/05/loginwebvpn.png)\n\n### 注册完成后，点击激活连接，会自动登录, 如果没有自动登录，输入邮箱　密码登录(仅第一次使用需要登录，以后就不需要了)\n\n### 登录之后，在浏览网页过程中，如果遇到海外网页加载慢，可以点击狐狸图标在服务器列表中 点击　选择代理服务器\n\n### ![](http://www.jixiaokang.com/wp-content/uploads/2018/05/usewebvpn.jpg)\n\n离线安装之后, 建议点击下面的连接, 从 chrome webstore 中做一次在线安装( 此时你应该能够访问 google webstore )   \n[![](http://www.jixiaokang.com/wp-content/uploads/2018/05/ChromeWebStore_Badge_v2_496x150.png)   \nclick, to instal](https://chrome.google.com/webstore/detail/webvpnproxy-selected-webs/hcohobfmhkabhpcedpbiddhoeeihcgpp)\n","slug":"2018-02-09-webVPN离线安装","published":1,"updated":"2020-03-14T06:50:15.502Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvkx00224k8y3amjbda9","content":"<h1 id=\"chrome-浏览器下-webVPN-离线安装教程\"><a href=\"#chrome-浏览器下-webVPN-离线安装教程\" class=\"headerlink\" title=\"chrome 浏览器下 , webVPN 离线安装教程\"></a>chrome 浏览器下 , webVPN 离线安装教程</h1><h2 id=\"方法-1：解压安装-推荐，保险的安装方式，安装之后，建议你点击下面的应用商店链接，从应用商店中安装一次-然后删除这个离线安装-webVPN\"><a href=\"#方法-1：解压安装-推荐，保险的安装方式，安装之后，建议你点击下面的应用商店链接，从应用商店中安装一次-然后删除这个离线安装-webVPN\" class=\"headerlink\" title=\"方法 1：解压安装(推荐，保险的安装方式，安装之后，建议你点击下面的应用商店链接，从应用商店中安装一次,然后删除这个离线安装 webVPN)\"></a>方法 1：解压安装(推荐，保险的安装方式，安装之后，建议你点击下面的应用商店链接，从应用商店中安装一次,然后删除这个离线安装 webVPN)</h2><h2 id=\"步骤-1\"><a href=\"#步骤-1\" class=\"headerlink\" title=\"步骤 1\"></a>步骤 1</h2><ul>\n<li>下载  <a href=\"https://jiasuqi.xyz/downloads/webVPN.2.5.crx\" target=\"_blank\" rel=\"noopener\">webVPN.2.5.crx</a></li>\n<li>把下载的文件 webVPN.2.5.crx  名字改为 webVPN.2.5.zip</li>\n<li>新建文件夹 webVPN.2.5, 解压 webVPN.2.5.zip 到 “webVPN.2.5” 目录</li>\n</ul>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/step1.jpg\" alt=\"\"></p>\n<h2 id=\"步骤-2\"><a href=\"#步骤-2\" class=\"headerlink\" title=\"步骤 2\"></a>步骤 2</h2><p>在浏览器地址栏输入 “chrome://extensions”, 然后回车, 进入 chrome extensions 管理页面 e;<br>在页面<a href=\"chrome://extensions/\"> chrome://extensions </a>,选择开发者模式 “developer mode”,</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/step2.jpg\" alt=\"\"></p>\n<h2 id=\"step-3\"><a href=\"#step-3\" class=\"headerlink\" title=\"step 3\"></a>step 3</h2><p>此时在<a href=\"chrome://extensions/\">chrome://extensions</a>  页面,会多出一个”加载未打包的 extension”(load unpacked extension)的按钮, 点击该按钮，弹出打开文件对话框，选择 webVPN2.5 所在的文件夹, 点击确定，就可以完成安装了</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/step3.jpg\" alt=\"\"></p>\n<p>从文件 webVPN.2.5 文件夹中安装</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/step4.jpg\" alt=\"\"></p>\n<h2 id=\"安装成功之后\"><a href=\"#安装成功之后\" class=\"headerlink\" title=\"安装成功之后\"></a>安装成功之后</h2><p>在浏览网页的过程中如果遇到不能访问的网站，或者需要代理的网站（有些视屏网站，对不同地区的ｉｐ有限制),点击浏览器右上角的狐狸图标，<br>在弹出的小窗里选择代理服务器 即可</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/step5.jpg\" alt=\"\"></p>\n<p>在你完成上面的离线安装之后，　我们强烈的建议您点击下面的在线安装地址，从ｃｈｒｏｍｅ应用商店在线安装(此时您应该已经能访问 google 了)<br><a href=\"https://chrome.google.com/webstore/detail/webvpnproxy-selected-webs/hcohobfmhkabhpcedpbiddhoeeihcgpp\" target=\"_blank\" rel=\"noopener\">click here, to do online install </a><br>使用在线安装，您的将自动的获取 webVPN 在线跟新<br><a href=\"https://chrome.google.com/webstore/detail/webvpnproxy-selected-webs/hcohobfmhkabhpcedpbiddhoeeihcgpp\" target=\"_blank\" rel=\"noopener\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/ChromeWebStore_Badge_v2_496x150.png\" alt=\"\"><br>click, to instal</a></p>\n<h2 id=\"方法-2：拖动安装-不推荐，高版本的-chrome-浏览器在安装完成之后会报错，这是因为-google-不想支持这种安装方式了，google希望用户都能直接从应用商店安装）\"><a href=\"#方法-2：拖动安装-不推荐，高版本的-chrome-浏览器在安装完成之后会报错，这是因为-google-不想支持这种安装方式了，google希望用户都能直接从应用商店安装）\" class=\"headerlink\" title=\"方法 2：拖动安装( 不推荐，高版本的 chrome 浏览器在安装完成之后会报错，这是因为 google 不想支持这种安装方式了，ｇｏｏｇｌｅ希望用户都能直接从应用商店安装）　\"></a>方法 2：拖动安装( 不推荐，高版本的 chrome 浏览器在安装完成之后会报错，这是因为 google 不想支持这种安装方式了，ｇｏｏｇｌｅ希望用户都能直接从应用商店安装）　</h2><h3 id=\"点击下载-webVPN-2-5-crx\"><a href=\"#点击下载-webVPN-2-5-crx\" class=\"headerlink\" title=\"点击下载  webVPN.2.5.crx\"></a>点击下载  <a href=\"https://jiasuqi.xyz/downloads/webVPN.2.5.crx\" target=\"_blank\" rel=\"noopener\">webVPN.2.5.crx</a></h3><p>在浏览器中输入 chrome://extensions , 进入浏览器扩展管理界面<br>鼠标移动到下载的 webVPN.2.5.crx 文件上,鼠标左键下压拖动 webVPN.2.5.crx 到 chrome://extensions 界面中,松开鼠标左键, 如下图所示</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/drag.jpg\" alt=\"\"></p>\n<h3 id=\"安装提示弹出-选择确认-安装完成\"><a href=\"#安装提示弹出-选择确认-安装完成\" class=\"headerlink\" title=\"安装提示弹出, 选择确认, 安装完成\"></a>安装提示弹出, 选择确认, 安装完成</h3><p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/drag_ok.png\" alt=\"\"></p>\n<h3 id=\"第一次使用，您需要注册点击-chrome-浏览器右上角的狐狸图标弹出如下所示的注册连接\"><a href=\"#第一次使用，您需要注册点击-chrome-浏览器右上角的狐狸图标弹出如下所示的注册连接\" class=\"headerlink\" title=\"第一次使用，您需要注册点击　 chrome 浏览器右上角的狐狸图标弹出如下所示的注册连接\"></a>第一次使用，您需要注册点击　 chrome 浏览器右上角的狐狸图标弹出如下所示的注册连接</h3><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/loginwebvpn.png\" alt=\"\"></h3><h3 id=\"注册完成后，点击激活连接，会自动登录-如果没有自动登录，输入邮箱-密码登录-仅第一次使用需要登录，以后就不需要了\"><a href=\"#注册完成后，点击激活连接，会自动登录-如果没有自动登录，输入邮箱-密码登录-仅第一次使用需要登录，以后就不需要了\" class=\"headerlink\" title=\"注册完成后，点击激活连接，会自动登录, 如果没有自动登录，输入邮箱　密码登录(仅第一次使用需要登录，以后就不需要了)\"></a>注册完成后，点击激活连接，会自动登录, 如果没有自动登录，输入邮箱　密码登录(仅第一次使用需要登录，以后就不需要了)</h3><h3 id=\"登录之后，在浏览网页过程中，如果遇到海外网页加载慢，可以点击狐狸图标在服务器列表中-点击-选择代理服务器\"><a href=\"#登录之后，在浏览网页过程中，如果遇到海外网页加载慢，可以点击狐狸图标在服务器列表中-点击-选择代理服务器\" class=\"headerlink\" title=\"登录之后，在浏览网页过程中，如果遇到海外网页加载慢，可以点击狐狸图标在服务器列表中 点击　选择代理服务器\"></a>登录之后，在浏览网页过程中，如果遇到海外网页加载慢，可以点击狐狸图标在服务器列表中 点击　选择代理服务器</h3><h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/usewebvpn.jpg\" alt=\"\"></h3><p>离线安装之后, 建议点击下面的连接, 从 chrome webstore 中做一次在线安装( 此时你应该能够访问 google webstore )<br><a href=\"https://chrome.google.com/webstore/detail/webvpnproxy-selected-webs/hcohobfmhkabhpcedpbiddhoeeihcgpp\" target=\"_blank\" rel=\"noopener\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/ChromeWebStore_Badge_v2_496x150.png\" alt=\"\"><br>click, to instal</a></p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h1 id=\"chrome-浏览器下-webVPN-离线安装教程\"><a href=\"#chrome-浏览器下-webVPN-离线安装教程\" class=\"headerlink\" title=\"chrome 浏览器下 , webVPN 离线安装教程\"></a>chrome 浏览器下 , webVPN 离线安装教程</h1><h2 id=\"方法-1：解压安装-推荐，保险的安装方式，安装之后，建议你点击下面的应用商店链接，从应用商店中安装一次-然后删除这个离线安装-webVPN\"><a href=\"#方法-1：解压安装-推荐，保险的安装方式，安装之后，建议你点击下面的应用商店链接，从应用商店中安装一次-然后删除这个离线安装-webVPN\" class=\"headerlink\" title=\"方法 1：解压安装(推荐，保险的安装方式，安装之后，建议你点击下面的应用商店链接，从应用商店中安装一次,然后删除这个离线安装 webVPN)\"></a>方法 1：解压安装(推荐，保险的安装方式，安装之后，建议你点击下面的应用商店链接，从应用商店中安装一次,然后删除这个离线安装 webVPN)</h2><h2 id=\"步骤-1\"><a href=\"#步骤-1\" class=\"headerlink\" title=\"步骤 1\"></a>步骤 1</h2><ul>\n<li>下载  <a href=\"https://jiasuqi.xyz/downloads/webVPN.2.5.crx\" target=\"_blank\" rel=\"noopener\">webVPN.2.5.crx</a></li>\n<li>把下载的文件 webVPN.2.5.crx  名字改为 webVPN.2.5.zip</li>\n<li>新建文件夹 webVPN.2.5, 解压 webVPN.2.5.zip 到 “webVPN.2.5” 目录</li>\n</ul>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/step1.jpg\" alt=\"\"></p>\n<h2 id=\"步骤-2\"><a href=\"#步骤-2\" class=\"headerlink\" title=\"步骤 2\"></a>步骤 2</h2><p>在浏览器地址栏输入 “chrome://extensions”, 然后回车, 进入 chrome extensions 管理页面 e;<br>在页面<a href=\"chrome://extensions/\"> chrome://extensions </a>,选择开发者模式 “developer mode”,</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/step2.jpg\" alt=\"\"></p>\n<h2 id=\"step-3\"><a href=\"#step-3\" class=\"headerlink\" title=\"step 3\"></a>step 3</h2><p>此时在<a href=\"chrome://extensions/\">chrome://extensions</a>  页面,会多出一个”加载未打包的 extension”(load unpacked extension)的按钮, 点击该按钮，弹出打开文件对话框，选择 webVPN2.5 所在的文件夹, 点击确定，就可以完成安装了</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/step3.jpg\" alt=\"\"></p>\n<p>从文件 webVPN.2.5 文件夹中安装</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/step4.jpg\" alt=\"\"></p>\n<h2 id=\"安装成功之后\"><a href=\"#安装成功之后\" class=\"headerlink\" title=\"安装成功之后\"></a>安装成功之后</h2><p>在浏览网页的过程中如果遇到不能访问的网站，或者需要代理的网站（有些视屏网站，对不同地区的ｉｐ有限制),点击浏览器右上角的狐狸图标，<br>在弹出的小窗里选择代理服务器 即可</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/step5.jpg\" alt=\"\"></p>\n<p>在你完成上面的离线安装之后，　我们强烈的建议您点击下面的在线安装地址，从ｃｈｒｏｍｅ应用商店在线安装(此时您应该已经能访问 google 了)<br><a href=\"https://chrome.google.com/webstore/detail/webvpnproxy-selected-webs/hcohobfmhkabhpcedpbiddhoeeihcgpp\" target=\"_blank\" rel=\"noopener\">click here, to do online install </a><br>使用在线安装，您的将自动的获取 webVPN 在线跟新<br><a href=\"https://chrome.google.com/webstore/detail/webvpnproxy-selected-webs/hcohobfmhkabhpcedpbiddhoeeihcgpp\" target=\"_blank\" rel=\"noopener\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/ChromeWebStore_Badge_v2_496x150.png\" alt=\"\"><br>click, to instal</a></p>\n<h2 id=\"方法-2：拖动安装-不推荐，高版本的-chrome-浏览器在安装完成之后会报错，这是因为-google-不想支持这种安装方式了，google希望用户都能直接从应用商店安装）\"><a href=\"#方法-2：拖动安装-不推荐，高版本的-chrome-浏览器在安装完成之后会报错，这是因为-google-不想支持这种安装方式了，google希望用户都能直接从应用商店安装）\" class=\"headerlink\" title=\"方法 2：拖动安装( 不推荐，高版本的 chrome 浏览器在安装完成之后会报错，这是因为 google 不想支持这种安装方式了，ｇｏｏｇｌｅ希望用户都能直接从应用商店安装）　\"></a>方法 2：拖动安装( 不推荐，高版本的 chrome 浏览器在安装完成之后会报错，这是因为 google 不想支持这种安装方式了，ｇｏｏｇｌｅ希望用户都能直接从应用商店安装）　</h2><h3 id=\"点击下载-webVPN-2-5-crx\"><a href=\"#点击下载-webVPN-2-5-crx\" class=\"headerlink\" title=\"点击下载  webVPN.2.5.crx\"></a>点击下载  <a href=\"https://jiasuqi.xyz/downloads/webVPN.2.5.crx\" target=\"_blank\" rel=\"noopener\">webVPN.2.5.crx</a></h3><p>在浏览器中输入 chrome://extensions , 进入浏览器扩展管理界面<br>鼠标移动到下载的 webVPN.2.5.crx 文件上,鼠标左键下压拖动 webVPN.2.5.crx 到 chrome://extensions 界面中,松开鼠标左键, 如下图所示</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/drag.jpg\" alt=\"\"></p>\n<h3 id=\"安装提示弹出-选择确认-安装完成\"><a href=\"#安装提示弹出-选择确认-安装完成\" class=\"headerlink\" title=\"安装提示弹出, 选择确认, 安装完成\"></a>安装提示弹出, 选择确认, 安装完成</h3><p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/drag_ok.png\" alt=\"\"></p>\n<h3 id=\"第一次使用，您需要注册点击-chrome-浏览器右上角的狐狸图标弹出如下所示的注册连接\"><a href=\"#第一次使用，您需要注册点击-chrome-浏览器右上角的狐狸图标弹出如下所示的注册连接\" class=\"headerlink\" title=\"第一次使用，您需要注册点击　 chrome 浏览器右上角的狐狸图标弹出如下所示的注册连接\"></a>第一次使用，您需要注册点击　 chrome 浏览器右上角的狐狸图标弹出如下所示的注册连接</h3><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/loginwebvpn.png\" alt=\"\"></h3><h3 id=\"注册完成后，点击激活连接，会自动登录-如果没有自动登录，输入邮箱-密码登录-仅第一次使用需要登录，以后就不需要了\"><a href=\"#注册完成后，点击激活连接，会自动登录-如果没有自动登录，输入邮箱-密码登录-仅第一次使用需要登录，以后就不需要了\" class=\"headerlink\" title=\"注册完成后，点击激活连接，会自动登录, 如果没有自动登录，输入邮箱　密码登录(仅第一次使用需要登录，以后就不需要了)\"></a>注册完成后，点击激活连接，会自动登录, 如果没有自动登录，输入邮箱　密码登录(仅第一次使用需要登录，以后就不需要了)</h3><h3 id=\"登录之后，在浏览网页过程中，如果遇到海外网页加载慢，可以点击狐狸图标在服务器列表中-点击-选择代理服务器\"><a href=\"#登录之后，在浏览网页过程中，如果遇到海外网页加载慢，可以点击狐狸图标在服务器列表中-点击-选择代理服务器\" class=\"headerlink\" title=\"登录之后，在浏览网页过程中，如果遇到海外网页加载慢，可以点击狐狸图标在服务器列表中 点击　选择代理服务器\"></a>登录之后，在浏览网页过程中，如果遇到海外网页加载慢，可以点击狐狸图标在服务器列表中 点击　选择代理服务器</h3><h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/usewebvpn.jpg\" alt=\"\"></h3><p>离线安装之后, 建议点击下面的连接, 从 chrome webstore 中做一次在线安装( 此时你应该能够访问 google webstore )<br><a href=\"https://chrome.google.com/webstore/detail/webvpnproxy-selected-webs/hcohobfmhkabhpcedpbiddhoeeihcgpp\" target=\"_blank\" rel=\"noopener\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/ChromeWebStore_Badge_v2_496x150.png\" alt=\"\"><br>click, to instal</a></p>\n"},{"title":"Mac 使用技巧总结","date":"2018-03-16T01:29:00.000Z","_content":"\n> Mac 系统日常使用技巧归纳总结。\n\n# 一、Mac 中 Finder 显示、关闭隐藏文件\n\n## 1.1 终端命令模式\n\n- 打开终端，输入：\n\n  1\n\n  2\n\n  3\n\n  4\n\n  5\n\n  # 此命令显示隐藏文件\n\n  defaults write com.apple.finder AppleShowAllFiles -bool true\n\n  # 此命令关闭显示隐藏文件\n\n  defaults write com.apple.finder AppleShowAllFiles -bool false\n\n- 命令运行之后需要重新加载 Finder\n\n  快捷键  `Option + Command + ESC`，选中  `Finder`，重新启动即可\n\n## 1.2 Finder 快捷键\n\n在 macOS Sierra（10.12） 版本的系统中，我们可以使用快捷键`⌘⇧.`(`Command + Shift + .`) 来快速（在 Finder 中）显示和隐藏隐藏文件了。\n\n# 二、Terminal 中使用 Sublime 打开文件\n\n## 2.1 如果使用默认 Shell\n\n在  `Terminal`  输入以下命令：\n\n1\n\nsudo ln -s \"/Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl\" /usr/bin/subl\n\n## 2.2 如果使用 zsh\n\n在文件  `~/.zshrc`  最后添加\n\n1\n\n2\n\n3\n\n4\n\n5\n\nalias subl=\"'/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl'\"\n\nalias nano=\"subl\"\n\nexport EDITOR=\"subl\"\n\n然后在  `Terminal`  中使用  `subl`  就可以打开  `Sublime`  了。\n\n## 2.3 使用 Sublime 打开指定的文件\n\n1\n\nopen -a Sublime\\ Text .m2/settings.xml\n\n> 可以使用  `Tab`  自定补全应用名称\n\n# 三、多屏切换 dock 显示\n\n如果  `dock`  在屏幕底部显示，移动鼠标到要显示  `dock`  的屏幕上，单击使屏幕处于选中状态，在屏幕底部中间部位向下滑动鼠标即可移动  `dock`  到当前屏幕上显示。\n\n# 四、Terminal 重启 Finder、dock 等命令\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n# Finder 崩溃重启\n\nkillall -kill Finder\n\n# Dock 崩溃重启\n\nkillall -kill Dock\n\n# 菜单栏崩溃重启\n\nkillall -kill SystemUIServer\n\n# 五、Terminal 中用打开当前路径的文件夹\n\n在  `Terminal`  中输入命令：\n\n1\n\nopen .\n\n# 六、剪贴文件\n\n1\n\n2\n\n3\n\n4\n\n5\n\n# 复制\n\nCommand + c\n\n# 剪切到当前目录\n\nCommand + Option + v\n\n# 七、快速打开最小化程序\n\n`Command + Tab`  切换程序的时候，最小化的程序不自动弹出窗口，解决办法如下：\n\n- 用  `Command + Tab`  切换到要打开的程序\n- 先松开  `Tab`  键，不要松开  `Command`  键\n- 然后按住  `Option`  键\n- 然后依次松开  `Command`  和  `Option`  键\n\n如上操作就可以快速打开最小化的程序了。\n\n# 八、常用快捷键\n\n[Mac 键盘快捷键官方参考](https://support.apple.com/zh-cn/HT201236)\n\n功能\n\n快捷键\n\n预览文件\n\n`空格`\n\n重命名\n\n`Enter`\n\n打开文件\n\n`Command + o`、`Command + ↓`\n\n显示桌面\n\n`F11`\n\n切换窗口全屏状态\n\n`Ctrl + Cmmad + f`\n\n影藏 / 显示 Dock\n\n`Command + Option + d`\n\n输入 emoji 表情\n\n`Ctrl + Cmmad + 空格`\n\n# 九、.DS_Store 文件处理\n\n[.DS_Store (英文全称 Desktop Services Store) 是一种由苹果公司的 Mac OS X 操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。](https://zh.wikipedia.org/wiki/.DS_Store)\n\n## 9.1 清除文件\n\n清除命令：\n\n`sudo find / -name \".DS_Store\" -depth -exec rm {} \\;`\n\n## 9.2 禁用或启用自动生成\n\n执行以下命令，回车执行，重启 Mac 即可生效。\n\n- 禁止. DS_store 生成：\n\n`defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE`\n\n- 恢复. DS_store 生成：\n\n`defaults delete com.apple.desktopservices DSDontWriteNetworkStores`\n\n# 十、NTFS 格式移动盘写入文件\n\n一般来说，MacOS 是不支持 NTFS 格式磁盘的写入，可以借助三方工具，例如：Tuxera NTFS，不过收费还挺高的。这里介绍一种方法，不需要借助三方工具也可以实现 NTFS 格式磁盘写入。（基于系统版本  `macOS Sierra 10.12.4`  亲测可行）\n\n- 插入移动硬盘，终端输入命令：`$ diskutil list`  查看移动硬盘名称。例如：\n\n  1\n\n  2\n\n  3\n\n  4\n\n  5\n\n  6\n\n  7\n\n  \\$ diskutil list\n\n  ....\n\n  /dev/disk2 (external, physical):\n\n  #: TYPE NAME SIZE IDENTIFIER\n\n  0: FDisk_partition_scheme \\*500.1 GB disk2\n\n  1: Windows_NTFS EHLXR 500.1 GB disk2s4\n\n- 编辑系统文件  `sudo vim /etc/fstab` ，写入以下内容，然后保存。\n\n  1\n\n  LABEL=EHLXR none ntfs rw,auto,nobrowse\n\n  其中  `EHLXR`  为移动硬盘名称。\n\n- 推出硬盘重新插入，这时候桌面已不再显示移动硬盘图标。\n\n- 在 Finder 中通过快捷键  `Command + Shift + g`  输入`/Volumes`  就可以重新看到移动硬盘，这时候打开移动硬盘就可以写入文件了。\n\n- 为了方便起见，可以通过命令：`sudo ln -s /Volumes ~/Desktop/Volumes`  在桌面建立快捷方式，方便查看。\n","source":"_posts/2018-03-16-Mac 使用技巧总结.md","raw":"---\ntitle: Mac 使用技巧总结\ntags:\n  - 工具\ndate: 2018-03-16 09:29:00\ncategories: 教程\n---\n\n> Mac 系统日常使用技巧归纳总结。\n\n# 一、Mac 中 Finder 显示、关闭隐藏文件\n\n## 1.1 终端命令模式\n\n- 打开终端，输入：\n\n  1\n\n  2\n\n  3\n\n  4\n\n  5\n\n  # 此命令显示隐藏文件\n\n  defaults write com.apple.finder AppleShowAllFiles -bool true\n\n  # 此命令关闭显示隐藏文件\n\n  defaults write com.apple.finder AppleShowAllFiles -bool false\n\n- 命令运行之后需要重新加载 Finder\n\n  快捷键  `Option + Command + ESC`，选中  `Finder`，重新启动即可\n\n## 1.2 Finder 快捷键\n\n在 macOS Sierra（10.12） 版本的系统中，我们可以使用快捷键`⌘⇧.`(`Command + Shift + .`) 来快速（在 Finder 中）显示和隐藏隐藏文件了。\n\n# 二、Terminal 中使用 Sublime 打开文件\n\n## 2.1 如果使用默认 Shell\n\n在  `Terminal`  输入以下命令：\n\n1\n\nsudo ln -s \"/Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl\" /usr/bin/subl\n\n## 2.2 如果使用 zsh\n\n在文件  `~/.zshrc`  最后添加\n\n1\n\n2\n\n3\n\n4\n\n5\n\nalias subl=\"'/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl'\"\n\nalias nano=\"subl\"\n\nexport EDITOR=\"subl\"\n\n然后在  `Terminal`  中使用  `subl`  就可以打开  `Sublime`  了。\n\n## 2.3 使用 Sublime 打开指定的文件\n\n1\n\nopen -a Sublime\\ Text .m2/settings.xml\n\n> 可以使用  `Tab`  自定补全应用名称\n\n# 三、多屏切换 dock 显示\n\n如果  `dock`  在屏幕底部显示，移动鼠标到要显示  `dock`  的屏幕上，单击使屏幕处于选中状态，在屏幕底部中间部位向下滑动鼠标即可移动  `dock`  到当前屏幕上显示。\n\n# 四、Terminal 重启 Finder、dock 等命令\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n# Finder 崩溃重启\n\nkillall -kill Finder\n\n# Dock 崩溃重启\n\nkillall -kill Dock\n\n# 菜单栏崩溃重启\n\nkillall -kill SystemUIServer\n\n# 五、Terminal 中用打开当前路径的文件夹\n\n在  `Terminal`  中输入命令：\n\n1\n\nopen .\n\n# 六、剪贴文件\n\n1\n\n2\n\n3\n\n4\n\n5\n\n# 复制\n\nCommand + c\n\n# 剪切到当前目录\n\nCommand + Option + v\n\n# 七、快速打开最小化程序\n\n`Command + Tab`  切换程序的时候，最小化的程序不自动弹出窗口，解决办法如下：\n\n- 用  `Command + Tab`  切换到要打开的程序\n- 先松开  `Tab`  键，不要松开  `Command`  键\n- 然后按住  `Option`  键\n- 然后依次松开  `Command`  和  `Option`  键\n\n如上操作就可以快速打开最小化的程序了。\n\n# 八、常用快捷键\n\n[Mac 键盘快捷键官方参考](https://support.apple.com/zh-cn/HT201236)\n\n功能\n\n快捷键\n\n预览文件\n\n`空格`\n\n重命名\n\n`Enter`\n\n打开文件\n\n`Command + o`、`Command + ↓`\n\n显示桌面\n\n`F11`\n\n切换窗口全屏状态\n\n`Ctrl + Cmmad + f`\n\n影藏 / 显示 Dock\n\n`Command + Option + d`\n\n输入 emoji 表情\n\n`Ctrl + Cmmad + 空格`\n\n# 九、.DS_Store 文件处理\n\n[.DS_Store (英文全称 Desktop Services Store) 是一种由苹果公司的 Mac OS X 操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。](https://zh.wikipedia.org/wiki/.DS_Store)\n\n## 9.1 清除文件\n\n清除命令：\n\n`sudo find / -name \".DS_Store\" -depth -exec rm {} \\;`\n\n## 9.2 禁用或启用自动生成\n\n执行以下命令，回车执行，重启 Mac 即可生效。\n\n- 禁止. DS_store 生成：\n\n`defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE`\n\n- 恢复. DS_store 生成：\n\n`defaults delete com.apple.desktopservices DSDontWriteNetworkStores`\n\n# 十、NTFS 格式移动盘写入文件\n\n一般来说，MacOS 是不支持 NTFS 格式磁盘的写入，可以借助三方工具，例如：Tuxera NTFS，不过收费还挺高的。这里介绍一种方法，不需要借助三方工具也可以实现 NTFS 格式磁盘写入。（基于系统版本  `macOS Sierra 10.12.4`  亲测可行）\n\n- 插入移动硬盘，终端输入命令：`$ diskutil list`  查看移动硬盘名称。例如：\n\n  1\n\n  2\n\n  3\n\n  4\n\n  5\n\n  6\n\n  7\n\n  \\$ diskutil list\n\n  ....\n\n  /dev/disk2 (external, physical):\n\n  #: TYPE NAME SIZE IDENTIFIER\n\n  0: FDisk_partition_scheme \\*500.1 GB disk2\n\n  1: Windows_NTFS EHLXR 500.1 GB disk2s4\n\n- 编辑系统文件  `sudo vim /etc/fstab` ，写入以下内容，然后保存。\n\n  1\n\n  LABEL=EHLXR none ntfs rw,auto,nobrowse\n\n  其中  `EHLXR`  为移动硬盘名称。\n\n- 推出硬盘重新插入，这时候桌面已不再显示移动硬盘图标。\n\n- 在 Finder 中通过快捷键  `Command + Shift + g`  输入`/Volumes`  就可以重新看到移动硬盘，这时候打开移动硬盘就可以写入文件了。\n\n- 为了方便起见，可以通过命令：`sudo ln -s /Volumes ~/Desktop/Volumes`  在桌面建立快捷方式，方便查看。\n","slug":"2018-03-16-Mac 使用技巧总结","published":1,"updated":"2020-03-14T06:51:08.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvky00254k8y5l2j1o1k","content":"<blockquote>\n<p>Mac 系统日常使用技巧归纳总结。</p>\n</blockquote>\n<h1 id=\"一、Mac-中-Finder-显示、关闭隐藏文件\"><a href=\"#一、Mac-中-Finder-显示、关闭隐藏文件\" class=\"headerlink\" title=\"一、Mac 中 Finder 显示、关闭隐藏文件\"></a>一、Mac 中 Finder 显示、关闭隐藏文件</h1><h2 id=\"1-1-终端命令模式\"><a href=\"#1-1-终端命令模式\" class=\"headerlink\" title=\"1.1 终端命令模式\"></a>1.1 终端命令模式</h2><ul>\n<li><p>打开终端，输入：</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<h1 id=\"此命令显示隐藏文件\"><a href=\"#此命令显示隐藏文件\" class=\"headerlink\" title=\"此命令显示隐藏文件\"></a>此命令显示隐藏文件</h1><p>defaults write com.apple.finder AppleShowAllFiles -bool true</p>\n<h1 id=\"此命令关闭显示隐藏文件\"><a href=\"#此命令关闭显示隐藏文件\" class=\"headerlink\" title=\"此命令关闭显示隐藏文件\"></a>此命令关闭显示隐藏文件</h1><p>defaults write com.apple.finder AppleShowAllFiles -bool false</p>\n</li>\n<li><p>命令运行之后需要重新加载 Finder</p>\n<p>快捷键  <code>Option + Command + ESC</code>，选中  <code>Finder</code>，重新启动即可</p>\n</li>\n</ul>\n<h2 id=\"1-2-Finder-快捷键\"><a href=\"#1-2-Finder-快捷键\" class=\"headerlink\" title=\"1.2 Finder 快捷键\"></a>1.2 Finder 快捷键</h2><p>在 macOS Sierra（10.12） 版本的系统中，我们可以使用快捷键<code>⌘⇧.</code>(<code>Command + Shift + .</code>) 来快速（在 Finder 中）显示和隐藏隐藏文件了。</p>\n<h1 id=\"二、Terminal-中使用-Sublime-打开文件\"><a href=\"#二、Terminal-中使用-Sublime-打开文件\" class=\"headerlink\" title=\"二、Terminal 中使用 Sublime 打开文件\"></a>二、Terminal 中使用 Sublime 打开文件</h1><h2 id=\"2-1-如果使用默认-Shell\"><a href=\"#2-1-如果使用默认-Shell\" class=\"headerlink\" title=\"2.1 如果使用默认 Shell\"></a>2.1 如果使用默认 Shell</h2><p>在  <code>Terminal</code>  输入以下命令：</p>\n<p>1</p>\n<p>sudo ln -s “/Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl” /usr/bin/subl</p>\n<h2 id=\"2-2-如果使用-zsh\"><a href=\"#2-2-如果使用-zsh\" class=\"headerlink\" title=\"2.2 如果使用 zsh\"></a>2.2 如果使用 zsh</h2><p>在文件  <code>~/.zshrc</code>  最后添加</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>alias subl=”‘/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl’”</p>\n<p>alias nano=”subl”</p>\n<p>export EDITOR=”subl”</p>\n<p>然后在  <code>Terminal</code>  中使用  <code>subl</code>  就可以打开  <code>Sublime</code>  了。</p>\n<h2 id=\"2-3-使用-Sublime-打开指定的文件\"><a href=\"#2-3-使用-Sublime-打开指定的文件\" class=\"headerlink\" title=\"2.3 使用 Sublime 打开指定的文件\"></a>2.3 使用 Sublime 打开指定的文件</h2><p>1</p>\n<p>open -a Sublime\\ Text .m2/settings.xml</p>\n<blockquote>\n<p>可以使用  <code>Tab</code>  自定补全应用名称</p>\n</blockquote>\n<h1 id=\"三、多屏切换-dock-显示\"><a href=\"#三、多屏切换-dock-显示\" class=\"headerlink\" title=\"三、多屏切换 dock 显示\"></a>三、多屏切换 dock 显示</h1><p>如果  <code>dock</code>  在屏幕底部显示，移动鼠标到要显示  <code>dock</code>  的屏幕上，单击使屏幕处于选中状态，在屏幕底部中间部位向下滑动鼠标即可移动  <code>dock</code>  到当前屏幕上显示。</p>\n<h1 id=\"四、Terminal-重启-Finder、dock-等命令\"><a href=\"#四、Terminal-重启-Finder、dock-等命令\" class=\"headerlink\" title=\"四、Terminal 重启 Finder、dock 等命令\"></a>四、Terminal 重启 Finder、dock 等命令</h1><p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<h1 id=\"Finder-崩溃重启\"><a href=\"#Finder-崩溃重启\" class=\"headerlink\" title=\"Finder 崩溃重启\"></a>Finder 崩溃重启</h1><p>killall -kill Finder</p>\n<h1 id=\"Dock-崩溃重启\"><a href=\"#Dock-崩溃重启\" class=\"headerlink\" title=\"Dock 崩溃重启\"></a>Dock 崩溃重启</h1><p>killall -kill Dock</p>\n<h1 id=\"菜单栏崩溃重启\"><a href=\"#菜单栏崩溃重启\" class=\"headerlink\" title=\"菜单栏崩溃重启\"></a>菜单栏崩溃重启</h1><p>killall -kill SystemUIServer</p>\n<h1 id=\"五、Terminal-中用打开当前路径的文件夹\"><a href=\"#五、Terminal-中用打开当前路径的文件夹\" class=\"headerlink\" title=\"五、Terminal 中用打开当前路径的文件夹\"></a>五、Terminal 中用打开当前路径的文件夹</h1><p>在  <code>Terminal</code>  中输入命令：</p>\n<p>1</p>\n<p>open .</p>\n<h1 id=\"六、剪贴文件\"><a href=\"#六、剪贴文件\" class=\"headerlink\" title=\"六、剪贴文件\"></a>六、剪贴文件</h1><p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<h1 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h1><p>Command + c</p>\n<h1 id=\"剪切到当前目录\"><a href=\"#剪切到当前目录\" class=\"headerlink\" title=\"剪切到当前目录\"></a>剪切到当前目录</h1><p>Command + Option + v</p>\n<h1 id=\"七、快速打开最小化程序\"><a href=\"#七、快速打开最小化程序\" class=\"headerlink\" title=\"七、快速打开最小化程序\"></a>七、快速打开最小化程序</h1><p><code>Command + Tab</code>  切换程序的时候，最小化的程序不自动弹出窗口，解决办法如下：</p>\n<ul>\n<li>用  <code>Command + Tab</code>  切换到要打开的程序</li>\n<li>先松开  <code>Tab</code>  键，不要松开  <code>Command</code>  键</li>\n<li>然后按住  <code>Option</code>  键</li>\n<li>然后依次松开  <code>Command</code>  和  <code>Option</code>  键</li>\n</ul>\n<p>如上操作就可以快速打开最小化的程序了。</p>\n<h1 id=\"八、常用快捷键\"><a href=\"#八、常用快捷键\" class=\"headerlink\" title=\"八、常用快捷键\"></a>八、常用快捷键</h1><p><a href=\"https://support.apple.com/zh-cn/HT201236\" target=\"_blank\" rel=\"noopener\">Mac 键盘快捷键官方参考</a></p>\n<p>功能</p>\n<p>快捷键</p>\n<p>预览文件</p>\n<p><code>空格</code></p>\n<p>重命名</p>\n<p><code>Enter</code></p>\n<p>打开文件</p>\n<p><code>Command + o</code>、<code>Command + ↓</code></p>\n<p>显示桌面</p>\n<p><code>F11</code></p>\n<p>切换窗口全屏状态</p>\n<p><code>Ctrl + Cmmad + f</code></p>\n<p>影藏 / 显示 Dock</p>\n<p><code>Command + Option + d</code></p>\n<p>输入 emoji 表情</p>\n<p><code>Ctrl + Cmmad + 空格</code></p>\n<h1 id=\"九、-DS-Store-文件处理\"><a href=\"#九、-DS-Store-文件处理\" class=\"headerlink\" title=\"九、.DS_Store 文件处理\"></a>九、.DS_Store 文件处理</h1><p><a href=\"https://zh.wikipedia.org/wiki/.DS_Store\" target=\"_blank\" rel=\"noopener\">.DS_Store (英文全称 Desktop Services Store) 是一种由苹果公司的 Mac OS X 操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。</a></p>\n<h2 id=\"9-1-清除文件\"><a href=\"#9-1-清除文件\" class=\"headerlink\" title=\"9.1 清除文件\"></a>9.1 清除文件</h2><p>清除命令：</p>\n<p><code>sudo find / -name &quot;.DS_Store&quot; -depth -exec rm {} \\;</code></p>\n<h2 id=\"9-2-禁用或启用自动生成\"><a href=\"#9-2-禁用或启用自动生成\" class=\"headerlink\" title=\"9.2 禁用或启用自动生成\"></a>9.2 禁用或启用自动生成</h2><p>执行以下命令，回车执行，重启 Mac 即可生效。</p>\n<ul>\n<li>禁止. DS_store 生成：</li>\n</ul>\n<p><code>defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE</code></p>\n<ul>\n<li>恢复. DS_store 生成：</li>\n</ul>\n<p><code>defaults delete com.apple.desktopservices DSDontWriteNetworkStores</code></p>\n<h1 id=\"十、NTFS-格式移动盘写入文件\"><a href=\"#十、NTFS-格式移动盘写入文件\" class=\"headerlink\" title=\"十、NTFS 格式移动盘写入文件\"></a>十、NTFS 格式移动盘写入文件</h1><p>一般来说，MacOS 是不支持 NTFS 格式磁盘的写入，可以借助三方工具，例如：Tuxera NTFS，不过收费还挺高的。这里介绍一种方法，不需要借助三方工具也可以实现 NTFS 格式磁盘写入。（基于系统版本  <code>macOS Sierra 10.12.4</code>  亲测可行）</p>\n<ul>\n<li><p>插入移动硬盘，终端输入命令：<code>$ diskutil list</code>  查看移动硬盘名称。例如：</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>$ diskutil list</p>\n<p>….</p>\n<p>/dev/disk2 (external, physical):</p>\n<p>#: TYPE NAME SIZE IDENTIFIER</p>\n<p>0: FDisk_partition_scheme *500.1 GB disk2</p>\n<p>1: Windows_NTFS EHLXR 500.1 GB disk2s4</p>\n</li>\n<li><p>编辑系统文件  <code>sudo vim /etc/fstab</code> ，写入以下内容，然后保存。</p>\n<p>1</p>\n<p>LABEL=EHLXR none ntfs rw,auto,nobrowse</p>\n<p>其中  <code>EHLXR</code>  为移动硬盘名称。</p>\n</li>\n<li><p>推出硬盘重新插入，这时候桌面已不再显示移动硬盘图标。</p>\n</li>\n<li><p>在 Finder 中通过快捷键  <code>Command + Shift + g</code>  输入<code>/Volumes</code>  就可以重新看到移动硬盘，这时候打开移动硬盘就可以写入文件了。</p>\n</li>\n<li><p>为了方便起见，可以通过命令：<code>sudo ln -s /Volumes ~/Desktop/Volumes</code>  在桌面建立快捷方式，方便查看。</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<blockquote>\n<p>Mac 系统日常使用技巧归纳总结。</p>\n</blockquote>\n<h1 id=\"一、Mac-中-Finder-显示、关闭隐藏文件\"><a href=\"#一、Mac-中-Finder-显示、关闭隐藏文件\" class=\"headerlink\" title=\"一、Mac 中 Finder 显示、关闭隐藏文件\"></a>一、Mac 中 Finder 显示、关闭隐藏文件</h1><h2 id=\"1-1-终端命令模式\"><a href=\"#1-1-终端命令模式\" class=\"headerlink\" title=\"1.1 终端命令模式\"></a>1.1 终端命令模式</h2><ul>\n<li><p>打开终端，输入：</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<h1 id=\"此命令显示隐藏文件\"><a href=\"#此命令显示隐藏文件\" class=\"headerlink\" title=\"此命令显示隐藏文件\"></a>此命令显示隐藏文件</h1><p>defaults write com.apple.finder AppleShowAllFiles -bool true</p>\n<h1 id=\"此命令关闭显示隐藏文件\"><a href=\"#此命令关闭显示隐藏文件\" class=\"headerlink\" title=\"此命令关闭显示隐藏文件\"></a>此命令关闭显示隐藏文件</h1><p>defaults write com.apple.finder AppleShowAllFiles -bool false</p>\n</li>\n<li><p>命令运行之后需要重新加载 Finder</p>\n<p>快捷键  <code>Option + Command + ESC</code>，选中  <code>Finder</code>，重新启动即可</p>\n</li>\n</ul>\n<h2 id=\"1-2-Finder-快捷键\"><a href=\"#1-2-Finder-快捷键\" class=\"headerlink\" title=\"1.2 Finder 快捷键\"></a>1.2 Finder 快捷键</h2><p>在 macOS Sierra（10.12） 版本的系统中，我们可以使用快捷键<code>⌘⇧.</code>(<code>Command + Shift + .</code>) 来快速（在 Finder 中）显示和隐藏隐藏文件了。</p>\n<h1 id=\"二、Terminal-中使用-Sublime-打开文件\"><a href=\"#二、Terminal-中使用-Sublime-打开文件\" class=\"headerlink\" title=\"二、Terminal 中使用 Sublime 打开文件\"></a>二、Terminal 中使用 Sublime 打开文件</h1><h2 id=\"2-1-如果使用默认-Shell\"><a href=\"#2-1-如果使用默认-Shell\" class=\"headerlink\" title=\"2.1 如果使用默认 Shell\"></a>2.1 如果使用默认 Shell</h2><p>在  <code>Terminal</code>  输入以下命令：</p>\n<p>1</p>\n<p>sudo ln -s “/Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl” /usr/bin/subl</p>\n<h2 id=\"2-2-如果使用-zsh\"><a href=\"#2-2-如果使用-zsh\" class=\"headerlink\" title=\"2.2 如果使用 zsh\"></a>2.2 如果使用 zsh</h2><p>在文件  <code>~/.zshrc</code>  最后添加</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>alias subl=”‘/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl’”</p>\n<p>alias nano=”subl”</p>\n<p>export EDITOR=”subl”</p>\n<p>然后在  <code>Terminal</code>  中使用  <code>subl</code>  就可以打开  <code>Sublime</code>  了。</p>\n<h2 id=\"2-3-使用-Sublime-打开指定的文件\"><a href=\"#2-3-使用-Sublime-打开指定的文件\" class=\"headerlink\" title=\"2.3 使用 Sublime 打开指定的文件\"></a>2.3 使用 Sublime 打开指定的文件</h2><p>1</p>\n<p>open -a Sublime\\ Text .m2/settings.xml</p>\n<blockquote>\n<p>可以使用  <code>Tab</code>  自定补全应用名称</p>\n</blockquote>\n<h1 id=\"三、多屏切换-dock-显示\"><a href=\"#三、多屏切换-dock-显示\" class=\"headerlink\" title=\"三、多屏切换 dock 显示\"></a>三、多屏切换 dock 显示</h1><p>如果  <code>dock</code>  在屏幕底部显示，移动鼠标到要显示  <code>dock</code>  的屏幕上，单击使屏幕处于选中状态，在屏幕底部中间部位向下滑动鼠标即可移动  <code>dock</code>  到当前屏幕上显示。</p>\n<h1 id=\"四、Terminal-重启-Finder、dock-等命令\"><a href=\"#四、Terminal-重启-Finder、dock-等命令\" class=\"headerlink\" title=\"四、Terminal 重启 Finder、dock 等命令\"></a>四、Terminal 重启 Finder、dock 等命令</h1><p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<h1 id=\"Finder-崩溃重启\"><a href=\"#Finder-崩溃重启\" class=\"headerlink\" title=\"Finder 崩溃重启\"></a>Finder 崩溃重启</h1><p>killall -kill Finder</p>\n<h1 id=\"Dock-崩溃重启\"><a href=\"#Dock-崩溃重启\" class=\"headerlink\" title=\"Dock 崩溃重启\"></a>Dock 崩溃重启</h1><p>killall -kill Dock</p>\n<h1 id=\"菜单栏崩溃重启\"><a href=\"#菜单栏崩溃重启\" class=\"headerlink\" title=\"菜单栏崩溃重启\"></a>菜单栏崩溃重启</h1><p>killall -kill SystemUIServer</p>\n<h1 id=\"五、Terminal-中用打开当前路径的文件夹\"><a href=\"#五、Terminal-中用打开当前路径的文件夹\" class=\"headerlink\" title=\"五、Terminal 中用打开当前路径的文件夹\"></a>五、Terminal 中用打开当前路径的文件夹</h1><p>在  <code>Terminal</code>  中输入命令：</p>\n<p>1</p>\n<p>open .</p>\n<h1 id=\"六、剪贴文件\"><a href=\"#六、剪贴文件\" class=\"headerlink\" title=\"六、剪贴文件\"></a>六、剪贴文件</h1><p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<h1 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h1><p>Command + c</p>\n<h1 id=\"剪切到当前目录\"><a href=\"#剪切到当前目录\" class=\"headerlink\" title=\"剪切到当前目录\"></a>剪切到当前目录</h1><p>Command + Option + v</p>\n<h1 id=\"七、快速打开最小化程序\"><a href=\"#七、快速打开最小化程序\" class=\"headerlink\" title=\"七、快速打开最小化程序\"></a>七、快速打开最小化程序</h1><p><code>Command + Tab</code>  切换程序的时候，最小化的程序不自动弹出窗口，解决办法如下：</p>\n<ul>\n<li>用  <code>Command + Tab</code>  切换到要打开的程序</li>\n<li>先松开  <code>Tab</code>  键，不要松开  <code>Command</code>  键</li>\n<li>然后按住  <code>Option</code>  键</li>\n<li>然后依次松开  <code>Command</code>  和  <code>Option</code>  键</li>\n</ul>\n<p>如上操作就可以快速打开最小化的程序了。</p>\n<h1 id=\"八、常用快捷键\"><a href=\"#八、常用快捷键\" class=\"headerlink\" title=\"八、常用快捷键\"></a>八、常用快捷键</h1><p><a href=\"https://support.apple.com/zh-cn/HT201236\" target=\"_blank\" rel=\"noopener\">Mac 键盘快捷键官方参考</a></p>\n<p>功能</p>\n<p>快捷键</p>\n<p>预览文件</p>\n<p><code>空格</code></p>\n<p>重命名</p>\n<p><code>Enter</code></p>\n<p>打开文件</p>\n<p><code>Command + o</code>、<code>Command + ↓</code></p>\n<p>显示桌面</p>\n<p><code>F11</code></p>\n<p>切换窗口全屏状态</p>\n<p><code>Ctrl + Cmmad + f</code></p>\n<p>影藏 / 显示 Dock</p>\n<p><code>Command + Option + d</code></p>\n<p>输入 emoji 表情</p>\n<p><code>Ctrl + Cmmad + 空格</code></p>\n<h1 id=\"九、-DS-Store-文件处理\"><a href=\"#九、-DS-Store-文件处理\" class=\"headerlink\" title=\"九、.DS_Store 文件处理\"></a>九、.DS_Store 文件处理</h1><p><a href=\"https://zh.wikipedia.org/wiki/.DS_Store\" target=\"_blank\" rel=\"noopener\">.DS_Store (英文全称 Desktop Services Store) 是一种由苹果公司的 Mac OS X 操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。</a></p>\n<h2 id=\"9-1-清除文件\"><a href=\"#9-1-清除文件\" class=\"headerlink\" title=\"9.1 清除文件\"></a>9.1 清除文件</h2><p>清除命令：</p>\n<p><code>sudo find / -name &quot;.DS_Store&quot; -depth -exec rm {} \\;</code></p>\n<h2 id=\"9-2-禁用或启用自动生成\"><a href=\"#9-2-禁用或启用自动生成\" class=\"headerlink\" title=\"9.2 禁用或启用自动生成\"></a>9.2 禁用或启用自动生成</h2><p>执行以下命令，回车执行，重启 Mac 即可生效。</p>\n<ul>\n<li>禁止. DS_store 生成：</li>\n</ul>\n<p><code>defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE</code></p>\n<ul>\n<li>恢复. DS_store 生成：</li>\n</ul>\n<p><code>defaults delete com.apple.desktopservices DSDontWriteNetworkStores</code></p>\n<h1 id=\"十、NTFS-格式移动盘写入文件\"><a href=\"#十、NTFS-格式移动盘写入文件\" class=\"headerlink\" title=\"十、NTFS 格式移动盘写入文件\"></a>十、NTFS 格式移动盘写入文件</h1><p>一般来说，MacOS 是不支持 NTFS 格式磁盘的写入，可以借助三方工具，例如：Tuxera NTFS，不过收费还挺高的。这里介绍一种方法，不需要借助三方工具也可以实现 NTFS 格式磁盘写入。（基于系统版本  <code>macOS Sierra 10.12.4</code>  亲测可行）</p>\n<ul>\n<li><p>插入移动硬盘，终端输入命令：<code>$ diskutil list</code>  查看移动硬盘名称。例如：</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>$ diskutil list</p>\n<p>….</p>\n<p>/dev/disk2 (external, physical):</p>\n<p>#: TYPE NAME SIZE IDENTIFIER</p>\n<p>0: FDisk_partition_scheme *500.1 GB disk2</p>\n<p>1: Windows_NTFS EHLXR 500.1 GB disk2s4</p>\n</li>\n<li><p>编辑系统文件  <code>sudo vim /etc/fstab</code> ，写入以下内容，然后保存。</p>\n<p>1</p>\n<p>LABEL=EHLXR none ntfs rw,auto,nobrowse</p>\n<p>其中  <code>EHLXR</code>  为移动硬盘名称。</p>\n</li>\n<li><p>推出硬盘重新插入，这时候桌面已不再显示移动硬盘图标。</p>\n</li>\n<li><p>在 Finder 中通过快捷键  <code>Command + Shift + g</code>  输入<code>/Volumes</code>  就可以重新看到移动硬盘，这时候打开移动硬盘就可以写入文件了。</p>\n</li>\n<li><p>为了方便起见，可以通过命令：<code>sudo ln -s /Volumes ~/Desktop/Volumes</code>  在桌面建立快捷方式，方便查看。</p>\n</li>\n</ul>\n"},{"title":"Mac 快捷键","date":"2018-03-16T01:24:00.000Z","_content":"\n作者：Macin  \n链接：https://www.zhihu.com/question/26379660/answer/32645377  \n来源：知乎  \n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n- 先热个身，CMD+Shift+K 打出  ，不限输入法。\n- 在 iTunes 搜索框输入内容后“Option+回车”可直接搜索 iTunes Store 。\n- 看网页或者文本的时候按一下方向键，指针就消失了。按 Tab 键也能变相实现。\n- “打印”选项（CMD+P）可以把网页、文本、图片等存储为 PDF 格式。\n- 『系统的最小音量』先按 F11 把音量降到最低，之后按一下 F10(静音按钮)，这时候，音量就变成最小了（比 1/4 音量还小，此时荧幕仍然显示零格，但是非静音）。\n- 『1/4 进度调整音量和亮度』按 F10/F11 或者 F1/F2 的时候同时按住 CMD+Shift。\n- 不想用第三方下载器下载东西，那就 CMD+C 链接，在 Safari 下载窗口里 CMD+V。\n- Option+点击 Dock 上的图标，可打开此程序或文件夹所在的目录。\n- Soptlight 的快捷键是 Control+Space ，打开搜索项所在目录的快捷键是选蓝后按 CMD+Enter 。\n- 想快速找到当前 Finder 窗口下的某个文件，直接键盘打它首字母即可，想更精确？快速打前几个字母，甚至是支持汉字的，用中文输入法的可以试下。\n- 当右键-打开方式有很多选项的时候，快速输入首字母或几个字母可以快速把光标锁定在目标上，和 Finder 窗口的一样。注：这个需要在英文输入状态下，不支持汉字。\n- “移到废纸篓”的快捷键是 CMD+Del ，那在“废纸篓”里“放回原处”的快捷键是什么呢？还是 CMD+Del 。\n- 『 如何只留一种输入法』 先把”越南文输入法 UniKey”打开(看清不是那个越南文)，然后把“美国英语”前面的沟去掉（这个时候才可以去掉），再把“越南文输入法”关掉，然后就只剩搜狗拼音或者 QQ 拼音百度拼音什么的了。\n- 雪豹下长按 Dock 栏图标显示此程序所有窗口的功能，在 Lion 和 ML 下的操作变成双指轻拍 Dock 栏图标，MagicMouse 对应的手势也是双指轻拍。在 Lion 和 ML 下也可以更改为在 Dock 栏上滚动鼠标中键，参照下文终端第 N 条。\n- 光标在地址栏的前提下，CMD+Del 可直接清空地址栏，我之前一直用的 CMD+L ，再 Del 的。\n- 『OS X 的第二套剪切/粘贴的快捷键』Control+K，Control+Y 。它其实是命令行快捷键，它不会改写剪切板中已经存在的内容，而且剪切走的内容只能粘贴出纯文本，不附加多余的样式。多用于 Markdown 编辑软件，比如 Mou，VIM 等，OS X 内置的“文本编辑”和“终端”也可用这套快捷键，不支持 Pages，Word。\n- 『移动文件』CMD+C 复制文件，在目标目录 CMD+Option+V，就把原文件移动过来了，相当于剪切粘贴。\n- 不同磁盘间拖动文件，Finder 会默认复制一份过去，按住 CMD+拖动，可实现不复制直接移动。\n- 按住 CMD+ Option+拖到文件，可快速“制作替身”。\n- 按住 Option+拖到文件，可快速复制一份原文件。\n- 在预览里选择导出格式时候，按 Option 点开会出现更多格式。\n- 两个同名文件夹，按住 Option 拖动才会出现“合并”选项，否则只能“替换”。\n- 『如何打出带声调的字母』在“美国英文”输入法下面，一直按下键盘上部分单个英文字母即可。\n- Option+双击文件夹，强制本窗口打开文件夹。\n- CMD+双击文件夹，强制新窗口打开文件夹。\n- Option+点击链接，用 Safari 下载链接。\n- Safari 下浏览多页面时，左右剪头可以翻页。\n- Control+Option+CMD+B，更换 Launchpad 背景显示模式：模糊、清晰、黑白、彩色。\n- Launchpad 也可以直接按键盘开始搜索了。\n- Finder 侧边栏、工具栏，均可拖文件夹、应用程序等上去，相当于快捷方式，CMD+拖出即去掉。\n- 菜单栏的部分图标可用 CMD+拖拽来调整位置，CMD+拖出即可去掉。\n- Option+F1/F2/F3/… 即可快速打开相对应的偏好设置。\n- 长按 QuickLook 右上角的“用 xx 打开”，可出现打开方式列表。\n- Mac 下的反向 Tab：Option+Shift+Tab。\n- CMD+Tab 和 CMD+`可正向反向切换后台，同时按 CMD+Q 或者 CMD+H 可配合关闭、隐藏应用程序。\n- 在选取本地文件时候，比如上传到网盘，嫌在选取对话框中一层层选取文件太麻烦，可以直接把文件拖到对话框里。同样在保存文件选取目录时候，也可直接把目标文件夹拖到路径栏里。\n- 预览中按“`”(1 左边那个)可调出放大镜。\n- Option+空格 是全屏 QuickLook。\n- Option+左键点击 Dock 上的已开启的应用程序图标，可隐藏对应的程序。\n- Option+右键 Dock 已运行程序会出现强制关闭。\n- Option+右键文件可快速更改默认打开方式。\n- 在 Finder 中按住 Option 然后 4 指左右滑动触控板是前进后退，对应的 MagicMouse 手势是，按住 Option 然后双指左右滑动，键盘是 CMD + \\[ 和 CMD + \\] 。\n- Photo Booth 自拍，按住 Option 不读秒。\n- Finder 的“前往”菜单里，按住 Option 才会显示用户名的资源库。\n- iTunes 下，按住 Option 点加号按钮是最大化，非全屏，重复操作，恢复大小。\n- 按住 Option 双击 iTunes 和 iPhoto，可出现选择资料库对话框。\n- iTunes 菜单栏“文件”下的“显示重复歌曲”，按住 Option 会变成“显示完全重复歌曲”。\n- iWork 套件，浏览所有版本，然后点击老版本的下拉箭头会显示“删除此版本”，按住 Option 显示删除旧版本，即所有版本。\n- 可能你和我一样经常要改歌曲的 ID3，那在 iTunes 歌曲的“显示简介”下，“上一个”和“下一个”分别对应的快捷键是“CMD+P”和”CMD+N”。\n- 长按 Safari 的标签项，可快速重命名。\n- 一般来说，在 iTunes 播放列表中删除歌曲只是从列表中移除，但按住 Option 键删除，可以直接将列表中的歌曲从曲库删除。\n- Control+左键点击相当于右键。\n- 在系统偏好设置-显示器的面板下，按住 Option 可出现“检测显示器”的选项。\n- 一直按着 Option+CMD 启动系统偏好设置（如果之前已经启动，请关掉再试），然后进显示器面板，会多了“旋转”选项。\n- 『把 iMac 当外界显示器』CMD+F2，进入/离开 iMac 的 Target Display 即外界显示器模式。实测 21、27 均可，而不是官方宣称的只有 27 才支持。\n- 在“桌面与屏幕保护程序”面板下，可以直接把当前壁纸拖出来。\n","source":"_posts/2018-03-16-Mac 快捷键.md","raw":"---\ntitle: Mac 快捷键\ntags:\n  - 工具\ndate: 2018-03-16 09:24:00\ncategories: 教程\n---\n\n作者：Macin  \n链接：https://www.zhihu.com/question/26379660/answer/32645377  \n来源：知乎  \n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n- 先热个身，CMD+Shift+K 打出  ，不限输入法。\n- 在 iTunes 搜索框输入内容后“Option+回车”可直接搜索 iTunes Store 。\n- 看网页或者文本的时候按一下方向键，指针就消失了。按 Tab 键也能变相实现。\n- “打印”选项（CMD+P）可以把网页、文本、图片等存储为 PDF 格式。\n- 『系统的最小音量』先按 F11 把音量降到最低，之后按一下 F10(静音按钮)，这时候，音量就变成最小了（比 1/4 音量还小，此时荧幕仍然显示零格，但是非静音）。\n- 『1/4 进度调整音量和亮度』按 F10/F11 或者 F1/F2 的时候同时按住 CMD+Shift。\n- 不想用第三方下载器下载东西，那就 CMD+C 链接，在 Safari 下载窗口里 CMD+V。\n- Option+点击 Dock 上的图标，可打开此程序或文件夹所在的目录。\n- Soptlight 的快捷键是 Control+Space ，打开搜索项所在目录的快捷键是选蓝后按 CMD+Enter 。\n- 想快速找到当前 Finder 窗口下的某个文件，直接键盘打它首字母即可，想更精确？快速打前几个字母，甚至是支持汉字的，用中文输入法的可以试下。\n- 当右键-打开方式有很多选项的时候，快速输入首字母或几个字母可以快速把光标锁定在目标上，和 Finder 窗口的一样。注：这个需要在英文输入状态下，不支持汉字。\n- “移到废纸篓”的快捷键是 CMD+Del ，那在“废纸篓”里“放回原处”的快捷键是什么呢？还是 CMD+Del 。\n- 『 如何只留一种输入法』 先把”越南文输入法 UniKey”打开(看清不是那个越南文)，然后把“美国英语”前面的沟去掉（这个时候才可以去掉），再把“越南文输入法”关掉，然后就只剩搜狗拼音或者 QQ 拼音百度拼音什么的了。\n- 雪豹下长按 Dock 栏图标显示此程序所有窗口的功能，在 Lion 和 ML 下的操作变成双指轻拍 Dock 栏图标，MagicMouse 对应的手势也是双指轻拍。在 Lion 和 ML 下也可以更改为在 Dock 栏上滚动鼠标中键，参照下文终端第 N 条。\n- 光标在地址栏的前提下，CMD+Del 可直接清空地址栏，我之前一直用的 CMD+L ，再 Del 的。\n- 『OS X 的第二套剪切/粘贴的快捷键』Control+K，Control+Y 。它其实是命令行快捷键，它不会改写剪切板中已经存在的内容，而且剪切走的内容只能粘贴出纯文本，不附加多余的样式。多用于 Markdown 编辑软件，比如 Mou，VIM 等，OS X 内置的“文本编辑”和“终端”也可用这套快捷键，不支持 Pages，Word。\n- 『移动文件』CMD+C 复制文件，在目标目录 CMD+Option+V，就把原文件移动过来了，相当于剪切粘贴。\n- 不同磁盘间拖动文件，Finder 会默认复制一份过去，按住 CMD+拖动，可实现不复制直接移动。\n- 按住 CMD+ Option+拖到文件，可快速“制作替身”。\n- 按住 Option+拖到文件，可快速复制一份原文件。\n- 在预览里选择导出格式时候，按 Option 点开会出现更多格式。\n- 两个同名文件夹，按住 Option 拖动才会出现“合并”选项，否则只能“替换”。\n- 『如何打出带声调的字母』在“美国英文”输入法下面，一直按下键盘上部分单个英文字母即可。\n- Option+双击文件夹，强制本窗口打开文件夹。\n- CMD+双击文件夹，强制新窗口打开文件夹。\n- Option+点击链接，用 Safari 下载链接。\n- Safari 下浏览多页面时，左右剪头可以翻页。\n- Control+Option+CMD+B，更换 Launchpad 背景显示模式：模糊、清晰、黑白、彩色。\n- Launchpad 也可以直接按键盘开始搜索了。\n- Finder 侧边栏、工具栏，均可拖文件夹、应用程序等上去，相当于快捷方式，CMD+拖出即去掉。\n- 菜单栏的部分图标可用 CMD+拖拽来调整位置，CMD+拖出即可去掉。\n- Option+F1/F2/F3/… 即可快速打开相对应的偏好设置。\n- 长按 QuickLook 右上角的“用 xx 打开”，可出现打开方式列表。\n- Mac 下的反向 Tab：Option+Shift+Tab。\n- CMD+Tab 和 CMD+`可正向反向切换后台，同时按 CMD+Q 或者 CMD+H 可配合关闭、隐藏应用程序。\n- 在选取本地文件时候，比如上传到网盘，嫌在选取对话框中一层层选取文件太麻烦，可以直接把文件拖到对话框里。同样在保存文件选取目录时候，也可直接把目标文件夹拖到路径栏里。\n- 预览中按“`”(1 左边那个)可调出放大镜。\n- Option+空格 是全屏 QuickLook。\n- Option+左键点击 Dock 上的已开启的应用程序图标，可隐藏对应的程序。\n- Option+右键 Dock 已运行程序会出现强制关闭。\n- Option+右键文件可快速更改默认打开方式。\n- 在 Finder 中按住 Option 然后 4 指左右滑动触控板是前进后退，对应的 MagicMouse 手势是，按住 Option 然后双指左右滑动，键盘是 CMD + \\[ 和 CMD + \\] 。\n- Photo Booth 自拍，按住 Option 不读秒。\n- Finder 的“前往”菜单里，按住 Option 才会显示用户名的资源库。\n- iTunes 下，按住 Option 点加号按钮是最大化，非全屏，重复操作，恢复大小。\n- 按住 Option 双击 iTunes 和 iPhoto，可出现选择资料库对话框。\n- iTunes 菜单栏“文件”下的“显示重复歌曲”，按住 Option 会变成“显示完全重复歌曲”。\n- iWork 套件，浏览所有版本，然后点击老版本的下拉箭头会显示“删除此版本”，按住 Option 显示删除旧版本，即所有版本。\n- 可能你和我一样经常要改歌曲的 ID3，那在 iTunes 歌曲的“显示简介”下，“上一个”和“下一个”分别对应的快捷键是“CMD+P”和”CMD+N”。\n- 长按 Safari 的标签项，可快速重命名。\n- 一般来说，在 iTunes 播放列表中删除歌曲只是从列表中移除，但按住 Option 键删除，可以直接将列表中的歌曲从曲库删除。\n- Control+左键点击相当于右键。\n- 在系统偏好设置-显示器的面板下，按住 Option 可出现“检测显示器”的选项。\n- 一直按着 Option+CMD 启动系统偏好设置（如果之前已经启动，请关掉再试），然后进显示器面板，会多了“旋转”选项。\n- 『把 iMac 当外界显示器』CMD+F2，进入/离开 iMac 的 Target Display 即外界显示器模式。实测 21、27 均可，而不是官方宣称的只有 27 才支持。\n- 在“桌面与屏幕保护程序”面板下，可以直接把当前壁纸拖出来。\n","slug":"2018-03-16-Mac 快捷键","published":1,"updated":"2020-03-14T06:50:59.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvl000294k8y9nsf6xzw","content":"<p>作者：Macin<br>链接：<a href=\"https://www.zhihu.com/question/26379660/answer/32645377\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/26379660/answer/32645377</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<ul>\n<li>先热个身，CMD+Shift+K 打出  ，不限输入法。</li>\n<li>在 iTunes 搜索框输入内容后“Option+回车”可直接搜索 iTunes Store 。</li>\n<li>看网页或者文本的时候按一下方向键，指针就消失了。按 Tab 键也能变相实现。</li>\n<li>“打印”选项（CMD+P）可以把网页、文本、图片等存储为 PDF 格式。</li>\n<li>『系统的最小音量』先按 F11 把音量降到最低，之后按一下 F10(静音按钮)，这时候，音量就变成最小了（比 1/4 音量还小，此时荧幕仍然显示零格，但是非静音）。</li>\n<li>『1/4 进度调整音量和亮度』按 F10/F11 或者 F1/F2 的时候同时按住 CMD+Shift。</li>\n<li>不想用第三方下载器下载东西，那就 CMD+C 链接，在 Safari 下载窗口里 CMD+V。</li>\n<li>Option+点击 Dock 上的图标，可打开此程序或文件夹所在的目录。</li>\n<li>Soptlight 的快捷键是 Control+Space ，打开搜索项所在目录的快捷键是选蓝后按 CMD+Enter 。</li>\n<li>想快速找到当前 Finder 窗口下的某个文件，直接键盘打它首字母即可，想更精确？快速打前几个字母，甚至是支持汉字的，用中文输入法的可以试下。</li>\n<li>当右键-打开方式有很多选项的时候，快速输入首字母或几个字母可以快速把光标锁定在目标上，和 Finder 窗口的一样。注：这个需要在英文输入状态下，不支持汉字。</li>\n<li>“移到废纸篓”的快捷键是 CMD+Del ，那在“废纸篓”里“放回原处”的快捷键是什么呢？还是 CMD+Del 。</li>\n<li>『 如何只留一种输入法』 先把”越南文输入法 UniKey”打开(看清不是那个越南文)，然后把“美国英语”前面的沟去掉（这个时候才可以去掉），再把“越南文输入法”关掉，然后就只剩搜狗拼音或者 QQ 拼音百度拼音什么的了。</li>\n<li>雪豹下长按 Dock 栏图标显示此程序所有窗口的功能，在 Lion 和 ML 下的操作变成双指轻拍 Dock 栏图标，MagicMouse 对应的手势也是双指轻拍。在 Lion 和 ML 下也可以更改为在 Dock 栏上滚动鼠标中键，参照下文终端第 N 条。</li>\n<li>光标在地址栏的前提下，CMD+Del 可直接清空地址栏，我之前一直用的 CMD+L ，再 Del 的。</li>\n<li>『OS X 的第二套剪切/粘贴的快捷键』Control+K，Control+Y 。它其实是命令行快捷键，它不会改写剪切板中已经存在的内容，而且剪切走的内容只能粘贴出纯文本，不附加多余的样式。多用于 Markdown 编辑软件，比如 Mou，VIM 等，OS X 内置的“文本编辑”和“终端”也可用这套快捷键，不支持 Pages，Word。</li>\n<li>『移动文件』CMD+C 复制文件，在目标目录 CMD+Option+V，就把原文件移动过来了，相当于剪切粘贴。</li>\n<li>不同磁盘间拖动文件，Finder 会默认复制一份过去，按住 CMD+拖动，可实现不复制直接移动。</li>\n<li>按住 CMD+ Option+拖到文件，可快速“制作替身”。</li>\n<li>按住 Option+拖到文件，可快速复制一份原文件。</li>\n<li>在预览里选择导出格式时候，按 Option 点开会出现更多格式。</li>\n<li>两个同名文件夹，按住 Option 拖动才会出现“合并”选项，否则只能“替换”。</li>\n<li>『如何打出带声调的字母』在“美国英文”输入法下面，一直按下键盘上部分单个英文字母即可。</li>\n<li>Option+双击文件夹，强制本窗口打开文件夹。</li>\n<li>CMD+双击文件夹，强制新窗口打开文件夹。</li>\n<li>Option+点击链接，用 Safari 下载链接。</li>\n<li>Safari 下浏览多页面时，左右剪头可以翻页。</li>\n<li>Control+Option+CMD+B，更换 Launchpad 背景显示模式：模糊、清晰、黑白、彩色。</li>\n<li>Launchpad 也可以直接按键盘开始搜索了。</li>\n<li>Finder 侧边栏、工具栏，均可拖文件夹、应用程序等上去，相当于快捷方式，CMD+拖出即去掉。</li>\n<li>菜单栏的部分图标可用 CMD+拖拽来调整位置，CMD+拖出即可去掉。</li>\n<li>Option+F1/F2/F3/… 即可快速打开相对应的偏好设置。</li>\n<li>长按 QuickLook 右上角的“用 xx 打开”，可出现打开方式列表。</li>\n<li>Mac 下的反向 Tab：Option+Shift+Tab。</li>\n<li>CMD+Tab 和 CMD+`可正向反向切换后台，同时按 CMD+Q 或者 CMD+H 可配合关闭、隐藏应用程序。</li>\n<li>在选取本地文件时候，比如上传到网盘，嫌在选取对话框中一层层选取文件太麻烦，可以直接把文件拖到对话框里。同样在保存文件选取目录时候，也可直接把目标文件夹拖到路径栏里。</li>\n<li>预览中按“`”(1 左边那个)可调出放大镜。</li>\n<li>Option+空格 是全屏 QuickLook。</li>\n<li>Option+左键点击 Dock 上的已开启的应用程序图标，可隐藏对应的程序。</li>\n<li>Option+右键 Dock 已运行程序会出现强制关闭。</li>\n<li>Option+右键文件可快速更改默认打开方式。</li>\n<li>在 Finder 中按住 Option 然后 4 指左右滑动触控板是前进后退，对应的 MagicMouse 手势是，按住 Option 然后双指左右滑动，键盘是 CMD + [ 和 CMD + ] 。</li>\n<li>Photo Booth 自拍，按住 Option 不读秒。</li>\n<li>Finder 的“前往”菜单里，按住 Option 才会显示用户名的资源库。</li>\n<li>iTunes 下，按住 Option 点加号按钮是最大化，非全屏，重复操作，恢复大小。</li>\n<li>按住 Option 双击 iTunes 和 iPhoto，可出现选择资料库对话框。</li>\n<li>iTunes 菜单栏“文件”下的“显示重复歌曲”，按住 Option 会变成“显示完全重复歌曲”。</li>\n<li>iWork 套件，浏览所有版本，然后点击老版本的下拉箭头会显示“删除此版本”，按住 Option 显示删除旧版本，即所有版本。</li>\n<li>可能你和我一样经常要改歌曲的 ID3，那在 iTunes 歌曲的“显示简介”下，“上一个”和“下一个”分别对应的快捷键是“CMD+P”和”CMD+N”。</li>\n<li>长按 Safari 的标签项，可快速重命名。</li>\n<li>一般来说，在 iTunes 播放列表中删除歌曲只是从列表中移除，但按住 Option 键删除，可以直接将列表中的歌曲从曲库删除。</li>\n<li>Control+左键点击相当于右键。</li>\n<li>在系统偏好设置-显示器的面板下，按住 Option 可出现“检测显示器”的选项。</li>\n<li>一直按着 Option+CMD 启动系统偏好设置（如果之前已经启动，请关掉再试），然后进显示器面板，会多了“旋转”选项。</li>\n<li>『把 iMac 当外界显示器』CMD+F2，进入/离开 iMac 的 Target Display 即外界显示器模式。实测 21、27 均可，而不是官方宣称的只有 27 才支持。</li>\n<li>在“桌面与屏幕保护程序”面板下，可以直接把当前壁纸拖出来。</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>作者：Macin<br>链接：<a href=\"https://www.zhihu.com/question/26379660/answer/32645377\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/26379660/answer/32645377</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<ul>\n<li>先热个身，CMD+Shift+K 打出  ，不限输入法。</li>\n<li>在 iTunes 搜索框输入内容后“Option+回车”可直接搜索 iTunes Store 。</li>\n<li>看网页或者文本的时候按一下方向键，指针就消失了。按 Tab 键也能变相实现。</li>\n<li>“打印”选项（CMD+P）可以把网页、文本、图片等存储为 PDF 格式。</li>\n<li>『系统的最小音量』先按 F11 把音量降到最低，之后按一下 F10(静音按钮)，这时候，音量就变成最小了（比 1/4 音量还小，此时荧幕仍然显示零格，但是非静音）。</li>\n<li>『1/4 进度调整音量和亮度』按 F10/F11 或者 F1/F2 的时候同时按住 CMD+Shift。</li>\n<li>不想用第三方下载器下载东西，那就 CMD+C 链接，在 Safari 下载窗口里 CMD+V。</li>\n<li>Option+点击 Dock 上的图标，可打开此程序或文件夹所在的目录。</li>\n<li>Soptlight 的快捷键是 Control+Space ，打开搜索项所在目录的快捷键是选蓝后按 CMD+Enter 。</li>\n<li>想快速找到当前 Finder 窗口下的某个文件，直接键盘打它首字母即可，想更精确？快速打前几个字母，甚至是支持汉字的，用中文输入法的可以试下。</li>\n<li>当右键-打开方式有很多选项的时候，快速输入首字母或几个字母可以快速把光标锁定在目标上，和 Finder 窗口的一样。注：这个需要在英文输入状态下，不支持汉字。</li>\n<li>“移到废纸篓”的快捷键是 CMD+Del ，那在“废纸篓”里“放回原处”的快捷键是什么呢？还是 CMD+Del 。</li>\n<li>『 如何只留一种输入法』 先把”越南文输入法 UniKey”打开(看清不是那个越南文)，然后把“美国英语”前面的沟去掉（这个时候才可以去掉），再把“越南文输入法”关掉，然后就只剩搜狗拼音或者 QQ 拼音百度拼音什么的了。</li>\n<li>雪豹下长按 Dock 栏图标显示此程序所有窗口的功能，在 Lion 和 ML 下的操作变成双指轻拍 Dock 栏图标，MagicMouse 对应的手势也是双指轻拍。在 Lion 和 ML 下也可以更改为在 Dock 栏上滚动鼠标中键，参照下文终端第 N 条。</li>\n<li>光标在地址栏的前提下，CMD+Del 可直接清空地址栏，我之前一直用的 CMD+L ，再 Del 的。</li>\n<li>『OS X 的第二套剪切/粘贴的快捷键』Control+K，Control+Y 。它其实是命令行快捷键，它不会改写剪切板中已经存在的内容，而且剪切走的内容只能粘贴出纯文本，不附加多余的样式。多用于 Markdown 编辑软件，比如 Mou，VIM 等，OS X 内置的“文本编辑”和“终端”也可用这套快捷键，不支持 Pages，Word。</li>\n<li>『移动文件』CMD+C 复制文件，在目标目录 CMD+Option+V，就把原文件移动过来了，相当于剪切粘贴。</li>\n<li>不同磁盘间拖动文件，Finder 会默认复制一份过去，按住 CMD+拖动，可实现不复制直接移动。</li>\n<li>按住 CMD+ Option+拖到文件，可快速“制作替身”。</li>\n<li>按住 Option+拖到文件，可快速复制一份原文件。</li>\n<li>在预览里选择导出格式时候，按 Option 点开会出现更多格式。</li>\n<li>两个同名文件夹，按住 Option 拖动才会出现“合并”选项，否则只能“替换”。</li>\n<li>『如何打出带声调的字母』在“美国英文”输入法下面，一直按下键盘上部分单个英文字母即可。</li>\n<li>Option+双击文件夹，强制本窗口打开文件夹。</li>\n<li>CMD+双击文件夹，强制新窗口打开文件夹。</li>\n<li>Option+点击链接，用 Safari 下载链接。</li>\n<li>Safari 下浏览多页面时，左右剪头可以翻页。</li>\n<li>Control+Option+CMD+B，更换 Launchpad 背景显示模式：模糊、清晰、黑白、彩色。</li>\n<li>Launchpad 也可以直接按键盘开始搜索了。</li>\n<li>Finder 侧边栏、工具栏，均可拖文件夹、应用程序等上去，相当于快捷方式，CMD+拖出即去掉。</li>\n<li>菜单栏的部分图标可用 CMD+拖拽来调整位置，CMD+拖出即可去掉。</li>\n<li>Option+F1/F2/F3/… 即可快速打开相对应的偏好设置。</li>\n<li>长按 QuickLook 右上角的“用 xx 打开”，可出现打开方式列表。</li>\n<li>Mac 下的反向 Tab：Option+Shift+Tab。</li>\n<li>CMD+Tab 和 CMD+`可正向反向切换后台，同时按 CMD+Q 或者 CMD+H 可配合关闭、隐藏应用程序。</li>\n<li>在选取本地文件时候，比如上传到网盘，嫌在选取对话框中一层层选取文件太麻烦，可以直接把文件拖到对话框里。同样在保存文件选取目录时候，也可直接把目标文件夹拖到路径栏里。</li>\n<li>预览中按“`”(1 左边那个)可调出放大镜。</li>\n<li>Option+空格 是全屏 QuickLook。</li>\n<li>Option+左键点击 Dock 上的已开启的应用程序图标，可隐藏对应的程序。</li>\n<li>Option+右键 Dock 已运行程序会出现强制关闭。</li>\n<li>Option+右键文件可快速更改默认打开方式。</li>\n<li>在 Finder 中按住 Option 然后 4 指左右滑动触控板是前进后退，对应的 MagicMouse 手势是，按住 Option 然后双指左右滑动，键盘是 CMD + [ 和 CMD + ] 。</li>\n<li>Photo Booth 自拍，按住 Option 不读秒。</li>\n<li>Finder 的“前往”菜单里，按住 Option 才会显示用户名的资源库。</li>\n<li>iTunes 下，按住 Option 点加号按钮是最大化，非全屏，重复操作，恢复大小。</li>\n<li>按住 Option 双击 iTunes 和 iPhoto，可出现选择资料库对话框。</li>\n<li>iTunes 菜单栏“文件”下的“显示重复歌曲”，按住 Option 会变成“显示完全重复歌曲”。</li>\n<li>iWork 套件，浏览所有版本，然后点击老版本的下拉箭头会显示“删除此版本”，按住 Option 显示删除旧版本，即所有版本。</li>\n<li>可能你和我一样经常要改歌曲的 ID3，那在 iTunes 歌曲的“显示简介”下，“上一个”和“下一个”分别对应的快捷键是“CMD+P”和”CMD+N”。</li>\n<li>长按 Safari 的标签项，可快速重命名。</li>\n<li>一般来说，在 iTunes 播放列表中删除歌曲只是从列表中移除，但按住 Option 键删除，可以直接将列表中的歌曲从曲库删除。</li>\n<li>Control+左键点击相当于右键。</li>\n<li>在系统偏好设置-显示器的面板下，按住 Option 可出现“检测显示器”的选项。</li>\n<li>一直按着 Option+CMD 启动系统偏好设置（如果之前已经启动，请关掉再试），然后进显示器面板，会多了“旋转”选项。</li>\n<li>『把 iMac 当外界显示器』CMD+F2，进入/离开 iMac 的 Target Display 即外界显示器模式。实测 21、27 均可，而不是官方宣称的只有 27 才支持。</li>\n<li>在“桌面与屏幕保护程序”面板下，可以直接把当前壁纸拖出来。</li>\n</ul>\n"},{"title":"Mac OS X 终端切换root用户","date":"2018-03-18T00:16:00.000Z","_content":"\nmac 打开终端默认是当前登录用户，若要切换到 root 用户，使用命令：\n\n第一种：(1)输入  sudo -i 或者 su - 或着 su - root  然后回车\n\n(2)输入密码，就可以进入 root 用户（因为我之前设置过一次 root，所以这里到底是输入当前登录用户的密码还是 root 用户的密码我也不是很清楚，看其他网友的博客不太一样，反正我输了一次当前用户密码就切换成功了，欢迎大家指正）。\n\n(3)这种方法的终端显示形式为：usernamedeMacBook-Pro:~ root#\n\n第二种：(1)输入 sudo su 然后回车\n\n(2)输入密码，就可以进入 root 用户\n\n(3)终端显示形式：sh-3.2#\n\n⚠️：这里两种方法进入 root 用户的终端显示不同，我并不知道有什么区别，欢迎大家告知\n\n从 root 用户进入你想登陆的普通用户的方法，这里普通用户名用 username 来举例\n\n(1)输入  su - username  然后回车\n\n(2)就可以进入 username 用户\n\n(3)这种方法的终端显示形式为：usernamedeMacBook-Pro:~ username\\$\n","source":"_posts/2018-03-18-Mac OS X 终端切换root用户.md","raw":"---\ntitle: Mac OS X 终端切换root用户\ntags:\n  - 工具\n  - 技术\ndate: 2018-03-18 08:16:00\ncategories: 教程\n---\n\nmac 打开终端默认是当前登录用户，若要切换到 root 用户，使用命令：\n\n第一种：(1)输入  sudo -i 或者 su - 或着 su - root  然后回车\n\n(2)输入密码，就可以进入 root 用户（因为我之前设置过一次 root，所以这里到底是输入当前登录用户的密码还是 root 用户的密码我也不是很清楚，看其他网友的博客不太一样，反正我输了一次当前用户密码就切换成功了，欢迎大家指正）。\n\n(3)这种方法的终端显示形式为：usernamedeMacBook-Pro:~ root#\n\n第二种：(1)输入 sudo su 然后回车\n\n(2)输入密码，就可以进入 root 用户\n\n(3)终端显示形式：sh-3.2#\n\n⚠️：这里两种方法进入 root 用户的终端显示不同，我并不知道有什么区别，欢迎大家告知\n\n从 root 用户进入你想登陆的普通用户的方法，这里普通用户名用 username 来举例\n\n(1)输入  su - username  然后回车\n\n(2)就可以进入 username 用户\n\n(3)这种方法的终端显示形式为：usernamedeMacBook-Pro:~ username\\$\n","slug":"2018-03-18-Mac OS X 终端切换root用户","published":1,"updated":"2020-03-14T06:51:16.478Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvl2002c4k8y5zp6d1yn","content":"<p>mac 打开终端默认是当前登录用户，若要切换到 root 用户，使用命令：</p>\n<p>第一种：(1)输入  sudo -i 或者 su - 或着 su - root  然后回车</p>\n<p>(2)输入密码，就可以进入 root 用户（因为我之前设置过一次 root，所以这里到底是输入当前登录用户的密码还是 root 用户的密码我也不是很清楚，看其他网友的博客不太一样，反正我输了一次当前用户密码就切换成功了，欢迎大家指正）。</p>\n<p>(3)这种方法的终端显示形式为：usernamedeMacBook-Pro:~ root#</p>\n<p>第二种：(1)输入 sudo su 然后回车</p>\n<p>(2)输入密码，就可以进入 root 用户</p>\n<p>(3)终端显示形式：sh-3.2#</p>\n<p>⚠️：这里两种方法进入 root 用户的终端显示不同，我并不知道有什么区别，欢迎大家告知</p>\n<p>从 root 用户进入你想登陆的普通用户的方法，这里普通用户名用 username 来举例</p>\n<p>(1)输入  su - username  然后回车</p>\n<p>(2)就可以进入 username 用户</p>\n<p>(3)这种方法的终端显示形式为：usernamedeMacBook-Pro:~ username$</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>mac 打开终端默认是当前登录用户，若要切换到 root 用户，使用命令：</p>\n<p>第一种：(1)输入  sudo -i 或者 su - 或着 su - root  然后回车</p>\n<p>(2)输入密码，就可以进入 root 用户（因为我之前设置过一次 root，所以这里到底是输入当前登录用户的密码还是 root 用户的密码我也不是很清楚，看其他网友的博客不太一样，反正我输了一次当前用户密码就切换成功了，欢迎大家指正）。</p>\n<p>(3)这种方法的终端显示形式为：usernamedeMacBook-Pro:~ root#</p>\n<p>第二种：(1)输入 sudo su 然后回车</p>\n<p>(2)输入密码，就可以进入 root 用户</p>\n<p>(3)终端显示形式：sh-3.2#</p>\n<p>⚠️：这里两种方法进入 root 用户的终端显示不同，我并不知道有什么区别，欢迎大家告知</p>\n<p>从 root 用户进入你想登陆的普通用户的方法，这里普通用户名用 username 来举例</p>\n<p>(1)输入  su - username  然后回车</p>\n<p>(2)就可以进入 username 用户</p>\n<p>(3)这种方法的终端显示形式为：usernamedeMacBook-Pro:~ username$</p>\n"},{"title":"vue 分享知识点","date":"2018-05-16T22:46:00.000Z","_content":"\nvue 分享模块清单\n1.Vue 2.0 之 Vue 实例和生命周期\n2.vue 2.0 之自定义指令\n3.vue 2.0 之观察者模式实现简单异步无限滚动 4.从 JavaScript 属性描述器剖析 Vue.js 响应式视图\n5.Vue 响应式及其缺陷\n6.Vue 2.0 之 Vue 中的响应式\n7.Vue 2.0 之 Vue 中的代理 Proxy 8.使用\\$refs 访问 Vue 中的 DOM\n9.Vue 2.0 之在 Vue 中使用样式\n10.Vue 2.0 之 Vue 的过滤器 11.在 Vue 中何时使用方法、计算属性\n12.Vue 2.0 之 Vue 的观察者\n13.Vue 2.0 之 Vue 的 Methods 和事件处理 14.使用 Vue 创建计算器\n15.Vue 的作用域插槽\n16.Vue 2.0 之 Vue 的模板\n17.Vue 的计算属性\n18.Vue 2.0 之 Vue 中的 computed 属性\n19.Vue 组件通讯：单个组件\n20.Vue.js 定义组件模板的七种方式\n21.Vue 2.0 之 v-bind 属性 22.在 vue 中有条件地使用 css 类\n23.Vue 2.0 之自定义表单组件\n24.Vue 2.0 之 v-model 属性\n25.Vue 的双向绑定原理及实现\n26.Vue 双向绑定的实现原理 Object.defineproperty\n27.Vue 2.0 之 v-on 属性\n28.Vue 2.0 之 v-text 和 v-html 属性\n29.Vue 2.0 之 v-for 属性\n30.Vue 2.0 之：v-if 和 v-show\n31.Vue 2.0 之 Vue 的运行环境\n32.Vue 2.0 之动画\n33.Vue 2.0 之 Vuex\n34.Vue:Vue-cli，生命周期钩子\n35.Vue:组件，Props，Slots\n36.Vue:渲染、指令和事件 37.浅谈前端状态管理 38.使用 Vue.js 和 Vuex 2.0 构建一个简单的 Todo 应用程序 39.使用 Vue.js 2 创建 To-Do App\n","source":"_posts/2018-05-17-vue 分享知识点.md","raw":"---\ntitle: vue 分享知识点\ntags:\n  - 技术\ndate: 2018-05-17 06:46:00\ncategories: 前端\n---\n\nvue 分享模块清单\n1.Vue 2.0 之 Vue 实例和生命周期\n2.vue 2.0 之自定义指令\n3.vue 2.0 之观察者模式实现简单异步无限滚动 4.从 JavaScript 属性描述器剖析 Vue.js 响应式视图\n5.Vue 响应式及其缺陷\n6.Vue 2.0 之 Vue 中的响应式\n7.Vue 2.0 之 Vue 中的代理 Proxy 8.使用\\$refs 访问 Vue 中的 DOM\n9.Vue 2.0 之在 Vue 中使用样式\n10.Vue 2.0 之 Vue 的过滤器 11.在 Vue 中何时使用方法、计算属性\n12.Vue 2.0 之 Vue 的观察者\n13.Vue 2.0 之 Vue 的 Methods 和事件处理 14.使用 Vue 创建计算器\n15.Vue 的作用域插槽\n16.Vue 2.0 之 Vue 的模板\n17.Vue 的计算属性\n18.Vue 2.0 之 Vue 中的 computed 属性\n19.Vue 组件通讯：单个组件\n20.Vue.js 定义组件模板的七种方式\n21.Vue 2.0 之 v-bind 属性 22.在 vue 中有条件地使用 css 类\n23.Vue 2.0 之自定义表单组件\n24.Vue 2.0 之 v-model 属性\n25.Vue 的双向绑定原理及实现\n26.Vue 双向绑定的实现原理 Object.defineproperty\n27.Vue 2.0 之 v-on 属性\n28.Vue 2.0 之 v-text 和 v-html 属性\n29.Vue 2.0 之 v-for 属性\n30.Vue 2.0 之：v-if 和 v-show\n31.Vue 2.0 之 Vue 的运行环境\n32.Vue 2.0 之动画\n33.Vue 2.0 之 Vuex\n34.Vue:Vue-cli，生命周期钩子\n35.Vue:组件，Props，Slots\n36.Vue:渲染、指令和事件 37.浅谈前端状态管理 38.使用 Vue.js 和 Vuex 2.0 构建一个简单的 Todo 应用程序 39.使用 Vue.js 2 创建 To-Do App\n","slug":"2018-05-17-vue 分享知识点","published":1,"updated":"2020-03-14T06:51:32.708Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvl3002g4k8y143w0td2","content":"<p>vue 分享模块清单<br>1.Vue 2.0 之 Vue 实例和生命周期<br>2.vue 2.0 之自定义指令<br>3.vue 2.0 之观察者模式实现简单异步无限滚动 4.从 JavaScript 属性描述器剖析 Vue.js 响应式视图<br>5.Vue 响应式及其缺陷<br>6.Vue 2.0 之 Vue 中的响应式<br>7.Vue 2.0 之 Vue 中的代理 Proxy 8.使用$refs 访问 Vue 中的 DOM<br>9.Vue 2.0 之在 Vue 中使用样式<br>10.Vue 2.0 之 Vue 的过滤器 11.在 Vue 中何时使用方法、计算属性<br>12.Vue 2.0 之 Vue 的观察者<br>13.Vue 2.0 之 Vue 的 Methods 和事件处理 14.使用 Vue 创建计算器<br>15.Vue 的作用域插槽<br>16.Vue 2.0 之 Vue 的模板<br>17.Vue 的计算属性<br>18.Vue 2.0 之 Vue 中的 computed 属性<br>19.Vue 组件通讯：单个组件<br>20.Vue.js 定义组件模板的七种方式<br>21.Vue 2.0 之 v-bind 属性 22.在 vue 中有条件地使用 css 类<br>23.Vue 2.0 之自定义表单组件<br>24.Vue 2.0 之 v-model 属性<br>25.Vue 的双向绑定原理及实现<br>26.Vue 双向绑定的实现原理 Object.defineproperty<br>27.Vue 2.0 之 v-on 属性<br>28.Vue 2.0 之 v-text 和 v-html 属性<br>29.Vue 2.0 之 v-for 属性<br>30.Vue 2.0 之：v-if 和 v-show<br>31.Vue 2.0 之 Vue 的运行环境<br>32.Vue 2.0 之动画<br>33.Vue 2.0 之 Vuex<br>34.Vue:Vue-cli，生命周期钩子<br>35.Vue:组件，Props，Slots<br>36.Vue:渲染、指令和事件 37.浅谈前端状态管理 38.使用 Vue.js 和 Vuex 2.0 构建一个简单的 Todo 应用程序 39.使用 Vue.js 2 创建 To-Do App</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>vue 分享模块清单<br>1.Vue 2.0 之 Vue 实例和生命周期<br>2.vue 2.0 之自定义指令<br>3.vue 2.0 之观察者模式实现简单异步无限滚动 4.从 JavaScript 属性描述器剖析 Vue.js 响应式视图<br>5.Vue 响应式及其缺陷<br>6.Vue 2.0 之 Vue 中的响应式<br>7.Vue 2.0 之 Vue 中的代理 Proxy 8.使用$refs 访问 Vue 中的 DOM<br>9.Vue 2.0 之在 Vue 中使用样式<br>10.Vue 2.0 之 Vue 的过滤器 11.在 Vue 中何时使用方法、计算属性<br>12.Vue 2.0 之 Vue 的观察者<br>13.Vue 2.0 之 Vue 的 Methods 和事件处理 14.使用 Vue 创建计算器<br>15.Vue 的作用域插槽<br>16.Vue 2.0 之 Vue 的模板<br>17.Vue 的计算属性<br>18.Vue 2.0 之 Vue 中的 computed 属性<br>19.Vue 组件通讯：单个组件<br>20.Vue.js 定义组件模板的七种方式<br>21.Vue 2.0 之 v-bind 属性 22.在 vue 中有条件地使用 css 类<br>23.Vue 2.0 之自定义表单组件<br>24.Vue 2.0 之 v-model 属性<br>25.Vue 的双向绑定原理及实现<br>26.Vue 双向绑定的实现原理 Object.defineproperty<br>27.Vue 2.0 之 v-on 属性<br>28.Vue 2.0 之 v-text 和 v-html 属性<br>29.Vue 2.0 之 v-for 属性<br>30.Vue 2.0 之：v-if 和 v-show<br>31.Vue 2.0 之 Vue 的运行环境<br>32.Vue 2.0 之动画<br>33.Vue 2.0 之 Vuex<br>34.Vue:Vue-cli，生命周期钩子<br>35.Vue:组件，Props，Slots<br>36.Vue:渲染、指令和事件 37.浅谈前端状态管理 38.使用 Vue.js 和 Vuex 2.0 构建一个简单的 Todo 应用程序 39.使用 Vue.js 2 创建 To-Do App</p>\n"},{"title":"vscode 常用配置","date":"2018-05-14T17:24:00.000Z","_content":"\n```\n{ \"workbench.iconTheme\": \"vscode-icons\", \"editor.tabSize\": 2, \"editor.detectIndentation\": false, \"editor.formatOnSave\": true, \"vetur.format.defaultFormatter.js\": \"vscode-typescript\", \"vetur.validation.template\": false, \"eslint.autoFixOnSave\": true, \"eslint.validate\": \\[ \"javascript\", \"javascriptreact\", \"html\", \"vue\",\n    { \"language\": \"html\", \"autoFix\": true },\n    { \"language\": \"vue\", \"autoFix\": true }\n  \\], \"javascript.format.insertSpaceBeforeFunctionParenthesis\": true, \"files.autoSave\": \"afterDelay\", \"background.customImages\": \\[ \"file:///C:/Users/jack_blue/Pictures/Camera Roll/bg.jpg\" \\], \"background.useDefault\": false, \"background.style\": { \"content\": \"''\", \"pointer-events\": \"none\", \"position\": \"absolute\", \"z-index\": \"99999\", \"width\": \"100%\", \"height\": \"100%\", \"background-position\": \"center\", \"background-repeat\": \"no-repeat\", \"opacity\": 0.1 }, \"gitlens.advanced.messages\": { \"suppressCommitHasNoPreviousCommitWarning\": false, \"suppressCommitNotFoundWarning\": false, \"suppressFileNotUnderSourceControlWarning\": false, \"suppressGitVersionWarning\": false, \"suppressLineUncommittedWarning\": false, \"suppressNoRepositoryWarning\": false, \"suppressResultsExplorerNotice\": false, \"suppressShowKeyBindingsNotice\": true },\n}\n```\n","source":"_posts/2018-05-15-vscode 常用配置.md","raw":"---\ntitle: vscode 常用配置\ntags:\n  - 工具\ndate: 2018-05-15 01:24:00\ncategories: 教程\n---\n\n```\n{ \"workbench.iconTheme\": \"vscode-icons\", \"editor.tabSize\": 2, \"editor.detectIndentation\": false, \"editor.formatOnSave\": true, \"vetur.format.defaultFormatter.js\": \"vscode-typescript\", \"vetur.validation.template\": false, \"eslint.autoFixOnSave\": true, \"eslint.validate\": \\[ \"javascript\", \"javascriptreact\", \"html\", \"vue\",\n    { \"language\": \"html\", \"autoFix\": true },\n    { \"language\": \"vue\", \"autoFix\": true }\n  \\], \"javascript.format.insertSpaceBeforeFunctionParenthesis\": true, \"files.autoSave\": \"afterDelay\", \"background.customImages\": \\[ \"file:///C:/Users/jack_blue/Pictures/Camera Roll/bg.jpg\" \\], \"background.useDefault\": false, \"background.style\": { \"content\": \"''\", \"pointer-events\": \"none\", \"position\": \"absolute\", \"z-index\": \"99999\", \"width\": \"100%\", \"height\": \"100%\", \"background-position\": \"center\", \"background-repeat\": \"no-repeat\", \"opacity\": 0.1 }, \"gitlens.advanced.messages\": { \"suppressCommitHasNoPreviousCommitWarning\": false, \"suppressCommitNotFoundWarning\": false, \"suppressFileNotUnderSourceControlWarning\": false, \"suppressGitVersionWarning\": false, \"suppressLineUncommittedWarning\": false, \"suppressNoRepositoryWarning\": false, \"suppressResultsExplorerNotice\": false, \"suppressShowKeyBindingsNotice\": true },\n}\n```\n","slug":"2018-05-15-vscode 常用配置","published":1,"updated":"2020-03-14T06:51:25.831Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvl5002j4k8ye4f95amu","content":"<pre><code>{ &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;, &quot;editor.tabSize&quot;: 2, &quot;editor.detectIndentation&quot;: false, &quot;editor.formatOnSave&quot;: true, &quot;vetur.format.defaultFormatter.js&quot;: &quot;vscode-typescript&quot;, &quot;vetur.validation.template&quot;: false, &quot;eslint.autoFixOnSave&quot;: true, &quot;eslint.validate&quot;: \\[ &quot;javascript&quot;, &quot;javascriptreact&quot;, &quot;html&quot;, &quot;vue&quot;,\n    { &quot;language&quot;: &quot;html&quot;, &quot;autoFix&quot;: true },\n    { &quot;language&quot;: &quot;vue&quot;, &quot;autoFix&quot;: true }\n  \\], &quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true, &quot;files.autoSave&quot;: &quot;afterDelay&quot;, &quot;background.customImages&quot;: \\[ &quot;file:///C:/Users/jack_blue/Pictures/Camera Roll/bg.jpg&quot; \\], &quot;background.useDefault&quot;: false, &quot;background.style&quot;: { &quot;content&quot;: &quot;&#39;&#39;&quot;, &quot;pointer-events&quot;: &quot;none&quot;, &quot;position&quot;: &quot;absolute&quot;, &quot;z-index&quot;: &quot;99999&quot;, &quot;width&quot;: &quot;100%&quot;, &quot;height&quot;: &quot;100%&quot;, &quot;background-position&quot;: &quot;center&quot;, &quot;background-repeat&quot;: &quot;no-repeat&quot;, &quot;opacity&quot;: 0.1 }, &quot;gitlens.advanced.messages&quot;: { &quot;suppressCommitHasNoPreviousCommitWarning&quot;: false, &quot;suppressCommitNotFoundWarning&quot;: false, &quot;suppressFileNotUnderSourceControlWarning&quot;: false, &quot;suppressGitVersionWarning&quot;: false, &quot;suppressLineUncommittedWarning&quot;: false, &quot;suppressNoRepositoryWarning&quot;: false, &quot;suppressResultsExplorerNotice&quot;: false, &quot;suppressShowKeyBindingsNotice&quot;: true },\n}</code></pre>","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<pre><code>{ &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;, &quot;editor.tabSize&quot;: 2, &quot;editor.detectIndentation&quot;: false, &quot;editor.formatOnSave&quot;: true, &quot;vetur.format.defaultFormatter.js&quot;: &quot;vscode-typescript&quot;, &quot;vetur.validation.template&quot;: false, &quot;eslint.autoFixOnSave&quot;: true, &quot;eslint.validate&quot;: \\[ &quot;javascript&quot;, &quot;javascriptreact&quot;, &quot;html&quot;, &quot;vue&quot;,\n    { &quot;language&quot;: &quot;html&quot;, &quot;autoFix&quot;: true },\n    { &quot;language&quot;: &quot;vue&quot;, &quot;autoFix&quot;: true }\n  \\], &quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true, &quot;files.autoSave&quot;: &quot;afterDelay&quot;, &quot;background.customImages&quot;: \\[ &quot;file:///C:/Users/jack_blue/Pictures/Camera Roll/bg.jpg&quot; \\], &quot;background.useDefault&quot;: false, &quot;background.style&quot;: { &quot;content&quot;: &quot;&#39;&#39;&quot;, &quot;pointer-events&quot;: &quot;none&quot;, &quot;position&quot;: &quot;absolute&quot;, &quot;z-index&quot;: &quot;99999&quot;, &quot;width&quot;: &quot;100%&quot;, &quot;height&quot;: &quot;100%&quot;, &quot;background-position&quot;: &quot;center&quot;, &quot;background-repeat&quot;: &quot;no-repeat&quot;, &quot;opacity&quot;: 0.1 }, &quot;gitlens.advanced.messages&quot;: { &quot;suppressCommitHasNoPreviousCommitWarning&quot;: false, &quot;suppressCommitNotFoundWarning&quot;: false, &quot;suppressFileNotUnderSourceControlWarning&quot;: false, &quot;suppressGitVersionWarning&quot;: false, &quot;suppressLineUncommittedWarning&quot;: false, &quot;suppressNoRepositoryWarning&quot;: false, &quot;suppressResultsExplorerNotice&quot;: false, &quot;suppressShowKeyBindingsNotice&quot;: true },\n}</code></pre>"},{"title":"javascript逻辑运算符“||”和“&&”的简单梳理","date":"2018-05-31T15:28:19.000Z","_content":"\n一道经典的前端面试题：\n\n> alert(1 && 2) 得到的结果是什么？ A:true      B:false      C:1      D:2\n\n请带着你的回答，往下看…… 那么 alert(1||''&&2)的结果呢？？\n\n## 逻辑或\n\n逻辑或,也就是“||”。从字面上来说，只有前后都是 false 的时候才返回 false，否则返回 true。\n\n1.  alert(true||false);    // true\n2.  alert(false||true);    // true\n3.  alert(true||true);        // true\n4.  alert(false||false);    // false\n\n更加深一点的\n\n1.  alert(0||1);  //1\n2.  alert(2||1);  //2\n3.  alert('a'||1); //'a'\n4.  alert(''||1);//1\n5.  alert('a'||0);// 'a'\n6.  alert('a'||'b');// 'a'\n7.  alert(''||0);// 0\n8.  alert(0||'');//''\n\n**这就意味** 1、只要“||”前面为 false,不管“||”后面是 true 还是 false，都返回“||”后面的值。 2、只要“||”前面为 true,不管“||”后面是 true 还是 false，都返回“||”前面的值。\n\n## 逻辑与\n\n下面说说逻辑与（&&）,从字面上来说，只有前后都是 true 的时候才返回 true，否则返回 false。\n\n1.  alert(true&&false);    // false\n2.  alert(true&&true);    // true\n3.  alert(false&&false);    // false\n4.  alert(false&&true);    // false\n\n同样的\n\n1.  alert(0&&1);  //0\n2.  alert(2&&1);  //1\n3.  alert('a'&&1); //1\n4.  alert(''&&1);//''\n5.  alert('a'&&0);// 0\n6.  alert('a'&&'b');// 'b'\n7.  alert(''&&0);// ''\n8.  alert(0&&'');//0\n\n**这意味着** 1、只要“&&”前面是 false，无论“&&”后面是 true 还是 false，结果都将返“&&”前面的值; 2、只要“&&”前面是 true，无论“&&”后面是 true 还是 false，结果都将返“&&”后面的值; 让我们总结一下： 1、只要“||”前面为 false，无论“||”后面是 true 还是 false，结果都返回“||”后面的值。 2、只要“||”前面为 true，无论“||”后面是 true 还是 false，结果都返回“||”前面的值。 3、只要“&&”前面是 false，无论“&&”后面是 true 还是 false，结果都将返“&&”前面的值; 4、只要“&&”前面是 true，无论“&&”后面是 true 还是 false，结果都将返“&&”后面的值; 由上两个测试可知，逻辑运算符，“||”和“&&”都是遵行短路原则，只要确定符号前面的真假，既可确定返回值。 **简单点来说，&&相当于 if，如果前面为 true 则进行下一步输出后面的值不为真则返回本身，||刚好和&&相反** 另外说明&&优先级高于||，所以上面的值为 2 和 1，亲爱的你做对了么？\n","source":"_posts/2018-05-31-javascript逻辑运算符“||”和“&&”的简单梳理.md","raw":"---\ntitle: javascript逻辑运算符“||”和“&&”的简单梳理\ndate: 2018-05-31 23:28:19\ntags: [技术]\ncategories: 前端\n---\n\n一道经典的前端面试题：\n\n> alert(1 && 2) 得到的结果是什么？ A:true      B:false      C:1      D:2\n\n请带着你的回答，往下看…… 那么 alert(1||''&&2)的结果呢？？\n\n## 逻辑或\n\n逻辑或,也就是“||”。从字面上来说，只有前后都是 false 的时候才返回 false，否则返回 true。\n\n1.  alert(true||false);    // true\n2.  alert(false||true);    // true\n3.  alert(true||true);        // true\n4.  alert(false||false);    // false\n\n更加深一点的\n\n1.  alert(0||1);  //1\n2.  alert(2||1);  //2\n3.  alert('a'||1); //'a'\n4.  alert(''||1);//1\n5.  alert('a'||0);// 'a'\n6.  alert('a'||'b');// 'a'\n7.  alert(''||0);// 0\n8.  alert(0||'');//''\n\n**这就意味** 1、只要“||”前面为 false,不管“||”后面是 true 还是 false，都返回“||”后面的值。 2、只要“||”前面为 true,不管“||”后面是 true 还是 false，都返回“||”前面的值。\n\n## 逻辑与\n\n下面说说逻辑与（&&）,从字面上来说，只有前后都是 true 的时候才返回 true，否则返回 false。\n\n1.  alert(true&&false);    // false\n2.  alert(true&&true);    // true\n3.  alert(false&&false);    // false\n4.  alert(false&&true);    // false\n\n同样的\n\n1.  alert(0&&1);  //0\n2.  alert(2&&1);  //1\n3.  alert('a'&&1); //1\n4.  alert(''&&1);//''\n5.  alert('a'&&0);// 0\n6.  alert('a'&&'b');// 'b'\n7.  alert(''&&0);// ''\n8.  alert(0&&'');//0\n\n**这意味着** 1、只要“&&”前面是 false，无论“&&”后面是 true 还是 false，结果都将返“&&”前面的值; 2、只要“&&”前面是 true，无论“&&”后面是 true 还是 false，结果都将返“&&”后面的值; 让我们总结一下： 1、只要“||”前面为 false，无论“||”后面是 true 还是 false，结果都返回“||”后面的值。 2、只要“||”前面为 true，无论“||”后面是 true 还是 false，结果都返回“||”前面的值。 3、只要“&&”前面是 false，无论“&&”后面是 true 还是 false，结果都将返“&&”前面的值; 4、只要“&&”前面是 true，无论“&&”后面是 true 还是 false，结果都将返“&&”后面的值; 由上两个测试可知，逻辑运算符，“||”和“&&”都是遵行短路原则，只要确定符号前面的真假，既可确定返回值。 **简单点来说，&&相当于 if，如果前面为 true 则进行下一步输出后面的值不为真则返回本身，||刚好和&&相反** 另外说明&&优先级高于||，所以上面的值为 2 和 1，亲爱的你做对了么？\n","slug":"2018-05-31-javascript逻辑运算符“||”和“&&”的简单梳理","published":1,"updated":"2020-03-14T06:51:52.336Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvl8002n4k8yhn55av7w","content":"<p>一道经典的前端面试题：</p>\n<blockquote>\n<p>alert(1 &amp;&amp; 2) 得到的结果是什么？ A:true      B:false      C:1      D:2</p>\n</blockquote>\n<p>请带着你的回答，往下看…… 那么 alert(1||’’&amp;&amp;2)的结果呢？？</p>\n<h2 id=\"逻辑或\"><a href=\"#逻辑或\" class=\"headerlink\" title=\"逻辑或\"></a>逻辑或</h2><p>逻辑或,也就是“||”。从字面上来说，只有前后都是 false 的时候才返回 false，否则返回 true。</p>\n<ol>\n<li>alert(true||false);    // true</li>\n<li>alert(false||true);    // true</li>\n<li>alert(true||true);        // true</li>\n<li>alert(false||false);    // false</li>\n</ol>\n<p>更加深一点的</p>\n<ol>\n<li>alert(0||1);  //1</li>\n<li>alert(2||1);  //2</li>\n<li>alert(‘a’||1); //‘a’</li>\n<li>alert(‘’||1);//1</li>\n<li>alert(‘a’||0);// ‘a’</li>\n<li>alert(‘a’||’b’);// ‘a’</li>\n<li>alert(‘’||0);// 0</li>\n<li>alert(0||’’);//‘’</li>\n</ol>\n<p><strong>这就意味</strong> 1、只要“||”前面为 false,不管“||”后面是 true 还是 false，都返回“||”后面的值。 2、只要“||”前面为 true,不管“||”后面是 true 还是 false，都返回“||”前面的值。</p>\n<h2 id=\"逻辑与\"><a href=\"#逻辑与\" class=\"headerlink\" title=\"逻辑与\"></a>逻辑与</h2><p>下面说说逻辑与（&amp;&amp;）,从字面上来说，只有前后都是 true 的时候才返回 true，否则返回 false。</p>\n<ol>\n<li>alert(true&amp;&amp;false);    // false</li>\n<li>alert(true&amp;&amp;true);    // true</li>\n<li>alert(false&amp;&amp;false);    // false</li>\n<li>alert(false&amp;&amp;true);    // false</li>\n</ol>\n<p>同样的</p>\n<ol>\n<li>alert(0&amp;&amp;1);  //0</li>\n<li>alert(2&amp;&amp;1);  //1</li>\n<li>alert(‘a’&amp;&amp;1); //1</li>\n<li>alert(‘’&amp;&amp;1);//‘’</li>\n<li>alert(‘a’&amp;&amp;0);// 0</li>\n<li>alert(‘a’&amp;&amp;’b’);// ‘b’</li>\n<li>alert(‘’&amp;&amp;0);// ‘’</li>\n<li>alert(0&amp;&amp;’’);//0</li>\n</ol>\n<p><strong>这意味着</strong> 1、只要“&amp;&amp;”前面是 false，无论“&amp;&amp;”后面是 true 还是 false，结果都将返“&amp;&amp;”前面的值; 2、只要“&amp;&amp;”前面是 true，无论“&amp;&amp;”后面是 true 还是 false，结果都将返“&amp;&amp;”后面的值; 让我们总结一下： 1、只要“||”前面为 false，无论“||”后面是 true 还是 false，结果都返回“||”后面的值。 2、只要“||”前面为 true，无论“||”后面是 true 还是 false，结果都返回“||”前面的值。 3、只要“&amp;&amp;”前面是 false，无论“&amp;&amp;”后面是 true 还是 false，结果都将返“&amp;&amp;”前面的值; 4、只要“&amp;&amp;”前面是 true，无论“&amp;&amp;”后面是 true 还是 false，结果都将返“&amp;&amp;”后面的值; 由上两个测试可知，逻辑运算符，“||”和“&amp;&amp;”都是遵行短路原则，只要确定符号前面的真假，既可确定返回值。 <strong>简单点来说，&amp;&amp;相当于 if，如果前面为 true 则进行下一步输出后面的值不为真则返回本身，||刚好和&amp;&amp;相反</strong> 另外说明&amp;&amp;优先级高于||，所以上面的值为 2 和 1，亲爱的你做对了么？</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>一道经典的前端面试题：</p>\n<blockquote>\n<p>alert(1 &amp;&amp; 2) 得到的结果是什么？ A:true      B:false      C:1      D:2</p>\n</blockquote>\n<p>请带着你的回答，往下看…… 那么 alert(1||’’&amp;&amp;2)的结果呢？？</p>\n<h2 id=\"逻辑或\"><a href=\"#逻辑或\" class=\"headerlink\" title=\"逻辑或\"></a>逻辑或</h2><p>逻辑或,也就是“||”。从字面上来说，只有前后都是 false 的时候才返回 false，否则返回 true。</p>\n<ol>\n<li>alert(true||false);    // true</li>\n<li>alert(false||true);    // true</li>\n<li>alert(true||true);        // true</li>\n<li>alert(false||false);    // false</li>\n</ol>\n<p>更加深一点的</p>\n<ol>\n<li>alert(0||1);  //1</li>\n<li>alert(2||1);  //2</li>\n<li>alert(‘a’||1); //‘a’</li>\n<li>alert(‘’||1);//1</li>\n<li>alert(‘a’||0);// ‘a’</li>\n<li>alert(‘a’||’b’);// ‘a’</li>\n<li>alert(‘’||0);// 0</li>\n<li>alert(0||’’);//‘’</li>\n</ol>\n<p><strong>这就意味</strong> 1、只要“||”前面为 false,不管“||”后面是 true 还是 false，都返回“||”后面的值。 2、只要“||”前面为 true,不管“||”后面是 true 还是 false，都返回“||”前面的值。</p>\n<h2 id=\"逻辑与\"><a href=\"#逻辑与\" class=\"headerlink\" title=\"逻辑与\"></a>逻辑与</h2><p>下面说说逻辑与（&amp;&amp;）,从字面上来说，只有前后都是 true 的时候才返回 true，否则返回 false。</p>\n<ol>\n<li>alert(true&amp;&amp;false);    // false</li>\n<li>alert(true&amp;&amp;true);    // true</li>\n<li>alert(false&amp;&amp;false);    // false</li>\n<li>alert(false&amp;&amp;true);    // false</li>\n</ol>\n<p>同样的</p>\n<ol>\n<li>alert(0&amp;&amp;1);  //0</li>\n<li>alert(2&amp;&amp;1);  //1</li>\n<li>alert(‘a’&amp;&amp;1); //1</li>\n<li>alert(‘’&amp;&amp;1);//‘’</li>\n<li>alert(‘a’&amp;&amp;0);// 0</li>\n<li>alert(‘a’&amp;&amp;’b’);// ‘b’</li>\n<li>alert(‘’&amp;&amp;0);// ‘’</li>\n<li>alert(0&amp;&amp;’’);//0</li>\n</ol>\n<p><strong>这意味着</strong> 1、只要“&amp;&amp;”前面是 false，无论“&amp;&amp;”后面是 true 还是 false，结果都将返“&amp;&amp;”前面的值; 2、只要“&amp;&amp;”前面是 true，无论“&amp;&amp;”后面是 true 还是 false，结果都将返“&amp;&amp;”后面的值; 让我们总结一下： 1、只要“||”前面为 false，无论“||”后面是 true 还是 false，结果都返回“||”后面的值。 2、只要“||”前面为 true，无论“||”后面是 true 还是 false，结果都返回“||”前面的值。 3、只要“&amp;&amp;”前面是 false，无论“&amp;&amp;”后面是 true 还是 false，结果都将返“&amp;&amp;”前面的值; 4、只要“&amp;&amp;”前面是 true，无论“&amp;&amp;”后面是 true 还是 false，结果都将返“&amp;&amp;”后面的值; 由上两个测试可知，逻辑运算符，“||”和“&amp;&amp;”都是遵行短路原则，只要确定符号前面的真假，既可确定返回值。 <strong>简单点来说，&amp;&amp;相当于 if，如果前面为 true 则进行下一步输出后面的值不为真则返回本身，||刚好和&amp;&amp;相反</strong> 另外说明&amp;&amp;优先级高于||，所以上面的值为 2 和 1，亲爱的你做对了么？</p>\n"},{"title":"Vue中数组和对象更改后视图不刷新的问题","date":"2018-06-27T07:01:38.000Z","_content":"\n#### Vue 数据响应原理\n\n\\[video width=\"2560\" height=\"1440\" webm=\"http://www.jixiaokang.com/wp-content/uploads/2018/06/AwesomeScreenshot-2018-06-27T06-59-55-089Z.webm\"\\]\\[/video\\]   官方的解释很清晰：\n\n> 当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。 用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 vue-devtools 来获取更加友好的检查接口。 每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 ![这里写图片描述](https://img-blog.csdn.net/20180102164454671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemlmZWl5dTEzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n---\n\n#### 关于 getter 和 setter 的局限性\n\n官方文档解释那么多，说到底就是数据的改变必须能够触发 set 方法，否则无法响应数据变化。那么，我们就看看 set 方法在什么时候会被触发，什么时候又不会被触发。\n\n    var person = {\n        defaultname: 'tom',\n        get name() {\n            return this.defaultname\n        },\n        set name(val) {\n            this.defaultname = val\n            console.log(\"触发了set\")\n        }\n    }\n\n这里我们定义一个叫做 person 的对象，我们通过 get/set 来控制 name，可以看到如果 set 被触发，就会打印出触发了 set。\n\n    person.name\n    =>\"tom\"\n    person.name = 123\n    =>触发了set\n    person.name\n    =>123\n\n可以看到我们直接修改 name 是可以触发 set 的。\n\n    person.name = {name: 'tom'}\n    =>触发了set\n    person.name\n    =>{name: \"tom\"}\n    person.name.name = 123123\n    =>没有打印出任何信息，说明修改name的属性值并没有触发set方法。\n    person.name.sex = 333\n    =>没有打印出任何信息，说明添加name的属性值并没有触发set方法。\n    delete person.name.name\n    =>没有打印出任何信息，说明删除name的属性值并没有触发set方法。\n    Object.defineProperty(person.name, 'name', {value: 4444})\n    =>没有打印出任何信息，说明Object.defineProperty也没有触发set方法。\n\n当 name 是一个对象的时候，我们修改、添加、删除 name 的属性值都没有触发 set 方法。\n\n    person.name = [1,2,3]\n    =>触发了set\n    person.name.push(4)\n    =>没有打印出任何信息，说明push方法并没有触发set方法。\n\n说明数组的 push 方法也无法触发 set 方法，同理 pop、shift、unshift 等原生数组方法也是无法触发 set。\n\n---\n\n#### 解决方案\n\n受现代 JavaScript 的限制 (以及废弃 Object.observe)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如：\n\n    var vm = new Vue({\n      data:{\n      a:1\n      }\n    })\n\n    // `vm.a` 是响应的\n\n    vm.b = 2\n    // `vm.b` 是非响应的\n\nVue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：\n\n    Vue.set(vm.someObject, 'b', 2)\n\n您还可以使用 vm.\\$set 实例方法，这也是全局 Vue.set 方法的别名：\n\n    this.$set(this.someObject,'b',2)\n\n有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 \\_.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：\n\n    // 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`\n    this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })\n\n[关于 Object.assign()的介绍](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) 数组更新检测 **变异方法** 还记得前面我们测试过 push 等方法是不能触发 set 方法的，所以 Vue 为我们定义了一系列的变异方法，可以直接使用：\n\n     - push()\n     - pop()\n     - shift()\n     - unshift()\n     - splice()\n     - sort()\n     - reverse()\n\n**替换方法** 变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如：filter(), concat() 和 slice() 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：\n\n    example1.items = example1.items.filter(function (item) {\n      return item.message.match(/Foo/)\n    })\n\n你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的、启发式的方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。 **注意事项** 由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如：vm.items\\[indexOfItem\\] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 为了解决第一类问题，以下两种方式都可以实现和 vm.items\\[indexOfItem\\] = newValue 相同的效果，同时也将触发状态更新：\n\n    // Vue.set\n    Vue.set(example1.items, indexOfItem, newValue)\n    // Array.prototype.splice\n    example1.items.splice(indexOfItem, 1, newValue)\n\n为了解决第二类问题，你可以使用 splice：\n\n    example1.items.splice(newLength)\n\n---\n\n#### 参考资料\n\n[深入响应式原理官方文档](https://cn.vuejs.org/v2/guide/reactivity.html) [Object.assign 方法介绍](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) [getter/setter 方法介绍](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get) [对象的响应问题](https://www.cnblogs.com/tugenhua0707/p/7440400.html)\n","source":"_posts/2018-06-27-Vue中数组和对象更改后视图不刷新的问题.md","raw":"---\ntitle: Vue中数组和对象更改后视图不刷新的问题\ndate: 2018-06-27 15:01:38\ntags: [vue]\ncategories: 前端\n---\n\n#### Vue 数据响应原理\n\n\\[video width=\"2560\" height=\"1440\" webm=\"http://www.jixiaokang.com/wp-content/uploads/2018/06/AwesomeScreenshot-2018-06-27T06-59-55-089Z.webm\"\\]\\[/video\\]   官方的解释很清晰：\n\n> 当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。 用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 vue-devtools 来获取更加友好的检查接口。 每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 ![这里写图片描述](https://img-blog.csdn.net/20180102164454671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemlmZWl5dTEzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n---\n\n#### 关于 getter 和 setter 的局限性\n\n官方文档解释那么多，说到底就是数据的改变必须能够触发 set 方法，否则无法响应数据变化。那么，我们就看看 set 方法在什么时候会被触发，什么时候又不会被触发。\n\n    var person = {\n        defaultname: 'tom',\n        get name() {\n            return this.defaultname\n        },\n        set name(val) {\n            this.defaultname = val\n            console.log(\"触发了set\")\n        }\n    }\n\n这里我们定义一个叫做 person 的对象，我们通过 get/set 来控制 name，可以看到如果 set 被触发，就会打印出触发了 set。\n\n    person.name\n    =>\"tom\"\n    person.name = 123\n    =>触发了set\n    person.name\n    =>123\n\n可以看到我们直接修改 name 是可以触发 set 的。\n\n    person.name = {name: 'tom'}\n    =>触发了set\n    person.name\n    =>{name: \"tom\"}\n    person.name.name = 123123\n    =>没有打印出任何信息，说明修改name的属性值并没有触发set方法。\n    person.name.sex = 333\n    =>没有打印出任何信息，说明添加name的属性值并没有触发set方法。\n    delete person.name.name\n    =>没有打印出任何信息，说明删除name的属性值并没有触发set方法。\n    Object.defineProperty(person.name, 'name', {value: 4444})\n    =>没有打印出任何信息，说明Object.defineProperty也没有触发set方法。\n\n当 name 是一个对象的时候，我们修改、添加、删除 name 的属性值都没有触发 set 方法。\n\n    person.name = [1,2,3]\n    =>触发了set\n    person.name.push(4)\n    =>没有打印出任何信息，说明push方法并没有触发set方法。\n\n说明数组的 push 方法也无法触发 set 方法，同理 pop、shift、unshift 等原生数组方法也是无法触发 set。\n\n---\n\n#### 解决方案\n\n受现代 JavaScript 的限制 (以及废弃 Object.observe)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如：\n\n    var vm = new Vue({\n      data:{\n      a:1\n      }\n    })\n\n    // `vm.a` 是响应的\n\n    vm.b = 2\n    // `vm.b` 是非响应的\n\nVue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：\n\n    Vue.set(vm.someObject, 'b', 2)\n\n您还可以使用 vm.\\$set 实例方法，这也是全局 Vue.set 方法的别名：\n\n    this.$set(this.someObject,'b',2)\n\n有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 \\_.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：\n\n    // 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`\n    this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })\n\n[关于 Object.assign()的介绍](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) 数组更新检测 **变异方法** 还记得前面我们测试过 push 等方法是不能触发 set 方法的，所以 Vue 为我们定义了一系列的变异方法，可以直接使用：\n\n     - push()\n     - pop()\n     - shift()\n     - unshift()\n     - splice()\n     - sort()\n     - reverse()\n\n**替换方法** 变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如：filter(), concat() 和 slice() 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：\n\n    example1.items = example1.items.filter(function (item) {\n      return item.message.match(/Foo/)\n    })\n\n你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的、启发式的方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。 **注意事项** 由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如：vm.items\\[indexOfItem\\] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 为了解决第一类问题，以下两种方式都可以实现和 vm.items\\[indexOfItem\\] = newValue 相同的效果，同时也将触发状态更新：\n\n    // Vue.set\n    Vue.set(example1.items, indexOfItem, newValue)\n    // Array.prototype.splice\n    example1.items.splice(indexOfItem, 1, newValue)\n\n为了解决第二类问题，你可以使用 splice：\n\n    example1.items.splice(newLength)\n\n---\n\n#### 参考资料\n\n[深入响应式原理官方文档](https://cn.vuejs.org/v2/guide/reactivity.html) [Object.assign 方法介绍](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) [getter/setter 方法介绍](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get) [对象的响应问题](https://www.cnblogs.com/tugenhua0707/p/7440400.html)\n","slug":"2018-06-27-Vue中数组和对象更改后视图不刷新的问题","published":1,"updated":"2020-03-14T06:51:56.187Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvla002q4k8yacaw7n58","content":"<h4 id=\"Vue-数据响应原理\"><a href=\"#Vue-数据响应原理\" class=\"headerlink\" title=\"Vue 数据响应原理\"></a>Vue 数据响应原理</h4><p>[video width=”2560” height=”1440” webm=”<a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/06/AwesomeScreenshot-2018-06-27T06-59-55-089Z.webm&quot;\\]\\[/video\\]\" target=\"_blank\" rel=\"noopener\">http://www.jixiaokang.com/wp-content/uploads/2018/06/AwesomeScreenshot-2018-06-27T06-59-55-089Z.webm&quot;\\]\\[/video\\]</a>   官方的解释很清晰：</p>\n<blockquote>\n<p>当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。 用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 vue-devtools 来获取更加友好的检查接口。 每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 <img src=\"https://img-blog.csdn.net/20180102164454671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemlmZWl5dTEzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<hr>\n<h4 id=\"关于-getter-和-setter-的局限性\"><a href=\"#关于-getter-和-setter-的局限性\" class=\"headerlink\" title=\"关于 getter 和 setter 的局限性\"></a>关于 getter 和 setter 的局限性</h4><p>官方文档解释那么多，说到底就是数据的改变必须能够触发 set 方法，否则无法响应数据变化。那么，我们就看看 set 方法在什么时候会被触发，什么时候又不会被触发。</p>\n<pre><code>var person = {\n    defaultname: &#39;tom&#39;,\n    get name() {\n        return this.defaultname\n    },\n    set name(val) {\n        this.defaultname = val\n        console.log(&quot;触发了set&quot;)\n    }\n}</code></pre><p>这里我们定义一个叫做 person 的对象，我们通过 get/set 来控制 name，可以看到如果 set 被触发，就会打印出触发了 set。</p>\n<pre><code>person.name\n=&gt;&quot;tom&quot;\nperson.name = 123\n=&gt;触发了set\nperson.name\n=&gt;123</code></pre><p>可以看到我们直接修改 name 是可以触发 set 的。</p>\n<pre><code>person.name = {name: &#39;tom&#39;}\n=&gt;触发了set\nperson.name\n=&gt;{name: &quot;tom&quot;}\nperson.name.name = 123123\n=&gt;没有打印出任何信息，说明修改name的属性值并没有触发set方法。\nperson.name.sex = 333\n=&gt;没有打印出任何信息，说明添加name的属性值并没有触发set方法。\ndelete person.name.name\n=&gt;没有打印出任何信息，说明删除name的属性值并没有触发set方法。\nObject.defineProperty(person.name, &#39;name&#39;, {value: 4444})\n=&gt;没有打印出任何信息，说明Object.defineProperty也没有触发set方法。</code></pre><p>当 name 是一个对象的时候，我们修改、添加、删除 name 的属性值都没有触发 set 方法。</p>\n<pre><code>person.name = [1,2,3]\n=&gt;触发了set\nperson.name.push(4)\n=&gt;没有打印出任何信息，说明push方法并没有触发set方法。</code></pre><p>说明数组的 push 方法也无法触发 set 方法，同理 pop、shift、unshift 等原生数组方法也是无法触发 set。</p>\n<hr>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>受现代 JavaScript 的限制 (以及废弃 Object.observe)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如：</p>\n<pre><code>var vm = new Vue({\n  data:{\n  a:1\n  }\n})\n\n// `vm.a` 是响应的\n\nvm.b = 2\n// `vm.b` 是非响应的</code></pre><p>Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：</p>\n<pre><code>Vue.set(vm.someObject, &#39;b&#39;, 2)</code></pre><p>您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名：</p>\n<pre><code>this.$set(this.someObject,&#39;b&#39;,2)</code></pre><p>有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：</p>\n<pre><code>// 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`\nthis.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })</code></pre><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\" rel=\"noopener\">关于 Object.assign()的介绍</a> 数组更新检测 <strong>变异方法</strong> 还记得前面我们测试过 push 等方法是不能触发 set 方法的，所以 Vue 为我们定义了一系列的变异方法，可以直接使用：</p>\n<pre><code> - push()\n - pop()\n - shift()\n - unshift()\n - splice()\n - sort()\n - reverse()</code></pre><p><strong>替换方法</strong> 变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如：filter(), concat() 和 slice() 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：</p>\n<pre><code>example1.items = example1.items.filter(function (item) {\n  return item.message.match(/Foo/)\n})</code></pre><p>你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的、启发式的方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。 <strong>注意事项</strong> 由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新：</p>\n<pre><code>// Vue.set\nVue.set(example1.items, indexOfItem, newValue)\n// Array.prototype.splice\nexample1.items.splice(indexOfItem, 1, newValue)</code></pre><p>为了解决第二类问题，你可以使用 splice：</p>\n<pre><code>example1.items.splice(newLength)</code></pre><hr>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://cn.vuejs.org/v2/guide/reactivity.html\" target=\"_blank\" rel=\"noopener\">深入响应式原理官方文档</a> <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\" rel=\"noopener\">Object.assign 方法介绍</a> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get\" target=\"_blank\" rel=\"noopener\">getter/setter 方法介绍</a> <a href=\"https://www.cnblogs.com/tugenhua0707/p/7440400.html\" target=\"_blank\" rel=\"noopener\">对象的响应问题</a></p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h4 id=\"Vue-数据响应原理\"><a href=\"#Vue-数据响应原理\" class=\"headerlink\" title=\"Vue 数据响应原理\"></a>Vue 数据响应原理</h4><p>[video width=”2560” height=”1440” webm=”<a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/06/AwesomeScreenshot-2018-06-27T06-59-55-089Z.webm&quot;\\]\\[/video\\]\" target=\"_blank\" rel=\"noopener\">http://www.jixiaokang.com/wp-content/uploads/2018/06/AwesomeScreenshot-2018-06-27T06-59-55-089Z.webm&quot;\\]\\[/video\\]</a>   官方的解释很清晰：</p>\n<blockquote>\n<p>当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。 用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 vue-devtools 来获取更加友好的检查接口。 每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 <img src=\"https://img-blog.csdn.net/20180102164454671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemlmZWl5dTEzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n</blockquote>\n<hr>\n<h4 id=\"关于-getter-和-setter-的局限性\"><a href=\"#关于-getter-和-setter-的局限性\" class=\"headerlink\" title=\"关于 getter 和 setter 的局限性\"></a>关于 getter 和 setter 的局限性</h4><p>官方文档解释那么多，说到底就是数据的改变必须能够触发 set 方法，否则无法响应数据变化。那么，我们就看看 set 方法在什么时候会被触发，什么时候又不会被触发。</p>\n<pre><code>var person = {\n    defaultname: &#39;tom&#39;,\n    get name() {\n        return this.defaultname\n    },\n    set name(val) {\n        this.defaultname = val\n        console.log(&quot;触发了set&quot;)\n    }\n}</code></pre><p>这里我们定义一个叫做 person 的对象，我们通过 get/set 来控制 name，可以看到如果 set 被触发，就会打印出触发了 set。</p>\n<pre><code>person.name\n=&gt;&quot;tom&quot;\nperson.name = 123\n=&gt;触发了set\nperson.name\n=&gt;123</code></pre><p>可以看到我们直接修改 name 是可以触发 set 的。</p>\n<pre><code>person.name = {name: &#39;tom&#39;}\n=&gt;触发了set\nperson.name\n=&gt;{name: &quot;tom&quot;}\nperson.name.name = 123123\n=&gt;没有打印出任何信息，说明修改name的属性值并没有触发set方法。\nperson.name.sex = 333\n=&gt;没有打印出任何信息，说明添加name的属性值并没有触发set方法。\ndelete person.name.name\n=&gt;没有打印出任何信息，说明删除name的属性值并没有触发set方法。\nObject.defineProperty(person.name, &#39;name&#39;, {value: 4444})\n=&gt;没有打印出任何信息，说明Object.defineProperty也没有触发set方法。</code></pre><p>当 name 是一个对象的时候，我们修改、添加、删除 name 的属性值都没有触发 set 方法。</p>\n<pre><code>person.name = [1,2,3]\n=&gt;触发了set\nperson.name.push(4)\n=&gt;没有打印出任何信息，说明push方法并没有触发set方法。</code></pre><p>说明数组的 push 方法也无法触发 set 方法，同理 pop、shift、unshift 等原生数组方法也是无法触发 set。</p>\n<hr>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>受现代 JavaScript 的限制 (以及废弃 Object.observe)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如：</p>\n<pre><code>var vm = new Vue({\n  data:{\n  a:1\n  }\n})\n\n// `vm.a` 是响应的\n\nvm.b = 2\n// `vm.b` 是非响应的</code></pre><p>Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：</p>\n<pre><code>Vue.set(vm.someObject, &#39;b&#39;, 2)</code></pre><p>您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名：</p>\n<pre><code>this.$set(this.someObject,&#39;b&#39;,2)</code></pre><p>有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：</p>\n<pre><code>// 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`\nthis.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })</code></pre><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\" rel=\"noopener\">关于 Object.assign()的介绍</a> 数组更新检测 <strong>变异方法</strong> 还记得前面我们测试过 push 等方法是不能触发 set 方法的，所以 Vue 为我们定义了一系列的变异方法，可以直接使用：</p>\n<pre><code> - push()\n - pop()\n - shift()\n - unshift()\n - splice()\n - sort()\n - reverse()</code></pre><p><strong>替换方法</strong> 变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如：filter(), concat() 和 slice() 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：</p>\n<pre><code>example1.items = example1.items.filter(function (item) {\n  return item.message.match(/Foo/)\n})</code></pre><p>你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的、启发式的方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。 <strong>注意事项</strong> 由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新：</p>\n<pre><code>// Vue.set\nVue.set(example1.items, indexOfItem, newValue)\n// Array.prototype.splice\nexample1.items.splice(indexOfItem, 1, newValue)</code></pre><p>为了解决第二类问题，你可以使用 splice：</p>\n<pre><code>example1.items.splice(newLength)</code></pre><hr>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://cn.vuejs.org/v2/guide/reactivity.html\" target=\"_blank\" rel=\"noopener\">深入响应式原理官方文档</a> <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\" rel=\"noopener\">Object.assign 方法介绍</a> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get\" target=\"_blank\" rel=\"noopener\">getter/setter 方法介绍</a> <a href=\"https://www.cnblogs.com/tugenhua0707/p/7440400.html\" target=\"_blank\" rel=\"noopener\">对象的响应问题</a></p>\n"},{"title":"JS几种数组遍历方式详解","date":"2018-05-27T12:42:38.000Z","_content":"\n# 前言\n\n## 在前端开发中循环是必不可少的，在很多情况下不知道该用哪种循环类型，真是让人头大 😵🐷，因此知道每种循环 ♻️ 的运行效率是武装我们自己最有效的方式。\n\n# 一、循环的类型\n\n#     在前端循环中，有大概八种：\n\n### 第一种:普通 for 循环\n\n>     for(j = 0; j < arr.length; j++) {\n>\n>     }\n\n### 第二种:优化版 for 循环(**性能最高的一种**)\n\n>     for(j = 0,len=arr.length; j < len; j++) {\n>\n>     }\n\n### 第三种:弱化版 for 循环(**性能要远远小于普通 for 循环**)\n\n>     for(j = 0; arr[j]!=null; j++) {\n>\n>     }\n\n### 第四种:foreach 循环(性能比普通 for 循环弱)\n\n>     arr.forEach(function(e){\n>\n>     });\n\n### 第五种:foreach 变种(比普通 foreach 弱)\n\n>     Array.prototype.forEach.call(arr,function(el){\n>\n>     });\n\n### 第六种:forin 循环(**效率是最低**)\n\n>     for(j in arr) {\n>\n>     }\n\n### 第七种:map 遍历(实际效率还比不上 foreach)\n\n>     arr.map(function(n){\n>\n>     });\n\n### 第八种:forof 遍历(需要 ES6 支持)\n\n>     for(let value of arr) {\n>\n>     });\n\n# 二、循环的性能\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/demo_js_performanceAnalysis_jsarrayGoThrough_1-768x1024.png)\n\n# 三、循环的区别\n\n## 一、for...in 和 for...of 的区别\n\n1.  推荐在循环对象属性的时候，使用`for...in`,在遍历数组的时候的时候使用`for...of`。\n2.  `for...in`循环出的是 key，`for...of`循环出的是 value\n3.  注意，`for...of`是 ES6 新引入的特性。修复了 ES5 引入的`for...in`的不足\n4.  `for...of`不能循环普通的对象，需要通过和`Object.keys()`搭配使用\n\n### for...in 循环数组下面的对象时会把 key 也拿到\\[{id:123,name:\"王五\"}{id:234,name:\"张三\"}\\]遍历对象属性\n\n### for...of 循环数组下面的对象时会拿到 name\\[\"张三\",\"李四\"\\]遍历对象元素\n\n## 二、**forEach()和 map()**遍历的区别\n\n相同点：\n\n1.  都是循环遍历数组中的每一项。\n2.  forEach() 和 map() 里面每一次执行匿名函数都支持 3 个参数：数组中的当前项 item,当前项的索引 index,原始数组 input。\n3.  匿名函数中的 this 都是指 Window。\n4.  只能遍历数组。\n\n不同点： 1.**forEach()「没有返回值」**\n\n- 参数：value 数组中的当前项, index 当前项的索引, array 原始数组；\n- 数组中有几项，那么传递进去的匿名回调函数就需要执行几次；\n- 理论上这个方法是没有返回值的，仅仅是遍历数组中的每一项，不对原来数组进行修改；但是可以自己通过数组的索引来修改原来的数组；\n\n  2.**map()「有返回值，可以 return」**\n\n- 参数：value 数组中的当前项,index 当前项的索引,array 原始数组；\n- 区别：map 的回调函数中支持 return 返回值；return 的是啥，相当于把数组中的这一项变为啥（并不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了）；\n\n# 总结\n\n循环方式对比是专门对比普通 for 循环和 foreach,以及其它遍历方式在大量运算后的结果，目前对比三大类型,for 循环,forin,foreac，以及 for 循环的几种不同运用，可以看到,不同的方式差距较大，在综合考虑性能和方便性和可靠性上还是多选用 for 吧，**在循环数组的时候还是用 for 循环吧，而在循环对象的时候再用 for...in**\n","source":"_posts/2018-05-27-JS几种数组遍历方式详解.md","raw":"---\ntitle: JS几种数组遍历方式详解\ntags:\n  - ES6\n  - JavaScript\ndate: 2018-05-27 20:42:38\ncategories: 前端\n---\n\n# 前言\n\n## 在前端开发中循环是必不可少的，在很多情况下不知道该用哪种循环类型，真是让人头大 😵🐷，因此知道每种循环 ♻️ 的运行效率是武装我们自己最有效的方式。\n\n# 一、循环的类型\n\n#     在前端循环中，有大概八种：\n\n### 第一种:普通 for 循环\n\n>     for(j = 0; j < arr.length; j++) {\n>\n>     }\n\n### 第二种:优化版 for 循环(**性能最高的一种**)\n\n>     for(j = 0,len=arr.length; j < len; j++) {\n>\n>     }\n\n### 第三种:弱化版 for 循环(**性能要远远小于普通 for 循环**)\n\n>     for(j = 0; arr[j]!=null; j++) {\n>\n>     }\n\n### 第四种:foreach 循环(性能比普通 for 循环弱)\n\n>     arr.forEach(function(e){\n>\n>     });\n\n### 第五种:foreach 变种(比普通 foreach 弱)\n\n>     Array.prototype.forEach.call(arr,function(el){\n>\n>     });\n\n### 第六种:forin 循环(**效率是最低**)\n\n>     for(j in arr) {\n>\n>     }\n\n### 第七种:map 遍历(实际效率还比不上 foreach)\n\n>     arr.map(function(n){\n>\n>     });\n\n### 第八种:forof 遍历(需要 ES6 支持)\n\n>     for(let value of arr) {\n>\n>     });\n\n# 二、循环的性能\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/demo_js_performanceAnalysis_jsarrayGoThrough_1-768x1024.png)\n\n# 三、循环的区别\n\n## 一、for...in 和 for...of 的区别\n\n1.  推荐在循环对象属性的时候，使用`for...in`,在遍历数组的时候的时候使用`for...of`。\n2.  `for...in`循环出的是 key，`for...of`循环出的是 value\n3.  注意，`for...of`是 ES6 新引入的特性。修复了 ES5 引入的`for...in`的不足\n4.  `for...of`不能循环普通的对象，需要通过和`Object.keys()`搭配使用\n\n### for...in 循环数组下面的对象时会把 key 也拿到\\[{id:123,name:\"王五\"}{id:234,name:\"张三\"}\\]遍历对象属性\n\n### for...of 循环数组下面的对象时会拿到 name\\[\"张三\",\"李四\"\\]遍历对象元素\n\n## 二、**forEach()和 map()**遍历的区别\n\n相同点：\n\n1.  都是循环遍历数组中的每一项。\n2.  forEach() 和 map() 里面每一次执行匿名函数都支持 3 个参数：数组中的当前项 item,当前项的索引 index,原始数组 input。\n3.  匿名函数中的 this 都是指 Window。\n4.  只能遍历数组。\n\n不同点： 1.**forEach()「没有返回值」**\n\n- 参数：value 数组中的当前项, index 当前项的索引, array 原始数组；\n- 数组中有几项，那么传递进去的匿名回调函数就需要执行几次；\n- 理论上这个方法是没有返回值的，仅仅是遍历数组中的每一项，不对原来数组进行修改；但是可以自己通过数组的索引来修改原来的数组；\n\n  2.**map()「有返回值，可以 return」**\n\n- 参数：value 数组中的当前项,index 当前项的索引,array 原始数组；\n- 区别：map 的回调函数中支持 return 返回值；return 的是啥，相当于把数组中的这一项变为啥（并不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了）；\n\n# 总结\n\n循环方式对比是专门对比普通 for 循环和 foreach,以及其它遍历方式在大量运算后的结果，目前对比三大类型,for 循环,forin,foreac，以及 for 循环的几种不同运用，可以看到,不同的方式差距较大，在综合考虑性能和方便性和可靠性上还是多选用 for 吧，**在循环数组的时候还是用 for 循环吧，而在循环对象的时候再用 for...in**\n","slug":"2018-05-27-JS几种数组遍历方式详解","published":1,"updated":"2020-03-14T06:51:36.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvlb002t4k8ycijtefsb","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><h2 id=\"在前端开发中循环是必不可少的，在很多情况下不知道该用哪种循环类型，真是让人头大-😵🐷，因此知道每种循环-♻️-的运行效率是武装我们自己最有效的方式。\"><a href=\"#在前端开发中循环是必不可少的，在很多情况下不知道该用哪种循环类型，真是让人头大-😵🐷，因此知道每种循环-♻️-的运行效率是武装我们自己最有效的方式。\" class=\"headerlink\" title=\"在前端开发中循环是必不可少的，在很多情况下不知道该用哪种循环类型，真是让人头大 😵🐷，因此知道每种循环 ♻️ 的运行效率是武装我们自己最有效的方式。\"></a>在前端开发中循环是必不可少的，在很多情况下不知道该用哪种循环类型，真是让人头大 😵🐷，因此知道每种循环 ♻️ 的运行效率是武装我们自己最有效的方式。</h2><h1 id=\"一、循环的类型\"><a href=\"#一、循环的类型\" class=\"headerlink\" title=\"一、循环的类型\"></a>一、循环的类型</h1><h1 id=\"在前端循环中，有大概八种：\"><a href=\"#在前端循环中，有大概八种：\" class=\"headerlink\" title=\"在前端循环中，有大概八种：\"></a>在前端循环中，有大概八种：</h1><h3 id=\"第一种-普通-for-循环\"><a href=\"#第一种-普通-for-循环\" class=\"headerlink\" title=\"第一种:普通 for 循环\"></a>第一种:普通 for 循环</h3><blockquote>\n<pre><code>for(j = 0; j &lt; arr.length; j++) {\n\n}</code></pre></blockquote>\n<h3 id=\"第二种-优化版-for-循环-性能最高的一种\"><a href=\"#第二种-优化版-for-循环-性能最高的一种\" class=\"headerlink\" title=\"第二种:优化版 for 循环(性能最高的一种)\"></a>第二种:优化版 for 循环(<strong>性能最高的一种</strong>)</h3><blockquote>\n<pre><code>for(j = 0,len=arr.length; j &lt; len; j++) {\n\n}</code></pre></blockquote>\n<h3 id=\"第三种-弱化版-for-循环-性能要远远小于普通-for-循环\"><a href=\"#第三种-弱化版-for-循环-性能要远远小于普通-for-循环\" class=\"headerlink\" title=\"第三种:弱化版 for 循环(性能要远远小于普通 for 循环)\"></a>第三种:弱化版 for 循环(<strong>性能要远远小于普通 for 循环</strong>)</h3><blockquote>\n<pre><code>for(j = 0; arr[j]!=null; j++) {\n\n}</code></pre></blockquote>\n<h3 id=\"第四种-foreach-循环-性能比普通-for-循环弱\"><a href=\"#第四种-foreach-循环-性能比普通-for-循环弱\" class=\"headerlink\" title=\"第四种:foreach 循环(性能比普通 for 循环弱)\"></a>第四种:foreach 循环(性能比普通 for 循环弱)</h3><blockquote>\n<pre><code>arr.forEach(function(e){\n\n});</code></pre></blockquote>\n<h3 id=\"第五种-foreach-变种-比普通-foreach-弱\"><a href=\"#第五种-foreach-变种-比普通-foreach-弱\" class=\"headerlink\" title=\"第五种:foreach 变种(比普通 foreach 弱)\"></a>第五种:foreach 变种(比普通 foreach 弱)</h3><blockquote>\n<pre><code>Array.prototype.forEach.call(arr,function(el){\n\n});</code></pre></blockquote>\n<h3 id=\"第六种-forin-循环-效率是最低\"><a href=\"#第六种-forin-循环-效率是最低\" class=\"headerlink\" title=\"第六种:forin 循环(效率是最低)\"></a>第六种:forin 循环(<strong>效率是最低</strong>)</h3><blockquote>\n<pre><code>for(j in arr) {\n\n}</code></pre></blockquote>\n<h3 id=\"第七种-map-遍历-实际效率还比不上-foreach\"><a href=\"#第七种-map-遍历-实际效率还比不上-foreach\" class=\"headerlink\" title=\"第七种:map 遍历(实际效率还比不上 foreach)\"></a>第七种:map 遍历(实际效率还比不上 foreach)</h3><blockquote>\n<pre><code>arr.map(function(n){\n\n});</code></pre></blockquote>\n<h3 id=\"第八种-forof-遍历-需要-ES6-支持\"><a href=\"#第八种-forof-遍历-需要-ES6-支持\" class=\"headerlink\" title=\"第八种:forof 遍历(需要 ES6 支持)\"></a>第八种:forof 遍历(需要 ES6 支持)</h3><blockquote>\n<pre><code>for(let value of arr) {\n\n});</code></pre></blockquote>\n<h1 id=\"二、循环的性能\"><a href=\"#二、循环的性能\" class=\"headerlink\" title=\"二、循环的性能\"></a>二、循环的性能</h1><p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/demo_js_performanceAnalysis_jsarrayGoThrough_1-768x1024.png\" alt=\"\"></p>\n<h1 id=\"三、循环的区别\"><a href=\"#三、循环的区别\" class=\"headerlink\" title=\"三、循环的区别\"></a>三、循环的区别</h1><h2 id=\"一、for…in-和-for…of-的区别\"><a href=\"#一、for…in-和-for…of-的区别\" class=\"headerlink\" title=\"一、for…in 和 for…of 的区别\"></a>一、for…in 和 for…of 的区别</h2><ol>\n<li>推荐在循环对象属性的时候，使用<code>for...in</code>,在遍历数组的时候的时候使用<code>for...of</code>。</li>\n<li><code>for...in</code>循环出的是 key，<code>for...of</code>循环出的是 value</li>\n<li>注意，<code>for...of</code>是 ES6 新引入的特性。修复了 ES5 引入的<code>for...in</code>的不足</li>\n<li><code>for...of</code>不能循环普通的对象，需要通过和<code>Object.keys()</code>搭配使用</li>\n</ol>\n<h3 id=\"for…in-循环数组下面的对象时会把-key-也拿到-id-123-name-”王五”-id-234-name-”张三”-遍历对象属性\"><a href=\"#for…in-循环数组下面的对象时会把-key-也拿到-id-123-name-”王五”-id-234-name-”张三”-遍历对象属性\" class=\"headerlink\" title=\"for…in 循环数组下面的对象时会把 key 也拿到[{id:123,name:”王五”}{id:234,name:”张三”}]遍历对象属性\"></a>for…in 循环数组下面的对象时会把 key 也拿到[{id:123,name:”王五”}{id:234,name:”张三”}]遍历对象属性</h3><h3 id=\"for…of-循环数组下面的对象时会拿到-name-“张三”-”李四”-遍历对象元素\"><a href=\"#for…of-循环数组下面的对象时会拿到-name-“张三”-”李四”-遍历对象元素\" class=\"headerlink\" title=\"for…of 循环数组下面的对象时会拿到 name[“张三”,”李四”]遍历对象元素\"></a>for…of 循环数组下面的对象时会拿到 name[“张三”,”李四”]遍历对象元素</h3><h2 id=\"二、forEach-和-map-遍历的区别\"><a href=\"#二、forEach-和-map-遍历的区别\" class=\"headerlink\" title=\"二、forEach()和 map()遍历的区别\"></a>二、<strong>forEach()和 map()</strong>遍历的区别</h2><p>相同点：</p>\n<ol>\n<li>都是循环遍历数组中的每一项。</li>\n<li>forEach() 和 map() 里面每一次执行匿名函数都支持 3 个参数：数组中的当前项 item,当前项的索引 index,原始数组 input。</li>\n<li>匿名函数中的 this 都是指 Window。</li>\n<li>只能遍历数组。</li>\n</ol>\n<p>不同点： 1.<strong>forEach()「没有返回值」</strong></p>\n<ul>\n<li><p>参数：value 数组中的当前项, index 当前项的索引, array 原始数组；</p>\n</li>\n<li><p>数组中有几项，那么传递进去的匿名回调函数就需要执行几次；</p>\n</li>\n<li><p>理论上这个方法是没有返回值的，仅仅是遍历数组中的每一项，不对原来数组进行修改；但是可以自己通过数组的索引来修改原来的数组；</p>\n<p>2.<strong>map()「有返回值，可以 return」</strong></p>\n</li>\n<li><p>参数：value 数组中的当前项,index 当前项的索引,array 原始数组；</p>\n</li>\n<li><p>区别：map 的回调函数中支持 return 返回值；return 的是啥，相当于把数组中的这一项变为啥（并不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了）；</p>\n</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>循环方式对比是专门对比普通 for 循环和 foreach,以及其它遍历方式在大量运算后的结果，目前对比三大类型,for 循环,forin,foreac，以及 for 循环的几种不同运用，可以看到,不同的方式差距较大，在综合考虑性能和方便性和可靠性上还是多选用 for 吧，<strong>在循环数组的时候还是用 for 循环吧，而在循环对象的时候再用 for…in</strong></p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><h2 id=\"在前端开发中循环是必不可少的，在很多情况下不知道该用哪种循环类型，真是让人头大-😵🐷，因此知道每种循环-♻️-的运行效率是武装我们自己最有效的方式。\"><a href=\"#在前端开发中循环是必不可少的，在很多情况下不知道该用哪种循环类型，真是让人头大-😵🐷，因此知道每种循环-♻️-的运行效率是武装我们自己最有效的方式。\" class=\"headerlink\" title=\"在前端开发中循环是必不可少的，在很多情况下不知道该用哪种循环类型，真是让人头大 😵🐷，因此知道每种循环 ♻️ 的运行效率是武装我们自己最有效的方式。\"></a>在前端开发中循环是必不可少的，在很多情况下不知道该用哪种循环类型，真是让人头大 😵🐷，因此知道每种循环 ♻️ 的运行效率是武装我们自己最有效的方式。</h2><h1 id=\"一、循环的类型\"><a href=\"#一、循环的类型\" class=\"headerlink\" title=\"一、循环的类型\"></a>一、循环的类型</h1><h1 id=\"在前端循环中，有大概八种：\"><a href=\"#在前端循环中，有大概八种：\" class=\"headerlink\" title=\"在前端循环中，有大概八种：\"></a>在前端循环中，有大概八种：</h1><h3 id=\"第一种-普通-for-循环\"><a href=\"#第一种-普通-for-循环\" class=\"headerlink\" title=\"第一种:普通 for 循环\"></a>第一种:普通 for 循环</h3><blockquote>\n<pre><code>for(j = 0; j &lt; arr.length; j++) {\n\n}</code></pre></blockquote>\n<h3 id=\"第二种-优化版-for-循环-性能最高的一种\"><a href=\"#第二种-优化版-for-循环-性能最高的一种\" class=\"headerlink\" title=\"第二种:优化版 for 循环(性能最高的一种)\"></a>第二种:优化版 for 循环(<strong>性能最高的一种</strong>)</h3><blockquote>\n<pre><code>for(j = 0,len=arr.length; j &lt; len; j++) {\n\n}</code></pre></blockquote>\n<h3 id=\"第三种-弱化版-for-循环-性能要远远小于普通-for-循环\"><a href=\"#第三种-弱化版-for-循环-性能要远远小于普通-for-循环\" class=\"headerlink\" title=\"第三种:弱化版 for 循环(性能要远远小于普通 for 循环)\"></a>第三种:弱化版 for 循环(<strong>性能要远远小于普通 for 循环</strong>)</h3><blockquote>\n<pre><code>for(j = 0; arr[j]!=null; j++) {\n\n}</code></pre></blockquote>\n<h3 id=\"第四种-foreach-循环-性能比普通-for-循环弱\"><a href=\"#第四种-foreach-循环-性能比普通-for-循环弱\" class=\"headerlink\" title=\"第四种:foreach 循环(性能比普通 for 循环弱)\"></a>第四种:foreach 循环(性能比普通 for 循环弱)</h3><blockquote>\n<pre><code>arr.forEach(function(e){\n\n});</code></pre></blockquote>\n<h3 id=\"第五种-foreach-变种-比普通-foreach-弱\"><a href=\"#第五种-foreach-变种-比普通-foreach-弱\" class=\"headerlink\" title=\"第五种:foreach 变种(比普通 foreach 弱)\"></a>第五种:foreach 变种(比普通 foreach 弱)</h3><blockquote>\n<pre><code>Array.prototype.forEach.call(arr,function(el){\n\n});</code></pre></blockquote>\n<h3 id=\"第六种-forin-循环-效率是最低\"><a href=\"#第六种-forin-循环-效率是最低\" class=\"headerlink\" title=\"第六种:forin 循环(效率是最低)\"></a>第六种:forin 循环(<strong>效率是最低</strong>)</h3><blockquote>\n<pre><code>for(j in arr) {\n\n}</code></pre></blockquote>\n<h3 id=\"第七种-map-遍历-实际效率还比不上-foreach\"><a href=\"#第七种-map-遍历-实际效率还比不上-foreach\" class=\"headerlink\" title=\"第七种:map 遍历(实际效率还比不上 foreach)\"></a>第七种:map 遍历(实际效率还比不上 foreach)</h3><blockquote>\n<pre><code>arr.map(function(n){\n\n});</code></pre></blockquote>\n<h3 id=\"第八种-forof-遍历-需要-ES6-支持\"><a href=\"#第八种-forof-遍历-需要-ES6-支持\" class=\"headerlink\" title=\"第八种:forof 遍历(需要 ES6 支持)\"></a>第八种:forof 遍历(需要 ES6 支持)</h3><blockquote>\n<pre><code>for(let value of arr) {\n\n});</code></pre></blockquote>\n<h1 id=\"二、循环的性能\"><a href=\"#二、循环的性能\" class=\"headerlink\" title=\"二、循环的性能\"></a>二、循环的性能</h1><p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/demo_js_performanceAnalysis_jsarrayGoThrough_1-768x1024.png\" alt=\"\"></p>\n<h1 id=\"三、循环的区别\"><a href=\"#三、循环的区别\" class=\"headerlink\" title=\"三、循环的区别\"></a>三、循环的区别</h1><h2 id=\"一、for…in-和-for…of-的区别\"><a href=\"#一、for…in-和-for…of-的区别\" class=\"headerlink\" title=\"一、for…in 和 for…of 的区别\"></a>一、for…in 和 for…of 的区别</h2><ol>\n<li>推荐在循环对象属性的时候，使用<code>for...in</code>,在遍历数组的时候的时候使用<code>for...of</code>。</li>\n<li><code>for...in</code>循环出的是 key，<code>for...of</code>循环出的是 value</li>\n<li>注意，<code>for...of</code>是 ES6 新引入的特性。修复了 ES5 引入的<code>for...in</code>的不足</li>\n<li><code>for...of</code>不能循环普通的对象，需要通过和<code>Object.keys()</code>搭配使用</li>\n</ol>\n<h3 id=\"for…in-循环数组下面的对象时会把-key-也拿到-id-123-name-”王五”-id-234-name-”张三”-遍历对象属性\"><a href=\"#for…in-循环数组下面的对象时会把-key-也拿到-id-123-name-”王五”-id-234-name-”张三”-遍历对象属性\" class=\"headerlink\" title=\"for…in 循环数组下面的对象时会把 key 也拿到[{id:123,name:”王五”}{id:234,name:”张三”}]遍历对象属性\"></a>for…in 循环数组下面的对象时会把 key 也拿到[{id:123,name:”王五”}{id:234,name:”张三”}]遍历对象属性</h3><h3 id=\"for…of-循环数组下面的对象时会拿到-name-“张三”-”李四”-遍历对象元素\"><a href=\"#for…of-循环数组下面的对象时会拿到-name-“张三”-”李四”-遍历对象元素\" class=\"headerlink\" title=\"for…of 循环数组下面的对象时会拿到 name[“张三”,”李四”]遍历对象元素\"></a>for…of 循环数组下面的对象时会拿到 name[“张三”,”李四”]遍历对象元素</h3><h2 id=\"二、forEach-和-map-遍历的区别\"><a href=\"#二、forEach-和-map-遍历的区别\" class=\"headerlink\" title=\"二、forEach()和 map()遍历的区别\"></a>二、<strong>forEach()和 map()</strong>遍历的区别</h2><p>相同点：</p>\n<ol>\n<li>都是循环遍历数组中的每一项。</li>\n<li>forEach() 和 map() 里面每一次执行匿名函数都支持 3 个参数：数组中的当前项 item,当前项的索引 index,原始数组 input。</li>\n<li>匿名函数中的 this 都是指 Window。</li>\n<li>只能遍历数组。</li>\n</ol>\n<p>不同点： 1.<strong>forEach()「没有返回值」</strong></p>\n<ul>\n<li><p>参数：value 数组中的当前项, index 当前项的索引, array 原始数组；</p>\n</li>\n<li><p>数组中有几项，那么传递进去的匿名回调函数就需要执行几次；</p>\n</li>\n<li><p>理论上这个方法是没有返回值的，仅仅是遍历数组中的每一项，不对原来数组进行修改；但是可以自己通过数组的索引来修改原来的数组；</p>\n<p>2.<strong>map()「有返回值，可以 return」</strong></p>\n</li>\n<li><p>参数：value 数组中的当前项,index 当前项的索引,array 原始数组；</p>\n</li>\n<li><p>区别：map 的回调函数中支持 return 返回值；return 的是啥，相当于把数组中的这一项变为啥（并不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了）；</p>\n</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>循环方式对比是专门对比普通 for 循环和 foreach,以及其它遍历方式在大量运算后的结果，目前对比三大类型,for 循环,forin,foreac，以及 for 循环的几种不同运用，可以看到,不同的方式差距较大，在综合考虑性能和方便性和可靠性上还是多选用 for 吧，<strong>在循环数组的时候还是用 for 循环吧，而在循环对象的时候再用 for…in</strong></p>\n"},{"title":"vue实现非路由跳转以及数据传递","date":"2017-09-16T09:16:00.000Z","_content":"\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/1213869-20170917010706391-470964538.gif)\n\n定义一个父组件\n\n<span style=\"color: #008000;\">/_</span><span style=\"color: #008000;\"> ============ \\* Home Index Page \\* ============ \\* \\* The home index page.\n</span><span style=\"color: #008000;\">_/</span><span style=\"color: #000000;\">\n\nimport VLayout from </span>'@/layouts/Default'<span style=\"color: #000000;\">;\nimport VCard from </span>'@/components/Card'<span style=\"color: #000000;\">;\nimport MyButton from </span>'@/components/MyButton'<span style=\"color: #000000;\">;\n\nexport </span><span style=\"color: #0000ff;\">default</span><span style=\"color: #000000;\"> {\n</span><span style=\"color: #008000;\">/_</span><span style=\"color: #008000;\">_ \\* The name of the page.\n</span><span style=\"color: #008000;\">_/</span><span style=\"color: #000000;\">\nname: </span>'home-index'<span style=\"color: #000000;\">,\ndata() {\n</span><span style=\"color: #0000ff;\">return</span><span style=\"color: #000000;\"> {\nshow: </span><span style=\"color: #0000ff;\">true</span><span style=\"color: #000000;\">,\nshowDate: </span>\"父子间传过来的数据\"<span style=\"color: #000000;\">\n}\n},\nmethods: {\ntoggle1(){\n</span><span style=\"color: #0000ff;\">this</span>.show =<span style=\"color: #0000ff;\">false</span><span style=\"color: #000000;\">;\n},\ntoggle(data) {\nconsole.log(data)\n</span><span style=\"color: #0000ff;\">this</span>.show =<span style=\"color: #000000;\"> data;\n}\n},\nmounted() {\n</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> this.toggle();</span>\n<span style=\"color: #000000;\"> },\n</span><span style=\"color: #008000;\">/_</span><span style=\"color: #008000;\">_ \\* The components that the page can use.\n</span><span style=\"color: #008000;\">_/</span><span style=\"color: #000000;\">\ncomponents: {\nVLayout,\nVCard,\nMyButton\n},\n};\n</span>\n\n再定义一个子组件\n\n<span style=\"color: #000000;\">\nexport </span><span style=\"color: #0000ff;\">default</span><span style=\"color: #000000;\"> {\n    props: \\[</span>\"showDate\"<span style=\"color: #000000;\">\\],\n    methods: {\n        toggle1() {\n            </span><span style=\"color: #0000ff;\">this</span>.$emit('toggleEvent', \"false\"<span style=\"color: #000000;\">)\n        }\n    }\n\n}\n</span>\n\n将父组件的数据通过 porps 传递到子组件,子组件通过 this.\\$emit(‘触发的事件函数’，要传输的数据)\n\n就目前来说（组件之间传递数据共有三种方法）：\n\n1.通过父子组件之间的通信\n\n2.通过 vuex\n\n3.通过路由传参\n\n要说的就这么多，晚安~~~\n","source":"_posts/2019-09-16-vue实现非路由跳转以及数据传递.md","raw":"---\ntitle: vue实现非路由跳转以及数据传递\ntags:\n  - 技术\n  - vue\ndate: 2017-09-16 17:16:00\ncategories: 前端\n---\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/1213869-20170917010706391-470964538.gif)\n\n定义一个父组件\n\n<span style=\"color: #008000;\">/_</span><span style=\"color: #008000;\"> ============ \\* Home Index Page \\* ============ \\* \\* The home index page.\n</span><span style=\"color: #008000;\">_/</span><span style=\"color: #000000;\">\n\nimport VLayout from </span>'@/layouts/Default'<span style=\"color: #000000;\">;\nimport VCard from </span>'@/components/Card'<span style=\"color: #000000;\">;\nimport MyButton from </span>'@/components/MyButton'<span style=\"color: #000000;\">;\n\nexport </span><span style=\"color: #0000ff;\">default</span><span style=\"color: #000000;\"> {\n</span><span style=\"color: #008000;\">/_</span><span style=\"color: #008000;\">_ \\* The name of the page.\n</span><span style=\"color: #008000;\">_/</span><span style=\"color: #000000;\">\nname: </span>'home-index'<span style=\"color: #000000;\">,\ndata() {\n</span><span style=\"color: #0000ff;\">return</span><span style=\"color: #000000;\"> {\nshow: </span><span style=\"color: #0000ff;\">true</span><span style=\"color: #000000;\">,\nshowDate: </span>\"父子间传过来的数据\"<span style=\"color: #000000;\">\n}\n},\nmethods: {\ntoggle1(){\n</span><span style=\"color: #0000ff;\">this</span>.show =<span style=\"color: #0000ff;\">false</span><span style=\"color: #000000;\">;\n},\ntoggle(data) {\nconsole.log(data)\n</span><span style=\"color: #0000ff;\">this</span>.show =<span style=\"color: #000000;\"> data;\n}\n},\nmounted() {\n</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> this.toggle();</span>\n<span style=\"color: #000000;\"> },\n</span><span style=\"color: #008000;\">/_</span><span style=\"color: #008000;\">_ \\* The components that the page can use.\n</span><span style=\"color: #008000;\">_/</span><span style=\"color: #000000;\">\ncomponents: {\nVLayout,\nVCard,\nMyButton\n},\n};\n</span>\n\n再定义一个子组件\n\n<span style=\"color: #000000;\">\nexport </span><span style=\"color: #0000ff;\">default</span><span style=\"color: #000000;\"> {\n    props: \\[</span>\"showDate\"<span style=\"color: #000000;\">\\],\n    methods: {\n        toggle1() {\n            </span><span style=\"color: #0000ff;\">this</span>.$emit('toggleEvent', \"false\"<span style=\"color: #000000;\">)\n        }\n    }\n\n}\n</span>\n\n将父组件的数据通过 porps 传递到子组件,子组件通过 this.\\$emit(‘触发的事件函数’，要传输的数据)\n\n就目前来说（组件之间传递数据共有三种方法）：\n\n1.通过父子组件之间的通信\n\n2.通过 vuex\n\n3.通过路由传参\n\n要说的就这么多，晚安~~~\n","slug":"2019-09-16-vue实现非路由跳转以及数据传递","published":1,"updated":"2020-03-14T06:52:23.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvld002x4k8y5vq0esaw","content":"<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1213869-20170917010706391-470964538.gif\" alt=\"\"></p>\n<p>定义一个父组件</p>\n<p><span style=\"color: #008000;\">/_</span><span style=\"color: #008000;\"> ============ * Home Index Page * ============ * * The home index page.<br></span><span style=\"color: #008000;\">_/</span><span style=\"color: #000000;\"></p>\n<p>import VLayout from </span>‘@/layouts/Default’<span style=\"color: #000000;\">;<br>import VCard from </span>‘@/components/Card’<span style=\"color: #000000;\">;<br>import MyButton from </span>‘@/components/MyButton’<span style=\"color: #000000;\">;</p>\n<p>export </span><span style=\"color: #0000ff;\">default</span><span style=\"color: #000000;\"> {<br></span><span style=\"color: #008000;\">/_</span><span style=\"color: #008000;\">_ * The name of the page.<br></span><span style=\"color: #008000;\"><em>/</span><span style=\"color: #000000;\"><br>name: </span>‘home-index’<span style=\"color: #000000;\">,<br>data() {<br></span><span style=\"color: #0000ff;\">return</span><span style=\"color: #000000;\"> {<br>show: </span><span style=\"color: #0000ff;\">true</span><span style=\"color: #000000;\">,<br>showDate: </span>“父子间传过来的数据”<span style=\"color: #000000;\"><br>}<br>},<br>methods: {<br>toggle1(){<br></span><span style=\"color: #0000ff;\">this</span>.show =<span style=\"color: #0000ff;\">false</span><span style=\"color: #000000;\">;<br>},<br>toggle(data) {<br>console.log(data)<br></span><span style=\"color: #0000ff;\">this</span>.show =<span style=\"color: #000000;\"> data;<br>}<br>},<br>mounted() {<br></span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> this.toggle();</span><br><span style=\"color: #000000;\"> },<br></span><span style=\"color: #008000;\">/</em></span><span style=\"color: #008000;\">_ * The components that the page can use.<br></span><span style=\"color: #008000;\">_/</span><span style=\"color: #000000;\"><br>components: {<br>VLayout,<br>VCard,<br>MyButton<br>},<br>};<br></span></p>\n<p>再定义一个子组件</p>\n<span style=\"color: #000000;\">\nexport </span><span style=\"color: #0000ff;\">default</span><span style=\"color: #000000;\"> {\n    props: \\[</span>\"showDate\"<span style=\"color: #000000;\">\\],\n    methods: {\n        toggle1() {\n            </span><span style=\"color: #0000ff;\">this</span>.$emit('toggleEvent', \"false\"<span style=\"color: #000000;\">)\n        }\n    }\n\n<p>}<br></span></p>\n<p>将父组件的数据通过 porps 传递到子组件,子组件通过 this.$emit(‘触发的事件函数’，要传输的数据)</p>\n<p>就目前来说（组件之间传递数据共有三种方法）：</p>\n<p>1.通过父子组件之间的通信</p>\n<p>2.通过 vuex</p>\n<p>3.通过路由传参</p>\n<p>要说的就这么多，晚安<del>~</del></p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1213869-20170917010706391-470964538.gif\" alt=\"\"></p>\n<p>定义一个父组件</p>\n<p><span style=\"color: #008000;\">/_</span><span style=\"color: #008000;\"> ============ * Home Index Page * ============ * * The home index page.<br></span><span style=\"color: #008000;\">_/</span><span style=\"color: #000000;\"></p>\n<p>import VLayout from </span>‘@/layouts/Default’<span style=\"color: #000000;\">;<br>import VCard from </span>‘@/components/Card’<span style=\"color: #000000;\">;<br>import MyButton from </span>‘@/components/MyButton’<span style=\"color: #000000;\">;</p>\n<p>export </span><span style=\"color: #0000ff;\">default</span><span style=\"color: #000000;\"> {<br></span><span style=\"color: #008000;\">/_</span><span style=\"color: #008000;\">_ * The name of the page.<br></span><span style=\"color: #008000;\"><em>/</span><span style=\"color: #000000;\"><br>name: </span>‘home-index’<span style=\"color: #000000;\">,<br>data() {<br></span><span style=\"color: #0000ff;\">return</span><span style=\"color: #000000;\"> {<br>show: </span><span style=\"color: #0000ff;\">true</span><span style=\"color: #000000;\">,<br>showDate: </span>“父子间传过来的数据”<span style=\"color: #000000;\"><br>}<br>},<br>methods: {<br>toggle1(){<br></span><span style=\"color: #0000ff;\">this</span>.show =<span style=\"color: #0000ff;\">false</span><span style=\"color: #000000;\">;<br>},<br>toggle(data) {<br>console.log(data)<br></span><span style=\"color: #0000ff;\">this</span>.show =<span style=\"color: #000000;\"> data;<br>}<br>},<br>mounted() {<br></span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> this.toggle();</span><br><span style=\"color: #000000;\"> },<br></span><span style=\"color: #008000;\">/</em></span><span style=\"color: #008000;\">_ * The components that the page can use.<br></span><span style=\"color: #008000;\">_/</span><span style=\"color: #000000;\"><br>components: {<br>VLayout,<br>VCard,<br>MyButton<br>},<br>};<br></span></p>\n<p>再定义一个子组件</p>\n<span style=\"color: #000000;\">\nexport </span><span style=\"color: #0000ff;\">default</span><span style=\"color: #000000;\"> {\n    props: \\[</span>\"showDate\"<span style=\"color: #000000;\">\\],\n    methods: {\n        toggle1() {\n            </span><span style=\"color: #0000ff;\">this</span>.$emit('toggleEvent', \"false\"<span style=\"color: #000000;\">)\n        }\n    }\n\n<p>}<br></span></p>\n<p>将父组件的数据通过 porps 传递到子组件,子组件通过 this.$emit(‘触发的事件函数’，要传输的数据)</p>\n<p>就目前来说（组件之间传递数据共有三种方法）：</p>\n<p>1.通过父子组件之间的通信</p>\n<p>2.通过 vuex</p>\n<p>3.通过路由传参</p>\n<p>要说的就这么多，晚安<del>~</del></p>\n"},{"layout":"post","title":"约在春天相见","date":"2020-03-13T03:57:26.000Z","img":"https://s1.ax1x.com/2020/03/14/8l3Eh6.png","top":false,"toc":false,"_content":"\n<center>\n\n# 《约在春天相见》\n\n## 词曲：大雄\n\n我们约在春天相见\n那是多么美好的画面\n站在珞珈山下\n我们白衣翩翩\n和樱花笑成了一片\n\n我们约在春天相见\n穿过这个冬天的梦魇\n户部巷的炊烟\n暖不了冰冷防线\n谁比我们更理解想念\n\n穿越死亡的我们啊\n泪水往下咽\n雾锁长江 黄鹤飞不见\n魔鬼的威胁在信誓旦旦\n谁在救度 谁在欺骗\n\n四散逃亡的我们啊\n泪水要擦干\n善良是我们最后的企盼\n比瘟疫更可怕的是谎言\n歌舞升平 白骨如山\n\n我们约在春天相见\n兑现一个古老的誓言\n坐在渡船两岸\n青春肩并着肩\n乘着光明一路向前\n\n穿越死亡的我们啊\n泪水往下咽\n雾锁长江 黄鹤飞不见\n魔鬼的威胁在信誓旦旦\n谁在救度 谁在欺骗\n\n四散逃亡的我们啊\n泪水要擦干\n善良是我们最后的企盼\n比瘟疫更可怕的是谎言\n歌舞升平 白骨如山\n\n天南地北的我们啊\n泪水苦也咸\n谁来守护这悲情的家园\n厉尽劫难，谁把希望点燃\n\n时代革命 光复武汉\n\n</center>\n","source":"_posts/2020-03-14-约在春天相见.md","raw":"---\nlayout: post\ntitle: 约在春天相见\ndate: 2020-03-13 11:57:26\nimg: https://s1.ax1x.com/2020/03/14/8l3Eh6.png\ntop: false\ntoc: false\ntags: [人生百态]\ncategories: 琐碎\n---\n\n<center>\n\n# 《约在春天相见》\n\n## 词曲：大雄\n\n我们约在春天相见\n那是多么美好的画面\n站在珞珈山下\n我们白衣翩翩\n和樱花笑成了一片\n\n我们约在春天相见\n穿过这个冬天的梦魇\n户部巷的炊烟\n暖不了冰冷防线\n谁比我们更理解想念\n\n穿越死亡的我们啊\n泪水往下咽\n雾锁长江 黄鹤飞不见\n魔鬼的威胁在信誓旦旦\n谁在救度 谁在欺骗\n\n四散逃亡的我们啊\n泪水要擦干\n善良是我们最后的企盼\n比瘟疫更可怕的是谎言\n歌舞升平 白骨如山\n\n我们约在春天相见\n兑现一个古老的誓言\n坐在渡船两岸\n青春肩并着肩\n乘着光明一路向前\n\n穿越死亡的我们啊\n泪水往下咽\n雾锁长江 黄鹤飞不见\n魔鬼的威胁在信誓旦旦\n谁在救度 谁在欺骗\n\n四散逃亡的我们啊\n泪水要擦干\n善良是我们最后的企盼\n比瘟疫更可怕的是谎言\n歌舞升平 白骨如山\n\n天南地北的我们啊\n泪水苦也咸\n谁来守护这悲情的家园\n厉尽劫难，谁把希望点燃\n\n时代革命 光复武汉\n\n</center>\n","slug":"2020-03-14-约在春天相见","published":1,"updated":"2020-03-14T12:25:04.735Z","comments":1,"photos":[],"link":"","_id":"ck7u2pvle00304k8y9h34f9dv","content":"<center>\n\n<h1 id=\"《约在春天相见》\"><a href=\"#《约在春天相见》\" class=\"headerlink\" title=\"《约在春天相见》\"></a>《约在春天相见》</h1><h2 id=\"词曲：大雄\"><a href=\"#词曲：大雄\" class=\"headerlink\" title=\"词曲：大雄\"></a>词曲：大雄</h2><p>我们约在春天相见<br>那是多么美好的画面<br>站在珞珈山下<br>我们白衣翩翩<br>和樱花笑成了一片</p>\n<p>我们约在春天相见<br>穿过这个冬天的梦魇<br>户部巷的炊烟<br>暖不了冰冷防线<br>谁比我们更理解想念</p>\n<p>穿越死亡的我们啊<br>泪水往下咽<br>雾锁长江 黄鹤飞不见<br>魔鬼的威胁在信誓旦旦<br>谁在救度 谁在欺骗</p>\n<p>四散逃亡的我们啊<br>泪水要擦干<br>善良是我们最后的企盼<br>比瘟疫更可怕的是谎言<br>歌舞升平 白骨如山</p>\n<p>我们约在春天相见<br>兑现一个古老的誓言<br>坐在渡船两岸<br>青春肩并着肩<br>乘着光明一路向前</p>\n<p>穿越死亡的我们啊<br>泪水往下咽<br>雾锁长江 黄鹤飞不见<br>魔鬼的威胁在信誓旦旦<br>谁在救度 谁在欺骗</p>\n<p>四散逃亡的我们啊<br>泪水要擦干<br>善良是我们最后的企盼<br>比瘟疫更可怕的是谎言<br>歌舞升平 白骨如山</p>\n<p>天南地北的我们啊<br>泪水苦也咸<br>谁来守护这悲情的家园<br>厉尽劫难，谁把希望点燃</p>\n<p>时代革命 光复武汉</p>\n</center>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<center>\n\n<h1 id=\"《约在春天相见》\"><a href=\"#《约在春天相见》\" class=\"headerlink\" title=\"《约在春天相见》\"></a>《约在春天相见》</h1><h2 id=\"词曲：大雄\"><a href=\"#词曲：大雄\" class=\"headerlink\" title=\"词曲：大雄\"></a>词曲：大雄</h2><p>我们约在春天相见<br>那是多么美好的画面<br>站在珞珈山下<br>我们白衣翩翩<br>和樱花笑成了一片</p>\n<p>我们约在春天相见<br>穿过这个冬天的梦魇<br>户部巷的炊烟<br>暖不了冰冷防线<br>谁比我们更理解想念</p>\n<p>穿越死亡的我们啊<br>泪水往下咽<br>雾锁长江 黄鹤飞不见<br>魔鬼的威胁在信誓旦旦<br>谁在救度 谁在欺骗</p>\n<p>四散逃亡的我们啊<br>泪水要擦干<br>善良是我们最后的企盼<br>比瘟疫更可怕的是谎言<br>歌舞升平 白骨如山</p>\n<p>我们约在春天相见<br>兑现一个古老的誓言<br>坐在渡船两岸<br>青春肩并着肩<br>乘着光明一路向前</p>\n<p>穿越死亡的我们啊<br>泪水往下咽<br>雾锁长江 黄鹤飞不见<br>魔鬼的威胁在信誓旦旦<br>谁在救度 谁在欺骗</p>\n<p>四散逃亡的我们啊<br>泪水要擦干<br>善良是我们最后的企盼<br>比瘟疫更可怕的是谎言<br>歌舞升平 白骨如山</p>\n<p>天南地北的我们啊<br>泪水苦也咸<br>谁来守护这悲情的家园<br>厉尽劫难，谁把希望点燃</p>\n<p>时代革命 光复武汉</p>\n</center>\n"},{"title":"Flex 布局教程：语法篇","date":"2017-08-07T22:55:00.000Z","_content":"\n网页布局（layout）是 CSS 的一个重点应用。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071001-1.gif)\n\n布局的传统解决方案，基于[盒状模型](https://developer.mozilla.org/en-US/docs/Web/CSS/box_model)，依赖  [`display`](https://developer.mozilla.org/en-US/docs/Web/CSS/display)  属性 + [`position`](https://developer.mozilla.org/en-US/docs/Web/CSS/position)属性 + [`float`](https://developer.mozilla.org/en-US/docs/Web/CSS/float)属性。它对于那些特殊布局非常不方便，比如，[垂直居中](https://css-tricks.com/centering-css-complete-guide/)就不容易实现。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071002-1.png)\n\n2009 年，W3C 提出了一种新的方案----Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071003-1.jpg)\n\nFlex 布局将成为未来布局的首选方案。本文介绍它的语法，[下一篇文章](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html)给出常见布局的 Flex 写法。网友  [JailBreak](http://vgee.cn/)为本文的所有示例制作了  [Demo](http://static.vgee.cn/static/index.html)，也可以参考。\n\n以下内容主要参考了下面两篇文章：[A Complete Guide to Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)  和  [A Visual Guide to CSS3 Flexbox Properties](https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties)。\n\n## 一、Flex 布局是什么？\n\nFlex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。\n\n任何一个容器都可以指定为 Flex 布局。\n\n>     .box{\n>       display: flex;\n>     }\n\n行内元素也可以使用 Flex 布局。\n\n>     .box{\n>       display: inline-flex;\n>     }\n\nWebkit 内核的浏览器，必须加上`-webkit`前缀。\n\n>     .box{\n>       display: -webkit-flex; /* Safari */\n>       display: flex;\n>     }\n\n注意，设为 Flex 布局以后，子元素的`float`、`clear`和`vertical-align`属性将失效。\n\n## 二、基本概念\n\n采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071004-1.png)\n\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做`main start`，结束位置叫做`main end`；交叉轴的开始位置叫做`cross start`，结束位置叫做`cross end`。\n\n项目默认沿主轴排列。单个项目占据的主轴空间叫做`main size`，占据的交叉轴空间叫做`cross size`。\n\n## 三、容器的属性\n\n以下 6 个属性设置在容器上。\n\n> - flex-direction\n> - flex-wrap\n> - flex-flow\n> - justify-content\n> - align-items\n> - align-content\n\n### 3.1 flex-direction 属性\n\n`flex-direction`属性决定主轴的方向（即项目的排列方向）。\n\n>     .box {\n>       flex-direction: row | row-reverse | column | column-reverse;\n>     }\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071005-1.png)\n\n它可能有 4 个值。\n\n> - `row`（默认值）：主轴为水平方向，起点在左端。\n> - `row-reverse`：主轴为水平方向，起点在右端。\n> - `column`：主轴为垂直方向，起点在上沿。\n> - `column-reverse`：主轴为垂直方向，起点在下沿。\n\n### 3.2 flex-wrap 属性\n\n默认情况下，项目都排在一条线（又称\"轴线\"）上。`flex-wrap`属性定义，如果一条轴线排不下，如何换行。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071006-1.png)\n\n>     .box{\n>       flex-wrap: nowrap | wrap | wrap-reverse;\n>     }\n\n它可能取三个值。\n\n（1）`nowrap`（默认）：不换行。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071007-1.png)\n\n（2）`wrap`：换行，第一行在上方。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071008-1.jpg)\n\n（3）`wrap-reverse`：换行，第一行在下方。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071009-1.jpg)\n\n### 3.3 flex-flow\n\n`flex-flow`属性是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`。\n\n>     .box {\n>       flex-flow:  || ;\n>     }\n\n### 3.4 justify-content 属性\n\n`justify-content`属性定义了项目在主轴上的对齐方式。\n\n>     .box {\n>       justify-content: flex-start | flex-end | center | space-between | space-around;\n>     }\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071010-1.png)\n\n它可能取 5 个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n\n> - `flex-start`（默认值）：左对齐\n> - `flex-end`：右对齐\n> - `center`： 居中\n> - `space-between`：两端对齐，项目之间的间隔都相等。\n> - `space-around`：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n### 3.5 align-items 属性\n\n`align-items`属性定义项目在交叉轴上如何对齐。\n\n>     .box {\n>       align-items: flex-start | flex-end | center | baseline | stretch;\n>     }\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071011-1.png)\n\n它可能取 5 个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n\n> - `flex-start`：交叉轴的起点对齐。\n> - `flex-end`：交叉轴的终点对齐。\n> - `center`：交叉轴的中点对齐。\n> - `baseline`: 项目的第一行文字的基线对齐。\n> - `stretch`（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。\n\n### 3.6 align-content 属性\n\n`align-content`属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n>     .box {\n>       align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n>     }\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071012-1.png)\n\n该属性可能取 6 个值。\n\n> - `flex-start`：与交叉轴的起点对齐。\n> - `flex-end`：与交叉轴的终点对齐。\n> - `center`：与交叉轴的中点对齐。\n> - `space-between`：与交叉轴两端对齐，轴线之间的间隔平均分布。\n> - `space-around`：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n> - `stretch`（默认值）：轴线占满整个交叉轴。\n\n### 四、项目的属性\n\n以下 6 个属性设置在项目上。\n\n> - `order`\n> - `flex-grow`\n> - `flex-shrink`\n> - `flex-basis`\n> - `flex`\n> - `align-self`\n\n### 4.1 order 属性\n\n`order`属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。\n\n>     .item {\n>       order: ;\n>     }\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071013-1.png)\n\n### 4.2 flex-grow 属性\n\n`flex-grow`属性定义项目的放大比例，默认为`0`，即如果存在剩余空间，也不放大。\n\n>     .item {\n>       flex-grow: ; /* default 0 */\n>     }\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071014-1.png)\n\n如果所有项目的`flex-grow`属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的`flex-grow`属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。\n\n### 4.3 flex-shrink 属性\n\n`flex-shrink`属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。\n\n>     .item {\n>       flex-shrink: ; /* default 1 */\n>     }\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071015-1.jpg)\n\n如果所有项目的`flex-shrink`属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的`flex-shrink`属性为 0，其他项目都为 1，则空间不足时，前者不缩小。\n\n负值对该属性无效。\n\n### 4.4 flex-basis 属性\n\n`flex-basis`属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。\n\n>     .item {\n>       flex-basis:  | auto; /* default auto */\n>     }\n\n它可以设为跟`width`或`height`属性一样的值（比如 350px），则项目将占据固定空间。\n\n### 4.5 flex 属性\n\n`flex`属性是`flex-grow`, `flex-shrink`  和  `flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选。\n\n>     .item {\n>       flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n>     }\n\n该属性有两个快捷值：`auto` (`1 1 auto`) 和 none (`0 0 auto`)。\n\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n### 4.6 align-self 属性\n\n`align-self`属性允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。\n\n>     .item {\n>       align-self: auto | flex-start | flex-end | center | baseline | stretch;\n>     }\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071016-1.png)\n\n该属性可能取 6 个值，除了 auto，其他都与 align-items 属性完全一致。\n","source":"_posts/2017-08-08-Flex 布局教程：语法篇.md","raw":"---\ntitle: Flex 布局教程：语法篇\ntags:\n  - CSS\n  - 技术\ndate: 2017-08-08 06:55:00\ncategories: 前端\n---\n\n网页布局（layout）是 CSS 的一个重点应用。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071001-1.gif)\n\n布局的传统解决方案，基于[盒状模型](https://developer.mozilla.org/en-US/docs/Web/CSS/box_model)，依赖  [`display`](https://developer.mozilla.org/en-US/docs/Web/CSS/display)  属性 + [`position`](https://developer.mozilla.org/en-US/docs/Web/CSS/position)属性 + [`float`](https://developer.mozilla.org/en-US/docs/Web/CSS/float)属性。它对于那些特殊布局非常不方便，比如，[垂直居中](https://css-tricks.com/centering-css-complete-guide/)就不容易实现。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071002-1.png)\n\n2009 年，W3C 提出了一种新的方案----Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071003-1.jpg)\n\nFlex 布局将成为未来布局的首选方案。本文介绍它的语法，[下一篇文章](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html)给出常见布局的 Flex 写法。网友  [JailBreak](http://vgee.cn/)为本文的所有示例制作了  [Demo](http://static.vgee.cn/static/index.html)，也可以参考。\n\n以下内容主要参考了下面两篇文章：[A Complete Guide to Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)  和  [A Visual Guide to CSS3 Flexbox Properties](https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties)。\n\n## 一、Flex 布局是什么？\n\nFlex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。\n\n任何一个容器都可以指定为 Flex 布局。\n\n>     .box{\n>       display: flex;\n>     }\n\n行内元素也可以使用 Flex 布局。\n\n>     .box{\n>       display: inline-flex;\n>     }\n\nWebkit 内核的浏览器，必须加上`-webkit`前缀。\n\n>     .box{\n>       display: -webkit-flex; /* Safari */\n>       display: flex;\n>     }\n\n注意，设为 Flex 布局以后，子元素的`float`、`clear`和`vertical-align`属性将失效。\n\n## 二、基本概念\n\n采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071004-1.png)\n\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做`main start`，结束位置叫做`main end`；交叉轴的开始位置叫做`cross start`，结束位置叫做`cross end`。\n\n项目默认沿主轴排列。单个项目占据的主轴空间叫做`main size`，占据的交叉轴空间叫做`cross size`。\n\n## 三、容器的属性\n\n以下 6 个属性设置在容器上。\n\n> - flex-direction\n> - flex-wrap\n> - flex-flow\n> - justify-content\n> - align-items\n> - align-content\n\n### 3.1 flex-direction 属性\n\n`flex-direction`属性决定主轴的方向（即项目的排列方向）。\n\n>     .box {\n>       flex-direction: row | row-reverse | column | column-reverse;\n>     }\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071005-1.png)\n\n它可能有 4 个值。\n\n> - `row`（默认值）：主轴为水平方向，起点在左端。\n> - `row-reverse`：主轴为水平方向，起点在右端。\n> - `column`：主轴为垂直方向，起点在上沿。\n> - `column-reverse`：主轴为垂直方向，起点在下沿。\n\n### 3.2 flex-wrap 属性\n\n默认情况下，项目都排在一条线（又称\"轴线\"）上。`flex-wrap`属性定义，如果一条轴线排不下，如何换行。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071006-1.png)\n\n>     .box{\n>       flex-wrap: nowrap | wrap | wrap-reverse;\n>     }\n\n它可能取三个值。\n\n（1）`nowrap`（默认）：不换行。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071007-1.png)\n\n（2）`wrap`：换行，第一行在上方。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071008-1.jpg)\n\n（3）`wrap-reverse`：换行，第一行在下方。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071009-1.jpg)\n\n### 3.3 flex-flow\n\n`flex-flow`属性是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`。\n\n>     .box {\n>       flex-flow:  || ;\n>     }\n\n### 3.4 justify-content 属性\n\n`justify-content`属性定义了项目在主轴上的对齐方式。\n\n>     .box {\n>       justify-content: flex-start | flex-end | center | space-between | space-around;\n>     }\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071010-1.png)\n\n它可能取 5 个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n\n> - `flex-start`（默认值）：左对齐\n> - `flex-end`：右对齐\n> - `center`： 居中\n> - `space-between`：两端对齐，项目之间的间隔都相等。\n> - `space-around`：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n### 3.5 align-items 属性\n\n`align-items`属性定义项目在交叉轴上如何对齐。\n\n>     .box {\n>       align-items: flex-start | flex-end | center | baseline | stretch;\n>     }\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071011-1.png)\n\n它可能取 5 个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n\n> - `flex-start`：交叉轴的起点对齐。\n> - `flex-end`：交叉轴的终点对齐。\n> - `center`：交叉轴的中点对齐。\n> - `baseline`: 项目的第一行文字的基线对齐。\n> - `stretch`（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。\n\n### 3.6 align-content 属性\n\n`align-content`属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n>     .box {\n>       align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n>     }\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071012-1.png)\n\n该属性可能取 6 个值。\n\n> - `flex-start`：与交叉轴的起点对齐。\n> - `flex-end`：与交叉轴的终点对齐。\n> - `center`：与交叉轴的中点对齐。\n> - `space-between`：与交叉轴两端对齐，轴线之间的间隔平均分布。\n> - `space-around`：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n> - `stretch`（默认值）：轴线占满整个交叉轴。\n\n### 四、项目的属性\n\n以下 6 个属性设置在项目上。\n\n> - `order`\n> - `flex-grow`\n> - `flex-shrink`\n> - `flex-basis`\n> - `flex`\n> - `align-self`\n\n### 4.1 order 属性\n\n`order`属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。\n\n>     .item {\n>       order: ;\n>     }\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071013-1.png)\n\n### 4.2 flex-grow 属性\n\n`flex-grow`属性定义项目的放大比例，默认为`0`，即如果存在剩余空间，也不放大。\n\n>     .item {\n>       flex-grow: ; /* default 0 */\n>     }\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071014-1.png)\n\n如果所有项目的`flex-grow`属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的`flex-grow`属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。\n\n### 4.3 flex-shrink 属性\n\n`flex-shrink`属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。\n\n>     .item {\n>       flex-shrink: ; /* default 1 */\n>     }\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071015-1.jpg)\n\n如果所有项目的`flex-shrink`属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的`flex-shrink`属性为 0，其他项目都为 1，则空间不足时，前者不缩小。\n\n负值对该属性无效。\n\n### 4.4 flex-basis 属性\n\n`flex-basis`属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。\n\n>     .item {\n>       flex-basis:  | auto; /* default auto */\n>     }\n\n它可以设为跟`width`或`height`属性一样的值（比如 350px），则项目将占据固定空间。\n\n### 4.5 flex 属性\n\n`flex`属性是`flex-grow`, `flex-shrink`  和  `flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选。\n\n>     .item {\n>       flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n>     }\n\n该属性有两个快捷值：`auto` (`1 1 auto`) 和 none (`0 0 auto`)。\n\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n### 4.6 align-self 属性\n\n`align-self`属性允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。\n\n>     .item {\n>       align-self: auto | flex-start | flex-end | center | baseline | stretch;\n>     }\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071016-1.png)\n\n该属性可能取 6 个值，除了 auto，其他都与 align-items 属性完全一致。\n","slug":"2017-08-08-Flex 布局教程：语法篇","published":1,"updated":"2020-03-14T06:44:20.111Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvmh003y4k8y8txc52y6","content":"<p>网页布局（layout）是 CSS 的一个重点应用。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071001-1.gif\" alt=\"\"></p>\n<p>布局的传统解决方案，基于<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/box_model\" target=\"_blank\" rel=\"noopener\">盒状模型</a>，依赖  <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/display\" target=\"_blank\" rel=\"noopener\"><code>display</code></a>  属性 + <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/position\" target=\"_blank\" rel=\"noopener\"><code>position</code></a>属性 + <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/float\" target=\"_blank\" rel=\"noopener\"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，<a href=\"https://css-tricks.com/centering-css-complete-guide/\" target=\"_blank\" rel=\"noopener\">垂直居中</a>就不容易实现。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071002-1.png\" alt=\"\"></p>\n<p>2009 年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071003-1.jpg\" alt=\"\"></p>\n<p>Flex 布局将成为未来布局的首选方案。本文介绍它的语法，<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\" target=\"_blank\" rel=\"noopener\">下一篇文章</a>给出常见布局的 Flex 写法。网友  <a href=\"http://vgee.cn/\" target=\"_blank\" rel=\"noopener\">JailBreak</a>为本文的所有示例制作了  <a href=\"http://static.vgee.cn/static/index.html\" target=\"_blank\" rel=\"noopener\">Demo</a>，也可以参考。</p>\n<p>以下内容主要参考了下面两篇文章：<a href=\"https://css-tricks.com/snippets/css/a-guide-to-flexbox/\" target=\"_blank\" rel=\"noopener\">A Complete Guide to Flexbox</a>  和  <a href=\"https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties\" target=\"_blank\" rel=\"noopener\">A Visual Guide to CSS3 Flexbox Properties</a>。</p>\n<h2 id=\"一、Flex-布局是什么？\"><a href=\"#一、Flex-布局是什么？\" class=\"headerlink\" title=\"一、Flex 布局是什么？\"></a>一、Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>\n<p>任何一个容器都可以指定为 Flex 布局。</p>\n<blockquote>\n<pre><code>.box{\n  display: flex;\n}</code></pre></blockquote>\n<p>行内元素也可以使用 Flex 布局。</p>\n<blockquote>\n<pre><code>.box{\n  display: inline-flex;\n}</code></pre></blockquote>\n<p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p>\n<blockquote>\n<pre><code>.box{\n  display: -webkit-flex; /* Safari */\n  display: flex;\n}</code></pre></blockquote>\n<p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p>\n<h2 id=\"二、基本概念\"><a href=\"#二、基本概念\" class=\"headerlink\" title=\"二、基本概念\"></a>二、基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071004-1.png\" alt=\"\"></p>\n<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p>\n<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p>\n<h2 id=\"三、容器的属性\"><a href=\"#三、容器的属性\" class=\"headerlink\" title=\"三、容器的属性\"></a>三、容器的属性</h2><p>以下 6 个属性设置在容器上。</p>\n<blockquote>\n<ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ul>\n</blockquote>\n<h3 id=\"3-1-flex-direction-属性\"><a href=\"#3-1-flex-direction-属性\" class=\"headerlink\" title=\"3.1 flex-direction 属性\"></a>3.1 flex-direction 属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p>\n<blockquote>\n<pre><code>.box {\n  flex-direction: row | row-reverse | column | column-reverse;\n}</code></pre></blockquote>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071005-1.png\" alt=\"\"></p>\n<p>它可能有 4 个值。</p>\n<blockquote>\n<ul>\n<li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li>\n<li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li>\n<li><code>column</code>：主轴为垂直方向，起点在上沿。</li>\n<li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li>\n</ul>\n</blockquote>\n<h3 id=\"3-2-flex-wrap-属性\"><a href=\"#3-2-flex-wrap-属性\" class=\"headerlink\" title=\"3.2 flex-wrap 属性\"></a>3.2 flex-wrap 属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071006-1.png\" alt=\"\"></p>\n<blockquote>\n<pre><code>.box{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}</code></pre></blockquote>\n<p>它可能取三个值。</p>\n<p>（1）<code>nowrap</code>（默认）：不换行。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071007-1.png\" alt=\"\"></p>\n<p>（2）<code>wrap</code>：换行，第一行在上方。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071008-1.jpg\" alt=\"\"></p>\n<p>（3）<code>wrap-reverse</code>：换行，第一行在下方。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071009-1.jpg\" alt=\"\"></p>\n<h3 id=\"3-3-flex-flow\"><a href=\"#3-3-flex-flow\" class=\"headerlink\" title=\"3.3 flex-flow\"></a>3.3 flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p>\n<blockquote>\n<pre><code>.box {\n  flex-flow:  || ;\n}</code></pre></blockquote>\n<h3 id=\"3-4-justify-content-属性\"><a href=\"#3-4-justify-content-属性\" class=\"headerlink\" title=\"3.4 justify-content 属性\"></a>3.4 justify-content 属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p>\n<blockquote>\n<pre><code>.box {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}</code></pre></blockquote>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071010-1.png\" alt=\"\"></p>\n<p>它可能取 5 个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>\n<blockquote>\n<ul>\n<li><code>flex-start</code>（默认值）：左对齐</li>\n<li><code>flex-end</code>：右对齐</li>\n<li><code>center</code>： 居中</li>\n<li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li>\n<li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>\n</ul>\n</blockquote>\n<h3 id=\"3-5-align-items-属性\"><a href=\"#3-5-align-items-属性\" class=\"headerlink\" title=\"3.5 align-items 属性\"></a>3.5 align-items 属性</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p>\n<blockquote>\n<pre><code>.box {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}</code></pre></blockquote>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071011-1.png\" alt=\"\"></p>\n<p>它可能取 5 个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>\n<blockquote>\n<ul>\n<li><code>flex-start</code>：交叉轴的起点对齐。</li>\n<li><code>flex-end</code>：交叉轴的终点对齐。</li>\n<li><code>center</code>：交叉轴的中点对齐。</li>\n<li><code>baseline</code>: 项目的第一行文字的基线对齐。</li>\n<li><code>stretch</code>（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。</li>\n</ul>\n</blockquote>\n<h3 id=\"3-6-align-content-属性\"><a href=\"#3-6-align-content-属性\" class=\"headerlink\" title=\"3.6 align-content 属性\"></a>3.6 align-content 属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>\n<blockquote>\n<pre><code>.box {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}</code></pre></blockquote>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071012-1.png\" alt=\"\"></p>\n<p>该属性可能取 6 个值。</p>\n<blockquote>\n<ul>\n<li><code>flex-start</code>：与交叉轴的起点对齐。</li>\n<li><code>flex-end</code>：与交叉轴的终点对齐。</li>\n<li><code>center</code>：与交叉轴的中点对齐。</li>\n<li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li>\n</ul>\n</blockquote>\n<h3 id=\"四、项目的属性\"><a href=\"#四、项目的属性\" class=\"headerlink\" title=\"四、项目的属性\"></a>四、项目的属性</h3><p>以下 6 个属性设置在项目上。</p>\n<blockquote>\n<ul>\n<li><code>order</code></li>\n<li><code>flex-grow</code></li>\n<li><code>flex-shrink</code></li>\n<li><code>flex-basis</code></li>\n<li><code>flex</code></li>\n<li><code>align-self</code></li>\n</ul>\n</blockquote>\n<h3 id=\"4-1-order-属性\"><a href=\"#4-1-order-属性\" class=\"headerlink\" title=\"4.1 order 属性\"></a>4.1 order 属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</p>\n<blockquote>\n<pre><code>.item {\n  order: ;\n}</code></pre></blockquote>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071013-1.png\" alt=\"\"></p>\n<h3 id=\"4-2-flex-grow-属性\"><a href=\"#4-2-flex-grow-属性\" class=\"headerlink\" title=\"4.2 flex-grow 属性\"></a>4.2 flex-grow 属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p>\n<blockquote>\n<pre><code>.item {\n  flex-grow: ; /* default 0 */\n}</code></pre></blockquote>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071014-1.png\" alt=\"\"></p>\n<p>如果所有项目的<code>flex-grow</code>属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p>\n<h3 id=\"4-3-flex-shrink-属性\"><a href=\"#4-3-flex-shrink-属性\" class=\"headerlink\" title=\"4.3 flex-shrink 属性\"></a>4.3 flex-shrink 属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。</p>\n<blockquote>\n<pre><code>.item {\n  flex-shrink: ; /* default 1 */\n}</code></pre></blockquote>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071015-1.jpg\" alt=\"\"></p>\n<p>如果所有项目的<code>flex-shrink</code>属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为 0，其他项目都为 1，则空间不足时，前者不缩小。</p>\n<p>负值对该属性无效。</p>\n<h3 id=\"4-4-flex-basis-属性\"><a href=\"#4-4-flex-basis-属性\" class=\"headerlink\" title=\"4.4 flex-basis 属性\"></a>4.4 flex-basis 属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p>\n<blockquote>\n<pre><code>.item {\n  flex-basis:  | auto; /* default auto */\n}</code></pre></blockquote>\n<p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如 350px），则项目将占据固定空间。</p>\n<h3 id=\"4-5-flex-属性\"><a href=\"#4-5-flex-属性\" class=\"headerlink\" title=\"4.5 flex 属性\"></a>4.5 flex 属性</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code>  和  <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p>\n<blockquote>\n<pre><code>.item {\n  flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]\n}</code></pre></blockquote>\n<p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p>\n<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>\n<h3 id=\"4-6-align-self-属性\"><a href=\"#4-6-align-self-属性\" class=\"headerlink\" title=\"4.6 align-self 属性\"></a>4.6 align-self 属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p>\n<blockquote>\n<pre><code>.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}</code></pre></blockquote>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071016-1.png\" alt=\"\"></p>\n<p>该属性可能取 6 个值，除了 auto，其他都与 align-items 属性完全一致。</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>网页布局（layout）是 CSS 的一个重点应用。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071001-1.gif\" alt=\"\"></p>\n<p>布局的传统解决方案，基于<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/box_model\" target=\"_blank\" rel=\"noopener\">盒状模型</a>，依赖  <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/display\" target=\"_blank\" rel=\"noopener\"><code>display</code></a>  属性 + <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/position\" target=\"_blank\" rel=\"noopener\"><code>position</code></a>属性 + <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/float\" target=\"_blank\" rel=\"noopener\"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，<a href=\"https://css-tricks.com/centering-css-complete-guide/\" target=\"_blank\" rel=\"noopener\">垂直居中</a>就不容易实现。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071002-1.png\" alt=\"\"></p>\n<p>2009 年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071003-1.jpg\" alt=\"\"></p>\n<p>Flex 布局将成为未来布局的首选方案。本文介绍它的语法，<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\" target=\"_blank\" rel=\"noopener\">下一篇文章</a>给出常见布局的 Flex 写法。网友  <a href=\"http://vgee.cn/\" target=\"_blank\" rel=\"noopener\">JailBreak</a>为本文的所有示例制作了  <a href=\"http://static.vgee.cn/static/index.html\" target=\"_blank\" rel=\"noopener\">Demo</a>，也可以参考。</p>\n<p>以下内容主要参考了下面两篇文章：<a href=\"https://css-tricks.com/snippets/css/a-guide-to-flexbox/\" target=\"_blank\" rel=\"noopener\">A Complete Guide to Flexbox</a>  和  <a href=\"https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties\" target=\"_blank\" rel=\"noopener\">A Visual Guide to CSS3 Flexbox Properties</a>。</p>\n<h2 id=\"一、Flex-布局是什么？\"><a href=\"#一、Flex-布局是什么？\" class=\"headerlink\" title=\"一、Flex 布局是什么？\"></a>一、Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>\n<p>任何一个容器都可以指定为 Flex 布局。</p>\n<blockquote>\n<pre><code>.box{\n  display: flex;\n}</code></pre></blockquote>\n<p>行内元素也可以使用 Flex 布局。</p>\n<blockquote>\n<pre><code>.box{\n  display: inline-flex;\n}</code></pre></blockquote>\n<p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p>\n<blockquote>\n<pre><code>.box{\n  display: -webkit-flex; /* Safari */\n  display: flex;\n}</code></pre></blockquote>\n<p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p>\n<h2 id=\"二、基本概念\"><a href=\"#二、基本概念\" class=\"headerlink\" title=\"二、基本概念\"></a>二、基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071004-1.png\" alt=\"\"></p>\n<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p>\n<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p>\n<h2 id=\"三、容器的属性\"><a href=\"#三、容器的属性\" class=\"headerlink\" title=\"三、容器的属性\"></a>三、容器的属性</h2><p>以下 6 个属性设置在容器上。</p>\n<blockquote>\n<ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ul>\n</blockquote>\n<h3 id=\"3-1-flex-direction-属性\"><a href=\"#3-1-flex-direction-属性\" class=\"headerlink\" title=\"3.1 flex-direction 属性\"></a>3.1 flex-direction 属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p>\n<blockquote>\n<pre><code>.box {\n  flex-direction: row | row-reverse | column | column-reverse;\n}</code></pre></blockquote>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071005-1.png\" alt=\"\"></p>\n<p>它可能有 4 个值。</p>\n<blockquote>\n<ul>\n<li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li>\n<li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li>\n<li><code>column</code>：主轴为垂直方向，起点在上沿。</li>\n<li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li>\n</ul>\n</blockquote>\n<h3 id=\"3-2-flex-wrap-属性\"><a href=\"#3-2-flex-wrap-属性\" class=\"headerlink\" title=\"3.2 flex-wrap 属性\"></a>3.2 flex-wrap 属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071006-1.png\" alt=\"\"></p>\n<blockquote>\n<pre><code>.box{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}</code></pre></blockquote>\n<p>它可能取三个值。</p>\n<p>（1）<code>nowrap</code>（默认）：不换行。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071007-1.png\" alt=\"\"></p>\n<p>（2）<code>wrap</code>：换行，第一行在上方。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071008-1.jpg\" alt=\"\"></p>\n<p>（3）<code>wrap-reverse</code>：换行，第一行在下方。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071009-1.jpg\" alt=\"\"></p>\n<h3 id=\"3-3-flex-flow\"><a href=\"#3-3-flex-flow\" class=\"headerlink\" title=\"3.3 flex-flow\"></a>3.3 flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p>\n<blockquote>\n<pre><code>.box {\n  flex-flow:  || ;\n}</code></pre></blockquote>\n<h3 id=\"3-4-justify-content-属性\"><a href=\"#3-4-justify-content-属性\" class=\"headerlink\" title=\"3.4 justify-content 属性\"></a>3.4 justify-content 属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p>\n<blockquote>\n<pre><code>.box {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}</code></pre></blockquote>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071010-1.png\" alt=\"\"></p>\n<p>它可能取 5 个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>\n<blockquote>\n<ul>\n<li><code>flex-start</code>（默认值）：左对齐</li>\n<li><code>flex-end</code>：右对齐</li>\n<li><code>center</code>： 居中</li>\n<li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li>\n<li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>\n</ul>\n</blockquote>\n<h3 id=\"3-5-align-items-属性\"><a href=\"#3-5-align-items-属性\" class=\"headerlink\" title=\"3.5 align-items 属性\"></a>3.5 align-items 属性</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p>\n<blockquote>\n<pre><code>.box {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}</code></pre></blockquote>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071011-1.png\" alt=\"\"></p>\n<p>它可能取 5 个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>\n<blockquote>\n<ul>\n<li><code>flex-start</code>：交叉轴的起点对齐。</li>\n<li><code>flex-end</code>：交叉轴的终点对齐。</li>\n<li><code>center</code>：交叉轴的中点对齐。</li>\n<li><code>baseline</code>: 项目的第一行文字的基线对齐。</li>\n<li><code>stretch</code>（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。</li>\n</ul>\n</blockquote>\n<h3 id=\"3-6-align-content-属性\"><a href=\"#3-6-align-content-属性\" class=\"headerlink\" title=\"3.6 align-content 属性\"></a>3.6 align-content 属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>\n<blockquote>\n<pre><code>.box {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}</code></pre></blockquote>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071012-1.png\" alt=\"\"></p>\n<p>该属性可能取 6 个值。</p>\n<blockquote>\n<ul>\n<li><code>flex-start</code>：与交叉轴的起点对齐。</li>\n<li><code>flex-end</code>：与交叉轴的终点对齐。</li>\n<li><code>center</code>：与交叉轴的中点对齐。</li>\n<li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li>\n</ul>\n</blockquote>\n<h3 id=\"四、项目的属性\"><a href=\"#四、项目的属性\" class=\"headerlink\" title=\"四、项目的属性\"></a>四、项目的属性</h3><p>以下 6 个属性设置在项目上。</p>\n<blockquote>\n<ul>\n<li><code>order</code></li>\n<li><code>flex-grow</code></li>\n<li><code>flex-shrink</code></li>\n<li><code>flex-basis</code></li>\n<li><code>flex</code></li>\n<li><code>align-self</code></li>\n</ul>\n</blockquote>\n<h3 id=\"4-1-order-属性\"><a href=\"#4-1-order-属性\" class=\"headerlink\" title=\"4.1 order 属性\"></a>4.1 order 属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</p>\n<blockquote>\n<pre><code>.item {\n  order: ;\n}</code></pre></blockquote>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071013-1.png\" alt=\"\"></p>\n<h3 id=\"4-2-flex-grow-属性\"><a href=\"#4-2-flex-grow-属性\" class=\"headerlink\" title=\"4.2 flex-grow 属性\"></a>4.2 flex-grow 属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p>\n<blockquote>\n<pre><code>.item {\n  flex-grow: ; /* default 0 */\n}</code></pre></blockquote>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071014-1.png\" alt=\"\"></p>\n<p>如果所有项目的<code>flex-grow</code>属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p>\n<h3 id=\"4-3-flex-shrink-属性\"><a href=\"#4-3-flex-shrink-属性\" class=\"headerlink\" title=\"4.3 flex-shrink 属性\"></a>4.3 flex-shrink 属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。</p>\n<blockquote>\n<pre><code>.item {\n  flex-shrink: ; /* default 1 */\n}</code></pre></blockquote>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071015-1.jpg\" alt=\"\"></p>\n<p>如果所有项目的<code>flex-shrink</code>属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为 0，其他项目都为 1，则空间不足时，前者不缩小。</p>\n<p>负值对该属性无效。</p>\n<h3 id=\"4-4-flex-basis-属性\"><a href=\"#4-4-flex-basis-属性\" class=\"headerlink\" title=\"4.4 flex-basis 属性\"></a>4.4 flex-basis 属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p>\n<blockquote>\n<pre><code>.item {\n  flex-basis:  | auto; /* default auto */\n}</code></pre></blockquote>\n<p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如 350px），则项目将占据固定空间。</p>\n<h3 id=\"4-5-flex-属性\"><a href=\"#4-5-flex-属性\" class=\"headerlink\" title=\"4.5 flex 属性\"></a>4.5 flex 属性</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code>  和  <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p>\n<blockquote>\n<pre><code>.item {\n  flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]\n}</code></pre></blockquote>\n<p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p>\n<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>\n<h3 id=\"4-6-align-self-属性\"><a href=\"#4-6-align-self-属性\" class=\"headerlink\" title=\"4.6 align-self 属性\"></a>4.6 align-self 属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p>\n<blockquote>\n<pre><code>.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}</code></pre></blockquote>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/bg2015071016-1.png\" alt=\"\"></p>\n<p>该属性可能取 6 个值，除了 auto，其他都与 align-items 属性完全一致。</p>\n"},{"title":"CSS中em、rem和px的区别以及各个的优缺点比较","date":"2017-08-11T23:50:00.000Z","_content":"\nPX:  \nPX 实际上就是像素，用 PX 设置字体大小时，比较稳定和精确。但是这种方法存在一个问题，当用户在浏览器中浏览我们制作的 Web 页面时，如果改变了浏览器的缩放，这时会使用我们的 Web 页面布局被打破。这样对于那些关心自己网站可用性的用户来说，就是一个大问题了。因此，这时就提出了使用“em”来定义 Web 页面的字体。\n\nEM:  \nEM 就是根据基准来缩放字体的大小。EM 实质是一个相对值，而非具体的数值。这种技术需要一个参考点，一般都是以的“font-size”为基准。如 WordPress 官方主题 Twenntytwelve 的基准就是 14px=1em。  \n另外，em 是相对于父元素的属性而计算的，如果想计算 px 和 em 之间的换算，这个网站不错，输入数据就可以 px 和 em 相互计算。狠击这里：px 和 em 换算\n\nRem:  \nEM 是相对于其父元素来设置字体大小的，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而 Rem 是相对于根元素，这样就意味着，我们只需要在根元素确定一个参考值。\n\n浏览器的兼容性  \n除了 IE6-IE8r，其它的浏览器都支持 em 和 rem 属性，px 是所有浏览器都支持。  \n因此为了浏览器的兼容性，可“px”和“rem”一起使用，用\"px\"来实现 IE6-8 下的效果，然后使用“Rem”来实现代浏览器的效果。\n\n\\-\\-\\-\\-\\-\\-\n\n## rem 是什么？\n\nrem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到 rem 大家一定会想起 em 单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。[·](http://caibaojian.com/web-app-rem.html)\n\n## 为什么 web app 要使用 rem？\n\n这里我特别强调 web app，web page 就不能使用 rem 吗，其实也当然可以，不过出于兼容性的考虑在 web app 下使用更加能突显这个单位的价值和能力，接下来我们来看看目前一些企业的 web app 是怎么做屏幕适配的。\n\n### 1、实现强大的屏幕适配布局：\n\n最近 iphone6 一下出了两款尺寸的手机，导致的移动端的屏幕种类更加的混乱，记得一两年前做 web app 有一种做法是以 320 宽度为标准去做适配，超过 320 的大小还是以 320 的规格去展示，这种实现方式以淘宝 web app 为代表作，但是近期手机淘宝首页进行了改版，采用了 rem 这个单位，首页以内依旧是和以前一样各种混乱，有定死宽度的页面，也有那种流式布局的页面。\n\n我们现在在切页面布局的使用常用的单位是 px，这是一个绝对单位，web app 的屏幕适配有很多中做法，例如：流式布局、限死宽度，还有就是通过[响应式](http://caibaojian.com/356.html \"响应式布局\")来做，但是这些方案都不是最佳的解决方法。\n\n例如流式布局的解决方案有不少弊端，它虽然可以让各种屏幕都适配，但是显示的效果极其的不好，因为只有几个尺寸的手机能够完美的显示出视觉设计师和交互最想要的效果，但是目前行业里用流式布局切 web app 的公司还是挺多的，看看下面我收集的一些案例：[·](http://caibaojian.com/web-app-rem.html)\n\n1.亚马逊：\n\n![1418896965](http://www.jixiaokang.com/wp-content/uploads/2018/05/1418896965.jpeg)\n\n2.携程：\n\n![原文来自http://caibaojian.com/web-app-rem.html](http://www.jixiaokang.com/wp-content/uploads/2018/05/1418891322.jpeg)\n\n3.兰亭\n\n![1418891825](http://www.jixiaokang.com/wp-content/uploads/2018/05/1418891825.jpeg)\n\n上面的网站都是采用的流式布局的技术实现的，他们在页面布局的时候都是通过百分比来定义宽度，但是高度大都是用 px 来固定住，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度还是和原来一样，实际显示非常的不协调，这就是流式布局的最致命的缺点，往往只有几个尺寸的手机下看到的效果是令人满意的，其实很多视觉设计师应该无法接受这种效果，因为他们的设计图在大屏幕手机下看到的效果相当于是被横向拉长来一样。\n\n流式布局并不是最理想的实现方式，通过大量的百分比布局，会经常出现许多兼容性的问题，还有就是对设计有很多的限制，因为他们在设计之初就需要考虑流式布局对元素造成的影响，只能设计横向拉伸的元素布局，设计的时候存在很多局限性。\n\n### 2.固定宽度做法\n\n还有一种是固定页面宽度的做法，早期有些网站把页面设置成 320 的宽度，超出部分留白，这样做视觉，前端都挺开心，视觉在也不用被流式布局限制自己的设计灵感了，前端也不用在搞坑爹的流式布局。但是这种解决方案也是存在一些问题，例如在大屏幕手机下两边是留白的，还有一个就是大屏幕手机下看起来页面会特别小，操作的按钮也很小，手机淘宝首页起初是这么做的，但近期改版了，采用了 rem。\n\n### 3.响应式做法\n\n响应式这种方式在国内很少有大型企业的复杂性的网站在移动端用这种方法去做，主要原因是工作大，维护性难，所以一般都是中小型的门户或者博客类站点会采用响应式的方法从 web page 到 web app 直接一步到位，因为这样反而可以节约成本，不用再专门为自己的网站做一个 web app 的版本。\n\n### 4.设置 viewport 进行缩放\n\n天猫的 web app 的首页就是采用这种方式去做的，以 320 宽度为基准，进行缩放，最大缩放为 320\\*1.3 = 416，基本缩放到 416 都就可以兼容 iphone6 plus 的屏幕了，这个方法简单粗暴，又高效。说实话我觉得他和用接下去我们要讲的 rem 都非常高效，不过有部分同学使用过程中反应缩放会导致有些页面元素会糊的情况。\n\n## rem 能等比例适配所有屏幕\n\n上面讲了一大堆目前大部分公司主流的一些 web app 的适配解决方案，接下来讲下 rem 是如何工作的。\n\n上面说过 rem 是通过根元素进行适配的，网页中的根元素指的是 html 我们通过设置 html 的字体大小就可以控制 rem 的大小。举个例子：\n\nhtml{\nfont-size:20px;\n}\n.btn {\nwidth: 6rem;\nheight: 3rem;\nline-height: 3rem;\nfont-size: 1.2rem;\ndisplay: inline-block;\nbackground: #06c;\ncolor: #fff;\nborder-radius: .5rem;\ntext-decoration: none;\ntext-align: center;  \n}\n\nDemo 上面代码结果按钮大小如下图：\n\n![1418899506](http://www.jixiaokang.com/wp-content/uploads/2018/05/1418899506.jpeg)\n\n我把 html 设置成 10px 是为了方便我们计算，为什么 6rem 等于 60px。如果这个时候我们的.btn 的样式不变，我们再改变 html 的 font-size 的值，看看按钮发生上面变化:\n\n//code from http://caibaojian.com/web-app-rem.html\nhtml{\nfont-size:40px;\n}\n\nDemo\n\n按钮大小结果如下：\n\n![1418898055](http://www.jixiaokang.com/wp-content/uploads/2018/05/1418898055.jpeg)\n\n上面的 width，height 变成了上面结果的两倍，我们只改变了 html 的 font-size，但.btn 样式的 width,height 的 rem 设置的属性不变的情况下就改变了按钮在 web 中的大小。\n\n其实从上面两个案例中我们就可以计算出 1px 多少 rem:\n\n第一个例子：\n\n120px = 6rem \\* 20px(根元素设置大值)\n\n第二个例子：\n\n240px = 6rem \\* 40px(根元素设置大值)\n\n推算出：\n\n10px  = 1rem 在根元素（font-size = 10px 的时候）；\n\n20px  = 1rem 在根元素（font-size = 20px 的时候）；\n\n40px  = 1rem 在根元素（font-size = 40px 的时候）；\n\n在上面两个例子中我们发现第一个案例按钮是等比例放大到第二个按钮，html font-size 的改变就会导致按钮的大小发生改变，我们并不需要改变先前给按钮设置的宽度和高度，其实这就是我们最想看到的，为什么这么说？接下来我们再来看一个例子：\n\nDemo\n\n![1418873132](http://www.jixiaokang.com/wp-content/uploads/2018/05/1418873132.jpeg)\n\n由上面两个的 demo 中我们知道改变 html 的 font-size 可以等比改变所有用了 rem 单位的元素，所以大家可以通过 chrome 浏览器的调试工具去切换第三个的 demo 在不同设备下的展示效果，或者通过缩放浏览器的宽度来查看效果，我们可以看到不管在任何分辨率下，页面的排版都是按照等比例进行切换，并且布局没有乱。我只是通过一段 js 根据浏览器当前的分辨率改变 font-size 的值，就简单的实现了上面的效果，页面的所有元素都不需要进行任何改变。\n\n**到这里肯定有很多人会问我是怎么计算出不同分辨率下 font-size 的值？**\n\n首先假设我上面的页面设计稿给我时候是按照 640 的标准尺寸给我的前提下，（当然这个尺寸肯定不一定是 640，可以是 320，或者 480，又或是 375）来看一组表格。\n\n![1418903956](http://www.jixiaokang.com/wp-content/uploads/2018/05/1418903956.jpeg)\n\n上面的表格蓝色一列是 Demo3 中页面的尺寸，页面是以 640 的宽度去切的，怎么计算不同宽度下 font-site 的值，大家看表格上面的数值变化应该能明白。举个例子：384/640 = 0.6，384 是 640 的 0.6 倍，所以 384 页面宽度下的 font-size 也等于它的 0.6 倍，这时 384 的 font-size 就等于 12px。在不同设备的宽度计算方式以此类推。\n\nDemo3 中我是通过[JS](http://caibaojian.com/javascript/ \"js\")去动态计算根元素的 font-size，这样的好处是所有设备分辨率都能兼容适配，淘宝首页目前就是用的 JS 计算。但其实不用 JS 我们也可以做适配，一般我们在做 web app 都会先统计自己网站有哪些主流的屏幕设备，然后去针对那些设备去做 media query 设置也可以实现适配，例如下面这样：\n\nhtml {\nfont-size : 20px;\n}\n@media only screen and (min-width: 401px){\nhtml {\nfont-size: 25px !important;\n}\n}\n@media only screen and (min-width: 428px){\nhtml {\nfont-size: 26.75px !important;\n}\n}\n@media only screen and (min-width: 481px){\nhtml {\nfont-size: 30px !important;\n}\n}\n@media only screen and (min-width: 569px){\nhtml {\nfont-size: 35px !important;\n}\n}\n@media only screen and (min-width: 641px){\nhtml {\nfont-size: 40px !important;\n}\n}\n\n上面的做的设置当然是不能所有设备全适配，但是用 JS 是可以实现全适配。具体用哪个就要根据自己的实际工作场景去定了。\n\n下面推荐两个国内用了 rem 技术的移动站，大家可以上去参考看看他们的做法，手机淘宝目前只有首页用了 rem，淘宝 native app 的首页是内嵌的 web app 首页。\n\n**淘宝首页**：m.taobao.com\n\n**D X**：m.dx.com\n\n### 最后我们再来看一看他的兼容性：\n\n![1418894538](http://www.jixiaokang.com/wp-content/uploads/2018/05/1418894538.png)\n\n### 在线工具\n\n@blinkcat，rem 是可以合并雪碧图的，viewport 设置确实简洁，但是过于粗暴，全局都进行缩放，有时候我布局并不希望全局缩放，部分布局希望不用缩放，所以使用 rem，不过具体使用什么方法大家都可以根据实际情况衡量。并不是每个人都喜欢使用 sass，所以在 px 转 rem 这块我做了一个在线转换工具：http://520ued.com/tools/rem\n\n### REM[自适应](http://caibaojian.com/t/自适应 \"自适应\")JS\n\n具体使用方法请参考这篇文章：[Rem 精简版实现自适应-优化 flexible.js](http://caibaojian.com/simple-flexible.html)\n\n//designWidth:设计稿的实际宽度值，需要根据实际设置\n//maxWidth:制作稿的最大宽度值，需要根据实际设置\n//这段 js 的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为 750，最大宽度为 750，则为(750,750)\n;(function(designWidth, maxWidth) {\nvar doc = document,\nwin = window,\ndocEl = doc.documentElement,\nremStyle = document.createElement(\"style\"),\ntid;\n\n    function refreshRem() {\n    \tvar width = docEl.getBoundingClientRect().width;\n    \tmaxWidth = maxWidth || 540;\n    \twidth>maxWidth && (width=maxWidth);\n    \tvar rem = width * 100 / designWidth;\n    \tremStyle.innerHTML = 'html{font-size:' + rem + 'px;}';\n    }\n\n    if (docEl.firstElementChild) {\n    \tdocEl.firstElementChild.appendChild(remStyle);\n    } else {\n    \tvar wrap = doc.createElement(\"div\");\n    \twrap.appendChild(remStyle);\n    \tdoc.write(wrap.innerHTML);\n    \twrap = null;\n    }\n    //要等 wiewport 设置好后才能执行 refreshRem，不然 refreshRem 会执行2次；\n    refreshRem();\n\n    win.addEventListener(\"resize\", function() {\n    \tclearTimeout(tid); //防止执行两次\n    \ttid = setTimeout(refreshRem, 300);\n    }, false);\n\n    win.addEventListener(\"pageshow\", function(e) {\n    \tif (e.persisted) { // 浏览器后退的时候重新计算\n    \t\tclearTimeout(tid);\n    \t\ttid = setTimeout(refreshRem, 300);\n    \t}\n    }, false);\n\n    if (doc.readyState === \"complete\") {\n    \tdoc.body.style.fontSize = \"16px\";\n    } else {\n    \tdoc.addEventListener(\"DOMContentLoaded\", function(e) {\n    \t\tdoc.body.style.fontSize = \"16px\";\n    \t}, false);\n    }\n\n})(750, 750);\n","source":"_posts/2017-08-12-CSS中em、rem和px.md","raw":"---\ntitle: CSS中em、rem和px的区别以及各个的优缺点比较\ntags:\n  - CSS\ndate: 2017-08-12 07:50:00\ncategories: 前端\n---\n\nPX:  \nPX 实际上就是像素，用 PX 设置字体大小时，比较稳定和精确。但是这种方法存在一个问题，当用户在浏览器中浏览我们制作的 Web 页面时，如果改变了浏览器的缩放，这时会使用我们的 Web 页面布局被打破。这样对于那些关心自己网站可用性的用户来说，就是一个大问题了。因此，这时就提出了使用“em”来定义 Web 页面的字体。\n\nEM:  \nEM 就是根据基准来缩放字体的大小。EM 实质是一个相对值，而非具体的数值。这种技术需要一个参考点，一般都是以的“font-size”为基准。如 WordPress 官方主题 Twenntytwelve 的基准就是 14px=1em。  \n另外，em 是相对于父元素的属性而计算的，如果想计算 px 和 em 之间的换算，这个网站不错，输入数据就可以 px 和 em 相互计算。狠击这里：px 和 em 换算\n\nRem:  \nEM 是相对于其父元素来设置字体大小的，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而 Rem 是相对于根元素，这样就意味着，我们只需要在根元素确定一个参考值。\n\n浏览器的兼容性  \n除了 IE6-IE8r，其它的浏览器都支持 em 和 rem 属性，px 是所有浏览器都支持。  \n因此为了浏览器的兼容性，可“px”和“rem”一起使用，用\"px\"来实现 IE6-8 下的效果，然后使用“Rem”来实现代浏览器的效果。\n\n\\-\\-\\-\\-\\-\\-\n\n## rem 是什么？\n\nrem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到 rem 大家一定会想起 em 单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。[·](http://caibaojian.com/web-app-rem.html)\n\n## 为什么 web app 要使用 rem？\n\n这里我特别强调 web app，web page 就不能使用 rem 吗，其实也当然可以，不过出于兼容性的考虑在 web app 下使用更加能突显这个单位的价值和能力，接下来我们来看看目前一些企业的 web app 是怎么做屏幕适配的。\n\n### 1、实现强大的屏幕适配布局：\n\n最近 iphone6 一下出了两款尺寸的手机，导致的移动端的屏幕种类更加的混乱，记得一两年前做 web app 有一种做法是以 320 宽度为标准去做适配，超过 320 的大小还是以 320 的规格去展示，这种实现方式以淘宝 web app 为代表作，但是近期手机淘宝首页进行了改版，采用了 rem 这个单位，首页以内依旧是和以前一样各种混乱，有定死宽度的页面，也有那种流式布局的页面。\n\n我们现在在切页面布局的使用常用的单位是 px，这是一个绝对单位，web app 的屏幕适配有很多中做法，例如：流式布局、限死宽度，还有就是通过[响应式](http://caibaojian.com/356.html \"响应式布局\")来做，但是这些方案都不是最佳的解决方法。\n\n例如流式布局的解决方案有不少弊端，它虽然可以让各种屏幕都适配，但是显示的效果极其的不好，因为只有几个尺寸的手机能够完美的显示出视觉设计师和交互最想要的效果，但是目前行业里用流式布局切 web app 的公司还是挺多的，看看下面我收集的一些案例：[·](http://caibaojian.com/web-app-rem.html)\n\n1.亚马逊：\n\n![1418896965](http://www.jixiaokang.com/wp-content/uploads/2018/05/1418896965.jpeg)\n\n2.携程：\n\n![原文来自http://caibaojian.com/web-app-rem.html](http://www.jixiaokang.com/wp-content/uploads/2018/05/1418891322.jpeg)\n\n3.兰亭\n\n![1418891825](http://www.jixiaokang.com/wp-content/uploads/2018/05/1418891825.jpeg)\n\n上面的网站都是采用的流式布局的技术实现的，他们在页面布局的时候都是通过百分比来定义宽度，但是高度大都是用 px 来固定住，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度还是和原来一样，实际显示非常的不协调，这就是流式布局的最致命的缺点，往往只有几个尺寸的手机下看到的效果是令人满意的，其实很多视觉设计师应该无法接受这种效果，因为他们的设计图在大屏幕手机下看到的效果相当于是被横向拉长来一样。\n\n流式布局并不是最理想的实现方式，通过大量的百分比布局，会经常出现许多兼容性的问题，还有就是对设计有很多的限制，因为他们在设计之初就需要考虑流式布局对元素造成的影响，只能设计横向拉伸的元素布局，设计的时候存在很多局限性。\n\n### 2.固定宽度做法\n\n还有一种是固定页面宽度的做法，早期有些网站把页面设置成 320 的宽度，超出部分留白，这样做视觉，前端都挺开心，视觉在也不用被流式布局限制自己的设计灵感了，前端也不用在搞坑爹的流式布局。但是这种解决方案也是存在一些问题，例如在大屏幕手机下两边是留白的，还有一个就是大屏幕手机下看起来页面会特别小，操作的按钮也很小，手机淘宝首页起初是这么做的，但近期改版了，采用了 rem。\n\n### 3.响应式做法\n\n响应式这种方式在国内很少有大型企业的复杂性的网站在移动端用这种方法去做，主要原因是工作大，维护性难，所以一般都是中小型的门户或者博客类站点会采用响应式的方法从 web page 到 web app 直接一步到位，因为这样反而可以节约成本，不用再专门为自己的网站做一个 web app 的版本。\n\n### 4.设置 viewport 进行缩放\n\n天猫的 web app 的首页就是采用这种方式去做的，以 320 宽度为基准，进行缩放，最大缩放为 320\\*1.3 = 416，基本缩放到 416 都就可以兼容 iphone6 plus 的屏幕了，这个方法简单粗暴，又高效。说实话我觉得他和用接下去我们要讲的 rem 都非常高效，不过有部分同学使用过程中反应缩放会导致有些页面元素会糊的情况。\n\n## rem 能等比例适配所有屏幕\n\n上面讲了一大堆目前大部分公司主流的一些 web app 的适配解决方案，接下来讲下 rem 是如何工作的。\n\n上面说过 rem 是通过根元素进行适配的，网页中的根元素指的是 html 我们通过设置 html 的字体大小就可以控制 rem 的大小。举个例子：\n\nhtml{\nfont-size:20px;\n}\n.btn {\nwidth: 6rem;\nheight: 3rem;\nline-height: 3rem;\nfont-size: 1.2rem;\ndisplay: inline-block;\nbackground: #06c;\ncolor: #fff;\nborder-radius: .5rem;\ntext-decoration: none;\ntext-align: center;  \n}\n\nDemo 上面代码结果按钮大小如下图：\n\n![1418899506](http://www.jixiaokang.com/wp-content/uploads/2018/05/1418899506.jpeg)\n\n我把 html 设置成 10px 是为了方便我们计算，为什么 6rem 等于 60px。如果这个时候我们的.btn 的样式不变，我们再改变 html 的 font-size 的值，看看按钮发生上面变化:\n\n//code from http://caibaojian.com/web-app-rem.html\nhtml{\nfont-size:40px;\n}\n\nDemo\n\n按钮大小结果如下：\n\n![1418898055](http://www.jixiaokang.com/wp-content/uploads/2018/05/1418898055.jpeg)\n\n上面的 width，height 变成了上面结果的两倍，我们只改变了 html 的 font-size，但.btn 样式的 width,height 的 rem 设置的属性不变的情况下就改变了按钮在 web 中的大小。\n\n其实从上面两个案例中我们就可以计算出 1px 多少 rem:\n\n第一个例子：\n\n120px = 6rem \\* 20px(根元素设置大值)\n\n第二个例子：\n\n240px = 6rem \\* 40px(根元素设置大值)\n\n推算出：\n\n10px  = 1rem 在根元素（font-size = 10px 的时候）；\n\n20px  = 1rem 在根元素（font-size = 20px 的时候）；\n\n40px  = 1rem 在根元素（font-size = 40px 的时候）；\n\n在上面两个例子中我们发现第一个案例按钮是等比例放大到第二个按钮，html font-size 的改变就会导致按钮的大小发生改变，我们并不需要改变先前给按钮设置的宽度和高度，其实这就是我们最想看到的，为什么这么说？接下来我们再来看一个例子：\n\nDemo\n\n![1418873132](http://www.jixiaokang.com/wp-content/uploads/2018/05/1418873132.jpeg)\n\n由上面两个的 demo 中我们知道改变 html 的 font-size 可以等比改变所有用了 rem 单位的元素，所以大家可以通过 chrome 浏览器的调试工具去切换第三个的 demo 在不同设备下的展示效果，或者通过缩放浏览器的宽度来查看效果，我们可以看到不管在任何分辨率下，页面的排版都是按照等比例进行切换，并且布局没有乱。我只是通过一段 js 根据浏览器当前的分辨率改变 font-size 的值，就简单的实现了上面的效果，页面的所有元素都不需要进行任何改变。\n\n**到这里肯定有很多人会问我是怎么计算出不同分辨率下 font-size 的值？**\n\n首先假设我上面的页面设计稿给我时候是按照 640 的标准尺寸给我的前提下，（当然这个尺寸肯定不一定是 640，可以是 320，或者 480，又或是 375）来看一组表格。\n\n![1418903956](http://www.jixiaokang.com/wp-content/uploads/2018/05/1418903956.jpeg)\n\n上面的表格蓝色一列是 Demo3 中页面的尺寸，页面是以 640 的宽度去切的，怎么计算不同宽度下 font-site 的值，大家看表格上面的数值变化应该能明白。举个例子：384/640 = 0.6，384 是 640 的 0.6 倍，所以 384 页面宽度下的 font-size 也等于它的 0.6 倍，这时 384 的 font-size 就等于 12px。在不同设备的宽度计算方式以此类推。\n\nDemo3 中我是通过[JS](http://caibaojian.com/javascript/ \"js\")去动态计算根元素的 font-size，这样的好处是所有设备分辨率都能兼容适配，淘宝首页目前就是用的 JS 计算。但其实不用 JS 我们也可以做适配，一般我们在做 web app 都会先统计自己网站有哪些主流的屏幕设备，然后去针对那些设备去做 media query 设置也可以实现适配，例如下面这样：\n\nhtml {\nfont-size : 20px;\n}\n@media only screen and (min-width: 401px){\nhtml {\nfont-size: 25px !important;\n}\n}\n@media only screen and (min-width: 428px){\nhtml {\nfont-size: 26.75px !important;\n}\n}\n@media only screen and (min-width: 481px){\nhtml {\nfont-size: 30px !important;\n}\n}\n@media only screen and (min-width: 569px){\nhtml {\nfont-size: 35px !important;\n}\n}\n@media only screen and (min-width: 641px){\nhtml {\nfont-size: 40px !important;\n}\n}\n\n上面的做的设置当然是不能所有设备全适配，但是用 JS 是可以实现全适配。具体用哪个就要根据自己的实际工作场景去定了。\n\n下面推荐两个国内用了 rem 技术的移动站，大家可以上去参考看看他们的做法，手机淘宝目前只有首页用了 rem，淘宝 native app 的首页是内嵌的 web app 首页。\n\n**淘宝首页**：m.taobao.com\n\n**D X**：m.dx.com\n\n### 最后我们再来看一看他的兼容性：\n\n![1418894538](http://www.jixiaokang.com/wp-content/uploads/2018/05/1418894538.png)\n\n### 在线工具\n\n@blinkcat，rem 是可以合并雪碧图的，viewport 设置确实简洁，但是过于粗暴，全局都进行缩放，有时候我布局并不希望全局缩放，部分布局希望不用缩放，所以使用 rem，不过具体使用什么方法大家都可以根据实际情况衡量。并不是每个人都喜欢使用 sass，所以在 px 转 rem 这块我做了一个在线转换工具：http://520ued.com/tools/rem\n\n### REM[自适应](http://caibaojian.com/t/自适应 \"自适应\")JS\n\n具体使用方法请参考这篇文章：[Rem 精简版实现自适应-优化 flexible.js](http://caibaojian.com/simple-flexible.html)\n\n//designWidth:设计稿的实际宽度值，需要根据实际设置\n//maxWidth:制作稿的最大宽度值，需要根据实际设置\n//这段 js 的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为 750，最大宽度为 750，则为(750,750)\n;(function(designWidth, maxWidth) {\nvar doc = document,\nwin = window,\ndocEl = doc.documentElement,\nremStyle = document.createElement(\"style\"),\ntid;\n\n    function refreshRem() {\n    \tvar width = docEl.getBoundingClientRect().width;\n    \tmaxWidth = maxWidth || 540;\n    \twidth>maxWidth && (width=maxWidth);\n    \tvar rem = width * 100 / designWidth;\n    \tremStyle.innerHTML = 'html{font-size:' + rem + 'px;}';\n    }\n\n    if (docEl.firstElementChild) {\n    \tdocEl.firstElementChild.appendChild(remStyle);\n    } else {\n    \tvar wrap = doc.createElement(\"div\");\n    \twrap.appendChild(remStyle);\n    \tdoc.write(wrap.innerHTML);\n    \twrap = null;\n    }\n    //要等 wiewport 设置好后才能执行 refreshRem，不然 refreshRem 会执行2次；\n    refreshRem();\n\n    win.addEventListener(\"resize\", function() {\n    \tclearTimeout(tid); //防止执行两次\n    \ttid = setTimeout(refreshRem, 300);\n    }, false);\n\n    win.addEventListener(\"pageshow\", function(e) {\n    \tif (e.persisted) { // 浏览器后退的时候重新计算\n    \t\tclearTimeout(tid);\n    \t\ttid = setTimeout(refreshRem, 300);\n    \t}\n    }, false);\n\n    if (doc.readyState === \"complete\") {\n    \tdoc.body.style.fontSize = \"16px\";\n    } else {\n    \tdoc.addEventListener(\"DOMContentLoaded\", function(e) {\n    \t\tdoc.body.style.fontSize = \"16px\";\n    \t}, false);\n    }\n\n})(750, 750);\n","slug":"2017-08-12-CSS中em、rem和px","published":1,"updated":"2020-03-14T06:45:00.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvmh003z4k8ygyb5hbdc","content":"<p>PX:<br>PX 实际上就是像素，用 PX 设置字体大小时，比较稳定和精确。但是这种方法存在一个问题，当用户在浏览器中浏览我们制作的 Web 页面时，如果改变了浏览器的缩放，这时会使用我们的 Web 页面布局被打破。这样对于那些关心自己网站可用性的用户来说，就是一个大问题了。因此，这时就提出了使用“em”来定义 Web 页面的字体。</p>\n<p>EM:<br>EM 就是根据基准来缩放字体的大小。EM 实质是一个相对值，而非具体的数值。这种技术需要一个参考点，一般都是以的“font-size”为基准。如 WordPress 官方主题 Twenntytwelve 的基准就是 14px=1em。<br>另外，em 是相对于父元素的属性而计算的，如果想计算 px 和 em 之间的换算，这个网站不错，输入数据就可以 px 和 em 相互计算。狠击这里：px 和 em 换算</p>\n<p>Rem:<br>EM 是相对于其父元素来设置字体大小的，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而 Rem 是相对于根元素，这样就意味着，我们只需要在根元素确定一个参考值。</p>\n<p>浏览器的兼容性<br>除了 IE6-IE8r，其它的浏览器都支持 em 和 rem 属性，px 是所有浏览器都支持。<br>因此为了浏览器的兼容性，可“px”和“rem”一起使用，用”px”来实现 IE6-8 下的效果，然后使用“Rem”来实现代浏览器的效果。</p>\n<p>------</p>\n<h2 id=\"rem-是什么？\"><a href=\"#rem-是什么？\" class=\"headerlink\" title=\"rem 是什么？\"></a>rem 是什么？</h2><p>rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到 rem 大家一定会想起 em 单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。<a href=\"http://caibaojian.com/web-app-rem.html\" target=\"_blank\" rel=\"noopener\">·</a></p>\n<h2 id=\"为什么-web-app-要使用-rem？\"><a href=\"#为什么-web-app-要使用-rem？\" class=\"headerlink\" title=\"为什么 web app 要使用 rem？\"></a>为什么 web app 要使用 rem？</h2><p>这里我特别强调 web app，web page 就不能使用 rem 吗，其实也当然可以，不过出于兼容性的考虑在 web app 下使用更加能突显这个单位的价值和能力，接下来我们来看看目前一些企业的 web app 是怎么做屏幕适配的。</p>\n<h3 id=\"1、实现强大的屏幕适配布局：\"><a href=\"#1、实现强大的屏幕适配布局：\" class=\"headerlink\" title=\"1、实现强大的屏幕适配布局：\"></a>1、实现强大的屏幕适配布局：</h3><p>最近 iphone6 一下出了两款尺寸的手机，导致的移动端的屏幕种类更加的混乱，记得一两年前做 web app 有一种做法是以 320 宽度为标准去做适配，超过 320 的大小还是以 320 的规格去展示，这种实现方式以淘宝 web app 为代表作，但是近期手机淘宝首页进行了改版，采用了 rem 这个单位，首页以内依旧是和以前一样各种混乱，有定死宽度的页面，也有那种流式布局的页面。</p>\n<p>我们现在在切页面布局的使用常用的单位是 px，这是一个绝对单位，web app 的屏幕适配有很多中做法，例如：流式布局、限死宽度，还有就是通过<a href=\"http://caibaojian.com/356.html\" target=\"_blank\" rel=\"noopener\" title=\"响应式布局\">响应式</a>来做，但是这些方案都不是最佳的解决方法。</p>\n<p>例如流式布局的解决方案有不少弊端，它虽然可以让各种屏幕都适配，但是显示的效果极其的不好，因为只有几个尺寸的手机能够完美的显示出视觉设计师和交互最想要的效果，但是目前行业里用流式布局切 web app 的公司还是挺多的，看看下面我收集的一些案例：<a href=\"http://caibaojian.com/web-app-rem.html\" target=\"_blank\" rel=\"noopener\">·</a></p>\n<p>1.亚马逊：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1418896965.jpeg\" alt=\"1418896965\"></p>\n<p>2.携程：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1418891322.jpeg\" alt=\"原文来自http://caibaojian.com/web-app-rem.html\"></p>\n<p>3.兰亭</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1418891825.jpeg\" alt=\"1418891825\"></p>\n<p>上面的网站都是采用的流式布局的技术实现的，他们在页面布局的时候都是通过百分比来定义宽度，但是高度大都是用 px 来固定住，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度还是和原来一样，实际显示非常的不协调，这就是流式布局的最致命的缺点，往往只有几个尺寸的手机下看到的效果是令人满意的，其实很多视觉设计师应该无法接受这种效果，因为他们的设计图在大屏幕手机下看到的效果相当于是被横向拉长来一样。</p>\n<p>流式布局并不是最理想的实现方式，通过大量的百分比布局，会经常出现许多兼容性的问题，还有就是对设计有很多的限制，因为他们在设计之初就需要考虑流式布局对元素造成的影响，只能设计横向拉伸的元素布局，设计的时候存在很多局限性。</p>\n<h3 id=\"2-固定宽度做法\"><a href=\"#2-固定宽度做法\" class=\"headerlink\" title=\"2.固定宽度做法\"></a>2.固定宽度做法</h3><p>还有一种是固定页面宽度的做法，早期有些网站把页面设置成 320 的宽度，超出部分留白，这样做视觉，前端都挺开心，视觉在也不用被流式布局限制自己的设计灵感了，前端也不用在搞坑爹的流式布局。但是这种解决方案也是存在一些问题，例如在大屏幕手机下两边是留白的，还有一个就是大屏幕手机下看起来页面会特别小，操作的按钮也很小，手机淘宝首页起初是这么做的，但近期改版了，采用了 rem。</p>\n<h3 id=\"3-响应式做法\"><a href=\"#3-响应式做法\" class=\"headerlink\" title=\"3.响应式做法\"></a>3.响应式做法</h3><p>响应式这种方式在国内很少有大型企业的复杂性的网站在移动端用这种方法去做，主要原因是工作大，维护性难，所以一般都是中小型的门户或者博客类站点会采用响应式的方法从 web page 到 web app 直接一步到位，因为这样反而可以节约成本，不用再专门为自己的网站做一个 web app 的版本。</p>\n<h3 id=\"4-设置-viewport-进行缩放\"><a href=\"#4-设置-viewport-进行缩放\" class=\"headerlink\" title=\"4.设置 viewport 进行缩放\"></a>4.设置 viewport 进行缩放</h3><p>天猫的 web app 的首页就是采用这种方式去做的，以 320 宽度为基准，进行缩放，最大缩放为 320*1.3 = 416，基本缩放到 416 都就可以兼容 iphone6 plus 的屏幕了，这个方法简单粗暴，又高效。说实话我觉得他和用接下去我们要讲的 rem 都非常高效，不过有部分同学使用过程中反应缩放会导致有些页面元素会糊的情况。</p>\n<h2 id=\"rem-能等比例适配所有屏幕\"><a href=\"#rem-能等比例适配所有屏幕\" class=\"headerlink\" title=\"rem 能等比例适配所有屏幕\"></a>rem 能等比例适配所有屏幕</h2><p>上面讲了一大堆目前大部分公司主流的一些 web app 的适配解决方案，接下来讲下 rem 是如何工作的。</p>\n<p>上面说过 rem 是通过根元素进行适配的，网页中的根元素指的是 html 我们通过设置 html 的字体大小就可以控制 rem 的大小。举个例子：</p>\n<p>html{<br>font-size:20px;<br>}<br>.btn {<br>width: 6rem;<br>height: 3rem;<br>line-height: 3rem;<br>font-size: 1.2rem;<br>display: inline-block;<br>background: #06c;<br>color: #fff;<br>border-radius: .5rem;<br>text-decoration: none;<br>text-align: center;<br>}</p>\n<p>Demo 上面代码结果按钮大小如下图：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1418899506.jpeg\" alt=\"1418899506\"></p>\n<p>我把 html 设置成 10px 是为了方便我们计算，为什么 6rem 等于 60px。如果这个时候我们的.btn 的样式不变，我们再改变 html 的 font-size 的值，看看按钮发生上面变化:</p>\n<p>//code from <a href=\"http://caibaojian.com/web-app-rem.html\" target=\"_blank\" rel=\"noopener\">http://caibaojian.com/web-app-rem.html</a><br>html{<br>font-size:40px;<br>}</p>\n<p>Demo</p>\n<p>按钮大小结果如下：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1418898055.jpeg\" alt=\"1418898055\"></p>\n<p>上面的 width，height 变成了上面结果的两倍，我们只改变了 html 的 font-size，但.btn 样式的 width,height 的 rem 设置的属性不变的情况下就改变了按钮在 web 中的大小。</p>\n<p>其实从上面两个案例中我们就可以计算出 1px 多少 rem:</p>\n<p>第一个例子：</p>\n<p>120px = 6rem * 20px(根元素设置大值)</p>\n<p>第二个例子：</p>\n<p>240px = 6rem * 40px(根元素设置大值)</p>\n<p>推算出：</p>\n<p>10px  = 1rem 在根元素（font-size = 10px 的时候）；</p>\n<p>20px  = 1rem 在根元素（font-size = 20px 的时候）；</p>\n<p>40px  = 1rem 在根元素（font-size = 40px 的时候）；</p>\n<p>在上面两个例子中我们发现第一个案例按钮是等比例放大到第二个按钮，html font-size 的改变就会导致按钮的大小发生改变，我们并不需要改变先前给按钮设置的宽度和高度，其实这就是我们最想看到的，为什么这么说？接下来我们再来看一个例子：</p>\n<p>Demo</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1418873132.jpeg\" alt=\"1418873132\"></p>\n<p>由上面两个的 demo 中我们知道改变 html 的 font-size 可以等比改变所有用了 rem 单位的元素，所以大家可以通过 chrome 浏览器的调试工具去切换第三个的 demo 在不同设备下的展示效果，或者通过缩放浏览器的宽度来查看效果，我们可以看到不管在任何分辨率下，页面的排版都是按照等比例进行切换，并且布局没有乱。我只是通过一段 js 根据浏览器当前的分辨率改变 font-size 的值，就简单的实现了上面的效果，页面的所有元素都不需要进行任何改变。</p>\n<p><strong>到这里肯定有很多人会问我是怎么计算出不同分辨率下 font-size 的值？</strong></p>\n<p>首先假设我上面的页面设计稿给我时候是按照 640 的标准尺寸给我的前提下，（当然这个尺寸肯定不一定是 640，可以是 320，或者 480，又或是 375）来看一组表格。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1418903956.jpeg\" alt=\"1418903956\"></p>\n<p>上面的表格蓝色一列是 Demo3 中页面的尺寸，页面是以 640 的宽度去切的，怎么计算不同宽度下 font-site 的值，大家看表格上面的数值变化应该能明白。举个例子：384/640 = 0.6，384 是 640 的 0.6 倍，所以 384 页面宽度下的 font-size 也等于它的 0.6 倍，这时 384 的 font-size 就等于 12px。在不同设备的宽度计算方式以此类推。</p>\n<p>Demo3 中我是通过<a href=\"http://caibaojian.com/javascript/\" target=\"_blank\" rel=\"noopener\" title=\"js\">JS</a>去动态计算根元素的 font-size，这样的好处是所有设备分辨率都能兼容适配，淘宝首页目前就是用的 JS 计算。但其实不用 JS 我们也可以做适配，一般我们在做 web app 都会先统计自己网站有哪些主流的屏幕设备，然后去针对那些设备去做 media query 设置也可以实现适配，例如下面这样：</p>\n<p>html {<br>font-size : 20px;<br>}<br>@media only screen and (min-width: 401px){<br>html {<br>font-size: 25px !important;<br>}<br>}<br>@media only screen and (min-width: 428px){<br>html {<br>font-size: 26.75px !important;<br>}<br>}<br>@media only screen and (min-width: 481px){<br>html {<br>font-size: 30px !important;<br>}<br>}<br>@media only screen and (min-width: 569px){<br>html {<br>font-size: 35px !important;<br>}<br>}<br>@media only screen and (min-width: 641px){<br>html {<br>font-size: 40px !important;<br>}<br>}</p>\n<p>上面的做的设置当然是不能所有设备全适配，但是用 JS 是可以实现全适配。具体用哪个就要根据自己的实际工作场景去定了。</p>\n<p>下面推荐两个国内用了 rem 技术的移动站，大家可以上去参考看看他们的做法，手机淘宝目前只有首页用了 rem，淘宝 native app 的首页是内嵌的 web app 首页。</p>\n<p><strong>淘宝首页</strong>：m.taobao.com</p>\n<p><strong>D X</strong>：m.dx.com</p>\n<h3 id=\"最后我们再来看一看他的兼容性：\"><a href=\"#最后我们再来看一看他的兼容性：\" class=\"headerlink\" title=\"最后我们再来看一看他的兼容性：\"></a>最后我们再来看一看他的兼容性：</h3><p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1418894538.png\" alt=\"1418894538\"></p>\n<h3 id=\"在线工具\"><a href=\"#在线工具\" class=\"headerlink\" title=\"在线工具\"></a>在线工具</h3><p>@blinkcat，rem 是可以合并雪碧图的，viewport 设置确实简洁，但是过于粗暴，全局都进行缩放，有时候我布局并不希望全局缩放，部分布局希望不用缩放，所以使用 rem，不过具体使用什么方法大家都可以根据实际情况衡量。并不是每个人都喜欢使用 sass，所以在 px 转 rem 这块我做了一个在线转换工具：<a href=\"http://520ued.com/tools/rem\" target=\"_blank\" rel=\"noopener\">http://520ued.com/tools/rem</a></p>\n<h3 id=\"REM自适应JS\"><a href=\"#REM自适应JS\" class=\"headerlink\" title=\"REM自适应JS\"></a>REM<a href=\"http://caibaojian.com/t/自适应\" target=\"_blank\" rel=\"noopener\" title=\"自适应\">自适应</a>JS</h3><p>具体使用方法请参考这篇文章：<a href=\"http://caibaojian.com/simple-flexible.html\" target=\"_blank\" rel=\"noopener\">Rem 精简版实现自适应-优化 flexible.js</a></p>\n<p>//designWidth:设计稿的实际宽度值，需要根据实际设置<br>//maxWidth:制作稿的最大宽度值，需要根据实际设置<br>//这段 js 的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为 750，最大宽度为 750，则为(750,750)<br>;(function(designWidth, maxWidth) {<br>var doc = document,<br>win = window,<br>docEl = doc.documentElement,<br>remStyle = document.createElement(“style”),<br>tid;</p>\n<pre><code>function refreshRem() {\n    var width = docEl.getBoundingClientRect().width;\n    maxWidth = maxWidth || 540;\n    width&gt;maxWidth &amp;&amp; (width=maxWidth);\n    var rem = width * 100 / designWidth;\n    remStyle.innerHTML = &#39;html{font-size:&#39; + rem + &#39;px;}&#39;;\n}\n\nif (docEl.firstElementChild) {\n    docEl.firstElementChild.appendChild(remStyle);\n} else {\n    var wrap = doc.createElement(&quot;div&quot;);\n    wrap.appendChild(remStyle);\n    doc.write(wrap.innerHTML);\n    wrap = null;\n}\n//要等 wiewport 设置好后才能执行 refreshRem，不然 refreshRem 会执行2次；\nrefreshRem();\n\nwin.addEventListener(&quot;resize&quot;, function() {\n    clearTimeout(tid); //防止执行两次\n    tid = setTimeout(refreshRem, 300);\n}, false);\n\nwin.addEventListener(&quot;pageshow&quot;, function(e) {\n    if (e.persisted) { // 浏览器后退的时候重新计算\n        clearTimeout(tid);\n        tid = setTimeout(refreshRem, 300);\n    }\n}, false);\n\nif (doc.readyState === &quot;complete&quot;) {\n    doc.body.style.fontSize = &quot;16px&quot;;\n} else {\n    doc.addEventListener(&quot;DOMContentLoaded&quot;, function(e) {\n        doc.body.style.fontSize = &quot;16px&quot;;\n    }, false);\n}</code></pre><p>})(750, 750);</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>PX:<br>PX 实际上就是像素，用 PX 设置字体大小时，比较稳定和精确。但是这种方法存在一个问题，当用户在浏览器中浏览我们制作的 Web 页面时，如果改变了浏览器的缩放，这时会使用我们的 Web 页面布局被打破。这样对于那些关心自己网站可用性的用户来说，就是一个大问题了。因此，这时就提出了使用“em”来定义 Web 页面的字体。</p>\n<p>EM:<br>EM 就是根据基准来缩放字体的大小。EM 实质是一个相对值，而非具体的数值。这种技术需要一个参考点，一般都是以的“font-size”为基准。如 WordPress 官方主题 Twenntytwelve 的基准就是 14px=1em。<br>另外，em 是相对于父元素的属性而计算的，如果想计算 px 和 em 之间的换算，这个网站不错，输入数据就可以 px 和 em 相互计算。狠击这里：px 和 em 换算</p>\n<p>Rem:<br>EM 是相对于其父元素来设置字体大小的，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而 Rem 是相对于根元素，这样就意味着，我们只需要在根元素确定一个参考值。</p>\n<p>浏览器的兼容性<br>除了 IE6-IE8r，其它的浏览器都支持 em 和 rem 属性，px 是所有浏览器都支持。<br>因此为了浏览器的兼容性，可“px”和“rem”一起使用，用”px”来实现 IE6-8 下的效果，然后使用“Rem”来实现代浏览器的效果。</p>\n<p>------</p>\n<h2 id=\"rem-是什么？\"><a href=\"#rem-是什么？\" class=\"headerlink\" title=\"rem 是什么？\"></a>rem 是什么？</h2><p>rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。看到 rem 大家一定会想起 em 单位，em（font size of the element）是指相对于父元素的字体大小的单位。它们之间其实很相似，只不过一个计算的规则是依赖根元素一个是依赖父元素计算。<a href=\"http://caibaojian.com/web-app-rem.html\" target=\"_blank\" rel=\"noopener\">·</a></p>\n<h2 id=\"为什么-web-app-要使用-rem？\"><a href=\"#为什么-web-app-要使用-rem？\" class=\"headerlink\" title=\"为什么 web app 要使用 rem？\"></a>为什么 web app 要使用 rem？</h2><p>这里我特别强调 web app，web page 就不能使用 rem 吗，其实也当然可以，不过出于兼容性的考虑在 web app 下使用更加能突显这个单位的价值和能力，接下来我们来看看目前一些企业的 web app 是怎么做屏幕适配的。</p>\n<h3 id=\"1、实现强大的屏幕适配布局：\"><a href=\"#1、实现强大的屏幕适配布局：\" class=\"headerlink\" title=\"1、实现强大的屏幕适配布局：\"></a>1、实现强大的屏幕适配布局：</h3><p>最近 iphone6 一下出了两款尺寸的手机，导致的移动端的屏幕种类更加的混乱，记得一两年前做 web app 有一种做法是以 320 宽度为标准去做适配，超过 320 的大小还是以 320 的规格去展示，这种实现方式以淘宝 web app 为代表作，但是近期手机淘宝首页进行了改版，采用了 rem 这个单位，首页以内依旧是和以前一样各种混乱，有定死宽度的页面，也有那种流式布局的页面。</p>\n<p>我们现在在切页面布局的使用常用的单位是 px，这是一个绝对单位，web app 的屏幕适配有很多中做法，例如：流式布局、限死宽度，还有就是通过<a href=\"http://caibaojian.com/356.html\" target=\"_blank\" rel=\"noopener\" title=\"响应式布局\">响应式</a>来做，但是这些方案都不是最佳的解决方法。</p>\n<p>例如流式布局的解决方案有不少弊端，它虽然可以让各种屏幕都适配，但是显示的效果极其的不好，因为只有几个尺寸的手机能够完美的显示出视觉设计师和交互最想要的效果，但是目前行业里用流式布局切 web app 的公司还是挺多的，看看下面我收集的一些案例：<a href=\"http://caibaojian.com/web-app-rem.html\" target=\"_blank\" rel=\"noopener\">·</a></p>\n<p>1.亚马逊：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1418896965.jpeg\" alt=\"1418896965\"></p>\n<p>2.携程：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1418891322.jpeg\" alt=\"原文来自http://caibaojian.com/web-app-rem.html\"></p>\n<p>3.兰亭</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1418891825.jpeg\" alt=\"1418891825\"></p>\n<p>上面的网站都是采用的流式布局的技术实现的，他们在页面布局的时候都是通过百分比来定义宽度，但是高度大都是用 px 来固定住，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度还是和原来一样，实际显示非常的不协调，这就是流式布局的最致命的缺点，往往只有几个尺寸的手机下看到的效果是令人满意的，其实很多视觉设计师应该无法接受这种效果，因为他们的设计图在大屏幕手机下看到的效果相当于是被横向拉长来一样。</p>\n<p>流式布局并不是最理想的实现方式，通过大量的百分比布局，会经常出现许多兼容性的问题，还有就是对设计有很多的限制，因为他们在设计之初就需要考虑流式布局对元素造成的影响，只能设计横向拉伸的元素布局，设计的时候存在很多局限性。</p>\n<h3 id=\"2-固定宽度做法\"><a href=\"#2-固定宽度做法\" class=\"headerlink\" title=\"2.固定宽度做法\"></a>2.固定宽度做法</h3><p>还有一种是固定页面宽度的做法，早期有些网站把页面设置成 320 的宽度，超出部分留白，这样做视觉，前端都挺开心，视觉在也不用被流式布局限制自己的设计灵感了，前端也不用在搞坑爹的流式布局。但是这种解决方案也是存在一些问题，例如在大屏幕手机下两边是留白的，还有一个就是大屏幕手机下看起来页面会特别小，操作的按钮也很小，手机淘宝首页起初是这么做的，但近期改版了，采用了 rem。</p>\n<h3 id=\"3-响应式做法\"><a href=\"#3-响应式做法\" class=\"headerlink\" title=\"3.响应式做法\"></a>3.响应式做法</h3><p>响应式这种方式在国内很少有大型企业的复杂性的网站在移动端用这种方法去做，主要原因是工作大，维护性难，所以一般都是中小型的门户或者博客类站点会采用响应式的方法从 web page 到 web app 直接一步到位，因为这样反而可以节约成本，不用再专门为自己的网站做一个 web app 的版本。</p>\n<h3 id=\"4-设置-viewport-进行缩放\"><a href=\"#4-设置-viewport-进行缩放\" class=\"headerlink\" title=\"4.设置 viewport 进行缩放\"></a>4.设置 viewport 进行缩放</h3><p>天猫的 web app 的首页就是采用这种方式去做的，以 320 宽度为基准，进行缩放，最大缩放为 320*1.3 = 416，基本缩放到 416 都就可以兼容 iphone6 plus 的屏幕了，这个方法简单粗暴，又高效。说实话我觉得他和用接下去我们要讲的 rem 都非常高效，不过有部分同学使用过程中反应缩放会导致有些页面元素会糊的情况。</p>\n<h2 id=\"rem-能等比例适配所有屏幕\"><a href=\"#rem-能等比例适配所有屏幕\" class=\"headerlink\" title=\"rem 能等比例适配所有屏幕\"></a>rem 能等比例适配所有屏幕</h2><p>上面讲了一大堆目前大部分公司主流的一些 web app 的适配解决方案，接下来讲下 rem 是如何工作的。</p>\n<p>上面说过 rem 是通过根元素进行适配的，网页中的根元素指的是 html 我们通过设置 html 的字体大小就可以控制 rem 的大小。举个例子：</p>\n<p>html{<br>font-size:20px;<br>}<br>.btn {<br>width: 6rem;<br>height: 3rem;<br>line-height: 3rem;<br>font-size: 1.2rem;<br>display: inline-block;<br>background: #06c;<br>color: #fff;<br>border-radius: .5rem;<br>text-decoration: none;<br>text-align: center;<br>}</p>\n<p>Demo 上面代码结果按钮大小如下图：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1418899506.jpeg\" alt=\"1418899506\"></p>\n<p>我把 html 设置成 10px 是为了方便我们计算，为什么 6rem 等于 60px。如果这个时候我们的.btn 的样式不变，我们再改变 html 的 font-size 的值，看看按钮发生上面变化:</p>\n<p>//code from <a href=\"http://caibaojian.com/web-app-rem.html\" target=\"_blank\" rel=\"noopener\">http://caibaojian.com/web-app-rem.html</a><br>html{<br>font-size:40px;<br>}</p>\n<p>Demo</p>\n<p>按钮大小结果如下：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1418898055.jpeg\" alt=\"1418898055\"></p>\n<p>上面的 width，height 变成了上面结果的两倍，我们只改变了 html 的 font-size，但.btn 样式的 width,height 的 rem 设置的属性不变的情况下就改变了按钮在 web 中的大小。</p>\n<p>其实从上面两个案例中我们就可以计算出 1px 多少 rem:</p>\n<p>第一个例子：</p>\n<p>120px = 6rem * 20px(根元素设置大值)</p>\n<p>第二个例子：</p>\n<p>240px = 6rem * 40px(根元素设置大值)</p>\n<p>推算出：</p>\n<p>10px  = 1rem 在根元素（font-size = 10px 的时候）；</p>\n<p>20px  = 1rem 在根元素（font-size = 20px 的时候）；</p>\n<p>40px  = 1rem 在根元素（font-size = 40px 的时候）；</p>\n<p>在上面两个例子中我们发现第一个案例按钮是等比例放大到第二个按钮，html font-size 的改变就会导致按钮的大小发生改变，我们并不需要改变先前给按钮设置的宽度和高度，其实这就是我们最想看到的，为什么这么说？接下来我们再来看一个例子：</p>\n<p>Demo</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1418873132.jpeg\" alt=\"1418873132\"></p>\n<p>由上面两个的 demo 中我们知道改变 html 的 font-size 可以等比改变所有用了 rem 单位的元素，所以大家可以通过 chrome 浏览器的调试工具去切换第三个的 demo 在不同设备下的展示效果，或者通过缩放浏览器的宽度来查看效果，我们可以看到不管在任何分辨率下，页面的排版都是按照等比例进行切换，并且布局没有乱。我只是通过一段 js 根据浏览器当前的分辨率改变 font-size 的值，就简单的实现了上面的效果，页面的所有元素都不需要进行任何改变。</p>\n<p><strong>到这里肯定有很多人会问我是怎么计算出不同分辨率下 font-size 的值？</strong></p>\n<p>首先假设我上面的页面设计稿给我时候是按照 640 的标准尺寸给我的前提下，（当然这个尺寸肯定不一定是 640，可以是 320，或者 480，又或是 375）来看一组表格。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1418903956.jpeg\" alt=\"1418903956\"></p>\n<p>上面的表格蓝色一列是 Demo3 中页面的尺寸，页面是以 640 的宽度去切的，怎么计算不同宽度下 font-site 的值，大家看表格上面的数值变化应该能明白。举个例子：384/640 = 0.6，384 是 640 的 0.6 倍，所以 384 页面宽度下的 font-size 也等于它的 0.6 倍，这时 384 的 font-size 就等于 12px。在不同设备的宽度计算方式以此类推。</p>\n<p>Demo3 中我是通过<a href=\"http://caibaojian.com/javascript/\" target=\"_blank\" rel=\"noopener\" title=\"js\">JS</a>去动态计算根元素的 font-size，这样的好处是所有设备分辨率都能兼容适配，淘宝首页目前就是用的 JS 计算。但其实不用 JS 我们也可以做适配，一般我们在做 web app 都会先统计自己网站有哪些主流的屏幕设备，然后去针对那些设备去做 media query 设置也可以实现适配，例如下面这样：</p>\n<p>html {<br>font-size : 20px;<br>}<br>@media only screen and (min-width: 401px){<br>html {<br>font-size: 25px !important;<br>}<br>}<br>@media only screen and (min-width: 428px){<br>html {<br>font-size: 26.75px !important;<br>}<br>}<br>@media only screen and (min-width: 481px){<br>html {<br>font-size: 30px !important;<br>}<br>}<br>@media only screen and (min-width: 569px){<br>html {<br>font-size: 35px !important;<br>}<br>}<br>@media only screen and (min-width: 641px){<br>html {<br>font-size: 40px !important;<br>}<br>}</p>\n<p>上面的做的设置当然是不能所有设备全适配，但是用 JS 是可以实现全适配。具体用哪个就要根据自己的实际工作场景去定了。</p>\n<p>下面推荐两个国内用了 rem 技术的移动站，大家可以上去参考看看他们的做法，手机淘宝目前只有首页用了 rem，淘宝 native app 的首页是内嵌的 web app 首页。</p>\n<p><strong>淘宝首页</strong>：m.taobao.com</p>\n<p><strong>D X</strong>：m.dx.com</p>\n<h3 id=\"最后我们再来看一看他的兼容性：\"><a href=\"#最后我们再来看一看他的兼容性：\" class=\"headerlink\" title=\"最后我们再来看一看他的兼容性：\"></a>最后我们再来看一看他的兼容性：</h3><p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1418894538.png\" alt=\"1418894538\"></p>\n<h3 id=\"在线工具\"><a href=\"#在线工具\" class=\"headerlink\" title=\"在线工具\"></a>在线工具</h3><p>@blinkcat，rem 是可以合并雪碧图的，viewport 设置确实简洁，但是过于粗暴，全局都进行缩放，有时候我布局并不希望全局缩放，部分布局希望不用缩放，所以使用 rem，不过具体使用什么方法大家都可以根据实际情况衡量。并不是每个人都喜欢使用 sass，所以在 px 转 rem 这块我做了一个在线转换工具：<a href=\"http://520ued.com/tools/rem\" target=\"_blank\" rel=\"noopener\">http://520ued.com/tools/rem</a></p>\n<h3 id=\"REM自适应JS\"><a href=\"#REM自适应JS\" class=\"headerlink\" title=\"REM自适应JS\"></a>REM<a href=\"http://caibaojian.com/t/自适应\" target=\"_blank\" rel=\"noopener\" title=\"自适应\">自适应</a>JS</h3><p>具体使用方法请参考这篇文章：<a href=\"http://caibaojian.com/simple-flexible.html\" target=\"_blank\" rel=\"noopener\">Rem 精简版实现自适应-优化 flexible.js</a></p>\n<p>//designWidth:设计稿的实际宽度值，需要根据实际设置<br>//maxWidth:制作稿的最大宽度值，需要根据实际设置<br>//这段 js 的最后面有两个参数记得要设置，一个为设计稿实际宽度，一个为制作稿最大宽度，例如设计稿为 750，最大宽度为 750，则为(750,750)<br>;(function(designWidth, maxWidth) {<br>var doc = document,<br>win = window,<br>docEl = doc.documentElement,<br>remStyle = document.createElement(“style”),<br>tid;</p>\n<pre><code>function refreshRem() {\n    var width = docEl.getBoundingClientRect().width;\n    maxWidth = maxWidth || 540;\n    width&gt;maxWidth &amp;&amp; (width=maxWidth);\n    var rem = width * 100 / designWidth;\n    remStyle.innerHTML = &#39;html{font-size:&#39; + rem + &#39;px;}&#39;;\n}\n\nif (docEl.firstElementChild) {\n    docEl.firstElementChild.appendChild(remStyle);\n} else {\n    var wrap = doc.createElement(&quot;div&quot;);\n    wrap.appendChild(remStyle);\n    doc.write(wrap.innerHTML);\n    wrap = null;\n}\n//要等 wiewport 设置好后才能执行 refreshRem，不然 refreshRem 会执行2次；\nrefreshRem();\n\nwin.addEventListener(&quot;resize&quot;, function() {\n    clearTimeout(tid); //防止执行两次\n    tid = setTimeout(refreshRem, 300);\n}, false);\n\nwin.addEventListener(&quot;pageshow&quot;, function(e) {\n    if (e.persisted) { // 浏览器后退的时候重新计算\n        clearTimeout(tid);\n        tid = setTimeout(refreshRem, 300);\n    }\n}, false);\n\nif (doc.readyState === &quot;complete&quot;) {\n    doc.body.style.fontSize = &quot;16px&quot;;\n} else {\n    doc.addEventListener(&quot;DOMContentLoaded&quot;, function(e) {\n        doc.body.style.fontSize = &quot;16px&quot;;\n    }, false);\n}</code></pre><p>})(750, 750);</p>\n"},{"layout":"post","title":"使用GitHub Pages+Jekyll搭建个人博客","date":"2016-11-20T16:00:00.000Z","_content":"\n### 概述\n\n![](/assets/build_blog_with_github_and_jekyll/01.jpg)\n\n> **`GitHub Pages`** 免费无限容量的站点数据托管工具(_国内访问速度较慢_)，内置 Jekyll 服务，能将特定名称的代码仓库动态编译为静态网页\n>\n> **`Jekyll`** 基于 Ruby 的静态网页生成系统，采用模板将 Markdown(或 Textile)文件转换为统一的网页\n>\n> **统计** 统计工具主要是为了方便查看站点的访问情况，目前支持[百度统计](http://tongji.baidu.com)和[Google Analytics](http://www.google.com/analytics/)(可同时使用)\n>\n> **评论** 评论工具可以为静态页面增加评论和分享功能，目前支持国内的[多说](http://duoshuo.com)和国外的[Disqus](https://disqus.com)\n>\n> > _本文将重点介绍标注 `` 的必选项目，未标注的可选项目请按照给定地址自行注册即可_\n\n### 建立 GitHub Pages 站点\n\n1. 在 GitHub 上建立一个以 **_.github.io_** 为后缀的和你帐号名一样的代码仓库，如我的帐号是:[xkloveme](https://github.com/xkloveme)，则建立的仓库名为:[xkloveme.github.io](https://github.com/xkloveme/xkloveme.github.io), 同时在底部 Add .gitigore 选择 Jekyll 模板，这样 Jekyll 产生的临时文件，例如\\_site 目录就不会添加到源代码管理中，当然你也可以以后手动配置:\n\n   ![](/assets/build_blog_with_github_and_jekyll/02.jpg)\n\n2. 将该代码仓库克隆到地:\n\n   > ```sh\n   > $ git clone https://github.com/xkloveme/xkloveme.github.io\n   > ```\n\n3) 创建一个测试页面并推送:\n\n   > ```sh\n   > $ cd xkloveme.github.io\n   > $ echo \"Hello World\" > index.html\n   > $ git add --all\n   > $ git commit -m \"Initial commit\"\n   > $ git push -u origin master\n   > ```\n\n4. 浏览器中输入[xkloveme.github.io](https://xkloveme.github.io)，如果一切正常，你应该能看到一个显示 Hello World 的页面.\n\n> _请将以上的 **xkloveme** 替换为你申请的帐号名_\n\n### 安装配置 Jekyll\n\n1. 安装 Jekyll:\n\n   > ```sh\n   > $ gem install jekyll\n   > ```\n\n2. 创建或使用模板, 创建模板使用 _jekyll new **name**_ 命令，但创建出来的测试模板极其简陋，在这里我主要介绍使用第三方主题，在 [这里](http://jekyllthemes.org) 你可以找到各种主题，当然你也可以直接使用我的博客模板:[点击下载](https://github.com/stidio/stidio.github.io/archive/master.zip)，下载后解压到本地代码仓库目录，并运行 _bundle install_ 命令安装项目依赖包.\n\n3. 运行 _jekyll serve_ 启动本地测试服务器，Jekyll 默认使用 4000 端口，如果被占用，可以使用 _jekyll serve -P \\$PORT_ 指定其他端口，如果本机从没配置过 Jekyll，可能会给出 _cannot load such file -- bundler_ 的错误，运行 _gem install bundler_ 即可解决，如果还是出现包缺失的错误，可以从以下两点排查：\n\n   > - Gemfile 文件未添加指定包\n   > - 运行环境冲突，可以运行 _bundle exe jekyll serve_ 执行，或者运行 _sudo bundle clean --force_(**该命令会对全局环境造成影响，小心使用**) 强制清理无关包后重新运行\n\n4. 在浏览器中输入 [127.0.0.1:4000](http://127.0.0.1:4000) 进行本地预览\n\n> Ruby 包管理工具介绍\n>\n> - `gem` 全局包管理工具，类似于 Python 的 pip, Node.js 的 npm -g\n>\n>   - gem install 安装组件\n>   - gem install -v 安装特定版本\n>   - gem list 列出已经安装组件\n>   - gem sources -a 添加源\n>   - gem sources --remove 删除源\n>\n> - `bundle` 项目包管理工具，可以理解为一个独立的运行环境\n>   - bundle update 更新项目依赖包\n>   - bundle install 安装项目依赖包\n>   - sudo bundle clean --force 强制删除不相关的包\n>   - bundle exe 在指定环境中运行\n\n### 使用我的博客模板\n\n1. 按照注释说明修改 _\\_config.yml_ 配置文件\n2. 删除文章目录 _\\_post/_ 和文章图片目录 _images/posts/_ 下面的所有内容\n3. Enjoy!\n\n我的模板在 [leopardpan](https://github.com/leopardpan/leopardpan.github.io) 基础上进行了修改，主要改进了以下内容:\n\n> - 统一风格，给关于，标签页面添加了标题栏\n> - 添加分割改进文章列表的多标签显示\n> - 修正了一些翻译不全的文字\n> - 代码颜色高亮支持，综合了 Pygments monokai 方案和 Rouge monokai.sublime 方案，[点此查看](/css/code_style_monokai.css)\n> - 底部统计和版权排版对齐\n> - 更新 Jekyll 及其依赖包到最新版本\n> - 修正 jekyll-sitemap 加载失败的问题\n> - 支持 GFM 形式的 Markdown Codeblock 解析\n\n如果喜欢请[Star!](https://github.com/xkloveme/xkloveme.github.io)，谢谢!\n\n### 编写文章\n\n推荐\n\n1. 国内在线 md 编辑工具[mdeditor](https://www.zybuluo.com/mdeditor)一款国内的在线 markdown 编辑器\n2. 国外在线 md 编辑工具[stackedit](https://stackedit.io/)国外的在线 markdown 编辑器，功能强大，同步云盘国内用户不推荐速度稍慢\n   文章为 Markdown 格式，请使用.md 作为后缀名，有以下两个文章目录：\n\n> - `_posts` 文件名格式为：YEAR-MONTH-DAY-title.md\n> - `_drafts` 草稿目录，文件名格式为：title.md，即不加日期前缀，如果需要预览草稿，使用 _\\--drafts_ 选项运行 _jekyll serve_ 或 _jekyll build_\n>\n> **\\* 尽量避免使用中文文件名, 具体目录结构请参考: [官方文档](http://jekyll.com.cn/docs/structure/)**\n\n每篇文章都必须以参数：\n\n> ```conf\n> ---\n> layout: post\n> title: 使用GitHub+Jekyll搭建个人博客\n> date: 2016-11-21 11:29:08 +0800\n> tags: [Jekyll, GitHub, 教程]\n> ---\n> ```\n\n作为头部信息，layout 为布局格式；title 为显示的文章名；date 为显示的发布日期；tags 为文章分类标签\n\n文章正文采用 Markdown 编写，如果不熟悉可以查看: [Markdown 快速入门](http://wowubuntu.com/markdown/basic.html)；强烈建议遵循[Markdown Lint](https://github.com/DavidAnson/markdownlint/blob/master/doc/Rules.md)，规范有一些对书写文章不友好的地方，我做了调整，以下是我的[Visual Studio Code](https://code.visualstudio.com)的配置文件:\n\n> ```json\n> \"markdownlint.config\": {\n>         \"MD002\": false,                                 // 禁用文章开头必须为H1标题栏\n>         \"MD001\": false,                                 // 禁用严格的标题层级关系(H1->H2->H3...)\n>         \"MD003\": { \"style\": \"setext_with_atx_closed\"},  // 允许#和===形式的标题风格混用\n>         \"MD009\": { \"br_spaces\": 2 },                    // 允许末尾两个空格为<BR/>自动换行模式\n>         \"MD013\": false,                                 // 禁用单行长度限制\n>         \"MD014\": false,                                 // 禁用sh命令以 $ 作为开始\n>         \"MD038\": false,                                 // 禁用代码不以空格作为开始或结束\n>         \"MD041\": false,                                 // 禁用代码段必须有标题栏\n>         \"MD029\": { \"style\": \"ordered\" }                 // 有序列表格式为顺序方式\n>     }\n> ```\n\nJekyll 的 Markdown 解释器从 3.0 开始，默认从 _redcarpet+Pygments_ 换为 _kramdown+Rouge_, 现在已知的问题为：列表下不支持 GFM 形式的代码块(神奇的是 Github 下的 README.md 文件支持)，折中的办法是使用区块引用(Blockquote)，在其下再使用代码块(我的博客模板已针对这种情况在呈现上做了优化)\n\n### 参考资料\n\n[Github 简明教程](http://www.runoob.com/w3cnote/git-guide.html)  \n[Git 简明指南](http://rogerdudler.github.io/git-guide/index.zh.html)  \n[Jekyll 英文文档](https://jekyllrb.com/docs/home/)  \n[Jekyll 中文文档](http://jekyll.com.cn/docs/home/)  \n[Jekyll 代码高亮的几种选择](http://blog.csdn.net/qiujuer/article/details/50419279)  \n[Markdown 语法说明](http://wowubuntu.com/markdown/index.html)  \n[Markdown Lint](https://github.com/DavidAnson/markdownlint/blob/master/doc/Rules.md)  \n[kramdown Quick Reference](http://kramdown.gettalong.org/quickref.html)\n","source":"_posts/2016-11-18-build_blog_with_github_and_jekyll.md","raw":"---\nlayout: post\ntitle: 使用GitHub Pages+Jekyll搭建个人博客\ndate: 2016-11-21\ntags: [Jekyll, GitHub, 教程]\ncategories: 教程\n---\n\n### 概述\n\n![](/assets/build_blog_with_github_and_jekyll/01.jpg)\n\n> **`GitHub Pages`** 免费无限容量的站点数据托管工具(_国内访问速度较慢_)，内置 Jekyll 服务，能将特定名称的代码仓库动态编译为静态网页\n>\n> **`Jekyll`** 基于 Ruby 的静态网页生成系统，采用模板将 Markdown(或 Textile)文件转换为统一的网页\n>\n> **统计** 统计工具主要是为了方便查看站点的访问情况，目前支持[百度统计](http://tongji.baidu.com)和[Google Analytics](http://www.google.com/analytics/)(可同时使用)\n>\n> **评论** 评论工具可以为静态页面增加评论和分享功能，目前支持国内的[多说](http://duoshuo.com)和国外的[Disqus](https://disqus.com)\n>\n> > _本文将重点介绍标注 `` 的必选项目，未标注的可选项目请按照给定地址自行注册即可_\n\n### 建立 GitHub Pages 站点\n\n1. 在 GitHub 上建立一个以 **_.github.io_** 为后缀的和你帐号名一样的代码仓库，如我的帐号是:[xkloveme](https://github.com/xkloveme)，则建立的仓库名为:[xkloveme.github.io](https://github.com/xkloveme/xkloveme.github.io), 同时在底部 Add .gitigore 选择 Jekyll 模板，这样 Jekyll 产生的临时文件，例如\\_site 目录就不会添加到源代码管理中，当然你也可以以后手动配置:\n\n   ![](/assets/build_blog_with_github_and_jekyll/02.jpg)\n\n2. 将该代码仓库克隆到地:\n\n   > ```sh\n   > $ git clone https://github.com/xkloveme/xkloveme.github.io\n   > ```\n\n3) 创建一个测试页面并推送:\n\n   > ```sh\n   > $ cd xkloveme.github.io\n   > $ echo \"Hello World\" > index.html\n   > $ git add --all\n   > $ git commit -m \"Initial commit\"\n   > $ git push -u origin master\n   > ```\n\n4. 浏览器中输入[xkloveme.github.io](https://xkloveme.github.io)，如果一切正常，你应该能看到一个显示 Hello World 的页面.\n\n> _请将以上的 **xkloveme** 替换为你申请的帐号名_\n\n### 安装配置 Jekyll\n\n1. 安装 Jekyll:\n\n   > ```sh\n   > $ gem install jekyll\n   > ```\n\n2. 创建或使用模板, 创建模板使用 _jekyll new **name**_ 命令，但创建出来的测试模板极其简陋，在这里我主要介绍使用第三方主题，在 [这里](http://jekyllthemes.org) 你可以找到各种主题，当然你也可以直接使用我的博客模板:[点击下载](https://github.com/stidio/stidio.github.io/archive/master.zip)，下载后解压到本地代码仓库目录，并运行 _bundle install_ 命令安装项目依赖包.\n\n3. 运行 _jekyll serve_ 启动本地测试服务器，Jekyll 默认使用 4000 端口，如果被占用，可以使用 _jekyll serve -P \\$PORT_ 指定其他端口，如果本机从没配置过 Jekyll，可能会给出 _cannot load such file -- bundler_ 的错误，运行 _gem install bundler_ 即可解决，如果还是出现包缺失的错误，可以从以下两点排查：\n\n   > - Gemfile 文件未添加指定包\n   > - 运行环境冲突，可以运行 _bundle exe jekyll serve_ 执行，或者运行 _sudo bundle clean --force_(**该命令会对全局环境造成影响，小心使用**) 强制清理无关包后重新运行\n\n4. 在浏览器中输入 [127.0.0.1:4000](http://127.0.0.1:4000) 进行本地预览\n\n> Ruby 包管理工具介绍\n>\n> - `gem` 全局包管理工具，类似于 Python 的 pip, Node.js 的 npm -g\n>\n>   - gem install 安装组件\n>   - gem install -v 安装特定版本\n>   - gem list 列出已经安装组件\n>   - gem sources -a 添加源\n>   - gem sources --remove 删除源\n>\n> - `bundle` 项目包管理工具，可以理解为一个独立的运行环境\n>   - bundle update 更新项目依赖包\n>   - bundle install 安装项目依赖包\n>   - sudo bundle clean --force 强制删除不相关的包\n>   - bundle exe 在指定环境中运行\n\n### 使用我的博客模板\n\n1. 按照注释说明修改 _\\_config.yml_ 配置文件\n2. 删除文章目录 _\\_post/_ 和文章图片目录 _images/posts/_ 下面的所有内容\n3. Enjoy!\n\n我的模板在 [leopardpan](https://github.com/leopardpan/leopardpan.github.io) 基础上进行了修改，主要改进了以下内容:\n\n> - 统一风格，给关于，标签页面添加了标题栏\n> - 添加分割改进文章列表的多标签显示\n> - 修正了一些翻译不全的文字\n> - 代码颜色高亮支持，综合了 Pygments monokai 方案和 Rouge monokai.sublime 方案，[点此查看](/css/code_style_monokai.css)\n> - 底部统计和版权排版对齐\n> - 更新 Jekyll 及其依赖包到最新版本\n> - 修正 jekyll-sitemap 加载失败的问题\n> - 支持 GFM 形式的 Markdown Codeblock 解析\n\n如果喜欢请[Star!](https://github.com/xkloveme/xkloveme.github.io)，谢谢!\n\n### 编写文章\n\n推荐\n\n1. 国内在线 md 编辑工具[mdeditor](https://www.zybuluo.com/mdeditor)一款国内的在线 markdown 编辑器\n2. 国外在线 md 编辑工具[stackedit](https://stackedit.io/)国外的在线 markdown 编辑器，功能强大，同步云盘国内用户不推荐速度稍慢\n   文章为 Markdown 格式，请使用.md 作为后缀名，有以下两个文章目录：\n\n> - `_posts` 文件名格式为：YEAR-MONTH-DAY-title.md\n> - `_drafts` 草稿目录，文件名格式为：title.md，即不加日期前缀，如果需要预览草稿，使用 _\\--drafts_ 选项运行 _jekyll serve_ 或 _jekyll build_\n>\n> **\\* 尽量避免使用中文文件名, 具体目录结构请参考: [官方文档](http://jekyll.com.cn/docs/structure/)**\n\n每篇文章都必须以参数：\n\n> ```conf\n> ---\n> layout: post\n> title: 使用GitHub+Jekyll搭建个人博客\n> date: 2016-11-21 11:29:08 +0800\n> tags: [Jekyll, GitHub, 教程]\n> ---\n> ```\n\n作为头部信息，layout 为布局格式；title 为显示的文章名；date 为显示的发布日期；tags 为文章分类标签\n\n文章正文采用 Markdown 编写，如果不熟悉可以查看: [Markdown 快速入门](http://wowubuntu.com/markdown/basic.html)；强烈建议遵循[Markdown Lint](https://github.com/DavidAnson/markdownlint/blob/master/doc/Rules.md)，规范有一些对书写文章不友好的地方，我做了调整，以下是我的[Visual Studio Code](https://code.visualstudio.com)的配置文件:\n\n> ```json\n> \"markdownlint.config\": {\n>         \"MD002\": false,                                 // 禁用文章开头必须为H1标题栏\n>         \"MD001\": false,                                 // 禁用严格的标题层级关系(H1->H2->H3...)\n>         \"MD003\": { \"style\": \"setext_with_atx_closed\"},  // 允许#和===形式的标题风格混用\n>         \"MD009\": { \"br_spaces\": 2 },                    // 允许末尾两个空格为<BR/>自动换行模式\n>         \"MD013\": false,                                 // 禁用单行长度限制\n>         \"MD014\": false,                                 // 禁用sh命令以 $ 作为开始\n>         \"MD038\": false,                                 // 禁用代码不以空格作为开始或结束\n>         \"MD041\": false,                                 // 禁用代码段必须有标题栏\n>         \"MD029\": { \"style\": \"ordered\" }                 // 有序列表格式为顺序方式\n>     }\n> ```\n\nJekyll 的 Markdown 解释器从 3.0 开始，默认从 _redcarpet+Pygments_ 换为 _kramdown+Rouge_, 现在已知的问题为：列表下不支持 GFM 形式的代码块(神奇的是 Github 下的 README.md 文件支持)，折中的办法是使用区块引用(Blockquote)，在其下再使用代码块(我的博客模板已针对这种情况在呈现上做了优化)\n\n### 参考资料\n\n[Github 简明教程](http://www.runoob.com/w3cnote/git-guide.html)  \n[Git 简明指南](http://rogerdudler.github.io/git-guide/index.zh.html)  \n[Jekyll 英文文档](https://jekyllrb.com/docs/home/)  \n[Jekyll 中文文档](http://jekyll.com.cn/docs/home/)  \n[Jekyll 代码高亮的几种选择](http://blog.csdn.net/qiujuer/article/details/50419279)  \n[Markdown 语法说明](http://wowubuntu.com/markdown/index.html)  \n[Markdown Lint](https://github.com/DavidAnson/markdownlint/blob/master/doc/Rules.md)  \n[kramdown Quick Reference](http://kramdown.gettalong.org/quickref.html)\n","slug":"2016-11-18-build_blog_with_github_and_jekyll","published":1,"updated":"2020-03-14T06:43:54.306Z","comments":1,"photos":[],"link":"","_id":"ck7u2pvmi00414k8y8b2veu8h","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p><img src=\"/assets/build_blog_with_github_and_jekyll/01.jpg\" alt=\"\"></p>\n<blockquote>\n<p><strong><code>GitHub Pages</code></strong> 免费无限容量的站点数据托管工具(<em>国内访问速度较慢</em>)，内置 Jekyll 服务，能将特定名称的代码仓库动态编译为静态网页</p>\n<p><strong><code>Jekyll</code></strong> 基于 Ruby 的静态网页生成系统，采用模板将 Markdown(或 Textile)文件转换为统一的网页</p>\n<p><strong>统计</strong> 统计工具主要是为了方便查看站点的访问情况，目前支持<a href=\"http://tongji.baidu.com\" target=\"_blank\" rel=\"noopener\">百度统计</a>和<a href=\"http://www.google.com/analytics/\" target=\"_blank\" rel=\"noopener\">Google Analytics</a>(可同时使用)</p>\n<p><strong>评论</strong> 评论工具可以为静态页面增加评论和分享功能，目前支持国内的<a href=\"http://duoshuo.com\" target=\"_blank\" rel=\"noopener\">多说</a>和国外的<a href=\"https://disqus.com\" target=\"_blank\" rel=\"noopener\">Disqus</a></p>\n<blockquote>\n<p><em>本文将重点介绍标注 `` 的必选项目，未标注的可选项目请按照给定地址自行注册即可</em></p>\n</blockquote>\n</blockquote>\n<h3 id=\"建立-GitHub-Pages-站点\"><a href=\"#建立-GitHub-Pages-站点\" class=\"headerlink\" title=\"建立 GitHub Pages 站点\"></a>建立 GitHub Pages 站点</h3><ol>\n<li><p>在 GitHub 上建立一个以 <strong><em>.github.io</em></strong> 为后缀的和你帐号名一样的代码仓库，如我的帐号是:<a href=\"https://github.com/xkloveme\" target=\"_blank\" rel=\"noopener\">xkloveme</a>，则建立的仓库名为:<a href=\"https://github.com/xkloveme/xkloveme.github.io\" target=\"_blank\" rel=\"noopener\">xkloveme.github.io</a>, 同时在底部 Add .gitigore 选择 Jekyll 模板，这样 Jekyll 产生的临时文件，例如_site 目录就不会添加到源代码管理中，当然你也可以以后手动配置:</p>\n<p><img src=\"/assets/build_blog_with_github_and_jekyll/02.jpg\" alt=\"\"></p>\n</li>\n<li><p>将该代码仓库克隆到地:</p>\n<blockquote>\n<pre class=\" language-sh\"><code class=\"language-sh\">$ git clone https://github.com/xkloveme/xkloveme.github.io</code></pre>\n</blockquote>\n</li>\n</ol>\n<p>3) 创建一个测试页面并推送:</p>\n<blockquote>\n<pre class=\" language-sh\"><code class=\"language-sh\">$ cd xkloveme.github.io\n$ echo \"Hello World\" > index.html\n$ git add --all\n$ git commit -m \"Initial commit\"\n$ git push -u origin master</code></pre>\n</blockquote>\n<ol start=\"4\">\n<li>浏览器中输入<a href=\"https://xkloveme.github.io\" target=\"_blank\" rel=\"noopener\">xkloveme.github.io</a>，如果一切正常，你应该能看到一个显示 Hello World 的页面.</li>\n</ol>\n<blockquote>\n<p><em>请将以上的 <strong>xkloveme</strong> 替换为你申请的帐号名</em></p>\n</blockquote>\n<h3 id=\"安装配置-Jekyll\"><a href=\"#安装配置-Jekyll\" class=\"headerlink\" title=\"安装配置 Jekyll\"></a>安装配置 Jekyll</h3><ol>\n<li><p>安装 Jekyll:</p>\n<blockquote>\n<pre class=\" language-sh\"><code class=\"language-sh\">$ gem install jekyll</code></pre>\n</blockquote>\n</li>\n<li><p>创建或使用模板, 创建模板使用 <em>jekyll new <strong>name</strong></em> 命令，但创建出来的测试模板极其简陋，在这里我主要介绍使用第三方主题，在 <a href=\"http://jekyllthemes.org\" target=\"_blank\" rel=\"noopener\">这里</a> 你可以找到各种主题，当然你也可以直接使用我的博客模板:<a href=\"https://github.com/stidio/stidio.github.io/archive/master.zip\" target=\"_blank\" rel=\"noopener\">点击下载</a>，下载后解压到本地代码仓库目录，并运行 <em>bundle install</em> 命令安装项目依赖包.</p>\n</li>\n<li><p>运行 <em>jekyll serve</em> 启动本地测试服务器，Jekyll 默认使用 4000 端口，如果被占用，可以使用 <em>jekyll serve -P $PORT</em> 指定其他端口，如果本机从没配置过 Jekyll，可能会给出 <em>cannot load such file – bundler</em> 的错误，运行 <em>gem install bundler</em> 即可解决，如果还是出现包缺失的错误，可以从以下两点排查：</p>\n<blockquote>\n<ul>\n<li>Gemfile 文件未添加指定包</li>\n<li>运行环境冲突，可以运行 <em>bundle exe jekyll serve</em> 执行，或者运行 <em>sudo bundle clean –force</em>(<strong>该命令会对全局环境造成影响，小心使用</strong>) 强制清理无关包后重新运行</li>\n</ul>\n</blockquote>\n</li>\n<li><p>在浏览器中输入 <a href=\"http://127.0.0.1:4000\" target=\"_blank\" rel=\"noopener\">127.0.0.1:4000</a> 进行本地预览</p>\n</li>\n</ol>\n<blockquote>\n<p>Ruby 包管理工具介绍</p>\n<ul>\n<li><p><code>gem</code> 全局包管理工具，类似于 Python 的 pip, Node.js 的 npm -g</p>\n<ul>\n<li>gem install 安装组件</li>\n<li>gem install -v 安装特定版本</li>\n<li>gem list 列出已经安装组件</li>\n<li>gem sources -a 添加源</li>\n<li>gem sources –remove 删除源</li>\n</ul>\n</li>\n<li><p><code>bundle</code> 项目包管理工具，可以理解为一个独立的运行环境</p>\n<ul>\n<li>bundle update 更新项目依赖包</li>\n<li>bundle install 安装项目依赖包</li>\n<li>sudo bundle clean –force 强制删除不相关的包</li>\n<li>bundle exe 在指定环境中运行</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"使用我的博客模板\"><a href=\"#使用我的博客模板\" class=\"headerlink\" title=\"使用我的博客模板\"></a>使用我的博客模板</h3><ol>\n<li>按照注释说明修改 <em>\\</em>config.yml_ 配置文件</li>\n<li>删除文章目录 <em>\\</em>post/_ 和文章图片目录 <em>images/posts/</em> 下面的所有内容</li>\n<li>Enjoy!</li>\n</ol>\n<p>我的模板在 <a href=\"https://github.com/leopardpan/leopardpan.github.io\" target=\"_blank\" rel=\"noopener\">leopardpan</a> 基础上进行了修改，主要改进了以下内容:</p>\n<blockquote>\n<ul>\n<li>统一风格，给关于，标签页面添加了标题栏</li>\n<li>添加分割改进文章列表的多标签显示</li>\n<li>修正了一些翻译不全的文字</li>\n<li>代码颜色高亮支持，综合了 Pygments monokai 方案和 Rouge monokai.sublime 方案，<a href=\"/css/code_style_monokai.css\">点此查看</a></li>\n<li>底部统计和版权排版对齐</li>\n<li>更新 Jekyll 及其依赖包到最新版本</li>\n<li>修正 jekyll-sitemap 加载失败的问题</li>\n<li>支持 GFM 形式的 Markdown Codeblock 解析</li>\n</ul>\n</blockquote>\n<p>如果喜欢请<a href=\"https://github.com/xkloveme/xkloveme.github.io\" target=\"_blank\" rel=\"noopener\">Star!</a>，谢谢!</p>\n<h3 id=\"编写文章\"><a href=\"#编写文章\" class=\"headerlink\" title=\"编写文章\"></a>编写文章</h3><p>推荐</p>\n<ol>\n<li>国内在线 md 编辑工具<a href=\"https://www.zybuluo.com/mdeditor\" target=\"_blank\" rel=\"noopener\">mdeditor</a>一款国内的在线 markdown 编辑器</li>\n<li>国外在线 md 编辑工具<a href=\"https://stackedit.io/\" target=\"_blank\" rel=\"noopener\">stackedit</a>国外的在线 markdown 编辑器，功能强大，同步云盘国内用户不推荐速度稍慢<br>文章为 Markdown 格式，请使用.md 作为后缀名，有以下两个文章目录：</li>\n</ol>\n<blockquote>\n<ul>\n<li><code>_posts</code> 文件名格式为：YEAR-MONTH-DAY-title.md</li>\n<li><code>_drafts</code> 草稿目录，文件名格式为：title.md，即不加日期前缀，如果需要预览草稿，使用 <em>--drafts</em> 选项运行 <em>jekyll serve</em> 或 <em>jekyll build</em></li>\n</ul>\n<p><strong>* 尽量避免使用中文文件名, 具体目录结构请参考: <a href=\"http://jekyll.com.cn/docs/structure/\" target=\"_blank\" rel=\"noopener\">官方文档</a></strong></p>\n</blockquote>\n<p>每篇文章都必须以参数：</p>\n<blockquote>\n<pre class=\" language-conf\"><code class=\"language-conf\">---\nlayout: post\ntitle: 使用GitHub+Jekyll搭建个人博客\ndate: 2016-11-21 11:29:08 +0800\ntags: [Jekyll, GitHub, 教程]\n---</code></pre>\n</blockquote>\n<p>作为头部信息，layout 为布局格式；title 为显示的文章名；date 为显示的发布日期；tags 为文章分类标签</p>\n<p>文章正文采用 Markdown 编写，如果不熟悉可以查看: <a href=\"http://wowubuntu.com/markdown/basic.html\" target=\"_blank\" rel=\"noopener\">Markdown 快速入门</a>；强烈建议遵循<a href=\"https://github.com/DavidAnson/markdownlint/blob/master/doc/Rules.md\" target=\"_blank\" rel=\"noopener\">Markdown Lint</a>，规范有一些对书写文章不友好的地方，我做了调整，以下是我的<a href=\"https://code.visualstudio.com\" target=\"_blank\" rel=\"noopener\">Visual Studio Code</a>的配置文件:</p>\n<blockquote>\n<pre class=\" language-json\"><code class=\"language-json\"><span class=\"token property\">\"markdownlint.config\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"MD002\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>                                 // 禁用文章开头必须为H1标题栏\n        <span class=\"token property\">\"MD001\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>                                 // 禁用严格的标题层级关系(H1->H2->H3...<span class=\"token punctuation\">)</span>\n        <span class=\"token property\">\"MD003\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token property\">\"style\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"setext_with_atx_closed\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>  // 允许#和===形式的标题风格混用\n        <span class=\"token property\">\"MD009\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token property\">\"br_spaces\"</span><span class=\"token operator\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>                    // 允许末尾两个空格为&lt;BR/>自动换行模式\n        <span class=\"token property\">\"MD013\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>                                 // 禁用单行长度限制\n        <span class=\"token property\">\"MD014\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>                                 // 禁用sh命令以 $ 作为开始\n        <span class=\"token property\">\"MD038\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>                                 // 禁用代码不以空格作为开始或结束\n        <span class=\"token property\">\"MD041\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>                                 // 禁用代码段必须有标题栏\n        <span class=\"token property\">\"MD029\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token property\">\"style\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"ordered\"</span> <span class=\"token punctuation\">}</span>                 // 有序列表格式为顺序方式\n    <span class=\"token punctuation\">}</span></code></pre>\n</blockquote>\n<p>Jekyll 的 Markdown 解释器从 3.0 开始，默认从 <em>redcarpet+Pygments</em> 换为 <em>kramdown+Rouge</em>, 现在已知的问题为：列表下不支持 GFM 形式的代码块(神奇的是 Github 下的 README.md 文件支持)，折中的办法是使用区块引用(Blockquote)，在其下再使用代码块(我的博客模板已针对这种情况在呈现上做了优化)</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"http://www.runoob.com/w3cnote/git-guide.html\" target=\"_blank\" rel=\"noopener\">Github 简明教程</a><br><a href=\"http://rogerdudler.github.io/git-guide/index.zh.html\" target=\"_blank\" rel=\"noopener\">Git 简明指南</a><br><a href=\"https://jekyllrb.com/docs/home/\" target=\"_blank\" rel=\"noopener\">Jekyll 英文文档</a><br><a href=\"http://jekyll.com.cn/docs/home/\" target=\"_blank\" rel=\"noopener\">Jekyll 中文文档</a><br><a href=\"http://blog.csdn.net/qiujuer/article/details/50419279\" target=\"_blank\" rel=\"noopener\">Jekyll 代码高亮的几种选择</a><br><a href=\"http://wowubuntu.com/markdown/index.html\" target=\"_blank\" rel=\"noopener\">Markdown 语法说明</a><br><a href=\"https://github.com/DavidAnson/markdownlint/blob/master/doc/Rules.md\" target=\"_blank\" rel=\"noopener\">Markdown Lint</a><br><a href=\"http://kramdown.gettalong.org/quickref.html\" target=\"_blank\" rel=\"noopener\">kramdown Quick Reference</a></p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p><img src=\"/assets/build_blog_with_github_and_jekyll/01.jpg\" alt=\"\"></p>\n<blockquote>\n<p><strong><code>GitHub Pages</code></strong> 免费无限容量的站点数据托管工具(<em>国内访问速度较慢</em>)，内置 Jekyll 服务，能将特定名称的代码仓库动态编译为静态网页</p>\n<p><strong><code>Jekyll</code></strong> 基于 Ruby 的静态网页生成系统，采用模板将 Markdown(或 Textile)文件转换为统一的网页</p>\n<p><strong>统计</strong> 统计工具主要是为了方便查看站点的访问情况，目前支持<a href=\"http://tongji.baidu.com\" target=\"_blank\" rel=\"noopener\">百度统计</a>和<a href=\"http://www.google.com/analytics/\" target=\"_blank\" rel=\"noopener\">Google Analytics</a>(可同时使用)</p>\n<p><strong>评论</strong> 评论工具可以为静态页面增加评论和分享功能，目前支持国内的<a href=\"http://duoshuo.com\" target=\"_blank\" rel=\"noopener\">多说</a>和国外的<a href=\"https://disqus.com\" target=\"_blank\" rel=\"noopener\">Disqus</a></p>\n<blockquote>\n<p><em>本文将重点介绍标注 `` 的必选项目，未标注的可选项目请按照给定地址自行注册即可</em></p>\n</blockquote>\n</blockquote>\n<h3 id=\"建立-GitHub-Pages-站点\"><a href=\"#建立-GitHub-Pages-站点\" class=\"headerlink\" title=\"建立 GitHub Pages 站点\"></a>建立 GitHub Pages 站点</h3><ol>\n<li><p>在 GitHub 上建立一个以 <strong><em>.github.io</em></strong> 为后缀的和你帐号名一样的代码仓库，如我的帐号是:<a href=\"https://github.com/xkloveme\" target=\"_blank\" rel=\"noopener\">xkloveme</a>，则建立的仓库名为:<a href=\"https://github.com/xkloveme/xkloveme.github.io\" target=\"_blank\" rel=\"noopener\">xkloveme.github.io</a>, 同时在底部 Add .gitigore 选择 Jekyll 模板，这样 Jekyll 产生的临时文件，例如_site 目录就不会添加到源代码管理中，当然你也可以以后手动配置:</p>\n<p><img src=\"/assets/build_blog_with_github_and_jekyll/02.jpg\" alt=\"\"></p>\n</li>\n<li><p>将该代码仓库克隆到地:</p>\n<blockquote>\n<pre><code class=\"sh\">$ git clone https://github.com/xkloveme/xkloveme.github.io</code></pre>\n</blockquote>\n</li>\n</ol>\n<p>3) 创建一个测试页面并推送:</p>\n<blockquote>\n<pre><code class=\"sh\">$ cd xkloveme.github.io\n$ echo &quot;Hello World&quot; &gt; index.html\n$ git add --all\n$ git commit -m &quot;Initial commit&quot;\n$ git push -u origin master</code></pre>\n</blockquote>\n<ol start=\"4\">\n<li>浏览器中输入<a href=\"https://xkloveme.github.io\" target=\"_blank\" rel=\"noopener\">xkloveme.github.io</a>，如果一切正常，你应该能看到一个显示 Hello World 的页面.</li>\n</ol>\n<blockquote>\n<p><em>请将以上的 <strong>xkloveme</strong> 替换为你申请的帐号名</em></p>\n</blockquote>\n<h3 id=\"安装配置-Jekyll\"><a href=\"#安装配置-Jekyll\" class=\"headerlink\" title=\"安装配置 Jekyll\"></a>安装配置 Jekyll</h3><ol>\n<li><p>安装 Jekyll:</p>\n<blockquote>\n<pre><code class=\"sh\">$ gem install jekyll</code></pre>\n</blockquote>\n</li>\n<li><p>创建或使用模板, 创建模板使用 <em>jekyll new <strong>name</strong></em> 命令，但创建出来的测试模板极其简陋，在这里我主要介绍使用第三方主题，在 <a href=\"http://jekyllthemes.org\" target=\"_blank\" rel=\"noopener\">这里</a> 你可以找到各种主题，当然你也可以直接使用我的博客模板:<a href=\"https://github.com/stidio/stidio.github.io/archive/master.zip\" target=\"_blank\" rel=\"noopener\">点击下载</a>，下载后解压到本地代码仓库目录，并运行 <em>bundle install</em> 命令安装项目依赖包.</p>\n</li>\n<li><p>运行 <em>jekyll serve</em> 启动本地测试服务器，Jekyll 默认使用 4000 端口，如果被占用，可以使用 <em>jekyll serve -P $PORT</em> 指定其他端口，如果本机从没配置过 Jekyll，可能会给出 <em>cannot load such file – bundler</em> 的错误，运行 <em>gem install bundler</em> 即可解决，如果还是出现包缺失的错误，可以从以下两点排查：</p>\n<blockquote>\n<ul>\n<li>Gemfile 文件未添加指定包</li>\n<li>运行环境冲突，可以运行 <em>bundle exe jekyll serve</em> 执行，或者运行 <em>sudo bundle clean –force</em>(<strong>该命令会对全局环境造成影响，小心使用</strong>) 强制清理无关包后重新运行</li>\n</ul>\n</blockquote>\n</li>\n<li><p>在浏览器中输入 <a href=\"http://127.0.0.1:4000\" target=\"_blank\" rel=\"noopener\">127.0.0.1:4000</a> 进行本地预览</p>\n</li>\n</ol>\n<blockquote>\n<p>Ruby 包管理工具介绍</p>\n<ul>\n<li><p><code>gem</code> 全局包管理工具，类似于 Python 的 pip, Node.js 的 npm -g</p>\n<ul>\n<li>gem install 安装组件</li>\n<li>gem install -v 安装特定版本</li>\n<li>gem list 列出已经安装组件</li>\n<li>gem sources -a 添加源</li>\n<li>gem sources –remove 删除源</li>\n</ul>\n</li>\n<li><p><code>bundle</code> 项目包管理工具，可以理解为一个独立的运行环境</p>\n<ul>\n<li>bundle update 更新项目依赖包</li>\n<li>bundle install 安装项目依赖包</li>\n<li>sudo bundle clean –force 强制删除不相关的包</li>\n<li>bundle exe 在指定环境中运行</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"使用我的博客模板\"><a href=\"#使用我的博客模板\" class=\"headerlink\" title=\"使用我的博客模板\"></a>使用我的博客模板</h3><ol>\n<li>按照注释说明修改 <em>\\</em>config.yml_ 配置文件</li>\n<li>删除文章目录 <em>\\</em>post/_ 和文章图片目录 <em>images/posts/</em> 下面的所有内容</li>\n<li>Enjoy!</li>\n</ol>\n<p>我的模板在 <a href=\"https://github.com/leopardpan/leopardpan.github.io\" target=\"_blank\" rel=\"noopener\">leopardpan</a> 基础上进行了修改，主要改进了以下内容:</p>\n<blockquote>\n<ul>\n<li>统一风格，给关于，标签页面添加了标题栏</li>\n<li>添加分割改进文章列表的多标签显示</li>\n<li>修正了一些翻译不全的文字</li>\n<li>代码颜色高亮支持，综合了 Pygments monokai 方案和 Rouge monokai.sublime 方案，<a href=\"/css/code_style_monokai.css\">点此查看</a></li>\n<li>底部统计和版权排版对齐</li>\n<li>更新 Jekyll 及其依赖包到最新版本</li>\n<li>修正 jekyll-sitemap 加载失败的问题</li>\n<li>支持 GFM 形式的 Markdown Codeblock 解析</li>\n</ul>\n</blockquote>\n<p>如果喜欢请<a href=\"https://github.com/xkloveme/xkloveme.github.io\" target=\"_blank\" rel=\"noopener\">Star!</a>，谢谢!</p>\n<h3 id=\"编写文章\"><a href=\"#编写文章\" class=\"headerlink\" title=\"编写文章\"></a>编写文章</h3><p>推荐</p>\n<ol>\n<li>国内在线 md 编辑工具<a href=\"https://www.zybuluo.com/mdeditor\" target=\"_blank\" rel=\"noopener\">mdeditor</a>一款国内的在线 markdown 编辑器</li>\n<li>国外在线 md 编辑工具<a href=\"https://stackedit.io/\" target=\"_blank\" rel=\"noopener\">stackedit</a>国外的在线 markdown 编辑器，功能强大，同步云盘国内用户不推荐速度稍慢<br>文章为 Markdown 格式，请使用.md 作为后缀名，有以下两个文章目录：</li>\n</ol>\n<blockquote>\n<ul>\n<li><code>_posts</code> 文件名格式为：YEAR-MONTH-DAY-title.md</li>\n<li><code>_drafts</code> 草稿目录，文件名格式为：title.md，即不加日期前缀，如果需要预览草稿，使用 <em>--drafts</em> 选项运行 <em>jekyll serve</em> 或 <em>jekyll build</em></li>\n</ul>\n<p><strong>* 尽量避免使用中文文件名, 具体目录结构请参考: <a href=\"http://jekyll.com.cn/docs/structure/\" target=\"_blank\" rel=\"noopener\">官方文档</a></strong></p>\n</blockquote>\n<p>每篇文章都必须以参数：</p>\n<blockquote>\n<pre><code class=\"conf\">---\nlayout: post\ntitle: 使用GitHub+Jekyll搭建个人博客\ndate: 2016-11-21 11:29:08 +0800\ntags: [Jekyll, GitHub, 教程]\n---</code></pre>\n</blockquote>\n<p>作为头部信息，layout 为布局格式；title 为显示的文章名；date 为显示的发布日期；tags 为文章分类标签</p>\n<p>文章正文采用 Markdown 编写，如果不熟悉可以查看: <a href=\"http://wowubuntu.com/markdown/basic.html\" target=\"_blank\" rel=\"noopener\">Markdown 快速入门</a>；强烈建议遵循<a href=\"https://github.com/DavidAnson/markdownlint/blob/master/doc/Rules.md\" target=\"_blank\" rel=\"noopener\">Markdown Lint</a>，规范有一些对书写文章不友好的地方，我做了调整，以下是我的<a href=\"https://code.visualstudio.com\" target=\"_blank\" rel=\"noopener\">Visual Studio Code</a>的配置文件:</p>\n<blockquote>\n<pre><code class=\"json\">&quot;markdownlint.config&quot;: {\n        &quot;MD002&quot;: false,                                 // 禁用文章开头必须为H1标题栏\n        &quot;MD001&quot;: false,                                 // 禁用严格的标题层级关系(H1-&gt;H2-&gt;H3...)\n        &quot;MD003&quot;: { &quot;style&quot;: &quot;setext_with_atx_closed&quot;},  // 允许#和===形式的标题风格混用\n        &quot;MD009&quot;: { &quot;br_spaces&quot;: 2 },                    // 允许末尾两个空格为&lt;BR/&gt;自动换行模式\n        &quot;MD013&quot;: false,                                 // 禁用单行长度限制\n        &quot;MD014&quot;: false,                                 // 禁用sh命令以 $ 作为开始\n        &quot;MD038&quot;: false,                                 // 禁用代码不以空格作为开始或结束\n        &quot;MD041&quot;: false,                                 // 禁用代码段必须有标题栏\n        &quot;MD029&quot;: { &quot;style&quot;: &quot;ordered&quot; }                 // 有序列表格式为顺序方式\n    }</code></pre>\n</blockquote>\n<p>Jekyll 的 Markdown 解释器从 3.0 开始，默认从 <em>redcarpet+Pygments</em> 换为 <em>kramdown+Rouge</em>, 现在已知的问题为：列表下不支持 GFM 形式的代码块(神奇的是 Github 下的 README.md 文件支持)，折中的办法是使用区块引用(Blockquote)，在其下再使用代码块(我的博客模板已针对这种情况在呈现上做了优化)</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"http://www.runoob.com/w3cnote/git-guide.html\" target=\"_blank\" rel=\"noopener\">Github 简明教程</a><br><a href=\"http://rogerdudler.github.io/git-guide/index.zh.html\" target=\"_blank\" rel=\"noopener\">Git 简明指南</a><br><a href=\"https://jekyllrb.com/docs/home/\" target=\"_blank\" rel=\"noopener\">Jekyll 英文文档</a><br><a href=\"http://jekyll.com.cn/docs/home/\" target=\"_blank\" rel=\"noopener\">Jekyll 中文文档</a><br><a href=\"http://blog.csdn.net/qiujuer/article/details/50419279\" target=\"_blank\" rel=\"noopener\">Jekyll 代码高亮的几种选择</a><br><a href=\"http://wowubuntu.com/markdown/index.html\" target=\"_blank\" rel=\"noopener\">Markdown 语法说明</a><br><a href=\"https://github.com/DavidAnson/markdownlint/blob/master/doc/Rules.md\" target=\"_blank\" rel=\"noopener\">Markdown Lint</a><br><a href=\"http://kramdown.gettalong.org/quickref.html\" target=\"_blank\" rel=\"noopener\">kramdown Quick Reference</a></p>\n"},{"title":"轻松搞定 flex 布局（精细篇）","date":"2017-08-12T01:06:00.000Z","_content":"\n## 寻根溯源话布局\n\n一切都始于这样一个问题：怎样通过 CSS 简单而优雅的实现水平、垂直同时居中。记得刚开始学习 CSS 的时候，看到  `float`  属性不由得感觉眼前一亮，顺理成章的联想到 Word 文档排版中用到的的左对齐、右对齐和居中对齐，然而很快就失望的发现 CSS 中并不存在  `float: center`  的写法，那么  `text-align: center`、`verticle-align: center`  是否可行呢？答案也是否定的。这两个属性只能用于行内元素，对于块级元素的布局是无效的。\n\n在网页布局没有进入 CSS 的时代，排版几乎是通过  `table`  元素实现的，在  `table`  的单元格里可以方便的使用  `align`、`valign`  来实现水平和垂直方向的对齐，随着 Web 语义化的流行，这些写法逐渐淡出了视野，CSS 标准为我们提供了 3 种布局方式：`标准文档流`、`浮动布局`和`定位布局`。这几种方式的搭配使用可以轻松搞定 PC 端页面的常见需求，比如实现水平居中可以使用  `margin: 0 auto`，实现水平垂直同时居中可以如下设置：\n\n    .dad {\n        position: relative;\n    }\n\n    .son {\n        position: absolute;\n        margin: auto;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n    }\n\n---\n\n    .dad {\n        position: relative;\n    }\n\n    .son {\n        width: 100px;\n        height: 100px;\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        margin-top: -50px;\n        margin-left: -50px;\n    }\n\n然而，这些写法都存在一些缺陷：缺少语义并且不够灵活。我们需要的是通过 1 个属性就能优雅的实现子元素居中或均匀分布，甚至可以随着窗口缩放自动适应。在这样的需求下，CSS 的第 4 种布局方式诞生了，这就是我们今天要重点介绍的 flex 布局。\n\n## flex 基本概念\n\n使用 flex 布局首先要设置父容器  `display: flex`，然后再设置  `justify-content: center`  实现水平居中，最后设置  `align-items: center`  实现垂直居中。\n\n    #dad {\n        display: flex;\n        justify-content: center;\n        align-items: center\n    }\n\n![](https://dn-mhke0kuv.qbox.me/933e6f0857399ccf7e83.png?imageView2/0/w/1280/h/960)\n\n就是这么简单，大功告成。等等，好像哪里不对，`justify-content`  和  `align-items`  是啥？哪里可以看出横向、竖向的语义？是的，flex 的确没有那么简单，这就要从两个基本概念说起了。\n\n![](https://dn-mhke0kuv.qbox.me/221bb6de73e54f4104a1.png?imageView2/0/w/1280/h/960)\n\n说来也不难，flex 的核心的概念就是   容器   和   轴。容器包括外层的   父容器   和内层的   子容器，轴包括   主轴   和   交叉轴，可以说 flex 布局的全部特性都构建在这两个概念上。flex 布局涉及到 12 个 CSS 属性（不含  `display: flex`），其中父容器、子容器各 6 个。不过常用的属性只有 4 个，父容器、子容器各 2 个，我们就先从常用的说起吧。\n\n### 1\\. 容器\n\n> 容器具有这样的特点：父容器可以统一设置子容器的排列方式，子容器也可以单独设置自身的排列方式，如果两者同时设置，以子容器的设置为准。\n\n![](https://dn-mhke0kuv.qbox.me/f443b657dbc39d361f68.png?imageView2/0/w/1280/h/960)\n\n#### 1.1 父容器\n\n- 设置子容器沿主轴排列：justify-content\n\n`justify-content`  属性用于定义如何沿着主轴方向排列子容器。\n\n![](https://dn-mhke0kuv.qbox.me/be5b7f0e022a8da60ed8.png?imageView2/0/w/1280/h/960)\n\n> flex-start：起始端对齐\n\n![](https://dn-mhke0kuv.qbox.me/ac1d8c5e7b4a2ba51ca7.png?imageView2/0/w/1280/h/960)\n\n> flex-end：末尾段对齐\n\n![](https://dn-mhke0kuv.qbox.me/9ec9245881c2882a35a6.png?imageView2/0/w/1280/h/960)\n\n> center：居中对齐\n\n![](https://dn-mhke0kuv.qbox.me/476461f1b9604a985046.png?imageView2/0/w/1280/h/960)\n\n> space-around：子容器沿主轴均匀分布，位于首尾两端的子容器到父容器的距离是子容器间距的一半。\n\n![](https://dn-mhke0kuv.qbox.me/63119c88aa64853107a9.png?imageView2/0/w/1280/h/960)\n\n> space-between：子容器沿主轴均匀分布，位于首尾两端的子容器与父容器相切。\n\n![](https://dn-mhke0kuv.qbox.me/495f46fc9c5c0c6d1e65.png?imageView2/0/w/1280/h/960)\n\n- 设置子容器如何沿交叉轴排列：align-items\n\n  `align-items`  属性用于定义如何沿着交叉轴方向分配子容器的间距。\n\n![](https://dn-mhke0kuv.qbox.me/e7e6aa079f5333828c58.png?imageView2/0/w/1280/h/960)\n\n> flex-start：起始端对齐\n\n![](https://dn-mhke0kuv.qbox.me/56622862c7831a4d61be.png?imageView2/0/w/1280/h/960)\n\n> flex-end：末尾段对齐\n\n![](https://dn-mhke0kuv.qbox.me/33519955a141be1e713a.png?imageView2/0/w/1280/h/960)\n\n> center：居中对齐\n\n![](https://dn-mhke0kuv.qbox.me/f10513a47130d52f2aa8.png?imageView2/0/w/1280/h/960)\n\n> baseline：基线对齐，这里的  `baseline`  默认是指首行文字，即  `first baseline`，所有子容器向基线对齐，交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线。\n\n![](https://dn-mhke0kuv.qbox.me/f78e9f42be9a3f165f8f.png?imageView2/0/w/1280/h/960)\n\n> stretch：子容器沿交叉轴方向的尺寸拉伸至与父容器一致。\n\n![](https://dn-mhke0kuv.qbox.me/160170b3d2022800ffea.png?imageView2/0/w/1280/h/960)\n\n#### 1.2 子容器\n\n- 在主轴上如何伸缩：flex\n\n![](https://dn-mhke0kuv.qbox.me/089d48122453e9fc372c.png?imageView2/0/w/1280/h/960)\n\n子容器是有弹性的（flex 即弹性），它们会自动填充剩余空间，子容器的伸缩比例由  `flex`属性确定。\n\n`flex`  的值可以是无单位数字（如：1, 2, 3），也可以是有单位数字（如：15px，30px，60px），还可以是  `none`  关键字。子容器会按照  `flex`  定义的尺寸比例自动伸缩，如果取值为  `none`  则不伸缩。\n\n虽然  `flex`  是多个属性的缩写，允许 1 - 3 个值连用，但通常用 1 个值就可以满足需求，它的全部写法可参考下图。\n\n![](https://dn-mhke0kuv.qbox.me/78e9030183f686e0b6ed.png?imageView2/0/w/1280/h/960)\n\n- 单独设置子容器如何沿交叉轴排列：align-self\n\n![](https://dn-mhke0kuv.qbox.me/1d09fe5bb413a6dfa5dd.png?imageView2/0/w/1280/h/960)\n\n每个子容器也可以单独定义沿交叉轴排列的方式，此属性的可选值与父容器  `align-items`  属性完全一致，如果两者同时设置则以子容器的  `align-self`  属性为准。\n\n> flex-start：起始端对齐\n\n![](https://dn-mhke0kuv.qbox.me/93d138727b9dd780bdda.png?imageView2/0/w/1280/h/960)\n\n> flex-end：末尾段对齐\n\n![](https://dn-mhke0kuv.qbox.me/112f075777fdcb6f5d6f.png?imageView2/0/w/1280/h/960)\n\n> center：居中对齐\n\n![](https://dn-mhke0kuv.qbox.me/d7b0131447247a5228fe.png?imageView2/0/w/1280/h/960)\n\n> baseline：基线对齐\n\n![](https://dn-mhke0kuv.qbox.me/26b04323df92c4b1b023.png?imageView2/0/w/1280/h/960)\n\n> stretch：拉伸对齐\n\n![](https://dn-mhke0kuv.qbox.me/ef196e2ba84c406c9ad6.png?imageView2/0/w/1280/h/960)\n\n### 2\\. 轴\n\n如图所示，轴   包括   主轴   和   交叉轴，我们知道  `justify-content`  属性决定子容器沿主轴的排列方式，`align-items`  属性决定子容器沿着交叉轴的排列方式。那么轴本身又是怎样确定的呢？在 flex 布局中，`flex-direction`  属性决定主轴的方向，交叉轴的方向由主轴确定。\n\n![](https://dn-mhke0kuv.qbox.me/5f2a17efffe8f3ab78a4.png?imageView2/0/w/1280/h/960)\n\n- 主轴\n\n主轴的起始端由  `flex-start`  表示，末尾段由  `flex-end`  表示。不同的主轴方向对应的起始端、末尾段的位置也不相同。\n\n> 向右：`flex-direction: row`\n\n![](https://dn-mhke0kuv.qbox.me/da0c2a225cbbdba47297.png?imageView2/0/w/1280/h/960)\n\n> 向下：`flex-direction: column`\n\n![](https://dn-mhke0kuv.qbox.me/ab305a50ff35d7e7b6b4.png?imageView2/0/w/1280/h/960)\n\n> 向左：`flex-direction: row-reverse`\n\n![](https://dn-mhke0kuv.qbox.me/f3b60f80ddd45974449d.png?imageView2/0/w/1280/h/960)\n\n> 向上：`flex-direction: column-reverse`\n\n![](https://dn-mhke0kuv.qbox.me/c219413da157decc5b9e.png?imageView2/0/w/1280/h/960)\n\n- 交叉轴\n\n  主轴沿逆时针方向旋转 90° 就得到了交叉轴，交叉轴的起始端和末尾段也由  `flex-start`和  `flex-end`  表示。\n\n  上面介绍的几项属性是 flex 布局中最常用到的部分，一般来说可以满足大多数需求，如果实现复杂的布局还需要深入了解更多的属性。\n\n---\n\n## flex 进阶概念\n\n### 1\\. 父容器\n\n- 设置换行方式：flex-wrap\n\n  决定子容器是否换行排列，不但可以顺序换行而且支持逆序换行。\n\n![](https://dn-mhke0kuv.qbox.me/19fb0f3a31fa497191b8.png?imageView2/0/w/1280/h/960)\n\n> nowrap：不换行\n\n![](https://dn-mhke0kuv.qbox.me/a41d1342e46cd37cd09e.png?imageView2/0/w/1280/h/960)\n\n> wrap：换行\n\n![](https://dn-mhke0kuv.qbox.me/0566bf9682ffa0890624.png?imageView2/0/w/1280/h/960)\n\n> wrap-reverse：逆序换行\n\n逆序换行是指沿着交叉轴的反方向换行。\n\n![](https://dn-mhke0kuv.qbox.me/2f578fcc69919238bd3b.png?imageView2/0/w/1280/h/960)\n\n- 轴向与换行组合设置：flex-flow\n\n  flow 即流向，也就是子容器沿着哪个方向流动，流动到终点是否允许换行，比如  `flex-flow: row wrap`，`flex-flow`  是一个复合属性，相当于 flex-direction 与 flex-wrap 的组合，可选的取值如下：\n\n  - `row`、`column`  等，可单独设置主轴方向\n\n  - `wrap`、`nowrap`  等，可单独设置换行方式\n\n  - `row nowrap`、`column wrap`  等，也可两者同时设置\n\n- 多行沿交叉轴对齐：align-content\n\n  当子容器多行排列时，设置行与行之间的对齐方式。\n\n![](https://dn-mhke0kuv.qbox.me/ff9bd219375f048b3304.png?imageView2/0/w/1280/h/960)\n\n> flex-start：起始端对齐\n\n![](https://dn-mhke0kuv.qbox.me/0183db03d8fedadc4cf8.png?imageView2/0/w/1280/h/960)\n\n> flex-end：末尾段对齐\n\n![](https://dn-mhke0kuv.qbox.me/12e524438423ac7afc8c.png?imageView2/0/w/1280/h/960)\n\n> center：居中对齐\n\n![](https://dn-mhke0kuv.qbox.me/274a5c1282b997e423db.png?imageView2/0/w/1280/h/960)\n\n> space-around：等边距均匀分布\n\n![](https://dn-mhke0kuv.qbox.me/4a435e3fd0cab3433631.png?imageView2/0/w/1280/h/960)\n\n> space-between：等间距均匀分布\n\n![](https://dn-mhke0kuv.qbox.me/f50d931bdfeb6c24ccae.png?imageView2/0/w/1280/h/960)\n\n> stretch：拉伸对齐\n\n![](https://dn-mhke0kuv.qbox.me/878b39463db6bc499fbc.png?imageView2/0/w/1280/h/960)\n\n### 2\\. 子容器\n\n- 设置基准大小：flex-basis\n\n  `flex-basis`  表示在不伸缩的情况下子容器的原始尺寸。主轴为横向时代表宽度，主轴为纵向时代表高度。\n\n![](https://dn-mhke0kuv.qbox.me/af0dbf4ca6e857ff5de8.png?imageView2/0/w/1280/h/960)\n\n![](https://dn-mhke0kuv.qbox.me/7c73d684a32fd8411db6.png?imageView2/0/w/1280/h/960)\n\n- 设置扩展比例：flex-grow\n\n  子容器弹性伸展的比例。如图，剩余空间按 1:2 的比例分配给子容器。\n\n![](https://dn-mhke0kuv.qbox.me/bcca55b82d18e2ac2367.png?imageView2/0/w/1280/h/960)\n\n![](https://dn-mhke0kuv.qbox.me/72e9f508dff25a474b40.png?imageView2/0/w/1280/h/960)\n\n- 设置收缩比例：flex-shrink\n\n  子容器弹性收缩的比例。如图，超出的部分按 1:2 的比例从给子容器中减去。\n\n![](https://dn-mhke0kuv.qbox.me/38596937d4f86beeac0b.png?imageView2/0/w/1280/h/960)\n\n![](https://dn-mhke0kuv.qbox.me/d278e36c13b9643ff481.png?imageView2/0/w/1280/h/960)\n\n- 设置排列顺序：order\n\n  改变子容器的排列顺序，覆盖 HTML 代码中的顺序，默认值为 0，可以为负值，数值越小排列越靠前。\n\n![](https://dn-mhke0kuv.qbox.me/4eb20f9bfc611e66b069.png?imageView2/0/w/1280/h/960)\n\n---\n\n以上就是 flex 布局的全部属性，一共 12 个，父容器、子容器各 6 个，可以随时通过下图进行回顾。\n\n![](https://dn-mhke0kuv.qbox.me/0dd26d8e99257ff36443.png?imageView2/0/w/1280/h/960)\n","source":"_posts/2017-08-12-轻松搞定 flex 布局（精细篇）.md","raw":"---\ntitle: 轻松搞定 flex 布局（精细篇）\ntags:\n  - CSS\ndate: 2017-08-12 09:06:00\ncategories: 前端\n---\n\n## 寻根溯源话布局\n\n一切都始于这样一个问题：怎样通过 CSS 简单而优雅的实现水平、垂直同时居中。记得刚开始学习 CSS 的时候，看到  `float`  属性不由得感觉眼前一亮，顺理成章的联想到 Word 文档排版中用到的的左对齐、右对齐和居中对齐，然而很快就失望的发现 CSS 中并不存在  `float: center`  的写法，那么  `text-align: center`、`verticle-align: center`  是否可行呢？答案也是否定的。这两个属性只能用于行内元素，对于块级元素的布局是无效的。\n\n在网页布局没有进入 CSS 的时代，排版几乎是通过  `table`  元素实现的，在  `table`  的单元格里可以方便的使用  `align`、`valign`  来实现水平和垂直方向的对齐，随着 Web 语义化的流行，这些写法逐渐淡出了视野，CSS 标准为我们提供了 3 种布局方式：`标准文档流`、`浮动布局`和`定位布局`。这几种方式的搭配使用可以轻松搞定 PC 端页面的常见需求，比如实现水平居中可以使用  `margin: 0 auto`，实现水平垂直同时居中可以如下设置：\n\n    .dad {\n        position: relative;\n    }\n\n    .son {\n        position: absolute;\n        margin: auto;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n    }\n\n---\n\n    .dad {\n        position: relative;\n    }\n\n    .son {\n        width: 100px;\n        height: 100px;\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        margin-top: -50px;\n        margin-left: -50px;\n    }\n\n然而，这些写法都存在一些缺陷：缺少语义并且不够灵活。我们需要的是通过 1 个属性就能优雅的实现子元素居中或均匀分布，甚至可以随着窗口缩放自动适应。在这样的需求下，CSS 的第 4 种布局方式诞生了，这就是我们今天要重点介绍的 flex 布局。\n\n## flex 基本概念\n\n使用 flex 布局首先要设置父容器  `display: flex`，然后再设置  `justify-content: center`  实现水平居中，最后设置  `align-items: center`  实现垂直居中。\n\n    #dad {\n        display: flex;\n        justify-content: center;\n        align-items: center\n    }\n\n![](https://dn-mhke0kuv.qbox.me/933e6f0857399ccf7e83.png?imageView2/0/w/1280/h/960)\n\n就是这么简单，大功告成。等等，好像哪里不对，`justify-content`  和  `align-items`  是啥？哪里可以看出横向、竖向的语义？是的，flex 的确没有那么简单，这就要从两个基本概念说起了。\n\n![](https://dn-mhke0kuv.qbox.me/221bb6de73e54f4104a1.png?imageView2/0/w/1280/h/960)\n\n说来也不难，flex 的核心的概念就是   容器   和   轴。容器包括外层的   父容器   和内层的   子容器，轴包括   主轴   和   交叉轴，可以说 flex 布局的全部特性都构建在这两个概念上。flex 布局涉及到 12 个 CSS 属性（不含  `display: flex`），其中父容器、子容器各 6 个。不过常用的属性只有 4 个，父容器、子容器各 2 个，我们就先从常用的说起吧。\n\n### 1\\. 容器\n\n> 容器具有这样的特点：父容器可以统一设置子容器的排列方式，子容器也可以单独设置自身的排列方式，如果两者同时设置，以子容器的设置为准。\n\n![](https://dn-mhke0kuv.qbox.me/f443b657dbc39d361f68.png?imageView2/0/w/1280/h/960)\n\n#### 1.1 父容器\n\n- 设置子容器沿主轴排列：justify-content\n\n`justify-content`  属性用于定义如何沿着主轴方向排列子容器。\n\n![](https://dn-mhke0kuv.qbox.me/be5b7f0e022a8da60ed8.png?imageView2/0/w/1280/h/960)\n\n> flex-start：起始端对齐\n\n![](https://dn-mhke0kuv.qbox.me/ac1d8c5e7b4a2ba51ca7.png?imageView2/0/w/1280/h/960)\n\n> flex-end：末尾段对齐\n\n![](https://dn-mhke0kuv.qbox.me/9ec9245881c2882a35a6.png?imageView2/0/w/1280/h/960)\n\n> center：居中对齐\n\n![](https://dn-mhke0kuv.qbox.me/476461f1b9604a985046.png?imageView2/0/w/1280/h/960)\n\n> space-around：子容器沿主轴均匀分布，位于首尾两端的子容器到父容器的距离是子容器间距的一半。\n\n![](https://dn-mhke0kuv.qbox.me/63119c88aa64853107a9.png?imageView2/0/w/1280/h/960)\n\n> space-between：子容器沿主轴均匀分布，位于首尾两端的子容器与父容器相切。\n\n![](https://dn-mhke0kuv.qbox.me/495f46fc9c5c0c6d1e65.png?imageView2/0/w/1280/h/960)\n\n- 设置子容器如何沿交叉轴排列：align-items\n\n  `align-items`  属性用于定义如何沿着交叉轴方向分配子容器的间距。\n\n![](https://dn-mhke0kuv.qbox.me/e7e6aa079f5333828c58.png?imageView2/0/w/1280/h/960)\n\n> flex-start：起始端对齐\n\n![](https://dn-mhke0kuv.qbox.me/56622862c7831a4d61be.png?imageView2/0/w/1280/h/960)\n\n> flex-end：末尾段对齐\n\n![](https://dn-mhke0kuv.qbox.me/33519955a141be1e713a.png?imageView2/0/w/1280/h/960)\n\n> center：居中对齐\n\n![](https://dn-mhke0kuv.qbox.me/f10513a47130d52f2aa8.png?imageView2/0/w/1280/h/960)\n\n> baseline：基线对齐，这里的  `baseline`  默认是指首行文字，即  `first baseline`，所有子容器向基线对齐，交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线。\n\n![](https://dn-mhke0kuv.qbox.me/f78e9f42be9a3f165f8f.png?imageView2/0/w/1280/h/960)\n\n> stretch：子容器沿交叉轴方向的尺寸拉伸至与父容器一致。\n\n![](https://dn-mhke0kuv.qbox.me/160170b3d2022800ffea.png?imageView2/0/w/1280/h/960)\n\n#### 1.2 子容器\n\n- 在主轴上如何伸缩：flex\n\n![](https://dn-mhke0kuv.qbox.me/089d48122453e9fc372c.png?imageView2/0/w/1280/h/960)\n\n子容器是有弹性的（flex 即弹性），它们会自动填充剩余空间，子容器的伸缩比例由  `flex`属性确定。\n\n`flex`  的值可以是无单位数字（如：1, 2, 3），也可以是有单位数字（如：15px，30px，60px），还可以是  `none`  关键字。子容器会按照  `flex`  定义的尺寸比例自动伸缩，如果取值为  `none`  则不伸缩。\n\n虽然  `flex`  是多个属性的缩写，允许 1 - 3 个值连用，但通常用 1 个值就可以满足需求，它的全部写法可参考下图。\n\n![](https://dn-mhke0kuv.qbox.me/78e9030183f686e0b6ed.png?imageView2/0/w/1280/h/960)\n\n- 单独设置子容器如何沿交叉轴排列：align-self\n\n![](https://dn-mhke0kuv.qbox.me/1d09fe5bb413a6dfa5dd.png?imageView2/0/w/1280/h/960)\n\n每个子容器也可以单独定义沿交叉轴排列的方式，此属性的可选值与父容器  `align-items`  属性完全一致，如果两者同时设置则以子容器的  `align-self`  属性为准。\n\n> flex-start：起始端对齐\n\n![](https://dn-mhke0kuv.qbox.me/93d138727b9dd780bdda.png?imageView2/0/w/1280/h/960)\n\n> flex-end：末尾段对齐\n\n![](https://dn-mhke0kuv.qbox.me/112f075777fdcb6f5d6f.png?imageView2/0/w/1280/h/960)\n\n> center：居中对齐\n\n![](https://dn-mhke0kuv.qbox.me/d7b0131447247a5228fe.png?imageView2/0/w/1280/h/960)\n\n> baseline：基线对齐\n\n![](https://dn-mhke0kuv.qbox.me/26b04323df92c4b1b023.png?imageView2/0/w/1280/h/960)\n\n> stretch：拉伸对齐\n\n![](https://dn-mhke0kuv.qbox.me/ef196e2ba84c406c9ad6.png?imageView2/0/w/1280/h/960)\n\n### 2\\. 轴\n\n如图所示，轴   包括   主轴   和   交叉轴，我们知道  `justify-content`  属性决定子容器沿主轴的排列方式，`align-items`  属性决定子容器沿着交叉轴的排列方式。那么轴本身又是怎样确定的呢？在 flex 布局中，`flex-direction`  属性决定主轴的方向，交叉轴的方向由主轴确定。\n\n![](https://dn-mhke0kuv.qbox.me/5f2a17efffe8f3ab78a4.png?imageView2/0/w/1280/h/960)\n\n- 主轴\n\n主轴的起始端由  `flex-start`  表示，末尾段由  `flex-end`  表示。不同的主轴方向对应的起始端、末尾段的位置也不相同。\n\n> 向右：`flex-direction: row`\n\n![](https://dn-mhke0kuv.qbox.me/da0c2a225cbbdba47297.png?imageView2/0/w/1280/h/960)\n\n> 向下：`flex-direction: column`\n\n![](https://dn-mhke0kuv.qbox.me/ab305a50ff35d7e7b6b4.png?imageView2/0/w/1280/h/960)\n\n> 向左：`flex-direction: row-reverse`\n\n![](https://dn-mhke0kuv.qbox.me/f3b60f80ddd45974449d.png?imageView2/0/w/1280/h/960)\n\n> 向上：`flex-direction: column-reverse`\n\n![](https://dn-mhke0kuv.qbox.me/c219413da157decc5b9e.png?imageView2/0/w/1280/h/960)\n\n- 交叉轴\n\n  主轴沿逆时针方向旋转 90° 就得到了交叉轴，交叉轴的起始端和末尾段也由  `flex-start`和  `flex-end`  表示。\n\n  上面介绍的几项属性是 flex 布局中最常用到的部分，一般来说可以满足大多数需求，如果实现复杂的布局还需要深入了解更多的属性。\n\n---\n\n## flex 进阶概念\n\n### 1\\. 父容器\n\n- 设置换行方式：flex-wrap\n\n  决定子容器是否换行排列，不但可以顺序换行而且支持逆序换行。\n\n![](https://dn-mhke0kuv.qbox.me/19fb0f3a31fa497191b8.png?imageView2/0/w/1280/h/960)\n\n> nowrap：不换行\n\n![](https://dn-mhke0kuv.qbox.me/a41d1342e46cd37cd09e.png?imageView2/0/w/1280/h/960)\n\n> wrap：换行\n\n![](https://dn-mhke0kuv.qbox.me/0566bf9682ffa0890624.png?imageView2/0/w/1280/h/960)\n\n> wrap-reverse：逆序换行\n\n逆序换行是指沿着交叉轴的反方向换行。\n\n![](https://dn-mhke0kuv.qbox.me/2f578fcc69919238bd3b.png?imageView2/0/w/1280/h/960)\n\n- 轴向与换行组合设置：flex-flow\n\n  flow 即流向，也就是子容器沿着哪个方向流动，流动到终点是否允许换行，比如  `flex-flow: row wrap`，`flex-flow`  是一个复合属性，相当于 flex-direction 与 flex-wrap 的组合，可选的取值如下：\n\n  - `row`、`column`  等，可单独设置主轴方向\n\n  - `wrap`、`nowrap`  等，可单独设置换行方式\n\n  - `row nowrap`、`column wrap`  等，也可两者同时设置\n\n- 多行沿交叉轴对齐：align-content\n\n  当子容器多行排列时，设置行与行之间的对齐方式。\n\n![](https://dn-mhke0kuv.qbox.me/ff9bd219375f048b3304.png?imageView2/0/w/1280/h/960)\n\n> flex-start：起始端对齐\n\n![](https://dn-mhke0kuv.qbox.me/0183db03d8fedadc4cf8.png?imageView2/0/w/1280/h/960)\n\n> flex-end：末尾段对齐\n\n![](https://dn-mhke0kuv.qbox.me/12e524438423ac7afc8c.png?imageView2/0/w/1280/h/960)\n\n> center：居中对齐\n\n![](https://dn-mhke0kuv.qbox.me/274a5c1282b997e423db.png?imageView2/0/w/1280/h/960)\n\n> space-around：等边距均匀分布\n\n![](https://dn-mhke0kuv.qbox.me/4a435e3fd0cab3433631.png?imageView2/0/w/1280/h/960)\n\n> space-between：等间距均匀分布\n\n![](https://dn-mhke0kuv.qbox.me/f50d931bdfeb6c24ccae.png?imageView2/0/w/1280/h/960)\n\n> stretch：拉伸对齐\n\n![](https://dn-mhke0kuv.qbox.me/878b39463db6bc499fbc.png?imageView2/0/w/1280/h/960)\n\n### 2\\. 子容器\n\n- 设置基准大小：flex-basis\n\n  `flex-basis`  表示在不伸缩的情况下子容器的原始尺寸。主轴为横向时代表宽度，主轴为纵向时代表高度。\n\n![](https://dn-mhke0kuv.qbox.me/af0dbf4ca6e857ff5de8.png?imageView2/0/w/1280/h/960)\n\n![](https://dn-mhke0kuv.qbox.me/7c73d684a32fd8411db6.png?imageView2/0/w/1280/h/960)\n\n- 设置扩展比例：flex-grow\n\n  子容器弹性伸展的比例。如图，剩余空间按 1:2 的比例分配给子容器。\n\n![](https://dn-mhke0kuv.qbox.me/bcca55b82d18e2ac2367.png?imageView2/0/w/1280/h/960)\n\n![](https://dn-mhke0kuv.qbox.me/72e9f508dff25a474b40.png?imageView2/0/w/1280/h/960)\n\n- 设置收缩比例：flex-shrink\n\n  子容器弹性收缩的比例。如图，超出的部分按 1:2 的比例从给子容器中减去。\n\n![](https://dn-mhke0kuv.qbox.me/38596937d4f86beeac0b.png?imageView2/0/w/1280/h/960)\n\n![](https://dn-mhke0kuv.qbox.me/d278e36c13b9643ff481.png?imageView2/0/w/1280/h/960)\n\n- 设置排列顺序：order\n\n  改变子容器的排列顺序，覆盖 HTML 代码中的顺序，默认值为 0，可以为负值，数值越小排列越靠前。\n\n![](https://dn-mhke0kuv.qbox.me/4eb20f9bfc611e66b069.png?imageView2/0/w/1280/h/960)\n\n---\n\n以上就是 flex 布局的全部属性，一共 12 个，父容器、子容器各 6 个，可以随时通过下图进行回顾。\n\n![](https://dn-mhke0kuv.qbox.me/0dd26d8e99257ff36443.png?imageView2/0/w/1280/h/960)\n","slug":"2017-08-12-轻松搞定 flex 布局（精细篇）","published":1,"updated":"2020-03-14T06:44:47.414Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvmj00434k8yfbf93cyg","content":"<h2 id=\"寻根溯源话布局\"><a href=\"#寻根溯源话布局\" class=\"headerlink\" title=\"寻根溯源话布局\"></a>寻根溯源话布局</h2><p>一切都始于这样一个问题：怎样通过 CSS 简单而优雅的实现水平、垂直同时居中。记得刚开始学习 CSS 的时候，看到  <code>float</code>  属性不由得感觉眼前一亮，顺理成章的联想到 Word 文档排版中用到的的左对齐、右对齐和居中对齐，然而很快就失望的发现 CSS 中并不存在  <code>float: center</code>  的写法，那么  <code>text-align: center</code>、<code>verticle-align: center</code>  是否可行呢？答案也是否定的。这两个属性只能用于行内元素，对于块级元素的布局是无效的。</p>\n<p>在网页布局没有进入 CSS 的时代，排版几乎是通过  <code>table</code>  元素实现的，在  <code>table</code>  的单元格里可以方便的使用  <code>align</code>、<code>valign</code>  来实现水平和垂直方向的对齐，随着 Web 语义化的流行，这些写法逐渐淡出了视野，CSS 标准为我们提供了 3 种布局方式：<code>标准文档流</code>、<code>浮动布局</code>和<code>定位布局</code>。这几种方式的搭配使用可以轻松搞定 PC 端页面的常见需求，比如实现水平居中可以使用  <code>margin: 0 auto</code>，实现水平垂直同时居中可以如下设置：</p>\n<pre><code>.dad {\n    position: relative;\n}\n\n.son {\n    position: absolute;\n    margin: auto;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n}</code></pre><hr>\n<pre><code>.dad {\n    position: relative;\n}\n\n.son {\n    width: 100px;\n    height: 100px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin-top: -50px;\n    margin-left: -50px;\n}</code></pre><p>然而，这些写法都存在一些缺陷：缺少语义并且不够灵活。我们需要的是通过 1 个属性就能优雅的实现子元素居中或均匀分布，甚至可以随着窗口缩放自动适应。在这样的需求下，CSS 的第 4 种布局方式诞生了，这就是我们今天要重点介绍的 flex 布局。</p>\n<h2 id=\"flex-基本概念\"><a href=\"#flex-基本概念\" class=\"headerlink\" title=\"flex 基本概念\"></a>flex 基本概念</h2><p>使用 flex 布局首先要设置父容器  <code>display: flex</code>，然后再设置  <code>justify-content: center</code>  实现水平居中，最后设置  <code>align-items: center</code>  实现垂直居中。</p>\n<pre><code>#dad {\n    display: flex;\n    justify-content: center;\n    align-items: center\n}</code></pre><p><img src=\"https://dn-mhke0kuv.qbox.me/933e6f0857399ccf7e83.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<p>就是这么简单，大功告成。等等，好像哪里不对，<code>justify-content</code>  和  <code>align-items</code>  是啥？哪里可以看出横向、竖向的语义？是的，flex 的确没有那么简单，这就要从两个基本概念说起了。</p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/221bb6de73e54f4104a1.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<p>说来也不难，flex 的核心的概念就是   容器   和   轴。容器包括外层的   父容器   和内层的   子容器，轴包括   主轴   和   交叉轴，可以说 flex 布局的全部特性都构建在这两个概念上。flex 布局涉及到 12 个 CSS 属性（不含  <code>display: flex</code>），其中父容器、子容器各 6 个。不过常用的属性只有 4 个，父容器、子容器各 2 个，我们就先从常用的说起吧。</p>\n<h3 id=\"1-容器\"><a href=\"#1-容器\" class=\"headerlink\" title=\"1. 容器\"></a>1. 容器</h3><blockquote>\n<p>容器具有这样的特点：父容器可以统一设置子容器的排列方式，子容器也可以单独设置自身的排列方式，如果两者同时设置，以子容器的设置为准。</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/f443b657dbc39d361f68.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<h4 id=\"1-1-父容器\"><a href=\"#1-1-父容器\" class=\"headerlink\" title=\"1.1 父容器\"></a>1.1 父容器</h4><ul>\n<li>设置子容器沿主轴排列：justify-content</li>\n</ul>\n<p><code>justify-content</code>  属性用于定义如何沿着主轴方向排列子容器。</p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/be5b7f0e022a8da60ed8.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>flex-start：起始端对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/ac1d8c5e7b4a2ba51ca7.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>flex-end：末尾段对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/9ec9245881c2882a35a6.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>center：居中对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/476461f1b9604a985046.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>space-around：子容器沿主轴均匀分布，位于首尾两端的子容器到父容器的距离是子容器间距的一半。</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/63119c88aa64853107a9.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>space-between：子容器沿主轴均匀分布，位于首尾两端的子容器与父容器相切。</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/495f46fc9c5c0c6d1e65.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<ul>\n<li><p>设置子容器如何沿交叉轴排列：align-items</p>\n<p><code>align-items</code>  属性用于定义如何沿着交叉轴方向分配子容器的间距。</p>\n</li>\n</ul>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/e7e6aa079f5333828c58.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>flex-start：起始端对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/56622862c7831a4d61be.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>flex-end：末尾段对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/33519955a141be1e713a.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>center：居中对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/f10513a47130d52f2aa8.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>baseline：基线对齐，这里的  <code>baseline</code>  默认是指首行文字，即  <code>first baseline</code>，所有子容器向基线对齐，交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线。</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/f78e9f42be9a3f165f8f.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>stretch：子容器沿交叉轴方向的尺寸拉伸至与父容器一致。</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/160170b3d2022800ffea.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<h4 id=\"1-2-子容器\"><a href=\"#1-2-子容器\" class=\"headerlink\" title=\"1.2 子容器\"></a>1.2 子容器</h4><ul>\n<li>在主轴上如何伸缩：flex</li>\n</ul>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/089d48122453e9fc372c.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<p>子容器是有弹性的（flex 即弹性），它们会自动填充剩余空间，子容器的伸缩比例由  <code>flex</code>属性确定。</p>\n<p><code>flex</code>  的值可以是无单位数字（如：1, 2, 3），也可以是有单位数字（如：15px，30px，60px），还可以是  <code>none</code>  关键字。子容器会按照  <code>flex</code>  定义的尺寸比例自动伸缩，如果取值为  <code>none</code>  则不伸缩。</p>\n<p>虽然  <code>flex</code>  是多个属性的缩写，允许 1 - 3 个值连用，但通常用 1 个值就可以满足需求，它的全部写法可参考下图。</p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/78e9030183f686e0b6ed.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<ul>\n<li>单独设置子容器如何沿交叉轴排列：align-self</li>\n</ul>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/1d09fe5bb413a6dfa5dd.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<p>每个子容器也可以单独定义沿交叉轴排列的方式，此属性的可选值与父容器  <code>align-items</code>  属性完全一致，如果两者同时设置则以子容器的  <code>align-self</code>  属性为准。</p>\n<blockquote>\n<p>flex-start：起始端对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/93d138727b9dd780bdda.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>flex-end：末尾段对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/112f075777fdcb6f5d6f.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>center：居中对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/d7b0131447247a5228fe.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>baseline：基线对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/26b04323df92c4b1b023.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>stretch：拉伸对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/ef196e2ba84c406c9ad6.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<h3 id=\"2-轴\"><a href=\"#2-轴\" class=\"headerlink\" title=\"2. 轴\"></a>2. 轴</h3><p>如图所示，轴   包括   主轴   和   交叉轴，我们知道  <code>justify-content</code>  属性决定子容器沿主轴的排列方式，<code>align-items</code>  属性决定子容器沿着交叉轴的排列方式。那么轴本身又是怎样确定的呢？在 flex 布局中，<code>flex-direction</code>  属性决定主轴的方向，交叉轴的方向由主轴确定。</p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/5f2a17efffe8f3ab78a4.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<ul>\n<li>主轴</li>\n</ul>\n<p>主轴的起始端由  <code>flex-start</code>  表示，末尾段由  <code>flex-end</code>  表示。不同的主轴方向对应的起始端、末尾段的位置也不相同。</p>\n<blockquote>\n<p>向右：<code>flex-direction: row</code></p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/da0c2a225cbbdba47297.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>向下：<code>flex-direction: column</code></p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/ab305a50ff35d7e7b6b4.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>向左：<code>flex-direction: row-reverse</code></p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/f3b60f80ddd45974449d.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>向上：<code>flex-direction: column-reverse</code></p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/c219413da157decc5b9e.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<ul>\n<li><p>交叉轴</p>\n<p>主轴沿逆时针方向旋转 90° 就得到了交叉轴，交叉轴的起始端和末尾段也由  <code>flex-start</code>和  <code>flex-end</code>  表示。</p>\n<p>上面介绍的几项属性是 flex 布局中最常用到的部分，一般来说可以满足大多数需求，如果实现复杂的布局还需要深入了解更多的属性。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"flex-进阶概念\"><a href=\"#flex-进阶概念\" class=\"headerlink\" title=\"flex 进阶概念\"></a>flex 进阶概念</h2><h3 id=\"1-父容器\"><a href=\"#1-父容器\" class=\"headerlink\" title=\"1. 父容器\"></a>1. 父容器</h3><ul>\n<li><p>设置换行方式：flex-wrap</p>\n<p>决定子容器是否换行排列，不但可以顺序换行而且支持逆序换行。</p>\n</li>\n</ul>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/19fb0f3a31fa497191b8.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>nowrap：不换行</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/a41d1342e46cd37cd09e.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>wrap：换行</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/0566bf9682ffa0890624.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>wrap-reverse：逆序换行</p>\n</blockquote>\n<p>逆序换行是指沿着交叉轴的反方向换行。</p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/2f578fcc69919238bd3b.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<ul>\n<li><p>轴向与换行组合设置：flex-flow</p>\n<p>flow 即流向，也就是子容器沿着哪个方向流动，流动到终点是否允许换行，比如  <code>flex-flow: row wrap</code>，<code>flex-flow</code>  是一个复合属性，相当于 flex-direction 与 flex-wrap 的组合，可选的取值如下：</p>\n<ul>\n<li><p><code>row</code>、<code>column</code>  等，可单独设置主轴方向</p>\n</li>\n<li><p><code>wrap</code>、<code>nowrap</code>  等，可单独设置换行方式</p>\n</li>\n<li><p><code>row nowrap</code>、<code>column wrap</code>  等，也可两者同时设置</p>\n</li>\n</ul>\n</li>\n<li><p>多行沿交叉轴对齐：align-content</p>\n<p>当子容器多行排列时，设置行与行之间的对齐方式。</p>\n</li>\n</ul>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/ff9bd219375f048b3304.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>flex-start：起始端对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/0183db03d8fedadc4cf8.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>flex-end：末尾段对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/12e524438423ac7afc8c.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>center：居中对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/274a5c1282b997e423db.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>space-around：等边距均匀分布</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/4a435e3fd0cab3433631.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>space-between：等间距均匀分布</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/f50d931bdfeb6c24ccae.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>stretch：拉伸对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/878b39463db6bc499fbc.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<h3 id=\"2-子容器\"><a href=\"#2-子容器\" class=\"headerlink\" title=\"2. 子容器\"></a>2. 子容器</h3><ul>\n<li><p>设置基准大小：flex-basis</p>\n<p><code>flex-basis</code>  表示在不伸缩的情况下子容器的原始尺寸。主轴为横向时代表宽度，主轴为纵向时代表高度。</p>\n</li>\n</ul>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/af0dbf4ca6e857ff5de8.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/7c73d684a32fd8411db6.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<ul>\n<li><p>设置扩展比例：flex-grow</p>\n<p>子容器弹性伸展的比例。如图，剩余空间按 1:2 的比例分配给子容器。</p>\n</li>\n</ul>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/bcca55b82d18e2ac2367.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/72e9f508dff25a474b40.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<ul>\n<li><p>设置收缩比例：flex-shrink</p>\n<p>子容器弹性收缩的比例。如图，超出的部分按 1:2 的比例从给子容器中减去。</p>\n</li>\n</ul>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/38596937d4f86beeac0b.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/d278e36c13b9643ff481.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<ul>\n<li><p>设置排列顺序：order</p>\n<p>改变子容器的排列顺序，覆盖 HTML 代码中的顺序，默认值为 0，可以为负值，数值越小排列越靠前。</p>\n</li>\n</ul>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/4eb20f9bfc611e66b069.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<hr>\n<p>以上就是 flex 布局的全部属性，一共 12 个，父容器、子容器各 6 个，可以随时通过下图进行回顾。</p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/0dd26d8e99257ff36443.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h2 id=\"寻根溯源话布局\"><a href=\"#寻根溯源话布局\" class=\"headerlink\" title=\"寻根溯源话布局\"></a>寻根溯源话布局</h2><p>一切都始于这样一个问题：怎样通过 CSS 简单而优雅的实现水平、垂直同时居中。记得刚开始学习 CSS 的时候，看到  <code>float</code>  属性不由得感觉眼前一亮，顺理成章的联想到 Word 文档排版中用到的的左对齐、右对齐和居中对齐，然而很快就失望的发现 CSS 中并不存在  <code>float: center</code>  的写法，那么  <code>text-align: center</code>、<code>verticle-align: center</code>  是否可行呢？答案也是否定的。这两个属性只能用于行内元素，对于块级元素的布局是无效的。</p>\n<p>在网页布局没有进入 CSS 的时代，排版几乎是通过  <code>table</code>  元素实现的，在  <code>table</code>  的单元格里可以方便的使用  <code>align</code>、<code>valign</code>  来实现水平和垂直方向的对齐，随着 Web 语义化的流行，这些写法逐渐淡出了视野，CSS 标准为我们提供了 3 种布局方式：<code>标准文档流</code>、<code>浮动布局</code>和<code>定位布局</code>。这几种方式的搭配使用可以轻松搞定 PC 端页面的常见需求，比如实现水平居中可以使用  <code>margin: 0 auto</code>，实现水平垂直同时居中可以如下设置：</p>\n<pre><code>.dad {\n    position: relative;\n}\n\n.son {\n    position: absolute;\n    margin: auto;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n}</code></pre><hr>\n<pre><code>.dad {\n    position: relative;\n}\n\n.son {\n    width: 100px;\n    height: 100px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    margin-top: -50px;\n    margin-left: -50px;\n}</code></pre><p>然而，这些写法都存在一些缺陷：缺少语义并且不够灵活。我们需要的是通过 1 个属性就能优雅的实现子元素居中或均匀分布，甚至可以随着窗口缩放自动适应。在这样的需求下，CSS 的第 4 种布局方式诞生了，这就是我们今天要重点介绍的 flex 布局。</p>\n<h2 id=\"flex-基本概念\"><a href=\"#flex-基本概念\" class=\"headerlink\" title=\"flex 基本概念\"></a>flex 基本概念</h2><p>使用 flex 布局首先要设置父容器  <code>display: flex</code>，然后再设置  <code>justify-content: center</code>  实现水平居中，最后设置  <code>align-items: center</code>  实现垂直居中。</p>\n<pre><code>#dad {\n    display: flex;\n    justify-content: center;\n    align-items: center\n}</code></pre><p><img src=\"https://dn-mhke0kuv.qbox.me/933e6f0857399ccf7e83.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<p>就是这么简单，大功告成。等等，好像哪里不对，<code>justify-content</code>  和  <code>align-items</code>  是啥？哪里可以看出横向、竖向的语义？是的，flex 的确没有那么简单，这就要从两个基本概念说起了。</p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/221bb6de73e54f4104a1.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<p>说来也不难，flex 的核心的概念就是   容器   和   轴。容器包括外层的   父容器   和内层的   子容器，轴包括   主轴   和   交叉轴，可以说 flex 布局的全部特性都构建在这两个概念上。flex 布局涉及到 12 个 CSS 属性（不含  <code>display: flex</code>），其中父容器、子容器各 6 个。不过常用的属性只有 4 个，父容器、子容器各 2 个，我们就先从常用的说起吧。</p>\n<h3 id=\"1-容器\"><a href=\"#1-容器\" class=\"headerlink\" title=\"1. 容器\"></a>1. 容器</h3><blockquote>\n<p>容器具有这样的特点：父容器可以统一设置子容器的排列方式，子容器也可以单独设置自身的排列方式，如果两者同时设置，以子容器的设置为准。</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/f443b657dbc39d361f68.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<h4 id=\"1-1-父容器\"><a href=\"#1-1-父容器\" class=\"headerlink\" title=\"1.1 父容器\"></a>1.1 父容器</h4><ul>\n<li>设置子容器沿主轴排列：justify-content</li>\n</ul>\n<p><code>justify-content</code>  属性用于定义如何沿着主轴方向排列子容器。</p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/be5b7f0e022a8da60ed8.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>flex-start：起始端对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/ac1d8c5e7b4a2ba51ca7.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>flex-end：末尾段对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/9ec9245881c2882a35a6.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>center：居中对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/476461f1b9604a985046.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>space-around：子容器沿主轴均匀分布，位于首尾两端的子容器到父容器的距离是子容器间距的一半。</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/63119c88aa64853107a9.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>space-between：子容器沿主轴均匀分布，位于首尾两端的子容器与父容器相切。</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/495f46fc9c5c0c6d1e65.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<ul>\n<li><p>设置子容器如何沿交叉轴排列：align-items</p>\n<p><code>align-items</code>  属性用于定义如何沿着交叉轴方向分配子容器的间距。</p>\n</li>\n</ul>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/e7e6aa079f5333828c58.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>flex-start：起始端对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/56622862c7831a4d61be.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>flex-end：末尾段对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/33519955a141be1e713a.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>center：居中对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/f10513a47130d52f2aa8.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>baseline：基线对齐，这里的  <code>baseline</code>  默认是指首行文字，即  <code>first baseline</code>，所有子容器向基线对齐，交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线。</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/f78e9f42be9a3f165f8f.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>stretch：子容器沿交叉轴方向的尺寸拉伸至与父容器一致。</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/160170b3d2022800ffea.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<h4 id=\"1-2-子容器\"><a href=\"#1-2-子容器\" class=\"headerlink\" title=\"1.2 子容器\"></a>1.2 子容器</h4><ul>\n<li>在主轴上如何伸缩：flex</li>\n</ul>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/089d48122453e9fc372c.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<p>子容器是有弹性的（flex 即弹性），它们会自动填充剩余空间，子容器的伸缩比例由  <code>flex</code>属性确定。</p>\n<p><code>flex</code>  的值可以是无单位数字（如：1, 2, 3），也可以是有单位数字（如：15px，30px，60px），还可以是  <code>none</code>  关键字。子容器会按照  <code>flex</code>  定义的尺寸比例自动伸缩，如果取值为  <code>none</code>  则不伸缩。</p>\n<p>虽然  <code>flex</code>  是多个属性的缩写，允许 1 - 3 个值连用，但通常用 1 个值就可以满足需求，它的全部写法可参考下图。</p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/78e9030183f686e0b6ed.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<ul>\n<li>单独设置子容器如何沿交叉轴排列：align-self</li>\n</ul>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/1d09fe5bb413a6dfa5dd.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<p>每个子容器也可以单独定义沿交叉轴排列的方式，此属性的可选值与父容器  <code>align-items</code>  属性完全一致，如果两者同时设置则以子容器的  <code>align-self</code>  属性为准。</p>\n<blockquote>\n<p>flex-start：起始端对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/93d138727b9dd780bdda.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>flex-end：末尾段对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/112f075777fdcb6f5d6f.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>center：居中对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/d7b0131447247a5228fe.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>baseline：基线对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/26b04323df92c4b1b023.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>stretch：拉伸对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/ef196e2ba84c406c9ad6.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<h3 id=\"2-轴\"><a href=\"#2-轴\" class=\"headerlink\" title=\"2. 轴\"></a>2. 轴</h3><p>如图所示，轴   包括   主轴   和   交叉轴，我们知道  <code>justify-content</code>  属性决定子容器沿主轴的排列方式，<code>align-items</code>  属性决定子容器沿着交叉轴的排列方式。那么轴本身又是怎样确定的呢？在 flex 布局中，<code>flex-direction</code>  属性决定主轴的方向，交叉轴的方向由主轴确定。</p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/5f2a17efffe8f3ab78a4.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<ul>\n<li>主轴</li>\n</ul>\n<p>主轴的起始端由  <code>flex-start</code>  表示，末尾段由  <code>flex-end</code>  表示。不同的主轴方向对应的起始端、末尾段的位置也不相同。</p>\n<blockquote>\n<p>向右：<code>flex-direction: row</code></p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/da0c2a225cbbdba47297.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>向下：<code>flex-direction: column</code></p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/ab305a50ff35d7e7b6b4.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>向左：<code>flex-direction: row-reverse</code></p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/f3b60f80ddd45974449d.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>向上：<code>flex-direction: column-reverse</code></p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/c219413da157decc5b9e.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<ul>\n<li><p>交叉轴</p>\n<p>主轴沿逆时针方向旋转 90° 就得到了交叉轴，交叉轴的起始端和末尾段也由  <code>flex-start</code>和  <code>flex-end</code>  表示。</p>\n<p>上面介绍的几项属性是 flex 布局中最常用到的部分，一般来说可以满足大多数需求，如果实现复杂的布局还需要深入了解更多的属性。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"flex-进阶概念\"><a href=\"#flex-进阶概念\" class=\"headerlink\" title=\"flex 进阶概念\"></a>flex 进阶概念</h2><h3 id=\"1-父容器\"><a href=\"#1-父容器\" class=\"headerlink\" title=\"1. 父容器\"></a>1. 父容器</h3><ul>\n<li><p>设置换行方式：flex-wrap</p>\n<p>决定子容器是否换行排列，不但可以顺序换行而且支持逆序换行。</p>\n</li>\n</ul>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/19fb0f3a31fa497191b8.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>nowrap：不换行</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/a41d1342e46cd37cd09e.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>wrap：换行</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/0566bf9682ffa0890624.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>wrap-reverse：逆序换行</p>\n</blockquote>\n<p>逆序换行是指沿着交叉轴的反方向换行。</p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/2f578fcc69919238bd3b.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<ul>\n<li><p>轴向与换行组合设置：flex-flow</p>\n<p>flow 即流向，也就是子容器沿着哪个方向流动，流动到终点是否允许换行，比如  <code>flex-flow: row wrap</code>，<code>flex-flow</code>  是一个复合属性，相当于 flex-direction 与 flex-wrap 的组合，可选的取值如下：</p>\n<ul>\n<li><p><code>row</code>、<code>column</code>  等，可单独设置主轴方向</p>\n</li>\n<li><p><code>wrap</code>、<code>nowrap</code>  等，可单独设置换行方式</p>\n</li>\n<li><p><code>row nowrap</code>、<code>column wrap</code>  等，也可两者同时设置</p>\n</li>\n</ul>\n</li>\n<li><p>多行沿交叉轴对齐：align-content</p>\n<p>当子容器多行排列时，设置行与行之间的对齐方式。</p>\n</li>\n</ul>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/ff9bd219375f048b3304.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>flex-start：起始端对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/0183db03d8fedadc4cf8.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>flex-end：末尾段对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/12e524438423ac7afc8c.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>center：居中对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/274a5c1282b997e423db.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>space-around：等边距均匀分布</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/4a435e3fd0cab3433631.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>space-between：等间距均匀分布</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/f50d931bdfeb6c24ccae.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<blockquote>\n<p>stretch：拉伸对齐</p>\n</blockquote>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/878b39463db6bc499fbc.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<h3 id=\"2-子容器\"><a href=\"#2-子容器\" class=\"headerlink\" title=\"2. 子容器\"></a>2. 子容器</h3><ul>\n<li><p>设置基准大小：flex-basis</p>\n<p><code>flex-basis</code>  表示在不伸缩的情况下子容器的原始尺寸。主轴为横向时代表宽度，主轴为纵向时代表高度。</p>\n</li>\n</ul>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/af0dbf4ca6e857ff5de8.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/7c73d684a32fd8411db6.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<ul>\n<li><p>设置扩展比例：flex-grow</p>\n<p>子容器弹性伸展的比例。如图，剩余空间按 1:2 的比例分配给子容器。</p>\n</li>\n</ul>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/bcca55b82d18e2ac2367.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/72e9f508dff25a474b40.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<ul>\n<li><p>设置收缩比例：flex-shrink</p>\n<p>子容器弹性收缩的比例。如图，超出的部分按 1:2 的比例从给子容器中减去。</p>\n</li>\n</ul>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/38596937d4f86beeac0b.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/d278e36c13b9643ff481.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<ul>\n<li><p>设置排列顺序：order</p>\n<p>改变子容器的排列顺序，覆盖 HTML 代码中的顺序，默认值为 0，可以为负值，数值越小排列越靠前。</p>\n</li>\n</ul>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/4eb20f9bfc611e66b069.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n<hr>\n<p>以上就是 flex 布局的全部属性，一共 12 个，父容器、子容器各 6 个，可以随时通过下图进行回顾。</p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/0dd26d8e99257ff36443.png?imageView2/0/w/1280/h/960\" alt=\"\"></p>\n"},{"title":"Vue 实例中的生命周期钩子","date":"2017-08-24T04:36:00.000Z","_content":"\nVue 框架的入口就是 Vue 实例，其实就是框架中的 view model ，它包含页面中的业务  \n处理逻辑、数据模型等，它的生命周期中有多个事件钩子，让我们在控制整个 Vue 实例的  \n过程时更容易形成好的逻辑。\n\n## Vue 实例\n\n在文档中经常会使用 vm 这个变量名表示 Vue 实例，在实例化 Vue 时，需要传入一个选  \n项对象，它可以包含数据(data)、模板(template)、挂载元素(el)、方法(methods)、生  \n命周期钩子(lifecyclehook)等选项。\n\n### Vue 实例化的选项\n\n需要注意的是含 this 的函数大多不要使用箭头函数，因为我们期望 this 指向 Vue 实例。\n\n### data\n\nVue 实例的数据都保存在 data 对象中，Vue 将会递归将 data 的属性转换为 getter/setter，  \n从而让 data 的属性能够响应数据变化。\n\n    var data = { a: 1 }\n    // 直接创建一个实例\n    var vm = new Vue({\n      data: data\n    })\n    vm.a // -> 1\n    vm.$data === data // -> true\n\n这样数据就绑定在 HTML 中，Vue 框架监视 data 的数据变化，自动更新 HTML 内容。\n\n### computed\n\n> 计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue  \n> 实例。[官方 API](https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE \"Vue API\")\n\n    var vm = new Vue({\n      data: { a: 1 },\n      computed: {\n        // 仅读取，值只须为函数\n        aDouble: function () {\n          return this.a * 2\n        },\n        // 读取和设置\n        aPlus: {\n          get: function () {\n            return this.a + 1\n          },\n          set: function (v) {\n            this.a = v - 1\n          }\n        }\n      }\n    })\n    vm.aPlus   // -> 2\n    vm.aPlus = 3\n    vm.a       // -> 2\n    vm.aDouble // -> 4\n\n这里可以省略 setter,如果省略了 setter，那么值就可以是普通函数，但是必须有返回值。\n\n### methods\n\n> methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达  \n> 式中使用。方法中的 this 自动绑定为 Vue 实例。[官方 API](https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE \"Vue API\")\n\n    var vm = new Vue({\n      data: { a: 1 },\n      methods: {\n        plus: function () {\n          this.a++\n        }\n      }\n    })\n    vm.plus()\n    vm.a // 2\n\n看下面这个例子，methods 和 computed 看起来可以做同样的事情，单纯看结果两种方式确实是相同的。  \n然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变  \n时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会  \n立即返回之前的计算结果，而不必再次执行函数。相比而言，只要发生重新渲染，method 调用总会执行  \n该函数。\n\n    var vm = new Vue({\n      el: '#example',\n      data: {\n        message: 'Hello'\n      },\n      computed: {\n        // a computed getter\n        reversedMessage: function () {\n          // `this` points to the vm instance\n          return this.message.split('').reverse().join('')\n        }\n      }\n    })\n\n### watch\n\n> 一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue  \n> 实例将会在实例化时调用 \\$watch()，遍历 watch 对象的每一个属性。\n\n    var vm = new Vue({\n      data: {\n        a: 1,\n        b: 2,\n        c: 3\n      },\n      watch: {\n        // 监控a变量变化的时候，自动执行此函数\n        a: function (val, oldVal) {\n          console.log('new: %s, old: %s', val, oldVal)\n        },\n        // 深度 watcher\n        c: {\n          handler: function (val, oldVal) { /* ... */ },\n          deep: true\n        }\n      }\n    })\n    vm.a = 2 // -> new: 2, old: 1\n\n## Vue 实例的生命周期\n\nVue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载 Dom→ 渲染、更新 → 渲染、卸载等一系列  \n过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。\n\n在 Vue 的整个生命周期中，它提供了一些[生命周期钩子](https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90 \"Vue API 生命周期钩子\")，给了我们执行自定义逻辑的机会。\n\n接下来我们用几个例子来看看生命周期钩子是怎么用的：\n\n完整的代码托管在  [codepen](http://codepen.io/koucxz/pen/vxdQrY)\n\nHTML 结构：\n\n{ { number }}\n\n我们对 input 和 p 绑定了 data 对象的 number 数据，Vue 实例构建如下：\n\n    var app = new Vue({\n        el: '#app',\n        data: {\n          number: 1\n        }\n    })\n\n在实例中分别在每个生命周期钩子中  `console.log('钩子名称',this.number)`  我们发现，第一次页面加载时  \n触发了 beforeCreate, created, beforeMount, mounted 这几个钩子，data 数据在 created 中可获取到。\n\n再去  `console.log('mounted: ', document.getElementsByTagName('p')[0])` ，DOM 渲染在 mounted 中已经  \n完成。\n\n我们再试着去更改 input 输入框中的内容，可以看到输入框上方的数据同步发生改变，这就是数据绑定的效果，在更  \n新数据时触发 beforeUpdate 和 updated 钩子，且在 beforeUpdate 触发时，数据已更新完毕。\n\n而 destroy 仅在调用`app.$destroy();`时触发，对 vue 实例进行销毁。销毁完成后，我们再重新改变 number 的值，vue 不再对此动作  \n进行响应了。但是原先生成的 dom 元素还存在，可以这么理解，执行了 destroy 操作，后续就不再受 vue 控制了。\n\n### Vue.nextTick\n\n> 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。[官方 API](https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90 \"Vue API 生命周期钩子\")\n\n    Vue.nextTick(function () {\n      // DOM 更新了\n    })\n\n官方还提供了一种写法，`vm.$nextTick`，用 this 自动绑定到调用它的实例上\n\n    created() {\n        setTimeout(() => {\n              this.number = 100\n              this.$nextTick(() => {\n                console.log('nextTick', document.getElementsByTagName('p')[0])\n              })\n        },100)\n    }\n\n> 什么时候需要用到[Vue.nextTick()](https://segmentfault.com/a/1190000008570874 \"segmentfault博客 Vue.nextTick()\")\n>\n> 1.  在 Vue 生命周期的 created() 钩子函数进行的 DOM 操作一定要放在 Vue.nextTick() 的回调函数中。原因是什么呢，原因是  \n>     在 created() 钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作  \n>     的 js 代码放进 Vue.nextTick() 的回调函数中。与之对应的就是 mounted 钩子函数，因为该钩子函数执行时所有的 DOM 挂载和  \n>     渲染都已完成，此时在该钩子函数中进行任何 DOM 操作都不会有问题 。\n> 2.  在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的 DOM 结构的时候，这个操作都应该放  \n>     进 Vue.nextTick() 的回调函数中。\n\n### 生命周期小结\n\n生命周期钩子的一些使用方法：\n\nbeforecreate : 可以在这加个 loading 事件，在加载实例时触发  \ncreated : 初始化完成时的事件写在这里，如在这结束 loading 事件，异步请求也适宜在这里调用  \nmounted : 挂载元素，获取到 DOM 节点  \nupdated : 如果对数据统一处理，在这里写上相应函数  \nbeforeDestroy : 可以做一个确认停止事件的确认框  \nnextTick : 更新数据后立即操作 dom\n\n## 官方示例中生命周期的运用\n\n### [一个极简的 Markdown 编辑器](https://cn.vuejs.org/v2/examples/index.html)\n\n运行这个例子需要 marked 组件，通过以下方法引入：  \n在项目目录下运行 npm i marked -S, js 文件中  `import marked from 'marked'`  即可。  \n这个例子没有用到生命周期钩子，简单解读一下这段代码，\n\n    methods: {\n        update: _.debounce(function (e) {\n          this.input = e.target.value\n        }, 300)\n      }\n\nhtml 中 textarea 绑定了  [@input](https://github.com/input) = \"update\" ，方法中用 debounce 指令设置了延时，在每次输  \n入后延时同步输入框的数据，减少了更新次数，提高性能。\n\n### [GitHub 提交](https://cn.vuejs.org/v2/examples/commits.html)\n\n这个例子从 Github 的 API 中获取了最新的 Vue.js 提交数据，并且以列表形式将它们展示了出  \n来。你可以轻松地切换 master 和 dev 分支。\n\n    created: function () {\n        this.fetchData()\n      },\n\n在 created 钩子中用声明的 fetchData 函数获取 ajax 异步数据并渲染到页面。\n\n### [内嵌组件](https://cn.vuejs.org/v2/examples/select2.html)\n\n本例中，整合了第三方 jQuery 插件（select2）,怎么做到的呢？就是把它内嵌在一个常用组件中\n\n    mounted: function () {\n        var vm = this\n        $(this.$el)\n          .val(this.value)\n          // init select2\n          .select2({ data: this.options })\n          // emit event on change.\n          .on('change', function () {\n            vm.$emit('input', this.value)\n          })\n      },\n\n这个例子建立了组件 select2 ，在 mounted 钩子中增加了 jQuery 插件 select2 的方法，数据加载时  \n给元素增加这几个方法，获取 DOM 数据。\n","source":"_posts/2017-08-24-Vue 实例中的生命周期钩子.md","raw":"---\ntitle: Vue 实例中的生命周期钩子\ntags:\n  - 技术\n  - vue\ndate: 2017-08-24 12:36:00\ncategories: 前端\n---\n\nVue 框架的入口就是 Vue 实例，其实就是框架中的 view model ，它包含页面中的业务  \n处理逻辑、数据模型等，它的生命周期中有多个事件钩子，让我们在控制整个 Vue 实例的  \n过程时更容易形成好的逻辑。\n\n## Vue 实例\n\n在文档中经常会使用 vm 这个变量名表示 Vue 实例，在实例化 Vue 时，需要传入一个选  \n项对象，它可以包含数据(data)、模板(template)、挂载元素(el)、方法(methods)、生  \n命周期钩子(lifecyclehook)等选项。\n\n### Vue 实例化的选项\n\n需要注意的是含 this 的函数大多不要使用箭头函数，因为我们期望 this 指向 Vue 实例。\n\n### data\n\nVue 实例的数据都保存在 data 对象中，Vue 将会递归将 data 的属性转换为 getter/setter，  \n从而让 data 的属性能够响应数据变化。\n\n    var data = { a: 1 }\n    // 直接创建一个实例\n    var vm = new Vue({\n      data: data\n    })\n    vm.a // -> 1\n    vm.$data === data // -> true\n\n这样数据就绑定在 HTML 中，Vue 框架监视 data 的数据变化，自动更新 HTML 内容。\n\n### computed\n\n> 计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue  \n> 实例。[官方 API](https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE \"Vue API\")\n\n    var vm = new Vue({\n      data: { a: 1 },\n      computed: {\n        // 仅读取，值只须为函数\n        aDouble: function () {\n          return this.a * 2\n        },\n        // 读取和设置\n        aPlus: {\n          get: function () {\n            return this.a + 1\n          },\n          set: function (v) {\n            this.a = v - 1\n          }\n        }\n      }\n    })\n    vm.aPlus   // -> 2\n    vm.aPlus = 3\n    vm.a       // -> 2\n    vm.aDouble // -> 4\n\n这里可以省略 setter,如果省略了 setter，那么值就可以是普通函数，但是必须有返回值。\n\n### methods\n\n> methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达  \n> 式中使用。方法中的 this 自动绑定为 Vue 实例。[官方 API](https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE \"Vue API\")\n\n    var vm = new Vue({\n      data: { a: 1 },\n      methods: {\n        plus: function () {\n          this.a++\n        }\n      }\n    })\n    vm.plus()\n    vm.a // 2\n\n看下面这个例子，methods 和 computed 看起来可以做同样的事情，单纯看结果两种方式确实是相同的。  \n然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变  \n时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会  \n立即返回之前的计算结果，而不必再次执行函数。相比而言，只要发生重新渲染，method 调用总会执行  \n该函数。\n\n    var vm = new Vue({\n      el: '#example',\n      data: {\n        message: 'Hello'\n      },\n      computed: {\n        // a computed getter\n        reversedMessage: function () {\n          // `this` points to the vm instance\n          return this.message.split('').reverse().join('')\n        }\n      }\n    })\n\n### watch\n\n> 一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue  \n> 实例将会在实例化时调用 \\$watch()，遍历 watch 对象的每一个属性。\n\n    var vm = new Vue({\n      data: {\n        a: 1,\n        b: 2,\n        c: 3\n      },\n      watch: {\n        // 监控a变量变化的时候，自动执行此函数\n        a: function (val, oldVal) {\n          console.log('new: %s, old: %s', val, oldVal)\n        },\n        // 深度 watcher\n        c: {\n          handler: function (val, oldVal) { /* ... */ },\n          deep: true\n        }\n      }\n    })\n    vm.a = 2 // -> new: 2, old: 1\n\n## Vue 实例的生命周期\n\nVue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载 Dom→ 渲染、更新 → 渲染、卸载等一系列  \n过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。\n\n在 Vue 的整个生命周期中，它提供了一些[生命周期钩子](https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90 \"Vue API 生命周期钩子\")，给了我们执行自定义逻辑的机会。\n\n接下来我们用几个例子来看看生命周期钩子是怎么用的：\n\n完整的代码托管在  [codepen](http://codepen.io/koucxz/pen/vxdQrY)\n\nHTML 结构：\n\n{ { number }}\n\n我们对 input 和 p 绑定了 data 对象的 number 数据，Vue 实例构建如下：\n\n    var app = new Vue({\n        el: '#app',\n        data: {\n          number: 1\n        }\n    })\n\n在实例中分别在每个生命周期钩子中  `console.log('钩子名称',this.number)`  我们发现，第一次页面加载时  \n触发了 beforeCreate, created, beforeMount, mounted 这几个钩子，data 数据在 created 中可获取到。\n\n再去  `console.log('mounted: ', document.getElementsByTagName('p')[0])` ，DOM 渲染在 mounted 中已经  \n完成。\n\n我们再试着去更改 input 输入框中的内容，可以看到输入框上方的数据同步发生改变，这就是数据绑定的效果，在更  \n新数据时触发 beforeUpdate 和 updated 钩子，且在 beforeUpdate 触发时，数据已更新完毕。\n\n而 destroy 仅在调用`app.$destroy();`时触发，对 vue 实例进行销毁。销毁完成后，我们再重新改变 number 的值，vue 不再对此动作  \n进行响应了。但是原先生成的 dom 元素还存在，可以这么理解，执行了 destroy 操作，后续就不再受 vue 控制了。\n\n### Vue.nextTick\n\n> 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。[官方 API](https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90 \"Vue API 生命周期钩子\")\n\n    Vue.nextTick(function () {\n      // DOM 更新了\n    })\n\n官方还提供了一种写法，`vm.$nextTick`，用 this 自动绑定到调用它的实例上\n\n    created() {\n        setTimeout(() => {\n              this.number = 100\n              this.$nextTick(() => {\n                console.log('nextTick', document.getElementsByTagName('p')[0])\n              })\n        },100)\n    }\n\n> 什么时候需要用到[Vue.nextTick()](https://segmentfault.com/a/1190000008570874 \"segmentfault博客 Vue.nextTick()\")\n>\n> 1.  在 Vue 生命周期的 created() 钩子函数进行的 DOM 操作一定要放在 Vue.nextTick() 的回调函数中。原因是什么呢，原因是  \n>     在 created() 钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作  \n>     的 js 代码放进 Vue.nextTick() 的回调函数中。与之对应的就是 mounted 钩子函数，因为该钩子函数执行时所有的 DOM 挂载和  \n>     渲染都已完成，此时在该钩子函数中进行任何 DOM 操作都不会有问题 。\n> 2.  在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的 DOM 结构的时候，这个操作都应该放  \n>     进 Vue.nextTick() 的回调函数中。\n\n### 生命周期小结\n\n生命周期钩子的一些使用方法：\n\nbeforecreate : 可以在这加个 loading 事件，在加载实例时触发  \ncreated : 初始化完成时的事件写在这里，如在这结束 loading 事件，异步请求也适宜在这里调用  \nmounted : 挂载元素，获取到 DOM 节点  \nupdated : 如果对数据统一处理，在这里写上相应函数  \nbeforeDestroy : 可以做一个确认停止事件的确认框  \nnextTick : 更新数据后立即操作 dom\n\n## 官方示例中生命周期的运用\n\n### [一个极简的 Markdown 编辑器](https://cn.vuejs.org/v2/examples/index.html)\n\n运行这个例子需要 marked 组件，通过以下方法引入：  \n在项目目录下运行 npm i marked -S, js 文件中  `import marked from 'marked'`  即可。  \n这个例子没有用到生命周期钩子，简单解读一下这段代码，\n\n    methods: {\n        update: _.debounce(function (e) {\n          this.input = e.target.value\n        }, 300)\n      }\n\nhtml 中 textarea 绑定了  [@input](https://github.com/input) = \"update\" ，方法中用 debounce 指令设置了延时，在每次输  \n入后延时同步输入框的数据，减少了更新次数，提高性能。\n\n### [GitHub 提交](https://cn.vuejs.org/v2/examples/commits.html)\n\n这个例子从 Github 的 API 中获取了最新的 Vue.js 提交数据，并且以列表形式将它们展示了出  \n来。你可以轻松地切换 master 和 dev 分支。\n\n    created: function () {\n        this.fetchData()\n      },\n\n在 created 钩子中用声明的 fetchData 函数获取 ajax 异步数据并渲染到页面。\n\n### [内嵌组件](https://cn.vuejs.org/v2/examples/select2.html)\n\n本例中，整合了第三方 jQuery 插件（select2）,怎么做到的呢？就是把它内嵌在一个常用组件中\n\n    mounted: function () {\n        var vm = this\n        $(this.$el)\n          .val(this.value)\n          // init select2\n          .select2({ data: this.options })\n          // emit event on change.\n          .on('change', function () {\n            vm.$emit('input', this.value)\n          })\n      },\n\n这个例子建立了组件 select2 ，在 mounted 钩子中增加了 jQuery 插件 select2 的方法，数据加载时  \n给元素增加这几个方法，获取 DOM 数据。\n","slug":"2017-08-24-Vue 实例中的生命周期钩子","published":1,"updated":"2020-03-14T06:46:09.983Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvml00474k8year6b00q","content":"<p>Vue 框架的入口就是 Vue 实例，其实就是框架中的 view model ，它包含页面中的业务<br>处理逻辑、数据模型等，它的生命周期中有多个事件钩子，让我们在控制整个 Vue 实例的<br>过程时更容易形成好的逻辑。</p>\n<h2 id=\"Vue-实例\"><a href=\"#Vue-实例\" class=\"headerlink\" title=\"Vue 实例\"></a>Vue 实例</h2><p>在文档中经常会使用 vm 这个变量名表示 Vue 实例，在实例化 Vue 时，需要传入一个选<br>项对象，它可以包含数据(data)、模板(template)、挂载元素(el)、方法(methods)、生<br>命周期钩子(lifecyclehook)等选项。</p>\n<h3 id=\"Vue-实例化的选项\"><a href=\"#Vue-实例化的选项\" class=\"headerlink\" title=\"Vue 实例化的选项\"></a>Vue 实例化的选项</h3><p>需要注意的是含 this 的函数大多不要使用箭头函数，因为我们期望 this 指向 Vue 实例。</p>\n<h3 id=\"data\"><a href=\"#data\" class=\"headerlink\" title=\"data\"></a>data</h3><p>Vue 实例的数据都保存在 data 对象中，Vue 将会递归将 data 的属性转换为 getter/setter，<br>从而让 data 的属性能够响应数据变化。</p>\n<pre><code>var data = { a: 1 }\n// 直接创建一个实例\nvar vm = new Vue({\n  data: data\n})\nvm.a // -&gt; 1\nvm.$data === data // -&gt; true</code></pre><p>这样数据就绑定在 HTML 中，Vue 框架监视 data 的数据变化，自动更新 HTML 内容。</p>\n<h3 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h3><blockquote>\n<p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue<br>实例。<a href=\"https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE\" target=\"_blank\" rel=\"noopener\" title=\"Vue API\">官方 API</a></p>\n</blockquote>\n<pre><code>var vm = new Vue({\n  data: { a: 1 },\n  computed: {\n    // 仅读取，值只须为函数\n    aDouble: function () {\n      return this.a * 2\n    },\n    // 读取和设置\n    aPlus: {\n      get: function () {\n        return this.a + 1\n      },\n      set: function (v) {\n        this.a = v - 1\n      }\n    }\n  }\n})\nvm.aPlus   // -&gt; 2\nvm.aPlus = 3\nvm.a       // -&gt; 2\nvm.aDouble // -&gt; 4</code></pre><p>这里可以省略 setter,如果省略了 setter，那么值就可以是普通函数，但是必须有返回值。</p>\n<h3 id=\"methods\"><a href=\"#methods\" class=\"headerlink\" title=\"methods\"></a>methods</h3><blockquote>\n<p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达<br>式中使用。方法中的 this 自动绑定为 Vue 实例。<a href=\"https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE\" target=\"_blank\" rel=\"noopener\" title=\"Vue API\">官方 API</a></p>\n</blockquote>\n<pre><code>var vm = new Vue({\n  data: { a: 1 },\n  methods: {\n    plus: function () {\n      this.a++\n    }\n  }\n})\nvm.plus()\nvm.a // 2</code></pre><p>看下面这个例子，methods 和 computed 看起来可以做同样的事情，单纯看结果两种方式确实是相同的。<br>然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变<br>时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会<br>立即返回之前的计算结果，而不必再次执行函数。相比而言，只要发生重新渲染，method 调用总会执行<br>该函数。</p>\n<pre><code>var vm = new Vue({\n  el: &#39;#example&#39;,\n  data: {\n    message: &#39;Hello&#39;\n  },\n  computed: {\n    // a computed getter\n    reversedMessage: function () {\n      // `this` points to the vm instance\n      return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)\n    }\n  }\n})</code></pre><h3 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h3><blockquote>\n<p>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue<br>实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。</p>\n</blockquote>\n<pre><code>var vm = new Vue({\n  data: {\n    a: 1,\n    b: 2,\n    c: 3\n  },\n  watch: {\n    // 监控a变量变化的时候，自动执行此函数\n    a: function (val, oldVal) {\n      console.log(&#39;new: %s, old: %s&#39;, val, oldVal)\n    },\n    // 深度 watcher\n    c: {\n      handler: function (val, oldVal) { /* ... */ },\n      deep: true\n    }\n  }\n})\nvm.a = 2 // -&gt; new: 2, old: 1</code></pre><h2 id=\"Vue-实例的生命周期\"><a href=\"#Vue-实例的生命周期\" class=\"headerlink\" title=\"Vue 实例的生命周期\"></a>Vue 实例的生命周期</h2><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载 Dom→ 渲染、更新 → 渲染、卸载等一系列<br>过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。</p>\n<p>在 Vue 的整个生命周期中，它提供了一些<a href=\"https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90\" target=\"_blank\" rel=\"noopener\" title=\"Vue API 生命周期钩子\">生命周期钩子</a>，给了我们执行自定义逻辑的机会。</p>\n<p>接下来我们用几个例子来看看生命周期钩子是怎么用的：</p>\n<p>完整的代码托管在  <a href=\"http://codepen.io/koucxz/pen/vxdQrY\" target=\"_blank\" rel=\"noopener\">codepen</a></p>\n<p>HTML 结构：</p>\n<p>{ { number }}</p>\n<p>我们对 input 和 p 绑定了 data 对象的 number 数据，Vue 实例构建如下：</p>\n<pre><code>var app = new Vue({\n    el: &#39;#app&#39;,\n    data: {\n      number: 1\n    }\n})</code></pre><p>在实例中分别在每个生命周期钩子中  <code>console.log(&#39;钩子名称&#39;,this.number)</code>  我们发现，第一次页面加载时<br>触发了 beforeCreate, created, beforeMount, mounted 这几个钩子，data 数据在 created 中可获取到。</p>\n<p>再去  <code>console.log(&#39;mounted: &#39;, document.getElementsByTagName(&#39;p&#39;)[0])</code> ，DOM 渲染在 mounted 中已经<br>完成。</p>\n<p>我们再试着去更改 input 输入框中的内容，可以看到输入框上方的数据同步发生改变，这就是数据绑定的效果，在更<br>新数据时触发 beforeUpdate 和 updated 钩子，且在 beforeUpdate 触发时，数据已更新完毕。</p>\n<p>而 destroy 仅在调用<code>app.$destroy();</code>时触发，对 vue 实例进行销毁。销毁完成后，我们再重新改变 number 的值，vue 不再对此动作<br>进行响应了。但是原先生成的 dom 元素还存在，可以这么理解，执行了 destroy 操作，后续就不再受 vue 控制了。</p>\n<h3 id=\"Vue-nextTick\"><a href=\"#Vue-nextTick\" class=\"headerlink\" title=\"Vue.nextTick\"></a>Vue.nextTick</h3><blockquote>\n<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。<a href=\"https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90\" target=\"_blank\" rel=\"noopener\" title=\"Vue API 生命周期钩子\">官方 API</a></p>\n</blockquote>\n<pre><code>Vue.nextTick(function () {\n  // DOM 更新了\n})</code></pre><p>官方还提供了一种写法，<code>vm.$nextTick</code>，用 this 自动绑定到调用它的实例上</p>\n<pre><code>created() {\n    setTimeout(() =&gt; {\n          this.number = 100\n          this.$nextTick(() =&gt; {\n            console.log(&#39;nextTick&#39;, document.getElementsByTagName(&#39;p&#39;)[0])\n          })\n    },100)\n}</code></pre><blockquote>\n<p>什么时候需要用到<a href=\"https://segmentfault.com/a/1190000008570874\" target=\"_blank\" rel=\"noopener\" title=\"segmentfault博客 Vue.nextTick()\">Vue.nextTick()</a></p>\n<ol>\n<li>在 Vue 生命周期的 created() 钩子函数进行的 DOM 操作一定要放在 Vue.nextTick() 的回调函数中。原因是什么呢，原因是<br>在 created() 钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作<br>的 js 代码放进 Vue.nextTick() 的回调函数中。与之对应的就是 mounted 钩子函数，因为该钩子函数执行时所有的 DOM 挂载和<br>渲染都已完成，此时在该钩子函数中进行任何 DOM 操作都不会有问题 。</li>\n<li>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的 DOM 结构的时候，这个操作都应该放<br>进 Vue.nextTick() 的回调函数中。</li>\n</ol>\n</blockquote>\n<h3 id=\"生命周期小结\"><a href=\"#生命周期小结\" class=\"headerlink\" title=\"生命周期小结\"></a>生命周期小结</h3><p>生命周期钩子的一些使用方法：</p>\n<p>beforecreate : 可以在这加个 loading 事件，在加载实例时触发<br>created : 初始化完成时的事件写在这里，如在这结束 loading 事件，异步请求也适宜在这里调用<br>mounted : 挂载元素，获取到 DOM 节点<br>updated : 如果对数据统一处理，在这里写上相应函数<br>beforeDestroy : 可以做一个确认停止事件的确认框<br>nextTick : 更新数据后立即操作 dom</p>\n<h2 id=\"官方示例中生命周期的运用\"><a href=\"#官方示例中生命周期的运用\" class=\"headerlink\" title=\"官方示例中生命周期的运用\"></a>官方示例中生命周期的运用</h2><h3 id=\"一个极简的-Markdown-编辑器\"><a href=\"#一个极简的-Markdown-编辑器\" class=\"headerlink\" title=\"一个极简的 Markdown 编辑器\"></a><a href=\"https://cn.vuejs.org/v2/examples/index.html\" target=\"_blank\" rel=\"noopener\">一个极简的 Markdown 编辑器</a></h3><p>运行这个例子需要 marked 组件，通过以下方法引入：<br>在项目目录下运行 npm i marked -S, js 文件中  <code>import marked from &#39;marked&#39;</code>  即可。<br>这个例子没有用到生命周期钩子，简单解读一下这段代码，</p>\n<pre><code>methods: {\n    update: _.debounce(function (e) {\n      this.input = e.target.value\n    }, 300)\n  }</code></pre><p>html 中 textarea 绑定了  <a href=\"https://github.com/input\" target=\"_blank\" rel=\"noopener\">@input</a> = “update” ，方法中用 debounce 指令设置了延时，在每次输<br>入后延时同步输入框的数据，减少了更新次数，提高性能。</p>\n<h3 id=\"GitHub-提交\"><a href=\"#GitHub-提交\" class=\"headerlink\" title=\"GitHub 提交\"></a><a href=\"https://cn.vuejs.org/v2/examples/commits.html\" target=\"_blank\" rel=\"noopener\">GitHub 提交</a></h3><p>这个例子从 Github 的 API 中获取了最新的 Vue.js 提交数据，并且以列表形式将它们展示了出<br>来。你可以轻松地切换 master 和 dev 分支。</p>\n<pre><code>created: function () {\n    this.fetchData()\n  },</code></pre><p>在 created 钩子中用声明的 fetchData 函数获取 ajax 异步数据并渲染到页面。</p>\n<h3 id=\"内嵌组件\"><a href=\"#内嵌组件\" class=\"headerlink\" title=\"内嵌组件\"></a><a href=\"https://cn.vuejs.org/v2/examples/select2.html\" target=\"_blank\" rel=\"noopener\">内嵌组件</a></h3><p>本例中，整合了第三方 jQuery 插件（select2）,怎么做到的呢？就是把它内嵌在一个常用组件中</p>\n<pre><code>mounted: function () {\n    var vm = this\n    $(this.$el)\n      .val(this.value)\n      // init select2\n      .select2({ data: this.options })\n      // emit event on change.\n      .on(&#39;change&#39;, function () {\n        vm.$emit(&#39;input&#39;, this.value)\n      })\n  },</code></pre><p>这个例子建立了组件 select2 ，在 mounted 钩子中增加了 jQuery 插件 select2 的方法，数据加载时<br>给元素增加这几个方法，获取 DOM 数据。</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>Vue 框架的入口就是 Vue 实例，其实就是框架中的 view model ，它包含页面中的业务<br>处理逻辑、数据模型等，它的生命周期中有多个事件钩子，让我们在控制整个 Vue 实例的<br>过程时更容易形成好的逻辑。</p>\n<h2 id=\"Vue-实例\"><a href=\"#Vue-实例\" class=\"headerlink\" title=\"Vue 实例\"></a>Vue 实例</h2><p>在文档中经常会使用 vm 这个变量名表示 Vue 实例，在实例化 Vue 时，需要传入一个选<br>项对象，它可以包含数据(data)、模板(template)、挂载元素(el)、方法(methods)、生<br>命周期钩子(lifecyclehook)等选项。</p>\n<h3 id=\"Vue-实例化的选项\"><a href=\"#Vue-实例化的选项\" class=\"headerlink\" title=\"Vue 实例化的选项\"></a>Vue 实例化的选项</h3><p>需要注意的是含 this 的函数大多不要使用箭头函数，因为我们期望 this 指向 Vue 实例。</p>\n<h3 id=\"data\"><a href=\"#data\" class=\"headerlink\" title=\"data\"></a>data</h3><p>Vue 实例的数据都保存在 data 对象中，Vue 将会递归将 data 的属性转换为 getter/setter，<br>从而让 data 的属性能够响应数据变化。</p>\n<pre><code>var data = { a: 1 }\n// 直接创建一个实例\nvar vm = new Vue({\n  data: data\n})\nvm.a // -&gt; 1\nvm.$data === data // -&gt; true</code></pre><p>这样数据就绑定在 HTML 中，Vue 框架监视 data 的数据变化，自动更新 HTML 内容。</p>\n<h3 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h3><blockquote>\n<p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue<br>实例。<a href=\"https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE\" target=\"_blank\" rel=\"noopener\" title=\"Vue API\">官方 API</a></p>\n</blockquote>\n<pre><code>var vm = new Vue({\n  data: { a: 1 },\n  computed: {\n    // 仅读取，值只须为函数\n    aDouble: function () {\n      return this.a * 2\n    },\n    // 读取和设置\n    aPlus: {\n      get: function () {\n        return this.a + 1\n      },\n      set: function (v) {\n        this.a = v - 1\n      }\n    }\n  }\n})\nvm.aPlus   // -&gt; 2\nvm.aPlus = 3\nvm.a       // -&gt; 2\nvm.aDouble // -&gt; 4</code></pre><p>这里可以省略 setter,如果省略了 setter，那么值就可以是普通函数，但是必须有返回值。</p>\n<h3 id=\"methods\"><a href=\"#methods\" class=\"headerlink\" title=\"methods\"></a>methods</h3><blockquote>\n<p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达<br>式中使用。方法中的 this 自动绑定为 Vue 实例。<a href=\"https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE\" target=\"_blank\" rel=\"noopener\" title=\"Vue API\">官方 API</a></p>\n</blockquote>\n<pre><code>var vm = new Vue({\n  data: { a: 1 },\n  methods: {\n    plus: function () {\n      this.a++\n    }\n  }\n})\nvm.plus()\nvm.a // 2</code></pre><p>看下面这个例子，methods 和 computed 看起来可以做同样的事情，单纯看结果两种方式确实是相同的。<br>然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变<br>时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会<br>立即返回之前的计算结果，而不必再次执行函数。相比而言，只要发生重新渲染，method 调用总会执行<br>该函数。</p>\n<pre><code>var vm = new Vue({\n  el: &#39;#example&#39;,\n  data: {\n    message: &#39;Hello&#39;\n  },\n  computed: {\n    // a computed getter\n    reversedMessage: function () {\n      // `this` points to the vm instance\n      return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)\n    }\n  }\n})</code></pre><h3 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h3><blockquote>\n<p>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue<br>实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。</p>\n</blockquote>\n<pre><code>var vm = new Vue({\n  data: {\n    a: 1,\n    b: 2,\n    c: 3\n  },\n  watch: {\n    // 监控a变量变化的时候，自动执行此函数\n    a: function (val, oldVal) {\n      console.log(&#39;new: %s, old: %s&#39;, val, oldVal)\n    },\n    // 深度 watcher\n    c: {\n      handler: function (val, oldVal) { /* ... */ },\n      deep: true\n    }\n  }\n})\nvm.a = 2 // -&gt; new: 2, old: 1</code></pre><h2 id=\"Vue-实例的生命周期\"><a href=\"#Vue-实例的生命周期\" class=\"headerlink\" title=\"Vue 实例的生命周期\"></a>Vue 实例的生命周期</h2><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载 Dom→ 渲染、更新 → 渲染、卸载等一系列<br>过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。</p>\n<p>在 Vue 的整个生命周期中，它提供了一些<a href=\"https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90\" target=\"_blank\" rel=\"noopener\" title=\"Vue API 生命周期钩子\">生命周期钩子</a>，给了我们执行自定义逻辑的机会。</p>\n<p>接下来我们用几个例子来看看生命周期钩子是怎么用的：</p>\n<p>完整的代码托管在  <a href=\"http://codepen.io/koucxz/pen/vxdQrY\" target=\"_blank\" rel=\"noopener\">codepen</a></p>\n<p>HTML 结构：</p>\n<p>{ { number }}</p>\n<p>我们对 input 和 p 绑定了 data 对象的 number 数据，Vue 实例构建如下：</p>\n<pre><code>var app = new Vue({\n    el: &#39;#app&#39;,\n    data: {\n      number: 1\n    }\n})</code></pre><p>在实例中分别在每个生命周期钩子中  <code>console.log(&#39;钩子名称&#39;,this.number)</code>  我们发现，第一次页面加载时<br>触发了 beforeCreate, created, beforeMount, mounted 这几个钩子，data 数据在 created 中可获取到。</p>\n<p>再去  <code>console.log(&#39;mounted: &#39;, document.getElementsByTagName(&#39;p&#39;)[0])</code> ，DOM 渲染在 mounted 中已经<br>完成。</p>\n<p>我们再试着去更改 input 输入框中的内容，可以看到输入框上方的数据同步发生改变，这就是数据绑定的效果，在更<br>新数据时触发 beforeUpdate 和 updated 钩子，且在 beforeUpdate 触发时，数据已更新完毕。</p>\n<p>而 destroy 仅在调用<code>app.$destroy();</code>时触发，对 vue 实例进行销毁。销毁完成后，我们再重新改变 number 的值，vue 不再对此动作<br>进行响应了。但是原先生成的 dom 元素还存在，可以这么理解，执行了 destroy 操作，后续就不再受 vue 控制了。</p>\n<h3 id=\"Vue-nextTick\"><a href=\"#Vue-nextTick\" class=\"headerlink\" title=\"Vue.nextTick\"></a>Vue.nextTick</h3><blockquote>\n<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。<a href=\"https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90\" target=\"_blank\" rel=\"noopener\" title=\"Vue API 生命周期钩子\">官方 API</a></p>\n</blockquote>\n<pre><code>Vue.nextTick(function () {\n  // DOM 更新了\n})</code></pre><p>官方还提供了一种写法，<code>vm.$nextTick</code>，用 this 自动绑定到调用它的实例上</p>\n<pre><code>created() {\n    setTimeout(() =&gt; {\n          this.number = 100\n          this.$nextTick(() =&gt; {\n            console.log(&#39;nextTick&#39;, document.getElementsByTagName(&#39;p&#39;)[0])\n          })\n    },100)\n}</code></pre><blockquote>\n<p>什么时候需要用到<a href=\"https://segmentfault.com/a/1190000008570874\" target=\"_blank\" rel=\"noopener\" title=\"segmentfault博客 Vue.nextTick()\">Vue.nextTick()</a></p>\n<ol>\n<li>在 Vue 生命周期的 created() 钩子函数进行的 DOM 操作一定要放在 Vue.nextTick() 的回调函数中。原因是什么呢，原因是<br>在 created() 钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作<br>的 js 代码放进 Vue.nextTick() 的回调函数中。与之对应的就是 mounted 钩子函数，因为该钩子函数执行时所有的 DOM 挂载和<br>渲染都已完成，此时在该钩子函数中进行任何 DOM 操作都不会有问题 。</li>\n<li>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的 DOM 结构的时候，这个操作都应该放<br>进 Vue.nextTick() 的回调函数中。</li>\n</ol>\n</blockquote>\n<h3 id=\"生命周期小结\"><a href=\"#生命周期小结\" class=\"headerlink\" title=\"生命周期小结\"></a>生命周期小结</h3><p>生命周期钩子的一些使用方法：</p>\n<p>beforecreate : 可以在这加个 loading 事件，在加载实例时触发<br>created : 初始化完成时的事件写在这里，如在这结束 loading 事件，异步请求也适宜在这里调用<br>mounted : 挂载元素，获取到 DOM 节点<br>updated : 如果对数据统一处理，在这里写上相应函数<br>beforeDestroy : 可以做一个确认停止事件的确认框<br>nextTick : 更新数据后立即操作 dom</p>\n<h2 id=\"官方示例中生命周期的运用\"><a href=\"#官方示例中生命周期的运用\" class=\"headerlink\" title=\"官方示例中生命周期的运用\"></a>官方示例中生命周期的运用</h2><h3 id=\"一个极简的-Markdown-编辑器\"><a href=\"#一个极简的-Markdown-编辑器\" class=\"headerlink\" title=\"一个极简的 Markdown 编辑器\"></a><a href=\"https://cn.vuejs.org/v2/examples/index.html\" target=\"_blank\" rel=\"noopener\">一个极简的 Markdown 编辑器</a></h3><p>运行这个例子需要 marked 组件，通过以下方法引入：<br>在项目目录下运行 npm i marked -S, js 文件中  <code>import marked from &#39;marked&#39;</code>  即可。<br>这个例子没有用到生命周期钩子，简单解读一下这段代码，</p>\n<pre><code>methods: {\n    update: _.debounce(function (e) {\n      this.input = e.target.value\n    }, 300)\n  }</code></pre><p>html 中 textarea 绑定了  <a href=\"https://github.com/input\" target=\"_blank\" rel=\"noopener\">@input</a> = “update” ，方法中用 debounce 指令设置了延时，在每次输<br>入后延时同步输入框的数据，减少了更新次数，提高性能。</p>\n<h3 id=\"GitHub-提交\"><a href=\"#GitHub-提交\" class=\"headerlink\" title=\"GitHub 提交\"></a><a href=\"https://cn.vuejs.org/v2/examples/commits.html\" target=\"_blank\" rel=\"noopener\">GitHub 提交</a></h3><p>这个例子从 Github 的 API 中获取了最新的 Vue.js 提交数据，并且以列表形式将它们展示了出<br>来。你可以轻松地切换 master 和 dev 分支。</p>\n<pre><code>created: function () {\n    this.fetchData()\n  },</code></pre><p>在 created 钩子中用声明的 fetchData 函数获取 ajax 异步数据并渲染到页面。</p>\n<h3 id=\"内嵌组件\"><a href=\"#内嵌组件\" class=\"headerlink\" title=\"内嵌组件\"></a><a href=\"https://cn.vuejs.org/v2/examples/select2.html\" target=\"_blank\" rel=\"noopener\">内嵌组件</a></h3><p>本例中，整合了第三方 jQuery 插件（select2）,怎么做到的呢？就是把它内嵌在一个常用组件中</p>\n<pre><code>mounted: function () {\n    var vm = this\n    $(this.$el)\n      .val(this.value)\n      // init select2\n      .select2({ data: this.options })\n      // emit event on change.\n      .on(&#39;change&#39;, function () {\n        vm.$emit(&#39;input&#39;, this.value)\n      })\n  },</code></pre><p>这个例子建立了组件 select2 ，在 mounted 钩子中增加了 jQuery 插件 select2 的方法，数据加载时<br>给元素增加这几个方法，获取 DOM 数据。</p>\n"},{"title":"Vuex新手入门指南-基本介绍","date":"2017-08-22T22:05:00.000Z","_content":"\n很多人在学习完 Vue.js 之后还会看到一个经常被提及的词语叫做 Vuex。\n\nVuex 字面上看与 Vue.js 只差了一个字母，但是他们两个做的事情完全不一样。\n\n在本文我会像之前的  Vue.js 新手入门指南文章一样的问答形式来写文章。\n\n![](http://img.mp.itc.cn/upload/20170313/1f60b593695b4e1f8f5f4bf16a63183d_th.jpeg)\n\n1.Vuex 是什么？\n\n我们还是像以往一样先看一看官方文档对此的解读（Vuex 是什么？ · GitBook）\n\n> Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具  devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。\n\n是不是又遇到了很多看起来很高大上听起来却一脸懵逼的专业术语？别急别急，我们慢慢来剖析一下这个 Vuex 究竟是个啥东西，他能做些啥。\n\n2.Vuex 到底用来做什么？\n\n用通俗一点的话来说，Vuex 就是一个用于管理 SPA 项目（不知道 SPA 是什么？请参考本专栏代码之美 - 知乎专栏中的历史文章）中状态的开源产品。\n\n接下来又引出了一个问题，什么是状态，为什么要用 Vuex 这个东西去管理它？\n\n3.什么是状态？为什么要去管理它？\n\n状态这个东西其实我们生活中随处可见。我们头顶上的灯就有两种状态，一种是开，一种是关。状态说白了就是灯这个对象的的某个属性的值。\n\n如果你对状态和属性这两个概念还是有所不了解，那么我打一个其他的比方吧。\n\n我们平时是否有玩过王者荣耀或者英雄联盟 LOL 之类的网游？这些游戏里面每一个英雄当前都有生命值，法力值，攻击力，法术强度，护甲和魔抗等等，这些是这个英雄的属性，也就是英雄这个对象当前的状态。\n\n属性分为固定属性和可变属性，一般像 LOL 里面大部分 ADC 英雄如果没有特殊的被动或者其他装备的支持，那么它的的攻击距离都是固定的，这个就是固定属性，这种固定属性的状态由于正常情况下都是不变的，所以我们可以直接写死在代码中（这种写死在代码中的变量的值称为硬编码），但是像其他的攻击力法术强度等等都是随装备和等级变化，那么这种属性是可变属性。\n\n这些属性的状态由于会根据用户的各种操作（比如说出装备，打怪升级升级）变化。在传统的 Vue.js 的组件化开发中，一般这些状态都是分散在各个组件中，此时此刻如果两个英雄互相打起来了，那么就得分别去不同的组件中取状态值，然后进行状态值的修改，最后还要互相读取对方的状态值。如果他们本身是父子组件，那么还可以通过事件触发或者 Prop 属性来传递状态，但是如果是不同的组件，由于由于 Vue.js 本身组件之间有作用域，它们无法直接相互通信，所以就需要一些东西例如 Vuex 去集中管理和追踪它的变化。（如果你现在还是不明白这一大段话，可以好好回顾一下官方文档中组件 - vue.js 非父子组件通信 这个部分的内容）\n\n在游戏中，这些状态一般以变量的形式保存在内存中，但是由于用户玩游戏的时候并不是直接去使用内存管理工具查看他们在内存里面的值，而是通过游戏界面去看这些值，所以还需要像 Vue.js 这种 MVVM 框架将状态同步到视图中。这就是 Vue.js 和 Vuex 之间的关系了。\n\n4.什么情况下我应该使用 Vuex？\n\n官方文档（Vuex 是什么？ · GitBook）中说：\n\n> 虽然 Vuex 可以帮助我们管理共享状态，但也附带了更多的概念和框架。这需要对短期和长期效益进行权衡。\n>\n> 如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的  global event bus  就足够您所需了。但是，如果您需要构建是一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：\n>\n> Flux 架构就像眼镜：您自会知道什么时候需要它。\n\n他的意思其实就是如果开发的程序并不是很庞大，一个页面中的组件不是很多并且他们之间并不需要大量频繁的互相读写操作，那么就可以直接使用传统的 Vue.js 中的组件 Prop 或者事件触发来修改状态，或者用组件 - vue.js#非父子组件通信 中介绍的 new 一个空的 Vue 对象实例，并且通过事件触发等方式来跨组件通信。\n\n否则的话还是建议使用 Vuex。虽然 Vuex 本身需要有一段时间的学习成本，但是这个学习成本相对于你开发时期使用传统非父子组件通信机制遇到的各种坑来说还是比较划算的。这个就看你自己的权衡了。\n\n5.Vuex 怎么安装和使用？\n\n在前面讲解 Vue.js 入门的时候，我们用的是 Vue-Cli 这个脚手架工具来搭建的，由于这个脚手架工具本身会帮我们配置好 npm 的 package.json 文件，这个文件里面包含了这个 Vue.js 项目中所有依赖的包。\n\n但是默认情况下这个脚手架工具没有为我们将 Vuex 这个依赖包给包含进去，所以我们得自己去“声明”一下我们这个 Vue.js 项目中需要依赖 Vuex 这个包。\n\n我们该怎么“声明”呢？现在有两种办法：\n\n一种是直接修改 package.json，这种方法看起来有点复杂，很多新手怕一不小心修改出错，可能会导致整个 package.json 文件结构出错，影响以后项目的依赖安装。\n\n还有一种方法比较安全，只需要一行命令：\n\nnpm install vuex --save\n\n表示安装 vuex 这个包，--save 表示将这个依赖包与本项目的依赖关系写入 package.json 中。\n\n然后我们仅仅安装了这个依赖包是没有用的，我们还得在之前 Vue-Cli 为我们自动构建好的项目文件中的 main.js 主入口文件的开头里面加上两行这样的代码：\n\nimport Vuex from 'vuex'Vue.use(Vuex)\n\n第一行是用 ECMA6 的 import 将 vuex 包导入进来（这个是不是和 java 中导入 jar 包以及 php 中导入命名空间很相似？）\n\n第二行是 Vue.js 本身的插件注入语法（参考官方文档插件 - vue.js），将插件注入 Vue.js 的目的是方便我们在插件内部调用它。\n\n6.官方文档的五大核心概念是什么？\n\n![](http://img.mp.itc.cn/upload/20170313/f2e5f9a1d9d543a4b82a2f7d99156d2c_th.png)\n\n打开官方文档（Introduction · GitBook）能看到五大核心概念，他们都是啥？看了半天官方文档我还是对它们没什么了解，楼主能不能以通俗易懂的方式讲解一下它们的作用？当然可以啦！\n\n首先先看一遍这个代码，不需要你看懂它。\n\nconst store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }})7.State（状态）\n\n官方文档：State · GitBook\n\n这个状态就是前面所介绍的“状态”值的存放处。\n\n看第 6 节末尾的代码中，状态就是在 state 属性中以键值对的形式声明这个 SPA 中所有的状态。上面的代码中声明了一个 count 状态。\n\n之所以要在这里声明所有状态的原因，一是让代码更加优雅，如果你接手你同事的项目的时候，能够一眼从 Vuex 的状态声明中看出这个应用中有哪些状态，肯定开发效率杠杠滴。二是如果在这里声明了状态，那么 Vuex 就能够追踪到这个状态的变化。那么 Vue.js 中就可以在视图中对这个状态做出响应。\n\n读取状态当然也是直接读取这个属性里面的各种子属性了。\n\n8.Getter（获取器）\n\n官方文档：Getters · GitBook\n\n这个获取器和一些后端开发中模型层 ORM 中的获取器其实是差不多的功能。\n\n比如说后端返回给我们的是一个 int 类型的时间戳，我们想把这个时间戳转换成正常人类可读的文本型时间表现形式（比如说 2017 年 3 月 11 日 12:43:31），那么我们就得在所有获取该状态的代码中增加一个转换函数。\n\n可是现在有了状态获取器之后，我们可以统一将这个时间戳转字符串的函数写在获取器里面，要调用的时候就直接调用获取器就好了。\n\n还有一些其他场景也可以使用获取器，比如说像错误码这种东西一般都是一个数字码对应一个文字形式的错误原因，我们也可以通过获取器来实现通过错误码拉取错误原因的功能。\n\n使用获取器的方法则是直接调用 Vuex 实例的 getter 下的各种函数即可。\n\n9.Mutations（转变）\n\n官方文档：Mutations · GitBook\n\n这个 Mutations 其实国内目前也没有比较好的翻译，通常我们都是直接称 Mutations。\n\n我们前面只讲了可以通过调用 Vuex 的实例的 state 属性或者 getter 获取器来读取状态。但是没讲到如何修改状态。\n\n官方文档中已经讲了需要先在 Vuex 实例的 Mutations 下编写对应的修改函数来修改状态。并且要修改的时候，要通过 Vuex 实例的 commit 方法来提交修改。也就是说任何对 state 状态的修改操作都必须写在 Mutations 中，并且还得用 Vuex 实例的 commit 来提交修改操作，并且由于 Mutations 函数可以传入参数，所以 commit 同理也可以传入参数。\n\n这个时候可能有一些同学就会提问了，前面既然讲到了读取可以直接访问 Vuex 实例的 state 属性，为什么修改却不能直接去操作 Vuex 实例的 state 呢？官方文档和其他高手的回答是：\n\n> 再次强调，我们通过提交 mutation 的方式，而非直接改变 store.state.count，是因为我们想要更明确地追踪到状态的变化。这个简单的约定能够让你的意图更加明显，这样你在阅读代码的时候能更容易地解读应用内部的状态改变。此外，这样也让我们有机会去实现一些能记录每次状态改变，保存状态快照的调试工具。有了它，我们甚至可以实现如时间穿梭般的调试体验。\n\n相当于我们通过一个 Mutations 函数可以显式的在代码中告诉开发者，我们这个 SPA 中究竟会对状态进行哪些操作，操作方式是什么。并且在后期我们使用一些辅助开发工具，可以保存状态的快照，就像 git 或者 svn 一样可以回滚状态。如果你还是有点不明白，总之你就按照官方文档说的去做吧，等开发一段时间之后会慢慢明白作者的良苦用心的，哈哈。\n\n还有一个问题就是为什么状态修改的提交必须通过 Vuex 实例的 commit 方法提交呢？为什么不能直接调用 Mutations 函数呢？除了上面官方文档中提到的原因，网上还有高手解释了：因为 Vue.js 的状态修改其实是在内部有一个修改队列，通过 commit 的方式提交修改可以保证状态的修改是有序的。\n\n10.Actions（动作）\n\n官方文档：Actions · GitBook\n\n前面提到了 Mutations 中可以对状态进行操作，但是忘记告诉各位同学，Mutations 中对状态的操作只能是同步操作，不能是异步操作。\n\n如果这个时候我们有一个对状态的修改操作是异步的怎么办呢？\n\n首先看看什么是异步操作？比如说 ajax 就可以选择是否发起异步请求，发起异步请求之后，我们就需要在回调函数里面进行请求结果的处理。关于 Java 异步的知识大家可以先使用各种搜索引擎自学一下。\n\n现在回到 actions 上来，看看官方文档（Actions · GitBook）：\n\n> Action 类似于 mutation，不同在于：\n>\n> - Action 提交的是 mutation，而不是直接变更状态。\n>\n> - Action 可以包含任意异步操作。\n\n其实异步的状态修改本质上还是通过几个同步操作组合的，所以我们还是得先声明好 mutation 同步操作方法，然后在 actions 中进行异步操作。如果我们暂时手头上没有 ajax 接口用于异步请求，那么我们可以像官方文档一样用 setTimeout 这种最简单的测试方法来理解。\n\nactions: { incrementAsync ({ commit }) { setTimeout(() => { commit('increment') }, 1000) }}\n\n前面讲到了 mutation 是用 commit 来提交操作的，那么 actions 是怎么提交的呢？官方文档中说了 actions 是使用 Vuex 实例的 dispatch 方法来提交（其实说分发会更加准确）的。\n\n至于其他更详细的 actions 操作官方文档讲的还是比较清楚的，没有什么比较复杂的概念，可以参考官方文档学习，这里不做更多讲解。\n\n至于后面“组合 actions”中提到的 Promise 对象以及  async / await  都是 Java 中的一些特性，大家可以利用搜索引擎进行更多了解。\n\n11.Modules（模块）\n\n官方文档：Modules · GitBook\n\n如果你的 SPA 项目非常的庞大，那么状态可能本身还需要进行分模块分类管理，这个时候就需要用到模块了。官方文档中已经给出了比较详细的模块操作代码，这里不再做更多讲解。\n\n至于前面在将 actions 的时候，官方文档中说 actions 方法在声明的时候需要带上一个 context 参数，原因在这里可以得到解答：\n\n> 对于模块内部的 action，context.state 是局部状态，根节点的状态是 context.rootState\n\n12.严格模式\n\n官方文档：严格模式 · GitBook\n\n> 在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。\n\n前面提到了 state 的修改需要通过提交 Mutations 或者分发 Actions，但是事实上我直接修改 state 可以吗？当然也是可以的，但是在开发阶段，为了尽可能防止开发者直接修改，就可以通过严格模式来检测这种错误的修改方式，并且抛出异常。\n\n但是官方文档后面也提到了：\n\n> 不要在发布环境下启用严格模式！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。\n\n因此不要在生产环境下开启严格模式导致性能损失。\n\n结语：\n\nVuex 综合来看是一个非常适合在 Vue.js 中使用的状态管理工具，当然类似的状态管理工具也有很多，比如说 React 的 Redux。\n\n但是我们为了能够尽可能保证项目稳定性以及学习曲线的平滑，推荐在 Vue.js 中使用 Vuex。\n","source":"_posts/2017-08-23-Vuex新手入门指南-基本介绍.md","raw":"---\ntitle: Vuex新手入门指南-基本介绍\ntags:\n  - 技术\n  - vue\ndate: 2017-08-23 06:05:00\ncategories: 前端\n---\n\n很多人在学习完 Vue.js 之后还会看到一个经常被提及的词语叫做 Vuex。\n\nVuex 字面上看与 Vue.js 只差了一个字母，但是他们两个做的事情完全不一样。\n\n在本文我会像之前的  Vue.js 新手入门指南文章一样的问答形式来写文章。\n\n![](http://img.mp.itc.cn/upload/20170313/1f60b593695b4e1f8f5f4bf16a63183d_th.jpeg)\n\n1.Vuex 是什么？\n\n我们还是像以往一样先看一看官方文档对此的解读（Vuex 是什么？ · GitBook）\n\n> Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具  devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。\n\n是不是又遇到了很多看起来很高大上听起来却一脸懵逼的专业术语？别急别急，我们慢慢来剖析一下这个 Vuex 究竟是个啥东西，他能做些啥。\n\n2.Vuex 到底用来做什么？\n\n用通俗一点的话来说，Vuex 就是一个用于管理 SPA 项目（不知道 SPA 是什么？请参考本专栏代码之美 - 知乎专栏中的历史文章）中状态的开源产品。\n\n接下来又引出了一个问题，什么是状态，为什么要用 Vuex 这个东西去管理它？\n\n3.什么是状态？为什么要去管理它？\n\n状态这个东西其实我们生活中随处可见。我们头顶上的灯就有两种状态，一种是开，一种是关。状态说白了就是灯这个对象的的某个属性的值。\n\n如果你对状态和属性这两个概念还是有所不了解，那么我打一个其他的比方吧。\n\n我们平时是否有玩过王者荣耀或者英雄联盟 LOL 之类的网游？这些游戏里面每一个英雄当前都有生命值，法力值，攻击力，法术强度，护甲和魔抗等等，这些是这个英雄的属性，也就是英雄这个对象当前的状态。\n\n属性分为固定属性和可变属性，一般像 LOL 里面大部分 ADC 英雄如果没有特殊的被动或者其他装备的支持，那么它的的攻击距离都是固定的，这个就是固定属性，这种固定属性的状态由于正常情况下都是不变的，所以我们可以直接写死在代码中（这种写死在代码中的变量的值称为硬编码），但是像其他的攻击力法术强度等等都是随装备和等级变化，那么这种属性是可变属性。\n\n这些属性的状态由于会根据用户的各种操作（比如说出装备，打怪升级升级）变化。在传统的 Vue.js 的组件化开发中，一般这些状态都是分散在各个组件中，此时此刻如果两个英雄互相打起来了，那么就得分别去不同的组件中取状态值，然后进行状态值的修改，最后还要互相读取对方的状态值。如果他们本身是父子组件，那么还可以通过事件触发或者 Prop 属性来传递状态，但是如果是不同的组件，由于由于 Vue.js 本身组件之间有作用域，它们无法直接相互通信，所以就需要一些东西例如 Vuex 去集中管理和追踪它的变化。（如果你现在还是不明白这一大段话，可以好好回顾一下官方文档中组件 - vue.js 非父子组件通信 这个部分的内容）\n\n在游戏中，这些状态一般以变量的形式保存在内存中，但是由于用户玩游戏的时候并不是直接去使用内存管理工具查看他们在内存里面的值，而是通过游戏界面去看这些值，所以还需要像 Vue.js 这种 MVVM 框架将状态同步到视图中。这就是 Vue.js 和 Vuex 之间的关系了。\n\n4.什么情况下我应该使用 Vuex？\n\n官方文档（Vuex 是什么？ · GitBook）中说：\n\n> 虽然 Vuex 可以帮助我们管理共享状态，但也附带了更多的概念和框架。这需要对短期和长期效益进行权衡。\n>\n> 如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的  global event bus  就足够您所需了。但是，如果您需要构建是一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：\n>\n> Flux 架构就像眼镜：您自会知道什么时候需要它。\n\n他的意思其实就是如果开发的程序并不是很庞大，一个页面中的组件不是很多并且他们之间并不需要大量频繁的互相读写操作，那么就可以直接使用传统的 Vue.js 中的组件 Prop 或者事件触发来修改状态，或者用组件 - vue.js#非父子组件通信 中介绍的 new 一个空的 Vue 对象实例，并且通过事件触发等方式来跨组件通信。\n\n否则的话还是建议使用 Vuex。虽然 Vuex 本身需要有一段时间的学习成本，但是这个学习成本相对于你开发时期使用传统非父子组件通信机制遇到的各种坑来说还是比较划算的。这个就看你自己的权衡了。\n\n5.Vuex 怎么安装和使用？\n\n在前面讲解 Vue.js 入门的时候，我们用的是 Vue-Cli 这个脚手架工具来搭建的，由于这个脚手架工具本身会帮我们配置好 npm 的 package.json 文件，这个文件里面包含了这个 Vue.js 项目中所有依赖的包。\n\n但是默认情况下这个脚手架工具没有为我们将 Vuex 这个依赖包给包含进去，所以我们得自己去“声明”一下我们这个 Vue.js 项目中需要依赖 Vuex 这个包。\n\n我们该怎么“声明”呢？现在有两种办法：\n\n一种是直接修改 package.json，这种方法看起来有点复杂，很多新手怕一不小心修改出错，可能会导致整个 package.json 文件结构出错，影响以后项目的依赖安装。\n\n还有一种方法比较安全，只需要一行命令：\n\nnpm install vuex --save\n\n表示安装 vuex 这个包，--save 表示将这个依赖包与本项目的依赖关系写入 package.json 中。\n\n然后我们仅仅安装了这个依赖包是没有用的，我们还得在之前 Vue-Cli 为我们自动构建好的项目文件中的 main.js 主入口文件的开头里面加上两行这样的代码：\n\nimport Vuex from 'vuex'Vue.use(Vuex)\n\n第一行是用 ECMA6 的 import 将 vuex 包导入进来（这个是不是和 java 中导入 jar 包以及 php 中导入命名空间很相似？）\n\n第二行是 Vue.js 本身的插件注入语法（参考官方文档插件 - vue.js），将插件注入 Vue.js 的目的是方便我们在插件内部调用它。\n\n6.官方文档的五大核心概念是什么？\n\n![](http://img.mp.itc.cn/upload/20170313/f2e5f9a1d9d543a4b82a2f7d99156d2c_th.png)\n\n打开官方文档（Introduction · GitBook）能看到五大核心概念，他们都是啥？看了半天官方文档我还是对它们没什么了解，楼主能不能以通俗易懂的方式讲解一下它们的作用？当然可以啦！\n\n首先先看一遍这个代码，不需要你看懂它。\n\nconst store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }})7.State（状态）\n\n官方文档：State · GitBook\n\n这个状态就是前面所介绍的“状态”值的存放处。\n\n看第 6 节末尾的代码中，状态就是在 state 属性中以键值对的形式声明这个 SPA 中所有的状态。上面的代码中声明了一个 count 状态。\n\n之所以要在这里声明所有状态的原因，一是让代码更加优雅，如果你接手你同事的项目的时候，能够一眼从 Vuex 的状态声明中看出这个应用中有哪些状态，肯定开发效率杠杠滴。二是如果在这里声明了状态，那么 Vuex 就能够追踪到这个状态的变化。那么 Vue.js 中就可以在视图中对这个状态做出响应。\n\n读取状态当然也是直接读取这个属性里面的各种子属性了。\n\n8.Getter（获取器）\n\n官方文档：Getters · GitBook\n\n这个获取器和一些后端开发中模型层 ORM 中的获取器其实是差不多的功能。\n\n比如说后端返回给我们的是一个 int 类型的时间戳，我们想把这个时间戳转换成正常人类可读的文本型时间表现形式（比如说 2017 年 3 月 11 日 12:43:31），那么我们就得在所有获取该状态的代码中增加一个转换函数。\n\n可是现在有了状态获取器之后，我们可以统一将这个时间戳转字符串的函数写在获取器里面，要调用的时候就直接调用获取器就好了。\n\n还有一些其他场景也可以使用获取器，比如说像错误码这种东西一般都是一个数字码对应一个文字形式的错误原因，我们也可以通过获取器来实现通过错误码拉取错误原因的功能。\n\n使用获取器的方法则是直接调用 Vuex 实例的 getter 下的各种函数即可。\n\n9.Mutations（转变）\n\n官方文档：Mutations · GitBook\n\n这个 Mutations 其实国内目前也没有比较好的翻译，通常我们都是直接称 Mutations。\n\n我们前面只讲了可以通过调用 Vuex 的实例的 state 属性或者 getter 获取器来读取状态。但是没讲到如何修改状态。\n\n官方文档中已经讲了需要先在 Vuex 实例的 Mutations 下编写对应的修改函数来修改状态。并且要修改的时候，要通过 Vuex 实例的 commit 方法来提交修改。也就是说任何对 state 状态的修改操作都必须写在 Mutations 中，并且还得用 Vuex 实例的 commit 来提交修改操作，并且由于 Mutations 函数可以传入参数，所以 commit 同理也可以传入参数。\n\n这个时候可能有一些同学就会提问了，前面既然讲到了读取可以直接访问 Vuex 实例的 state 属性，为什么修改却不能直接去操作 Vuex 实例的 state 呢？官方文档和其他高手的回答是：\n\n> 再次强调，我们通过提交 mutation 的方式，而非直接改变 store.state.count，是因为我们想要更明确地追踪到状态的变化。这个简单的约定能够让你的意图更加明显，这样你在阅读代码的时候能更容易地解读应用内部的状态改变。此外，这样也让我们有机会去实现一些能记录每次状态改变，保存状态快照的调试工具。有了它，我们甚至可以实现如时间穿梭般的调试体验。\n\n相当于我们通过一个 Mutations 函数可以显式的在代码中告诉开发者，我们这个 SPA 中究竟会对状态进行哪些操作，操作方式是什么。并且在后期我们使用一些辅助开发工具，可以保存状态的快照，就像 git 或者 svn 一样可以回滚状态。如果你还是有点不明白，总之你就按照官方文档说的去做吧，等开发一段时间之后会慢慢明白作者的良苦用心的，哈哈。\n\n还有一个问题就是为什么状态修改的提交必须通过 Vuex 实例的 commit 方法提交呢？为什么不能直接调用 Mutations 函数呢？除了上面官方文档中提到的原因，网上还有高手解释了：因为 Vue.js 的状态修改其实是在内部有一个修改队列，通过 commit 的方式提交修改可以保证状态的修改是有序的。\n\n10.Actions（动作）\n\n官方文档：Actions · GitBook\n\n前面提到了 Mutations 中可以对状态进行操作，但是忘记告诉各位同学，Mutations 中对状态的操作只能是同步操作，不能是异步操作。\n\n如果这个时候我们有一个对状态的修改操作是异步的怎么办呢？\n\n首先看看什么是异步操作？比如说 ajax 就可以选择是否发起异步请求，发起异步请求之后，我们就需要在回调函数里面进行请求结果的处理。关于 Java 异步的知识大家可以先使用各种搜索引擎自学一下。\n\n现在回到 actions 上来，看看官方文档（Actions · GitBook）：\n\n> Action 类似于 mutation，不同在于：\n>\n> - Action 提交的是 mutation，而不是直接变更状态。\n>\n> - Action 可以包含任意异步操作。\n\n其实异步的状态修改本质上还是通过几个同步操作组合的，所以我们还是得先声明好 mutation 同步操作方法，然后在 actions 中进行异步操作。如果我们暂时手头上没有 ajax 接口用于异步请求，那么我们可以像官方文档一样用 setTimeout 这种最简单的测试方法来理解。\n\nactions: { incrementAsync ({ commit }) { setTimeout(() => { commit('increment') }, 1000) }}\n\n前面讲到了 mutation 是用 commit 来提交操作的，那么 actions 是怎么提交的呢？官方文档中说了 actions 是使用 Vuex 实例的 dispatch 方法来提交（其实说分发会更加准确）的。\n\n至于其他更详细的 actions 操作官方文档讲的还是比较清楚的，没有什么比较复杂的概念，可以参考官方文档学习，这里不做更多讲解。\n\n至于后面“组合 actions”中提到的 Promise 对象以及  async / await  都是 Java 中的一些特性，大家可以利用搜索引擎进行更多了解。\n\n11.Modules（模块）\n\n官方文档：Modules · GitBook\n\n如果你的 SPA 项目非常的庞大，那么状态可能本身还需要进行分模块分类管理，这个时候就需要用到模块了。官方文档中已经给出了比较详细的模块操作代码，这里不再做更多讲解。\n\n至于前面在将 actions 的时候，官方文档中说 actions 方法在声明的时候需要带上一个 context 参数，原因在这里可以得到解答：\n\n> 对于模块内部的 action，context.state 是局部状态，根节点的状态是 context.rootState\n\n12.严格模式\n\n官方文档：严格模式 · GitBook\n\n> 在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。\n\n前面提到了 state 的修改需要通过提交 Mutations 或者分发 Actions，但是事实上我直接修改 state 可以吗？当然也是可以的，但是在开发阶段，为了尽可能防止开发者直接修改，就可以通过严格模式来检测这种错误的修改方式，并且抛出异常。\n\n但是官方文档后面也提到了：\n\n> 不要在发布环境下启用严格模式！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。\n\n因此不要在生产环境下开启严格模式导致性能损失。\n\n结语：\n\nVuex 综合来看是一个非常适合在 Vue.js 中使用的状态管理工具，当然类似的状态管理工具也有很多，比如说 React 的 Redux。\n\n但是我们为了能够尽可能保证项目稳定性以及学习曲线的平滑，推荐在 Vue.js 中使用 Vuex。\n","slug":"2017-08-23-Vuex新手入门指南-基本介绍","published":1,"updated":"2020-03-14T06:46:01.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvmm004a4k8y93gmb7fs","content":"<p>很多人在学习完 Vue.js 之后还会看到一个经常被提及的词语叫做 Vuex。</p>\n<p>Vuex 字面上看与 Vue.js 只差了一个字母，但是他们两个做的事情完全不一样。</p>\n<p>在本文我会像之前的  Vue.js 新手入门指南文章一样的问答形式来写文章。</p>\n<p><img src=\"http://img.mp.itc.cn/upload/20170313/1f60b593695b4e1f8f5f4bf16a63183d_th.jpeg\" alt=\"\"></p>\n<p>1.Vuex 是什么？</p>\n<p>我们还是像以往一样先看一看官方文档对此的解读（Vuex 是什么？ · GitBook）</p>\n<blockquote>\n<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具  devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p>\n</blockquote>\n<p>是不是又遇到了很多看起来很高大上听起来却一脸懵逼的专业术语？别急别急，我们慢慢来剖析一下这个 Vuex 究竟是个啥东西，他能做些啥。</p>\n<p>2.Vuex 到底用来做什么？</p>\n<p>用通俗一点的话来说，Vuex 就是一个用于管理 SPA 项目（不知道 SPA 是什么？请参考本专栏代码之美 - 知乎专栏中的历史文章）中状态的开源产品。</p>\n<p>接下来又引出了一个问题，什么是状态，为什么要用 Vuex 这个东西去管理它？</p>\n<p>3.什么是状态？为什么要去管理它？</p>\n<p>状态这个东西其实我们生活中随处可见。我们头顶上的灯就有两种状态，一种是开，一种是关。状态说白了就是灯这个对象的的某个属性的值。</p>\n<p>如果你对状态和属性这两个概念还是有所不了解，那么我打一个其他的比方吧。</p>\n<p>我们平时是否有玩过王者荣耀或者英雄联盟 LOL 之类的网游？这些游戏里面每一个英雄当前都有生命值，法力值，攻击力，法术强度，护甲和魔抗等等，这些是这个英雄的属性，也就是英雄这个对象当前的状态。</p>\n<p>属性分为固定属性和可变属性，一般像 LOL 里面大部分 ADC 英雄如果没有特殊的被动或者其他装备的支持，那么它的的攻击距离都是固定的，这个就是固定属性，这种固定属性的状态由于正常情况下都是不变的，所以我们可以直接写死在代码中（这种写死在代码中的变量的值称为硬编码），但是像其他的攻击力法术强度等等都是随装备和等级变化，那么这种属性是可变属性。</p>\n<p>这些属性的状态由于会根据用户的各种操作（比如说出装备，打怪升级升级）变化。在传统的 Vue.js 的组件化开发中，一般这些状态都是分散在各个组件中，此时此刻如果两个英雄互相打起来了，那么就得分别去不同的组件中取状态值，然后进行状态值的修改，最后还要互相读取对方的状态值。如果他们本身是父子组件，那么还可以通过事件触发或者 Prop 属性来传递状态，但是如果是不同的组件，由于由于 Vue.js 本身组件之间有作用域，它们无法直接相互通信，所以就需要一些东西例如 Vuex 去集中管理和追踪它的变化。（如果你现在还是不明白这一大段话，可以好好回顾一下官方文档中组件 - vue.js 非父子组件通信 这个部分的内容）</p>\n<p>在游戏中，这些状态一般以变量的形式保存在内存中，但是由于用户玩游戏的时候并不是直接去使用内存管理工具查看他们在内存里面的值，而是通过游戏界面去看这些值，所以还需要像 Vue.js 这种 MVVM 框架将状态同步到视图中。这就是 Vue.js 和 Vuex 之间的关系了。</p>\n<p>4.什么情况下我应该使用 Vuex？</p>\n<p>官方文档（Vuex 是什么？ · GitBook）中说：</p>\n<blockquote>\n<p>虽然 Vuex 可以帮助我们管理共享状态，但也附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</p>\n<p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的  global event bus  就足够您所需了。但是，如果您需要构建是一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：</p>\n<p>Flux 架构就像眼镜：您自会知道什么时候需要它。</p>\n</blockquote>\n<p>他的意思其实就是如果开发的程序并不是很庞大，一个页面中的组件不是很多并且他们之间并不需要大量频繁的互相读写操作，那么就可以直接使用传统的 Vue.js 中的组件 Prop 或者事件触发来修改状态，或者用组件 - vue.js#非父子组件通信 中介绍的 new 一个空的 Vue 对象实例，并且通过事件触发等方式来跨组件通信。</p>\n<p>否则的话还是建议使用 Vuex。虽然 Vuex 本身需要有一段时间的学习成本，但是这个学习成本相对于你开发时期使用传统非父子组件通信机制遇到的各种坑来说还是比较划算的。这个就看你自己的权衡了。</p>\n<p>5.Vuex 怎么安装和使用？</p>\n<p>在前面讲解 Vue.js 入门的时候，我们用的是 Vue-Cli 这个脚手架工具来搭建的，由于这个脚手架工具本身会帮我们配置好 npm 的 package.json 文件，这个文件里面包含了这个 Vue.js 项目中所有依赖的包。</p>\n<p>但是默认情况下这个脚手架工具没有为我们将 Vuex 这个依赖包给包含进去，所以我们得自己去“声明”一下我们这个 Vue.js 项目中需要依赖 Vuex 这个包。</p>\n<p>我们该怎么“声明”呢？现在有两种办法：</p>\n<p>一种是直接修改 package.json，这种方法看起来有点复杂，很多新手怕一不小心修改出错，可能会导致整个 package.json 文件结构出错，影响以后项目的依赖安装。</p>\n<p>还有一种方法比较安全，只需要一行命令：</p>\n<p>npm install vuex –save</p>\n<p>表示安装 vuex 这个包，–save 表示将这个依赖包与本项目的依赖关系写入 package.json 中。</p>\n<p>然后我们仅仅安装了这个依赖包是没有用的，我们还得在之前 Vue-Cli 为我们自动构建好的项目文件中的 main.js 主入口文件的开头里面加上两行这样的代码：</p>\n<p>import Vuex from ‘vuex’Vue.use(Vuex)</p>\n<p>第一行是用 ECMA6 的 import 将 vuex 包导入进来（这个是不是和 java 中导入 jar 包以及 php 中导入命名空间很相似？）</p>\n<p>第二行是 Vue.js 本身的插件注入语法（参考官方文档插件 - vue.js），将插件注入 Vue.js 的目的是方便我们在插件内部调用它。</p>\n<p>6.官方文档的五大核心概念是什么？</p>\n<p><img src=\"http://img.mp.itc.cn/upload/20170313/f2e5f9a1d9d543a4b82a2f7d99156d2c_th.png\" alt=\"\"></p>\n<p>打开官方文档（Introduction · GitBook）能看到五大核心概念，他们都是啥？看了半天官方文档我还是对它们没什么了解，楼主能不能以通俗易懂的方式讲解一下它们的作用？当然可以啦！</p>\n<p>首先先看一遍这个代码，不需要你看懂它。</p>\n<p>const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }})7.State（状态）</p>\n<p>官方文档：State · GitBook</p>\n<p>这个状态就是前面所介绍的“状态”值的存放处。</p>\n<p>看第 6 节末尾的代码中，状态就是在 state 属性中以键值对的形式声明这个 SPA 中所有的状态。上面的代码中声明了一个 count 状态。</p>\n<p>之所以要在这里声明所有状态的原因，一是让代码更加优雅，如果你接手你同事的项目的时候，能够一眼从 Vuex 的状态声明中看出这个应用中有哪些状态，肯定开发效率杠杠滴。二是如果在这里声明了状态，那么 Vuex 就能够追踪到这个状态的变化。那么 Vue.js 中就可以在视图中对这个状态做出响应。</p>\n<p>读取状态当然也是直接读取这个属性里面的各种子属性了。</p>\n<p>8.Getter（获取器）</p>\n<p>官方文档：Getters · GitBook</p>\n<p>这个获取器和一些后端开发中模型层 ORM 中的获取器其实是差不多的功能。</p>\n<p>比如说后端返回给我们的是一个 int 类型的时间戳，我们想把这个时间戳转换成正常人类可读的文本型时间表现形式（比如说 2017 年 3 月 11 日 12:43:31），那么我们就得在所有获取该状态的代码中增加一个转换函数。</p>\n<p>可是现在有了状态获取器之后，我们可以统一将这个时间戳转字符串的函数写在获取器里面，要调用的时候就直接调用获取器就好了。</p>\n<p>还有一些其他场景也可以使用获取器，比如说像错误码这种东西一般都是一个数字码对应一个文字形式的错误原因，我们也可以通过获取器来实现通过错误码拉取错误原因的功能。</p>\n<p>使用获取器的方法则是直接调用 Vuex 实例的 getter 下的各种函数即可。</p>\n<p>9.Mutations（转变）</p>\n<p>官方文档：Mutations · GitBook</p>\n<p>这个 Mutations 其实国内目前也没有比较好的翻译，通常我们都是直接称 Mutations。</p>\n<p>我们前面只讲了可以通过调用 Vuex 的实例的 state 属性或者 getter 获取器来读取状态。但是没讲到如何修改状态。</p>\n<p>官方文档中已经讲了需要先在 Vuex 实例的 Mutations 下编写对应的修改函数来修改状态。并且要修改的时候，要通过 Vuex 实例的 commit 方法来提交修改。也就是说任何对 state 状态的修改操作都必须写在 Mutations 中，并且还得用 Vuex 实例的 commit 来提交修改操作，并且由于 Mutations 函数可以传入参数，所以 commit 同理也可以传入参数。</p>\n<p>这个时候可能有一些同学就会提问了，前面既然讲到了读取可以直接访问 Vuex 实例的 state 属性，为什么修改却不能直接去操作 Vuex 实例的 state 呢？官方文档和其他高手的回答是：</p>\n<blockquote>\n<p>再次强调，我们通过提交 mutation 的方式，而非直接改变 store.state.count，是因为我们想要更明确地追踪到状态的变化。这个简单的约定能够让你的意图更加明显，这样你在阅读代码的时候能更容易地解读应用内部的状态改变。此外，这样也让我们有机会去实现一些能记录每次状态改变，保存状态快照的调试工具。有了它，我们甚至可以实现如时间穿梭般的调试体验。</p>\n</blockquote>\n<p>相当于我们通过一个 Mutations 函数可以显式的在代码中告诉开发者，我们这个 SPA 中究竟会对状态进行哪些操作，操作方式是什么。并且在后期我们使用一些辅助开发工具，可以保存状态的快照，就像 git 或者 svn 一样可以回滚状态。如果你还是有点不明白，总之你就按照官方文档说的去做吧，等开发一段时间之后会慢慢明白作者的良苦用心的，哈哈。</p>\n<p>还有一个问题就是为什么状态修改的提交必须通过 Vuex 实例的 commit 方法提交呢？为什么不能直接调用 Mutations 函数呢？除了上面官方文档中提到的原因，网上还有高手解释了：因为 Vue.js 的状态修改其实是在内部有一个修改队列，通过 commit 的方式提交修改可以保证状态的修改是有序的。</p>\n<p>10.Actions（动作）</p>\n<p>官方文档：Actions · GitBook</p>\n<p>前面提到了 Mutations 中可以对状态进行操作，但是忘记告诉各位同学，Mutations 中对状态的操作只能是同步操作，不能是异步操作。</p>\n<p>如果这个时候我们有一个对状态的修改操作是异步的怎么办呢？</p>\n<p>首先看看什么是异步操作？比如说 ajax 就可以选择是否发起异步请求，发起异步请求之后，我们就需要在回调函数里面进行请求结果的处理。关于 Java 异步的知识大家可以先使用各种搜索引擎自学一下。</p>\n<p>现在回到 actions 上来，看看官方文档（Actions · GitBook）：</p>\n<blockquote>\n<p>Action 类似于 mutation，不同在于：</p>\n<ul>\n<li><p>Action 提交的是 mutation，而不是直接变更状态。</p>\n</li>\n<li><p>Action 可以包含任意异步操作。</p>\n</li>\n</ul>\n</blockquote>\n<p>其实异步的状态修改本质上还是通过几个同步操作组合的，所以我们还是得先声明好 mutation 同步操作方法，然后在 actions 中进行异步操作。如果我们暂时手头上没有 ajax 接口用于异步请求，那么我们可以像官方文档一样用 setTimeout 这种最简单的测试方法来理解。</p>\n<p>actions: { incrementAsync ({ commit }) { setTimeout(() =&gt; { commit(‘increment’) }, 1000) }}</p>\n<p>前面讲到了 mutation 是用 commit 来提交操作的，那么 actions 是怎么提交的呢？官方文档中说了 actions 是使用 Vuex 实例的 dispatch 方法来提交（其实说分发会更加准确）的。</p>\n<p>至于其他更详细的 actions 操作官方文档讲的还是比较清楚的，没有什么比较复杂的概念，可以参考官方文档学习，这里不做更多讲解。</p>\n<p>至于后面“组合 actions”中提到的 Promise 对象以及  async / await  都是 Java 中的一些特性，大家可以利用搜索引擎进行更多了解。</p>\n<p>11.Modules（模块）</p>\n<p>官方文档：Modules · GitBook</p>\n<p>如果你的 SPA 项目非常的庞大，那么状态可能本身还需要进行分模块分类管理，这个时候就需要用到模块了。官方文档中已经给出了比较详细的模块操作代码，这里不再做更多讲解。</p>\n<p>至于前面在将 actions 的时候，官方文档中说 actions 方法在声明的时候需要带上一个 context 参数，原因在这里可以得到解答：</p>\n<blockquote>\n<p>对于模块内部的 action，context.state 是局部状态，根节点的状态是 context.rootState</p>\n</blockquote>\n<p>12.严格模式</p>\n<p>官方文档：严格模式 · GitBook</p>\n<blockquote>\n<p>在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p>\n</blockquote>\n<p>前面提到了 state 的修改需要通过提交 Mutations 或者分发 Actions，但是事实上我直接修改 state 可以吗？当然也是可以的，但是在开发阶段，为了尽可能防止开发者直接修改，就可以通过严格模式来检测这种错误的修改方式，并且抛出异常。</p>\n<p>但是官方文档后面也提到了：</p>\n<blockquote>\n<p>不要在发布环境下启用严格模式！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。</p>\n</blockquote>\n<p>因此不要在生产环境下开启严格模式导致性能损失。</p>\n<p>结语：</p>\n<p>Vuex 综合来看是一个非常适合在 Vue.js 中使用的状态管理工具，当然类似的状态管理工具也有很多，比如说 React 的 Redux。</p>\n<p>但是我们为了能够尽可能保证项目稳定性以及学习曲线的平滑，推荐在 Vue.js 中使用 Vuex。</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>很多人在学习完 Vue.js 之后还会看到一个经常被提及的词语叫做 Vuex。</p>\n<p>Vuex 字面上看与 Vue.js 只差了一个字母，但是他们两个做的事情完全不一样。</p>\n<p>在本文我会像之前的  Vue.js 新手入门指南文章一样的问答形式来写文章。</p>\n<p><img src=\"http://img.mp.itc.cn/upload/20170313/1f60b593695b4e1f8f5f4bf16a63183d_th.jpeg\" alt=\"\"></p>\n<p>1.Vuex 是什么？</p>\n<p>我们还是像以往一样先看一看官方文档对此的解读（Vuex 是什么？ · GitBook）</p>\n<blockquote>\n<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具  devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p>\n</blockquote>\n<p>是不是又遇到了很多看起来很高大上听起来却一脸懵逼的专业术语？别急别急，我们慢慢来剖析一下这个 Vuex 究竟是个啥东西，他能做些啥。</p>\n<p>2.Vuex 到底用来做什么？</p>\n<p>用通俗一点的话来说，Vuex 就是一个用于管理 SPA 项目（不知道 SPA 是什么？请参考本专栏代码之美 - 知乎专栏中的历史文章）中状态的开源产品。</p>\n<p>接下来又引出了一个问题，什么是状态，为什么要用 Vuex 这个东西去管理它？</p>\n<p>3.什么是状态？为什么要去管理它？</p>\n<p>状态这个东西其实我们生活中随处可见。我们头顶上的灯就有两种状态，一种是开，一种是关。状态说白了就是灯这个对象的的某个属性的值。</p>\n<p>如果你对状态和属性这两个概念还是有所不了解，那么我打一个其他的比方吧。</p>\n<p>我们平时是否有玩过王者荣耀或者英雄联盟 LOL 之类的网游？这些游戏里面每一个英雄当前都有生命值，法力值，攻击力，法术强度，护甲和魔抗等等，这些是这个英雄的属性，也就是英雄这个对象当前的状态。</p>\n<p>属性分为固定属性和可变属性，一般像 LOL 里面大部分 ADC 英雄如果没有特殊的被动或者其他装备的支持，那么它的的攻击距离都是固定的，这个就是固定属性，这种固定属性的状态由于正常情况下都是不变的，所以我们可以直接写死在代码中（这种写死在代码中的变量的值称为硬编码），但是像其他的攻击力法术强度等等都是随装备和等级变化，那么这种属性是可变属性。</p>\n<p>这些属性的状态由于会根据用户的各种操作（比如说出装备，打怪升级升级）变化。在传统的 Vue.js 的组件化开发中，一般这些状态都是分散在各个组件中，此时此刻如果两个英雄互相打起来了，那么就得分别去不同的组件中取状态值，然后进行状态值的修改，最后还要互相读取对方的状态值。如果他们本身是父子组件，那么还可以通过事件触发或者 Prop 属性来传递状态，但是如果是不同的组件，由于由于 Vue.js 本身组件之间有作用域，它们无法直接相互通信，所以就需要一些东西例如 Vuex 去集中管理和追踪它的变化。（如果你现在还是不明白这一大段话，可以好好回顾一下官方文档中组件 - vue.js 非父子组件通信 这个部分的内容）</p>\n<p>在游戏中，这些状态一般以变量的形式保存在内存中，但是由于用户玩游戏的时候并不是直接去使用内存管理工具查看他们在内存里面的值，而是通过游戏界面去看这些值，所以还需要像 Vue.js 这种 MVVM 框架将状态同步到视图中。这就是 Vue.js 和 Vuex 之间的关系了。</p>\n<p>4.什么情况下我应该使用 Vuex？</p>\n<p>官方文档（Vuex 是什么？ · GitBook）中说：</p>\n<blockquote>\n<p>虽然 Vuex 可以帮助我们管理共享状态，但也附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</p>\n<p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的  global event bus  就足够您所需了。但是，如果您需要构建是一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。引用 Redux 的作者 Dan Abramov 的话说就是：</p>\n<p>Flux 架构就像眼镜：您自会知道什么时候需要它。</p>\n</blockquote>\n<p>他的意思其实就是如果开发的程序并不是很庞大，一个页面中的组件不是很多并且他们之间并不需要大量频繁的互相读写操作，那么就可以直接使用传统的 Vue.js 中的组件 Prop 或者事件触发来修改状态，或者用组件 - vue.js#非父子组件通信 中介绍的 new 一个空的 Vue 对象实例，并且通过事件触发等方式来跨组件通信。</p>\n<p>否则的话还是建议使用 Vuex。虽然 Vuex 本身需要有一段时间的学习成本，但是这个学习成本相对于你开发时期使用传统非父子组件通信机制遇到的各种坑来说还是比较划算的。这个就看你自己的权衡了。</p>\n<p>5.Vuex 怎么安装和使用？</p>\n<p>在前面讲解 Vue.js 入门的时候，我们用的是 Vue-Cli 这个脚手架工具来搭建的，由于这个脚手架工具本身会帮我们配置好 npm 的 package.json 文件，这个文件里面包含了这个 Vue.js 项目中所有依赖的包。</p>\n<p>但是默认情况下这个脚手架工具没有为我们将 Vuex 这个依赖包给包含进去，所以我们得自己去“声明”一下我们这个 Vue.js 项目中需要依赖 Vuex 这个包。</p>\n<p>我们该怎么“声明”呢？现在有两种办法：</p>\n<p>一种是直接修改 package.json，这种方法看起来有点复杂，很多新手怕一不小心修改出错，可能会导致整个 package.json 文件结构出错，影响以后项目的依赖安装。</p>\n<p>还有一种方法比较安全，只需要一行命令：</p>\n<p>npm install vuex –save</p>\n<p>表示安装 vuex 这个包，–save 表示将这个依赖包与本项目的依赖关系写入 package.json 中。</p>\n<p>然后我们仅仅安装了这个依赖包是没有用的，我们还得在之前 Vue-Cli 为我们自动构建好的项目文件中的 main.js 主入口文件的开头里面加上两行这样的代码：</p>\n<p>import Vuex from ‘vuex’Vue.use(Vuex)</p>\n<p>第一行是用 ECMA6 的 import 将 vuex 包导入进来（这个是不是和 java 中导入 jar 包以及 php 中导入命名空间很相似？）</p>\n<p>第二行是 Vue.js 本身的插件注入语法（参考官方文档插件 - vue.js），将插件注入 Vue.js 的目的是方便我们在插件内部调用它。</p>\n<p>6.官方文档的五大核心概念是什么？</p>\n<p><img src=\"http://img.mp.itc.cn/upload/20170313/f2e5f9a1d9d543a4b82a2f7d99156d2c_th.png\" alt=\"\"></p>\n<p>打开官方文档（Introduction · GitBook）能看到五大核心概念，他们都是啥？看了半天官方文档我还是对它们没什么了解，楼主能不能以通俗易懂的方式讲解一下它们的作用？当然可以啦！</p>\n<p>首先先看一遍这个代码，不需要你看懂它。</p>\n<p>const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }})7.State（状态）</p>\n<p>官方文档：State · GitBook</p>\n<p>这个状态就是前面所介绍的“状态”值的存放处。</p>\n<p>看第 6 节末尾的代码中，状态就是在 state 属性中以键值对的形式声明这个 SPA 中所有的状态。上面的代码中声明了一个 count 状态。</p>\n<p>之所以要在这里声明所有状态的原因，一是让代码更加优雅，如果你接手你同事的项目的时候，能够一眼从 Vuex 的状态声明中看出这个应用中有哪些状态，肯定开发效率杠杠滴。二是如果在这里声明了状态，那么 Vuex 就能够追踪到这个状态的变化。那么 Vue.js 中就可以在视图中对这个状态做出响应。</p>\n<p>读取状态当然也是直接读取这个属性里面的各种子属性了。</p>\n<p>8.Getter（获取器）</p>\n<p>官方文档：Getters · GitBook</p>\n<p>这个获取器和一些后端开发中模型层 ORM 中的获取器其实是差不多的功能。</p>\n<p>比如说后端返回给我们的是一个 int 类型的时间戳，我们想把这个时间戳转换成正常人类可读的文本型时间表现形式（比如说 2017 年 3 月 11 日 12:43:31），那么我们就得在所有获取该状态的代码中增加一个转换函数。</p>\n<p>可是现在有了状态获取器之后，我们可以统一将这个时间戳转字符串的函数写在获取器里面，要调用的时候就直接调用获取器就好了。</p>\n<p>还有一些其他场景也可以使用获取器，比如说像错误码这种东西一般都是一个数字码对应一个文字形式的错误原因，我们也可以通过获取器来实现通过错误码拉取错误原因的功能。</p>\n<p>使用获取器的方法则是直接调用 Vuex 实例的 getter 下的各种函数即可。</p>\n<p>9.Mutations（转变）</p>\n<p>官方文档：Mutations · GitBook</p>\n<p>这个 Mutations 其实国内目前也没有比较好的翻译，通常我们都是直接称 Mutations。</p>\n<p>我们前面只讲了可以通过调用 Vuex 的实例的 state 属性或者 getter 获取器来读取状态。但是没讲到如何修改状态。</p>\n<p>官方文档中已经讲了需要先在 Vuex 实例的 Mutations 下编写对应的修改函数来修改状态。并且要修改的时候，要通过 Vuex 实例的 commit 方法来提交修改。也就是说任何对 state 状态的修改操作都必须写在 Mutations 中，并且还得用 Vuex 实例的 commit 来提交修改操作，并且由于 Mutations 函数可以传入参数，所以 commit 同理也可以传入参数。</p>\n<p>这个时候可能有一些同学就会提问了，前面既然讲到了读取可以直接访问 Vuex 实例的 state 属性，为什么修改却不能直接去操作 Vuex 实例的 state 呢？官方文档和其他高手的回答是：</p>\n<blockquote>\n<p>再次强调，我们通过提交 mutation 的方式，而非直接改变 store.state.count，是因为我们想要更明确地追踪到状态的变化。这个简单的约定能够让你的意图更加明显，这样你在阅读代码的时候能更容易地解读应用内部的状态改变。此外，这样也让我们有机会去实现一些能记录每次状态改变，保存状态快照的调试工具。有了它，我们甚至可以实现如时间穿梭般的调试体验。</p>\n</blockquote>\n<p>相当于我们通过一个 Mutations 函数可以显式的在代码中告诉开发者，我们这个 SPA 中究竟会对状态进行哪些操作，操作方式是什么。并且在后期我们使用一些辅助开发工具，可以保存状态的快照，就像 git 或者 svn 一样可以回滚状态。如果你还是有点不明白，总之你就按照官方文档说的去做吧，等开发一段时间之后会慢慢明白作者的良苦用心的，哈哈。</p>\n<p>还有一个问题就是为什么状态修改的提交必须通过 Vuex 实例的 commit 方法提交呢？为什么不能直接调用 Mutations 函数呢？除了上面官方文档中提到的原因，网上还有高手解释了：因为 Vue.js 的状态修改其实是在内部有一个修改队列，通过 commit 的方式提交修改可以保证状态的修改是有序的。</p>\n<p>10.Actions（动作）</p>\n<p>官方文档：Actions · GitBook</p>\n<p>前面提到了 Mutations 中可以对状态进行操作，但是忘记告诉各位同学，Mutations 中对状态的操作只能是同步操作，不能是异步操作。</p>\n<p>如果这个时候我们有一个对状态的修改操作是异步的怎么办呢？</p>\n<p>首先看看什么是异步操作？比如说 ajax 就可以选择是否发起异步请求，发起异步请求之后，我们就需要在回调函数里面进行请求结果的处理。关于 Java 异步的知识大家可以先使用各种搜索引擎自学一下。</p>\n<p>现在回到 actions 上来，看看官方文档（Actions · GitBook）：</p>\n<blockquote>\n<p>Action 类似于 mutation，不同在于：</p>\n<ul>\n<li><p>Action 提交的是 mutation，而不是直接变更状态。</p>\n</li>\n<li><p>Action 可以包含任意异步操作。</p>\n</li>\n</ul>\n</blockquote>\n<p>其实异步的状态修改本质上还是通过几个同步操作组合的，所以我们还是得先声明好 mutation 同步操作方法，然后在 actions 中进行异步操作。如果我们暂时手头上没有 ajax 接口用于异步请求，那么我们可以像官方文档一样用 setTimeout 这种最简单的测试方法来理解。</p>\n<p>actions: { incrementAsync ({ commit }) { setTimeout(() =&gt; { commit(‘increment’) }, 1000) }}</p>\n<p>前面讲到了 mutation 是用 commit 来提交操作的，那么 actions 是怎么提交的呢？官方文档中说了 actions 是使用 Vuex 实例的 dispatch 方法来提交（其实说分发会更加准确）的。</p>\n<p>至于其他更详细的 actions 操作官方文档讲的还是比较清楚的，没有什么比较复杂的概念，可以参考官方文档学习，这里不做更多讲解。</p>\n<p>至于后面“组合 actions”中提到的 Promise 对象以及  async / await  都是 Java 中的一些特性，大家可以利用搜索引擎进行更多了解。</p>\n<p>11.Modules（模块）</p>\n<p>官方文档：Modules · GitBook</p>\n<p>如果你的 SPA 项目非常的庞大，那么状态可能本身还需要进行分模块分类管理，这个时候就需要用到模块了。官方文档中已经给出了比较详细的模块操作代码，这里不再做更多讲解。</p>\n<p>至于前面在将 actions 的时候，官方文档中说 actions 方法在声明的时候需要带上一个 context 参数，原因在这里可以得到解答：</p>\n<blockquote>\n<p>对于模块内部的 action，context.state 是局部状态，根节点的状态是 context.rootState</p>\n</blockquote>\n<p>12.严格模式</p>\n<p>官方文档：严格模式 · GitBook</p>\n<blockquote>\n<p>在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p>\n</blockquote>\n<p>前面提到了 state 的修改需要通过提交 Mutations 或者分发 Actions，但是事实上我直接修改 state 可以吗？当然也是可以的，但是在开发阶段，为了尽可能防止开发者直接修改，就可以通过严格模式来检测这种错误的修改方式，并且抛出异常。</p>\n<p>但是官方文档后面也提到了：</p>\n<blockquote>\n<p>不要在发布环境下启用严格模式！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。</p>\n</blockquote>\n<p>因此不要在生产环境下开启严格模式导致性能损失。</p>\n<p>结语：</p>\n<p>Vuex 综合来看是一个非常适合在 Vue.js 中使用的状态管理工具，当然类似的状态管理工具也有很多，比如说 React 的 Redux。</p>\n<p>但是我们为了能够尽可能保证项目稳定性以及学习曲线的平滑，推荐在 Vue.js 中使用 Vuex。</p>\n"},{"title":"对vue生命周期/钩子函数的理解","date":"2017-08-25T22:30:00.000Z","_content":"\n对于实现页面逻辑交互等效果，我们必须知晓 vue 的生命周期，才能愉快的玩耍，知道我们写的东西应该挂载到哪里，vue 官方给出的 api 讲解的那叫一个简单啊，如下：\n\n所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着**你不能使用箭头函数来定义一个生命周期方法**(例如 created: () => this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。\n\n下面附加一张生命周期图示\n\n![](//upload-images.jianshu.io/upload_images/2615941-444e7f8762fd0ef3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/1213869-20170826142620121-2040456715.png)\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/ContractedBlock-1.gif)![](http://www.jixiaokang.com/wp-content/uploads/2018/05/ExpandedBlockStart-1.gif)\n\n1 DOCTYPE html>\n2 <html>\n3 <head>\n4 <title>title>\n5 <meta charset=\"utf-8\">\n6 <script type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/vue/2.1.3/vue.js\">script>\n7 head>\n8 <body>\n9\n10 <div id=\"app\">\n11 <p>{ { message }}p>\n12 div>\n13\n14 <script type=\"text/javascript\">\n15 var app = new Vue({ 16 el: '#app', 17 data: { 18 message: \"this is a test\"\n19 }, 20 beforeCreate: function () { 21 console.group('beforeCreate 创建前状态===============》'); 22 console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); //undefined\n23             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); //undefined\n24 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message) 25 }, 26 created: function () { 27 console.group('created 创建完毕状态===============》'); 28 console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); //undefined\n29             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); //已被初始化\n30 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); //已被初始化\n31 }, 32 beforeMount: function () { 33 console.group('beforeMount 挂载前状态===============》'); 34 console.log(\"%c%s\", \"color:red\", \"el : \" + (this.$el)); //已被初始化\n35             console.log(this.$el); 36 console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); //已被初始化\n37             console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); //已被初始化\n38 }, 39 mounted: function () { 40             console.group('mounted 挂载结束状态===============》'); 41             console.log(\"%c%s\", \"color:red\", \"el     : \" + this.$el); //已被初始化\n42 console.log(this.$el); 43             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); //已被初始化\n44 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); //已被初始化\n45 }, 46 beforeUpdate: function () { 47 console.group('beforeUpdate 更新前状态===============》'); 48 console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); 49             console.log(this.$el); 50 console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); 51             console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); 52 }, 53 updated: function () { 54             console.group('updated 更新完成状态===============》'); 55             console.log(\"%c%s\", \"color:red\", \"el     : \" + this.$el); 56 console.log(this.$el); 57             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); 58 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); 59 }, 60 beforeDestroy: function () { 61 console.group('beforeDestroy 销毁前状态===============》'); 62 console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); 63             console.log(this.$el); 64 console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); 65             console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); 66 }, 67 destroyed: function () { 68             console.group('destroyed 销毁完成状态===============》'); 69             console.log(\"%c%s\", \"color:red\", \"el     : \" + this.$el); 70 console.log(this.$el); 71             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); 72 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message) 73 } 74 }) 75 script>\n76 body>\n77 html>\n\n生命周期\n\n1.  [beforeCreate](https://cn.vuejs.org/v2/api/#beforeCreate)\n2.  [created](https://cn.vuejs.org/v2/api/#created)\n3.  [beforeMount](https://cn.vuejs.org/v2/api/#beforeMount)\n4.  [mounted](https://cn.vuejs.org/v2/api/#mounted)\n5.  [beforeUpdate](https://cn.vuejs.org/v2/api/#beforeUpdate)\n6.  [updated](https://cn.vuejs.org/v2/api/#updated)\n7.  [activated](https://cn.vuejs.org/v2/api/#activated)\n8.  [deactivated](https://cn.vuejs.org/v2/api/#deactivated)\n9.  [beforeDestroy](https://cn.vuejs.org/v2/api/#beforeDestroy)\n10. [destroyed](https://cn.vuejs.org/v2/api/#destroyed)\n\n### 详解：\n\n1.  `beforeCreate`  \n    **官方说明：**在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。  \n    **解释：**这个时期，this 变量还不能使用，在 data 下的数据，和 methods 下的方法，watcher 中的事件都不能获得到；\n\n         beforeCreate() {\n           console.log(this.page); // undefined\n           console.log{this.showPage); // undefined\n         },\n         data() {\n           return {\n             page: 123\n           }\n         },\n         methods: {\n           showPage() {\n             console.log(this.page);\n           }\n         }\n\n2.  `created`  \n    **官方说明：**实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，\\$el 属性目前不可见。  \n    **解释说明：** 这个时候可以操作 vue 实例中的数据和各种方法，但是还不能对\"dom\"节点进行操作；\n\n         created() {\n           console.log(this.page); // 123\n           console.log{this.showPage); // ...\n           $('select').select2(); // jQuery插件需要操作相关dom，不会起作用\n         },\n         data() {\n           return {\n             page: 123\n           }\n         },\n         methods: {\n           showPage() {\n             console.log(this.page);\n           }\n         }\n\n3.  `beforeMounte`  \n    **官方说明：**在挂载开始之前被调用：相关的 render 函数首次被调用。\n\n4.  `mounted`  \n    **官方说明：**`el` 被新创建的 `vm.$el` 替换，并挂载到实例上去之后调用该钩子。如果`root`实例挂载了一个文档内元素，当 `mounted` 被调用时 `vm.$el` 也在文档内。  \n    **解释说明：**挂载完毕，这时`dom`节点被渲染到文档内，一些需要`dom`的操作在此时才能正常进行\n\n         mounted() {\n           $('select').select2(); // jQuery插件可以正常使用\n         },\n\n这时初始化插件没有问题，插件能正常运行，但是这并不代表万事大吉；下面思考一个问题：\n\n![select2](//upload-images.jianshu.io/upload_images/2480162-963129596d325d26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nselect2\n\n图中的`select`的`option`都是通过异步请求得到的，然后通过`v-for`渲染进去，到此一切看起来很正常。**还有一个需求**是当页面刷新后要保留上次一查询的条件。我通过`vue-router`来给`select`指定一个默认选项；\n\n那么问题就来了，`option`的获得是一个异步请求，那这个请求完成的时刻和`mounted`的顺序是什么？如果`mounted`在请求成功之前执行，那将很遗憾——默认选项会设置失败\n\n![option有默认效果的是130，select中的值还是保持全部](//upload-images.jianshu.io/upload_images/2480162-5f3d7b05331886c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\noption 有默认效果的是 130，select 中的值还是保持全部\n\n什么时候执行`$('select').select2()`，是解决这个问题的关键。大家肯定猜到了，mounted 的确是在请求成功之前执行的，所以这时的办法就是将`$('select').select2()`的执行放到请求成功的回调里执行：\n\n      $.getJSON(urls.agentAndCity, {pageType: this.pageType}, (res) => {\n        const a = this.agentList,\n        d = res.data;\n        a.id = d.orgIds;\n        a.name = d.orgNames;\n        a.city = d.cityMap;\n        $('select').select2()；\n      });\n\n本以为这样就完美解决了，但是发现还是会出现和上图一样的效果；如何是好？这时轮到[vm.\\$nextTick](https://cn.vuejs.org/v2/api/#vm-nextTick-callback)登场了：  \n**说明：** 将回调延迟到下次 `DOM` 更新循环之后执行。在修改数据之后立即使用它，然后等待 `DOM` 更新。  \n官方示例代码：\n\n        new Vue({\n          // ...\n          methods: {\n          // ...\n          example: function () {\n          // 修改数据\n          this.message = 'changed'\n          // DOM 还没有更新\n            this.$nextTick(function () {\n              // DOM 现在更新了\n              // `this` 绑定到当前实例\n              this.doSomethingElse()\n            })\n          }\n        }\n      })\n\n所以我的解决办法如下：\n\n    $.getJSON(urls.agentAndCity, {pageType: this.pageType}, (res) => {\n        const a = this.agentList,\n        d = res.data;\n        a.id = d.orgIds;\n        a.name = d.orgNames;\n        a.city = d.cityMap;\n        this.$nextTick(() => {\n          $('select').select2();\n        });\n      });\n\n至此这个问题才算比较满意的解决\n","source":"_posts/2017-08-26-对vue生命周期钩子函数的理解.md","raw":"---\ntitle: 对vue生命周期/钩子函数的理解\ntags:\n  - vue\ndate: 2017-08-26 06:30:00\ncategories: 前端\n---\n\n对于实现页面逻辑交互等效果，我们必须知晓 vue 的生命周期，才能愉快的玩耍，知道我们写的东西应该挂载到哪里，vue 官方给出的 api 讲解的那叫一个简单啊，如下：\n\n所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着**你不能使用箭头函数来定义一个生命周期方法**(例如 created: () => this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。\n\n下面附加一张生命周期图示\n\n![](//upload-images.jianshu.io/upload_images/2615941-444e7f8762fd0ef3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/1213869-20170826142620121-2040456715.png)\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/ContractedBlock-1.gif)![](http://www.jixiaokang.com/wp-content/uploads/2018/05/ExpandedBlockStart-1.gif)\n\n1 DOCTYPE html>\n2 <html>\n3 <head>\n4 <title>title>\n5 <meta charset=\"utf-8\">\n6 <script type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/vue/2.1.3/vue.js\">script>\n7 head>\n8 <body>\n9\n10 <div id=\"app\">\n11 <p>{ { message }}p>\n12 div>\n13\n14 <script type=\"text/javascript\">\n15 var app = new Vue({ 16 el: '#app', 17 data: { 18 message: \"this is a test\"\n19 }, 20 beforeCreate: function () { 21 console.group('beforeCreate 创建前状态===============》'); 22 console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); //undefined\n23             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); //undefined\n24 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message) 25 }, 26 created: function () { 27 console.group('created 创建完毕状态===============》'); 28 console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); //undefined\n29             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); //已被初始化\n30 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); //已被初始化\n31 }, 32 beforeMount: function () { 33 console.group('beforeMount 挂载前状态===============》'); 34 console.log(\"%c%s\", \"color:red\", \"el : \" + (this.$el)); //已被初始化\n35             console.log(this.$el); 36 console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); //已被初始化\n37             console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); //已被初始化\n38 }, 39 mounted: function () { 40             console.group('mounted 挂载结束状态===============》'); 41             console.log(\"%c%s\", \"color:red\", \"el     : \" + this.$el); //已被初始化\n42 console.log(this.$el); 43             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); //已被初始化\n44 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); //已被初始化\n45 }, 46 beforeUpdate: function () { 47 console.group('beforeUpdate 更新前状态===============》'); 48 console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); 49             console.log(this.$el); 50 console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); 51             console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); 52 }, 53 updated: function () { 54             console.group('updated 更新完成状态===============》'); 55             console.log(\"%c%s\", \"color:red\", \"el     : \" + this.$el); 56 console.log(this.$el); 57             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); 58 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); 59 }, 60 beforeDestroy: function () { 61 console.group('beforeDestroy 销毁前状态===============》'); 62 console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); 63             console.log(this.$el); 64 console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); 65             console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); 66 }, 67 destroyed: function () { 68             console.group('destroyed 销毁完成状态===============》'); 69             console.log(\"%c%s\", \"color:red\", \"el     : \" + this.$el); 70 console.log(this.$el); 71             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); 72 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message) 73 } 74 }) 75 script>\n76 body>\n77 html>\n\n生命周期\n\n1.  [beforeCreate](https://cn.vuejs.org/v2/api/#beforeCreate)\n2.  [created](https://cn.vuejs.org/v2/api/#created)\n3.  [beforeMount](https://cn.vuejs.org/v2/api/#beforeMount)\n4.  [mounted](https://cn.vuejs.org/v2/api/#mounted)\n5.  [beforeUpdate](https://cn.vuejs.org/v2/api/#beforeUpdate)\n6.  [updated](https://cn.vuejs.org/v2/api/#updated)\n7.  [activated](https://cn.vuejs.org/v2/api/#activated)\n8.  [deactivated](https://cn.vuejs.org/v2/api/#deactivated)\n9.  [beforeDestroy](https://cn.vuejs.org/v2/api/#beforeDestroy)\n10. [destroyed](https://cn.vuejs.org/v2/api/#destroyed)\n\n### 详解：\n\n1.  `beforeCreate`  \n    **官方说明：**在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。  \n    **解释：**这个时期，this 变量还不能使用，在 data 下的数据，和 methods 下的方法，watcher 中的事件都不能获得到；\n\n         beforeCreate() {\n           console.log(this.page); // undefined\n           console.log{this.showPage); // undefined\n         },\n         data() {\n           return {\n             page: 123\n           }\n         },\n         methods: {\n           showPage() {\n             console.log(this.page);\n           }\n         }\n\n2.  `created`  \n    **官方说明：**实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，\\$el 属性目前不可见。  \n    **解释说明：** 这个时候可以操作 vue 实例中的数据和各种方法，但是还不能对\"dom\"节点进行操作；\n\n         created() {\n           console.log(this.page); // 123\n           console.log{this.showPage); // ...\n           $('select').select2(); // jQuery插件需要操作相关dom，不会起作用\n         },\n         data() {\n           return {\n             page: 123\n           }\n         },\n         methods: {\n           showPage() {\n             console.log(this.page);\n           }\n         }\n\n3.  `beforeMounte`  \n    **官方说明：**在挂载开始之前被调用：相关的 render 函数首次被调用。\n\n4.  `mounted`  \n    **官方说明：**`el` 被新创建的 `vm.$el` 替换，并挂载到实例上去之后调用该钩子。如果`root`实例挂载了一个文档内元素，当 `mounted` 被调用时 `vm.$el` 也在文档内。  \n    **解释说明：**挂载完毕，这时`dom`节点被渲染到文档内，一些需要`dom`的操作在此时才能正常进行\n\n         mounted() {\n           $('select').select2(); // jQuery插件可以正常使用\n         },\n\n这时初始化插件没有问题，插件能正常运行，但是这并不代表万事大吉；下面思考一个问题：\n\n![select2](//upload-images.jianshu.io/upload_images/2480162-963129596d325d26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nselect2\n\n图中的`select`的`option`都是通过异步请求得到的，然后通过`v-for`渲染进去，到此一切看起来很正常。**还有一个需求**是当页面刷新后要保留上次一查询的条件。我通过`vue-router`来给`select`指定一个默认选项；\n\n那么问题就来了，`option`的获得是一个异步请求，那这个请求完成的时刻和`mounted`的顺序是什么？如果`mounted`在请求成功之前执行，那将很遗憾——默认选项会设置失败\n\n![option有默认效果的是130，select中的值还是保持全部](//upload-images.jianshu.io/upload_images/2480162-5f3d7b05331886c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\noption 有默认效果的是 130，select 中的值还是保持全部\n\n什么时候执行`$('select').select2()`，是解决这个问题的关键。大家肯定猜到了，mounted 的确是在请求成功之前执行的，所以这时的办法就是将`$('select').select2()`的执行放到请求成功的回调里执行：\n\n      $.getJSON(urls.agentAndCity, {pageType: this.pageType}, (res) => {\n        const a = this.agentList,\n        d = res.data;\n        a.id = d.orgIds;\n        a.name = d.orgNames;\n        a.city = d.cityMap;\n        $('select').select2()；\n      });\n\n本以为这样就完美解决了，但是发现还是会出现和上图一样的效果；如何是好？这时轮到[vm.\\$nextTick](https://cn.vuejs.org/v2/api/#vm-nextTick-callback)登场了：  \n**说明：** 将回调延迟到下次 `DOM` 更新循环之后执行。在修改数据之后立即使用它，然后等待 `DOM` 更新。  \n官方示例代码：\n\n        new Vue({\n          // ...\n          methods: {\n          // ...\n          example: function () {\n          // 修改数据\n          this.message = 'changed'\n          // DOM 还没有更新\n            this.$nextTick(function () {\n              // DOM 现在更新了\n              // `this` 绑定到当前实例\n              this.doSomethingElse()\n            })\n          }\n        }\n      })\n\n所以我的解决办法如下：\n\n    $.getJSON(urls.agentAndCity, {pageType: this.pageType}, (res) => {\n        const a = this.agentList,\n        d = res.data;\n        a.id = d.orgIds;\n        a.name = d.orgNames;\n        a.city = d.cityMap;\n        this.$nextTick(() => {\n          $('select').select2();\n        });\n      });\n\n至此这个问题才算比较满意的解决\n","slug":"2017-08-26-对vue生命周期钩子函数的理解","published":1,"updated":"2020-03-14T06:46:33.507Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvmo004d4k8y36mz3uml","content":"<p>对于实现页面逻辑交互等效果，我们必须知晓 vue 的生命周期，才能愉快的玩耍，知道我们写的东西应该挂载到哪里，vue 官方给出的 api 讲解的那叫一个简单啊，如下：</p>\n<p>所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着<strong>你不能使用箭头函数来定义一个生命周期方法</strong>(例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。</p>\n<p>下面附加一张生命周期图示</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/2615941-444e7f8762fd0ef3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1213869-20170826142620121-2040456715.png\" alt=\"\"></p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/ContractedBlock-1.gif\" alt=\"\">)<img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/ExpandedBlockStart-1.gif\" alt=\"\"></p>\n<p>1 DOCTYPE html&gt;<br>2 <html><br>3 <head><br>4 <title>title&gt;<br>5 <meta charset=\"utf-8\"><br>6 <script type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/vue/2.1.3/vue.js\">script><br>7 head><br>8 <body><br>9<br>10 <div id=\"app\"><br>11 <p>{ { message }}p><br>12 div><br>13<br>14 <script type=\"text/javascript\"><br>15 var app = new Vue({ 16 el: '#app', 17 data: { 18 message: \"this is a test\"<br>19 }, 20 beforeCreate: function () { 21 console.group('beforeCreate 创建前状态===============》'); 22 console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); //undefined<br>23             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); //undefined<br>24 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message) 25 }, 26 created: function () { 27 console.group('created 创建完毕状态===============》'); 28 console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); //undefined<br>29             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); //已被初始化<br>30 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); //已被初始化<br>31 }, 32 beforeMount: function () { 33 console.group('beforeMount 挂载前状态===============》'); 34 console.log(\"%c%s\", \"color:red\", \"el : \" + (this.$el)); //已被初始化<br>35             console.log(this.$el); 36 console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); //已被初始化<br>37             console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); //已被初始化<br>38 }, 39 mounted: function () { 40             console.group('mounted 挂载结束状态===============》'); 41             console.log(\"%c%s\", \"color:red\", \"el     : \" + this.$el); //已被初始化<br>42 console.log(this.$el); 43             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); //已被初始化<br>44 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); //已被初始化<br>45 }, 46 beforeUpdate: function () { 47 console.group('beforeUpdate 更新前状态===============》'); 48 console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); 49             console.log(this.$el); 50 console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); 51             console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); 52 }, 53 updated: function () { 54             console.group('updated 更新完成状态===============》'); 55             console.log(\"%c%s\", \"color:red\", \"el     : \" + this.$el); 56 console.log(this.$el); 57             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); 58 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); 59 }, 60 beforeDestroy: function () { 61 console.group('beforeDestroy 销毁前状态===============》'); 62 console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); 63             console.log(this.$el); 64 console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); 65             console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); 66 }, 67 destroyed: function () { 68             console.group('destroyed 销毁完成状态===============》'); 69             console.log(\"%c%s\", \"color:red\", \"el     : \" + this.$el); 70 console.log(this.$el); 71             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); 72 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message) 73 } 74 }) 75 script><br>76 body><br>77 html></p>\n<p>生命周期</p>\n<ol>\n<li><a href=\"https://cn.vuejs.org/v2/api/#beforeCreate\" target=\"_blank\" rel=\"noopener\">beforeCreate</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#created\" target=\"_blank\" rel=\"noopener\">created</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#beforeMount\" target=\"_blank\" rel=\"noopener\">beforeMount</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#mounted\" target=\"_blank\" rel=\"noopener\">mounted</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#beforeUpdate\" target=\"_blank\" rel=\"noopener\">beforeUpdate</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#updated\" target=\"_blank\" rel=\"noopener\">updated</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#activated\" target=\"_blank\" rel=\"noopener\">activated</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#deactivated\" target=\"_blank\" rel=\"noopener\">deactivated</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#beforeDestroy\" target=\"_blank\" rel=\"noopener\">beforeDestroy</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#destroyed\" target=\"_blank\" rel=\"noopener\">destroyed</a></li>\n</ol>\n<h3 id=\"详解：\"><a href=\"#详解：\" class=\"headerlink\" title=\"详解：\"></a>详解：</h3><ol>\n<li><p><code>beforeCreate</code><br><strong>官方说明：</strong>在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。<br><strong>解释：</strong>这个时期，this 变量还不能使用，在 data 下的数据，和 methods 下的方法，watcher 中的事件都不能获得到；</p>\n<pre><code> beforeCreate() {\n   console.log(this.page); // undefined\n   console.log{this.showPage); // undefined\n },\n data() {\n   return {\n     page: 123\n   }\n },\n methods: {\n   showPage() {\n     console.log(this.page);\n   }\n }</code></pre></li>\n<li><p><code>created</code><br><strong>官方说明：</strong>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。<br><strong>解释说明：</strong> 这个时候可以操作 vue 实例中的数据和各种方法，但是还不能对\"dom\"节点进行操作；</p>\n<pre><code> created() {\n   console.log(this.page); // 123\n   console.log{this.showPage); // ...\n   $(&#39;select&#39;).select2(); // jQuery插件需要操作相关dom，不会起作用\n },\n data() {\n   return {\n     page: 123\n   }\n },\n methods: {\n   showPage() {\n     console.log(this.page);\n   }\n }</code></pre></li>\n<li><p><code>beforeMounte</code><br><strong>官方说明：</strong>在挂载开始之前被调用：相关的 render 函数首次被调用。</p>\n</li>\n<li><p><code>mounted</code><br><strong>官方说明：</strong><code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果<code>root</code>实例挂载了一个文档内元素，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。<br><strong>解释说明：</strong>挂载完毕，这时<code>dom</code>节点被渲染到文档内，一些需要<code>dom</code>的操作在此时才能正常进行</p>\n<pre><code> mounted() {\n   $(&#39;select&#39;).select2(); // jQuery插件可以正常使用\n },</code></pre></li>\n</ol>\n<p>这时初始化插件没有问题，插件能正常运行，但是这并不代表万事大吉；下面思考一个问题：</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/2480162-963129596d325d26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"select2\"></p>\n<p>select2</p>\n<p>图中的<code>select</code>的<code>option</code>都是通过异步请求得到的，然后通过<code>v-for</code>渲染进去，到此一切看起来很正常。<strong>还有一个需求</strong>是当页面刷新后要保留上次一查询的条件。我通过<code>vue-router</code>来给<code>select</code>指定一个默认选项；</p>\n<p>那么问题就来了，<code>option</code>的获得是一个异步请求，那这个请求完成的时刻和<code>mounted</code>的顺序是什么？如果<code>mounted</code>在请求成功之前执行，那将很遗憾——默认选项会设置失败</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/2480162-5f3d7b05331886c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"option有默认效果的是130，select中的值还是保持全部\"></p>\n<p>option 有默认效果的是 130，select 中的值还是保持全部</p>\n<p>什么时候执行<code>$(&#39;select&#39;).select2()</code>，是解决这个问题的关键。大家肯定猜到了，mounted 的确是在请求成功之前执行的，所以这时的办法就是将<code>$(&#39;select&#39;).select2()</code>的执行放到请求成功的回调里执行：</p>\n<pre><code>  $.getJSON(urls.agentAndCity, {pageType: this.pageType}, (res) =&gt; {\n    const a = this.agentList,\n    d = res.data;\n    a.id = d.orgIds;\n    a.name = d.orgNames;\n    a.city = d.cityMap;\n    $(&#39;select&#39;).select2()；\n  });</code></pre><p>本以为这样就完美解决了，但是发现还是会出现和上图一样的效果；如何是好？这时轮到<a href=\"https://cn.vuejs.org/v2/api/#vm-nextTick-callback\" target=\"_blank\" rel=\"noopener\">vm.$nextTick</a>登场了：<br><strong>说明：</strong> 将回调延迟到下次 <code>DOM</code> 更新循环之后执行。在修改数据之后立即使用它，然后等待 <code>DOM</code> 更新。<br>官方示例代码：</p>\n<pre><code>    new Vue({\n      // ...\n      methods: {\n      // ...\n      example: function () {\n      // 修改数据\n      this.message = &#39;changed&#39;\n      // DOM 还没有更新\n        this.$nextTick(function () {\n          // DOM 现在更新了\n          // `this` 绑定到当前实例\n          this.doSomethingElse()\n        })\n      }\n    }\n  })</code></pre><p>所以我的解决办法如下：</p>\n<pre><code>$.getJSON(urls.agentAndCity, {pageType: this.pageType}, (res) =&gt; {\n    const a = this.agentList,\n    d = res.data;\n    a.id = d.orgIds;\n    a.name = d.orgNames;\n    a.city = d.cityMap;\n    this.$nextTick(() =&gt; {\n      $(&#39;select&#39;).select2();\n    });\n  });</code></pre><p>至此这个问题才算比较满意的解决</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>对于实现页面逻辑交互等效果，我们必须知晓 vue 的生命周期，才能愉快的玩耍，知道我们写的东西应该挂载到哪里，vue 官方给出的 api 讲解的那叫一个简单啊，如下：</p>\n<p>所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着<strong>你不能使用箭头函数来定义一个生命周期方法</strong>(例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。</p>\n<p>下面附加一张生命周期图示</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/2615941-444e7f8762fd0ef3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/1213869-20170826142620121-2040456715.png\" alt=\"\"></p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/ContractedBlock-1.gif\" alt=\"\">)<img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/ExpandedBlockStart-1.gif\" alt=\"\"></p>\n<p>1 DOCTYPE html&gt;<br>2 <html><br>3 <head><br>4 <title>title&gt;<br>5 <meta charset=\"utf-8\"><br>6 <script type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/vue/2.1.3/vue.js\">script><br>7 head><br>8 <body><br>9<br>10 <div id=\"app\"><br>11 <p>{ { message }}p><br>12 div><br>13<br>14 <script type=\"text/javascript\"><br>15 var app = new Vue({ 16 el: '#app', 17 data: { 18 message: \"this is a test\"<br>19 }, 20 beforeCreate: function () { 21 console.group('beforeCreate 创建前状态===============》'); 22 console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); //undefined<br>23             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); //undefined<br>24 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message) 25 }, 26 created: function () { 27 console.group('created 创建完毕状态===============》'); 28 console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); //undefined<br>29             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); //已被初始化<br>30 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); //已被初始化<br>31 }, 32 beforeMount: function () { 33 console.group('beforeMount 挂载前状态===============》'); 34 console.log(\"%c%s\", \"color:red\", \"el : \" + (this.$el)); //已被初始化<br>35             console.log(this.$el); 36 console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); //已被初始化<br>37             console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); //已被初始化<br>38 }, 39 mounted: function () { 40             console.group('mounted 挂载结束状态===============》'); 41             console.log(\"%c%s\", \"color:red\", \"el     : \" + this.$el); //已被初始化<br>42 console.log(this.$el); 43             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); //已被初始化<br>44 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); //已被初始化<br>45 }, 46 beforeUpdate: function () { 47 console.group('beforeUpdate 更新前状态===============》'); 48 console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); 49             console.log(this.$el); 50 console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); 51             console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); 52 }, 53 updated: function () { 54             console.group('updated 更新完成状态===============》'); 55             console.log(\"%c%s\", \"color:red\", \"el     : \" + this.$el); 56 console.log(this.$el); 57             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); 58 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); 59 }, 60 beforeDestroy: function () { 61 console.group('beforeDestroy 销毁前状态===============》'); 62 console.log(\"%c%s\", \"color:red\", \"el : \" + this.$el); 63             console.log(this.$el); 64 console.log(\"%c%s\", \"color:red\", \"data : \" + this.$data); 65             console.log(\"%c%s\", \"color:red\", \"message: \" + this.message); 66 }, 67 destroyed: function () { 68             console.group('destroyed 销毁完成状态===============》'); 69             console.log(\"%c%s\", \"color:red\", \"el     : \" + this.$el); 70 console.log(this.$el); 71             console.log(\"%c%s\", \"color:red\", \"data   : \" + this.$data); 72 console.log(\"%c%s\", \"color:red\", \"message: \" + this.message) 73 } 74 }) 75 script><br>76 body><br>77 html></p>\n<p>生命周期</p>\n<ol>\n<li><a href=\"https://cn.vuejs.org/v2/api/#beforeCreate\" target=\"_blank\" rel=\"noopener\">beforeCreate</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#created\" target=\"_blank\" rel=\"noopener\">created</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#beforeMount\" target=\"_blank\" rel=\"noopener\">beforeMount</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#mounted\" target=\"_blank\" rel=\"noopener\">mounted</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#beforeUpdate\" target=\"_blank\" rel=\"noopener\">beforeUpdate</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#updated\" target=\"_blank\" rel=\"noopener\">updated</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#activated\" target=\"_blank\" rel=\"noopener\">activated</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#deactivated\" target=\"_blank\" rel=\"noopener\">deactivated</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#beforeDestroy\" target=\"_blank\" rel=\"noopener\">beforeDestroy</a></li>\n<li><a href=\"https://cn.vuejs.org/v2/api/#destroyed\" target=\"_blank\" rel=\"noopener\">destroyed</a></li>\n</ol>\n<h3 id=\"详解：\"><a href=\"#详解：\" class=\"headerlink\" title=\"详解：\"></a>详解：</h3><ol>\n<li><p><code>beforeCreate</code><br><strong>官方说明：</strong>在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。<br><strong>解释：</strong>这个时期，this 变量还不能使用，在 data 下的数据，和 methods 下的方法，watcher 中的事件都不能获得到；</p>\n<pre><code> beforeCreate() {\n   console.log(this.page); // undefined\n   console.log{this.showPage); // undefined\n },\n data() {\n   return {\n     page: 123\n   }\n },\n methods: {\n   showPage() {\n     console.log(this.page);\n   }\n }</code></pre></li>\n<li><p><code>created</code><br><strong>官方说明：</strong>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。<br><strong>解释说明：</strong> 这个时候可以操作 vue 实例中的数据和各种方法，但是还不能对\"dom\"节点进行操作；</p>\n<pre><code> created() {\n   console.log(this.page); // 123\n   console.log{this.showPage); // ...\n   $(&#39;select&#39;).select2(); // jQuery插件需要操作相关dom，不会起作用\n },\n data() {\n   return {\n     page: 123\n   }\n },\n methods: {\n   showPage() {\n     console.log(this.page);\n   }\n }</code></pre></li>\n<li><p><code>beforeMounte</code><br><strong>官方说明：</strong>在挂载开始之前被调用：相关的 render 函数首次被调用。</p>\n</li>\n<li><p><code>mounted</code><br><strong>官方说明：</strong><code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果<code>root</code>实例挂载了一个文档内元素，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。<br><strong>解释说明：</strong>挂载完毕，这时<code>dom</code>节点被渲染到文档内，一些需要<code>dom</code>的操作在此时才能正常进行</p>\n<pre><code> mounted() {\n   $(&#39;select&#39;).select2(); // jQuery插件可以正常使用\n },</code></pre></li>\n</ol>\n<p>这时初始化插件没有问题，插件能正常运行，但是这并不代表万事大吉；下面思考一个问题：</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/2480162-963129596d325d26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"select2\"></p>\n<p>select2</p>\n<p>图中的<code>select</code>的<code>option</code>都是通过异步请求得到的，然后通过<code>v-for</code>渲染进去，到此一切看起来很正常。<strong>还有一个需求</strong>是当页面刷新后要保留上次一查询的条件。我通过<code>vue-router</code>来给<code>select</code>指定一个默认选项；</p>\n<p>那么问题就来了，<code>option</code>的获得是一个异步请求，那这个请求完成的时刻和<code>mounted</code>的顺序是什么？如果<code>mounted</code>在请求成功之前执行，那将很遗憾——默认选项会设置失败</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/2480162-5f3d7b05331886c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"option有默认效果的是130，select中的值还是保持全部\"></p>\n<p>option 有默认效果的是 130，select 中的值还是保持全部</p>\n<p>什么时候执行<code>$(&#39;select&#39;).select2()</code>，是解决这个问题的关键。大家肯定猜到了，mounted 的确是在请求成功之前执行的，所以这时的办法就是将<code>$(&#39;select&#39;).select2()</code>的执行放到请求成功的回调里执行：</p>\n<pre><code>  $.getJSON(urls.agentAndCity, {pageType: this.pageType}, (res) =&gt; {\n    const a = this.agentList,\n    d = res.data;\n    a.id = d.orgIds;\n    a.name = d.orgNames;\n    a.city = d.cityMap;\n    $(&#39;select&#39;).select2()；\n  });</code></pre><p>本以为这样就完美解决了，但是发现还是会出现和上图一样的效果；如何是好？这时轮到<a href=\"https://cn.vuejs.org/v2/api/#vm-nextTick-callback\" target=\"_blank\" rel=\"noopener\">vm.$nextTick</a>登场了：<br><strong>说明：</strong> 将回调延迟到下次 <code>DOM</code> 更新循环之后执行。在修改数据之后立即使用它，然后等待 <code>DOM</code> 更新。<br>官方示例代码：</p>\n<pre><code>    new Vue({\n      // ...\n      methods: {\n      // ...\n      example: function () {\n      // 修改数据\n      this.message = &#39;changed&#39;\n      // DOM 还没有更新\n        this.$nextTick(function () {\n          // DOM 现在更新了\n          // `this` 绑定到当前实例\n          this.doSomethingElse()\n        })\n      }\n    }\n  })</code></pre><p>所以我的解决办法如下：</p>\n<pre><code>$.getJSON(urls.agentAndCity, {pageType: this.pageType}, (res) =&gt; {\n    const a = this.agentList,\n    d = res.data;\n    a.id = d.orgIds;\n    a.name = d.orgNames;\n    a.city = d.cityMap;\n    this.$nextTick(() =&gt; {\n      $(&#39;select&#39;).select2();\n    });\n  });</code></pre><p>至此这个问题才算比较满意的解决</p>\n"},{"title":"一篇傻瓜都能看懂的Promises文章","date":"2017-08-31T07:34:00.000Z","_content":"\nJavaScript Promises 其实不难。然而，很多人一开始就觉得有点难理解.。因此我想用一种假设的方式写下我理解 promise。\n\n## （一）理解 promises\n\n举个简单例子：\n\n想象你是一个孩子。你老妈承诺下礼拜 给你买个新手机。你 \\[不知道\\] 你是否会得到手机直到下礼拜。你老妈可以真的买你一个全新的手机，也可以让你滚蛋并告诉你不买了（如果她不高兴了）。\n\n这是一个承诺。一个承诺有 3 个状态。分别是:\n\n1.悬而未决：你 \\[不知道\\] 你是否会得到手机直到下礼拜。\n\n2.解决：你老妈可以真的买你一个全新的手机。\n\n3.拒绝：你老妈拒绝给你买，因为你惹她不高兴。\n\n（二）创建一个 promise\n\n咱们把上面的例子转换成 JavaScript.\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-bddd640f82f57be2996015b83b80c232_b.png)\n\n--\\> 代码表现力挺强的嘛！\n\n1.  “isMomHappy”是个布尔值，定义老妈是否开心。\n2.  “willIGetNewPhone”是一个 promise，这个承诺可以解决(给你买)，也可以拒绝(老妈不开心就不给你买)。.\n3.  还有一个标准语法去定义一个新的 promise，参考[MDN documentation](http://link.zhihu.com/?target=https%3A//developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise)，看下面代码：\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-c5447368a938c1e4637c958bf7309b20_b.png)\n\n1.  需要记住的是，在你定义的 promise 里，当结果是成功的，叫 解决(你的成功值)，如果结果失败了，叫 拒绝（你的失败值）。\n2.  在我们的例子中，如果老妈高兴，我们会得到一个电话。因此，我们称 resolvefunction（电话变量）。如果老妈不高兴，我们称为 拒绝函数（拒绝的理由）；\n\n## （三）玩转 promises\n\n现在有了 promise，咱们就开始玩一玩。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-dd6de543c36c77e4977b9dc160e36992_b.png)\n\n1.  我们有一个函数“askmom”。在这个函数中，我们将使用我们的承诺“ willigetnewphone”。\n2.  当我们的 promise 是解决或者拒绝的时候，我们要做点事儿，我们用“.then & .catch ”来处理我们的行动；\n3.  在“.then”里面有函数“ function(fulfilled) { ... } ”。这个函数的返回值是啥呢？返回值是 promise 解决的值（你的成功时候的值）；在我们的案例中它是一部新电话 。\n4.  在 \".catch\"里面有函数\"function(error){ ... } \"。猜测一下，其实这个返回的是错误值，就是 promise 拒绝的值。\n\n走一下案例看下结果!\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-045efcf752f1e929d6cd45d94004a703_b.jpg)\n\n## （四）链接 promises\n\nPromises 都是可链的。\n\n这样说吧，你，咱例子中的孩子，承诺给你的朋友说：如果你老妈给你买了新手机，就让你的朋友过过眼瘾，你要显摆显摆！\n\n这又是另外一个 promise 了，写成代码看下!\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-9f4668dd366b16e12155fda0e0bf50bd_b.png)\n\n注意：\n\n- 在这个例子中，你可能会意识到我们不叫 拒绝。因为它是可选的。\n- 我们可以缩短这个案例，看代码：\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-a47456668347170c874ace6938f1ea3c_b.png)\n\n咱们现在链接 promise。你，这个孩子只能在得到手机后才能显摆手机。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-c0980c53aa2343c9bf98766fdeb01340_b.png)\n\n--\\> 简单吧！\n\n## （五）promises 都是异步的\n\nPromises 都是异步的，咱们在这个 promise 开始和结束前写一段信息。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-8f7031b7feb2f9138e9fbf9e43cea4ba_b.png)\n\n期望输出的顺序是什么？也许你以为：\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-ab5f509dd4b7fa340e70f18464a7feef_b.png)\n\n然而，实际的输出序列是：\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-5112fc6cb9fe8362dde307decef8cb31_b.png)![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-dcc2a769de96a95e5e313175803175f3_b.jpg)\n\n#### 为啥？因为生活就是不等人的，JavaScript 也是！\n\n你，孩子，不会说不去玩了就干等你老妈的承诺（新手机），对吧。这就是 异步调用，代码将无阻塞运行或等待结果。任何需要等 promise 的行为放在\".then\"里面。\n\n## Promise 在 ES5 /ES6 /ES7 下：\n\n#### ES5 - 大多数的浏览器\n\nES5 不支持 promise，大多数浏览器借助第三方库（[Bluebird](http://link.zhihu.com/?target=http%3A//bluebirdjs.com/docs/getting-started.html) 、[Q](http://link.zhihu.com/?target=https%3A//github.com/kriskowal/q)）的话可以实现；\n\n#### ES6 - 现代浏览器\n\n演示代码是 ok 的，因为 ES6 支持 promise。此外，我们也可以用 ES6 的箭头函数来简化代码。也可以用上 let 和 const。\n\n下面是 ES6 的演示代码：\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-f7a80927108438f8adc8d56aff34d545_b.png)\n\n--\\> 注意到所有的 var 都被 const 取代。所有的函数（解决，拒绝） 都使用箭头函数简化。\n\n#### ES7 - 异步等待使语法看起来更漂亮！\n\nES7 介绍 异步 和 等待 语法。它使异步语法看起来更漂亮、更容易理解，没有 \".then\" 和\".catch\"。\n\n用 ES7 语法来重写我们的例子：\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-ad5f551844f352ed5879b9296160e9e1_b.png)\n\n1.  当你需要在一个函数里面返回一个 promise，你在异步 调用这个函数。例如 案例中的异步函数\"function showOff(phone)\"。\n2.  当你需要一个 promise，你就在等待着 。例如 \"let phone = await willIGetNewPhone;\" & \" let message = await showOff(phone)\"。\n3.  使用 \" try { ... } catch(error) { ... } \" 捕捉 promise 错误/拒绝 。\n\n## 为什么使用 promise？什么时候使用它们？\n\n为什么我们需要 promise？promise 之前的世界是怎样的？在回答这些问题之前，让我们回到最基础的地方。\n\n### 对比正常函数和异步函数\n\n让我们来看看这两个例子，这两个例子执行两个数字相加：\n\n正常函数两个数相加：\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-7655e97e8eac3bad9bf7c6462c71471c_b.png)\n\n异步函数两个数相加：![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-cfc0dae019c56b1bacb9af1b94ae593c_b.png)\n\n如果你用正常的函数让两个数字，你会立即得到结果.。但是，当你发出远程调用来得到结果时，你需要等待，你不能立即得到结果.。\n\n或者这样说，你不知道你是否会得到结果，因为服务器可能会下降，响应速度慢等，你不希望在等待结果的时候，整个进程被阻止。调用 API，下载文件，读取文件中的一些你要执行的常用的异步操作。\n\nPromises 之前的世界：Callback 回调\n\n我们必须使用 promise 来实现异步调用吗？不是的，在 promise 之前，我们使用回调。回调函数只是你得到返回结果时调用的函数.。让我们使用回调修改前面的例子。  \n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-a0c0cc78e15e5ce37898520f433ee9f0_b.png)\n\n异步看起来 ok，为啥还要用 promise 呢?\n\n### 如果你想进行后续的异步操作怎么办？\n\n三个数相加，正常函数这样写：\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-59dc79d91bc6308f1f9dcab7c1f526ec_b.png)\n\n怎么看起来像回调？\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-e49abd186159baff398864f7493f5cf0_b.png)\n\n语法对用户是友好的。有一个更好的术语，它看起来像一个金字塔，但人们通常把这称为“回调地狱”，因为回调嵌套到另一个回调。假设你有 10 的回调，你的代码将嵌套的 10 倍！\n\n### 逃离回调地狱吧！\n\n让 promise 来拯救。让我们来看看同样的例子的 promise 版本。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-137fc3c1c3f2a3064c3c56c19de109dd_b.png)\n\n有了承诺，我们用\".then\"扁平化回调。在某种程度上，因为没有回调嵌套，它看起来干净。当然，用 ES7 异步语法，可以让他看起来更简洁！\n\n## 新家伙：Observables 观测值\n\n在 promise 已经让你很幸福的时候，Observables 这货来锦上添花，让处理异步数据量更容易。\n\n> Observables 是懒惰的事件流，可以发出零个或多个事件，而且可能完成也可能不完成。\n\npromise 和 observable 的关键区别是：\n\n- Observables 观测值是可以取消的\n- Observable 是懒惰的\n\n不要害怕，让我们来看看 Observables 的案例。在这个例子中，关于 Observables 使用 RxJS。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-e7fc7687124a145f61c8ba55afedc011_b.png)\n\nObservables 观测值可以很容易的做一些时髦的东西。看案例：\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-6c2ecaebec8cf5dbf0dbfc800bbd4204_b.png)\n\n好吧，咱们以后再接着讨论 Observables 观测值吧！\n","source":"_posts/2017-08-31-Promises.md","raw":"---\ntitle: 一篇傻瓜都能看懂的Promises文章\ntags:\n  - 技术\ndate: 2017-08-31 15:34:00\ncategories: 前端\n---\n\nJavaScript Promises 其实不难。然而，很多人一开始就觉得有点难理解.。因此我想用一种假设的方式写下我理解 promise。\n\n## （一）理解 promises\n\n举个简单例子：\n\n想象你是一个孩子。你老妈承诺下礼拜 给你买个新手机。你 \\[不知道\\] 你是否会得到手机直到下礼拜。你老妈可以真的买你一个全新的手机，也可以让你滚蛋并告诉你不买了（如果她不高兴了）。\n\n这是一个承诺。一个承诺有 3 个状态。分别是:\n\n1.悬而未决：你 \\[不知道\\] 你是否会得到手机直到下礼拜。\n\n2.解决：你老妈可以真的买你一个全新的手机。\n\n3.拒绝：你老妈拒绝给你买，因为你惹她不高兴。\n\n（二）创建一个 promise\n\n咱们把上面的例子转换成 JavaScript.\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-bddd640f82f57be2996015b83b80c232_b.png)\n\n--\\> 代码表现力挺强的嘛！\n\n1.  “isMomHappy”是个布尔值，定义老妈是否开心。\n2.  “willIGetNewPhone”是一个 promise，这个承诺可以解决(给你买)，也可以拒绝(老妈不开心就不给你买)。.\n3.  还有一个标准语法去定义一个新的 promise，参考[MDN documentation](http://link.zhihu.com/?target=https%3A//developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise)，看下面代码：\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-c5447368a938c1e4637c958bf7309b20_b.png)\n\n1.  需要记住的是，在你定义的 promise 里，当结果是成功的，叫 解决(你的成功值)，如果结果失败了，叫 拒绝（你的失败值）。\n2.  在我们的例子中，如果老妈高兴，我们会得到一个电话。因此，我们称 resolvefunction（电话变量）。如果老妈不高兴，我们称为 拒绝函数（拒绝的理由）；\n\n## （三）玩转 promises\n\n现在有了 promise，咱们就开始玩一玩。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-dd6de543c36c77e4977b9dc160e36992_b.png)\n\n1.  我们有一个函数“askmom”。在这个函数中，我们将使用我们的承诺“ willigetnewphone”。\n2.  当我们的 promise 是解决或者拒绝的时候，我们要做点事儿，我们用“.then & .catch ”来处理我们的行动；\n3.  在“.then”里面有函数“ function(fulfilled) { ... } ”。这个函数的返回值是啥呢？返回值是 promise 解决的值（你的成功时候的值）；在我们的案例中它是一部新电话 。\n4.  在 \".catch\"里面有函数\"function(error){ ... } \"。猜测一下，其实这个返回的是错误值，就是 promise 拒绝的值。\n\n走一下案例看下结果!\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-045efcf752f1e929d6cd45d94004a703_b.jpg)\n\n## （四）链接 promises\n\nPromises 都是可链的。\n\n这样说吧，你，咱例子中的孩子，承诺给你的朋友说：如果你老妈给你买了新手机，就让你的朋友过过眼瘾，你要显摆显摆！\n\n这又是另外一个 promise 了，写成代码看下!\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-9f4668dd366b16e12155fda0e0bf50bd_b.png)\n\n注意：\n\n- 在这个例子中，你可能会意识到我们不叫 拒绝。因为它是可选的。\n- 我们可以缩短这个案例，看代码：\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-a47456668347170c874ace6938f1ea3c_b.png)\n\n咱们现在链接 promise。你，这个孩子只能在得到手机后才能显摆手机。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-c0980c53aa2343c9bf98766fdeb01340_b.png)\n\n--\\> 简单吧！\n\n## （五）promises 都是异步的\n\nPromises 都是异步的，咱们在这个 promise 开始和结束前写一段信息。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-8f7031b7feb2f9138e9fbf9e43cea4ba_b.png)\n\n期望输出的顺序是什么？也许你以为：\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-ab5f509dd4b7fa340e70f18464a7feef_b.png)\n\n然而，实际的输出序列是：\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-5112fc6cb9fe8362dde307decef8cb31_b.png)![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-dcc2a769de96a95e5e313175803175f3_b.jpg)\n\n#### 为啥？因为生活就是不等人的，JavaScript 也是！\n\n你，孩子，不会说不去玩了就干等你老妈的承诺（新手机），对吧。这就是 异步调用，代码将无阻塞运行或等待结果。任何需要等 promise 的行为放在\".then\"里面。\n\n## Promise 在 ES5 /ES6 /ES7 下：\n\n#### ES5 - 大多数的浏览器\n\nES5 不支持 promise，大多数浏览器借助第三方库（[Bluebird](http://link.zhihu.com/?target=http%3A//bluebirdjs.com/docs/getting-started.html) 、[Q](http://link.zhihu.com/?target=https%3A//github.com/kriskowal/q)）的话可以实现；\n\n#### ES6 - 现代浏览器\n\n演示代码是 ok 的，因为 ES6 支持 promise。此外，我们也可以用 ES6 的箭头函数来简化代码。也可以用上 let 和 const。\n\n下面是 ES6 的演示代码：\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-f7a80927108438f8adc8d56aff34d545_b.png)\n\n--\\> 注意到所有的 var 都被 const 取代。所有的函数（解决，拒绝） 都使用箭头函数简化。\n\n#### ES7 - 异步等待使语法看起来更漂亮！\n\nES7 介绍 异步 和 等待 语法。它使异步语法看起来更漂亮、更容易理解，没有 \".then\" 和\".catch\"。\n\n用 ES7 语法来重写我们的例子：\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-ad5f551844f352ed5879b9296160e9e1_b.png)\n\n1.  当你需要在一个函数里面返回一个 promise，你在异步 调用这个函数。例如 案例中的异步函数\"function showOff(phone)\"。\n2.  当你需要一个 promise，你就在等待着 。例如 \"let phone = await willIGetNewPhone;\" & \" let message = await showOff(phone)\"。\n3.  使用 \" try { ... } catch(error) { ... } \" 捕捉 promise 错误/拒绝 。\n\n## 为什么使用 promise？什么时候使用它们？\n\n为什么我们需要 promise？promise 之前的世界是怎样的？在回答这些问题之前，让我们回到最基础的地方。\n\n### 对比正常函数和异步函数\n\n让我们来看看这两个例子，这两个例子执行两个数字相加：\n\n正常函数两个数相加：\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-7655e97e8eac3bad9bf7c6462c71471c_b.png)\n\n异步函数两个数相加：![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-cfc0dae019c56b1bacb9af1b94ae593c_b.png)\n\n如果你用正常的函数让两个数字，你会立即得到结果.。但是，当你发出远程调用来得到结果时，你需要等待，你不能立即得到结果.。\n\n或者这样说，你不知道你是否会得到结果，因为服务器可能会下降，响应速度慢等，你不希望在等待结果的时候，整个进程被阻止。调用 API，下载文件，读取文件中的一些你要执行的常用的异步操作。\n\nPromises 之前的世界：Callback 回调\n\n我们必须使用 promise 来实现异步调用吗？不是的，在 promise 之前，我们使用回调。回调函数只是你得到返回结果时调用的函数.。让我们使用回调修改前面的例子。  \n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-a0c0cc78e15e5ce37898520f433ee9f0_b.png)\n\n异步看起来 ok，为啥还要用 promise 呢?\n\n### 如果你想进行后续的异步操作怎么办？\n\n三个数相加，正常函数这样写：\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-59dc79d91bc6308f1f9dcab7c1f526ec_b.png)\n\n怎么看起来像回调？\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-e49abd186159baff398864f7493f5cf0_b.png)\n\n语法对用户是友好的。有一个更好的术语，它看起来像一个金字塔，但人们通常把这称为“回调地狱”，因为回调嵌套到另一个回调。假设你有 10 的回调，你的代码将嵌套的 10 倍！\n\n### 逃离回调地狱吧！\n\n让 promise 来拯救。让我们来看看同样的例子的 promise 版本。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-137fc3c1c3f2a3064c3c56c19de109dd_b.png)\n\n有了承诺，我们用\".then\"扁平化回调。在某种程度上，因为没有回调嵌套，它看起来干净。当然，用 ES7 异步语法，可以让他看起来更简洁！\n\n## 新家伙：Observables 观测值\n\n在 promise 已经让你很幸福的时候，Observables 这货来锦上添花，让处理异步数据量更容易。\n\n> Observables 是懒惰的事件流，可以发出零个或多个事件，而且可能完成也可能不完成。\n\npromise 和 observable 的关键区别是：\n\n- Observables 观测值是可以取消的\n- Observable 是懒惰的\n\n不要害怕，让我们来看看 Observables 的案例。在这个例子中，关于 Observables 使用 RxJS。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-e7fc7687124a145f61c8ba55afedc011_b.png)\n\nObservables 观测值可以很容易的做一些时髦的东西。看案例：\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-6c2ecaebec8cf5dbf0dbfc800bbd4204_b.png)\n\n好吧，咱们以后再接着讨论 Observables 观测值吧！\n","slug":"2017-08-31-Promises","published":1,"updated":"2020-03-14T06:47:16.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvmq004h4k8y8cpl9ppi","content":"<p>JavaScript Promises 其实不难。然而，很多人一开始就觉得有点难理解.。因此我想用一种假设的方式写下我理解 promise。</p>\n<h2 id=\"（一）理解-promises\"><a href=\"#（一）理解-promises\" class=\"headerlink\" title=\"（一）理解 promises\"></a>（一）理解 promises</h2><p>举个简单例子：</p>\n<p>想象你是一个孩子。你老妈承诺下礼拜 给你买个新手机。你 [不知道] 你是否会得到手机直到下礼拜。你老妈可以真的买你一个全新的手机，也可以让你滚蛋并告诉你不买了（如果她不高兴了）。</p>\n<p>这是一个承诺。一个承诺有 3 个状态。分别是:</p>\n<p>1.悬而未决：你 [不知道] 你是否会得到手机直到下礼拜。</p>\n<p>2.解决：你老妈可以真的买你一个全新的手机。</p>\n<p>3.拒绝：你老妈拒绝给你买，因为你惹她不高兴。</p>\n<p>（二）创建一个 promise</p>\n<p>咱们把上面的例子转换成 JavaScript.</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-bddd640f82f57be2996015b83b80c232_b.png\" alt=\"\"></p>\n<p>–&gt; 代码表现力挺强的嘛！</p>\n<ol>\n<li>“isMomHappy”是个布尔值，定义老妈是否开心。</li>\n<li>“willIGetNewPhone”是一个 promise，这个承诺可以解决(给你买)，也可以拒绝(老妈不开心就不给你买)。.</li>\n<li>还有一个标准语法去定义一个新的 promise，参考<a href=\"http://link.zhihu.com/?target=https%3A//developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise\">MDN documentation</a>，看下面代码：</li>\n</ol>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-c5447368a938c1e4637c958bf7309b20_b.png\" alt=\"\"></p>\n<ol>\n<li>需要记住的是，在你定义的 promise 里，当结果是成功的，叫 解决(你的成功值)，如果结果失败了，叫 拒绝（你的失败值）。</li>\n<li>在我们的例子中，如果老妈高兴，我们会得到一个电话。因此，我们称 resolvefunction（电话变量）。如果老妈不高兴，我们称为 拒绝函数（拒绝的理由）；</li>\n</ol>\n<h2 id=\"（三）玩转-promises\"><a href=\"#（三）玩转-promises\" class=\"headerlink\" title=\"（三）玩转 promises\"></a>（三）玩转 promises</h2><p>现在有了 promise，咱们就开始玩一玩。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-dd6de543c36c77e4977b9dc160e36992_b.png\" alt=\"\"></p>\n<ol>\n<li>我们有一个函数“askmom”。在这个函数中，我们将使用我们的承诺“ willigetnewphone”。</li>\n<li>当我们的 promise 是解决或者拒绝的时候，我们要做点事儿，我们用“.then &amp; .catch ”来处理我们的行动；</li>\n<li>在“.then”里面有函数“ function(fulfilled) { … } ”。这个函数的返回值是啥呢？返回值是 promise 解决的值（你的成功时候的值）；在我们的案例中它是一部新电话 。</li>\n<li>在 “.catch”里面有函数”function(error){ … } “。猜测一下，其实这个返回的是错误值，就是 promise 拒绝的值。</li>\n</ol>\n<p>走一下案例看下结果!</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-045efcf752f1e929d6cd45d94004a703_b.jpg\" alt=\"\"></p>\n<h2 id=\"（四）链接-promises\"><a href=\"#（四）链接-promises\" class=\"headerlink\" title=\"（四）链接 promises\"></a>（四）链接 promises</h2><p>Promises 都是可链的。</p>\n<p>这样说吧，你，咱例子中的孩子，承诺给你的朋友说：如果你老妈给你买了新手机，就让你的朋友过过眼瘾，你要显摆显摆！</p>\n<p>这又是另外一个 promise 了，写成代码看下!</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-9f4668dd366b16e12155fda0e0bf50bd_b.png\" alt=\"\"></p>\n<p>注意：</p>\n<ul>\n<li>在这个例子中，你可能会意识到我们不叫 拒绝。因为它是可选的。</li>\n<li>我们可以缩短这个案例，看代码：</li>\n</ul>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-a47456668347170c874ace6938f1ea3c_b.png\" alt=\"\"></p>\n<p>咱们现在链接 promise。你，这个孩子只能在得到手机后才能显摆手机。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-c0980c53aa2343c9bf98766fdeb01340_b.png\" alt=\"\"></p>\n<p>–&gt; 简单吧！</p>\n<h2 id=\"（五）promises-都是异步的\"><a href=\"#（五）promises-都是异步的\" class=\"headerlink\" title=\"（五）promises 都是异步的\"></a>（五）promises 都是异步的</h2><p>Promises 都是异步的，咱们在这个 promise 开始和结束前写一段信息。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-8f7031b7feb2f9138e9fbf9e43cea4ba_b.png\" alt=\"\"></p>\n<p>期望输出的顺序是什么？也许你以为：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-ab5f509dd4b7fa340e70f18464a7feef_b.png\" alt=\"\"></p>\n<p>然而，实际的输出序列是：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-5112fc6cb9fe8362dde307decef8cb31_b.png\" alt=\"\">)<img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-dcc2a769de96a95e5e313175803175f3_b.jpg\" alt=\"\"></p>\n<h4 id=\"为啥？因为生活就是不等人的，JavaScript-也是！\"><a href=\"#为啥？因为生活就是不等人的，JavaScript-也是！\" class=\"headerlink\" title=\"为啥？因为生活就是不等人的，JavaScript 也是！\"></a>为啥？因为生活就是不等人的，JavaScript 也是！</h4><p>你，孩子，不会说不去玩了就干等你老妈的承诺（新手机），对吧。这就是 异步调用，代码将无阻塞运行或等待结果。任何需要等 promise 的行为放在”.then”里面。</p>\n<h2 id=\"Promise-在-ES5-ES6-ES7-下：\"><a href=\"#Promise-在-ES5-ES6-ES7-下：\" class=\"headerlink\" title=\"Promise 在 ES5 /ES6 /ES7 下：\"></a>Promise 在 ES5 /ES6 /ES7 下：</h2><h4 id=\"ES5-大多数的浏览器\"><a href=\"#ES5-大多数的浏览器\" class=\"headerlink\" title=\"ES5 - 大多数的浏览器\"></a>ES5 - 大多数的浏览器</h4><p>ES5 不支持 promise，大多数浏览器借助第三方库（<a href=\"http://link.zhihu.com/?target=http%3A//bluebirdjs.com/docs/getting-started.html\">Bluebird</a> 、<a href=\"http://link.zhihu.com/?target=https%3A//github.com/kriskowal/q\">Q</a>）的话可以实现；</p>\n<h4 id=\"ES6-现代浏览器\"><a href=\"#ES6-现代浏览器\" class=\"headerlink\" title=\"ES6 - 现代浏览器\"></a>ES6 - 现代浏览器</h4><p>演示代码是 ok 的，因为 ES6 支持 promise。此外，我们也可以用 ES6 的箭头函数来简化代码。也可以用上 let 和 const。</p>\n<p>下面是 ES6 的演示代码：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-f7a80927108438f8adc8d56aff34d545_b.png\" alt=\"\"></p>\n<p>–&gt; 注意到所有的 var 都被 const 取代。所有的函数（解决，拒绝） 都使用箭头函数简化。</p>\n<h4 id=\"ES7-异步等待使语法看起来更漂亮！\"><a href=\"#ES7-异步等待使语法看起来更漂亮！\" class=\"headerlink\" title=\"ES7 - 异步等待使语法看起来更漂亮！\"></a>ES7 - 异步等待使语法看起来更漂亮！</h4><p>ES7 介绍 异步 和 等待 语法。它使异步语法看起来更漂亮、更容易理解，没有 “.then” 和”.catch”。</p>\n<p>用 ES7 语法来重写我们的例子：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-ad5f551844f352ed5879b9296160e9e1_b.png\" alt=\"\"></p>\n<ol>\n<li>当你需要在一个函数里面返回一个 promise，你在异步 调用这个函数。例如 案例中的异步函数”function showOff(phone)”。</li>\n<li>当你需要一个 promise，你就在等待着 。例如 “let phone = await willIGetNewPhone;” &amp; “ let message = await showOff(phone)”。</li>\n<li>使用 “ try { … } catch(error) { … } “ 捕捉 promise 错误/拒绝 。</li>\n</ol>\n<h2 id=\"为什么使用-promise？什么时候使用它们？\"><a href=\"#为什么使用-promise？什么时候使用它们？\" class=\"headerlink\" title=\"为什么使用 promise？什么时候使用它们？\"></a>为什么使用 promise？什么时候使用它们？</h2><p>为什么我们需要 promise？promise 之前的世界是怎样的？在回答这些问题之前，让我们回到最基础的地方。</p>\n<h3 id=\"对比正常函数和异步函数\"><a href=\"#对比正常函数和异步函数\" class=\"headerlink\" title=\"对比正常函数和异步函数\"></a>对比正常函数和异步函数</h3><p>让我们来看看这两个例子，这两个例子执行两个数字相加：</p>\n<p>正常函数两个数相加：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-7655e97e8eac3bad9bf7c6462c71471c_b.png\" alt=\"\"></p>\n<p>异步函数两个数相加：<img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-cfc0dae019c56b1bacb9af1b94ae593c_b.png\" alt=\"\"></p>\n<p>如果你用正常的函数让两个数字，你会立即得到结果.。但是，当你发出远程调用来得到结果时，你需要等待，你不能立即得到结果.。</p>\n<p>或者这样说，你不知道你是否会得到结果，因为服务器可能会下降，响应速度慢等，你不希望在等待结果的时候，整个进程被阻止。调用 API，下载文件，读取文件中的一些你要执行的常用的异步操作。</p>\n<p>Promises 之前的世界：Callback 回调</p>\n<p>我们必须使用 promise 来实现异步调用吗？不是的，在 promise 之前，我们使用回调。回调函数只是你得到返回结果时调用的函数.。让我们使用回调修改前面的例子。<br><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-a0c0cc78e15e5ce37898520f433ee9f0_b.png\" alt=\"\"></p>\n<p>异步看起来 ok，为啥还要用 promise 呢?</p>\n<h3 id=\"如果你想进行后续的异步操作怎么办？\"><a href=\"#如果你想进行后续的异步操作怎么办？\" class=\"headerlink\" title=\"如果你想进行后续的异步操作怎么办？\"></a>如果你想进行后续的异步操作怎么办？</h3><p>三个数相加，正常函数这样写：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-59dc79d91bc6308f1f9dcab7c1f526ec_b.png\" alt=\"\"></p>\n<p>怎么看起来像回调？</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-e49abd186159baff398864f7493f5cf0_b.png\" alt=\"\"></p>\n<p>语法对用户是友好的。有一个更好的术语，它看起来像一个金字塔，但人们通常把这称为“回调地狱”，因为回调嵌套到另一个回调。假设你有 10 的回调，你的代码将嵌套的 10 倍！</p>\n<h3 id=\"逃离回调地狱吧！\"><a href=\"#逃离回调地狱吧！\" class=\"headerlink\" title=\"逃离回调地狱吧！\"></a>逃离回调地狱吧！</h3><p>让 promise 来拯救。让我们来看看同样的例子的 promise 版本。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-137fc3c1c3f2a3064c3c56c19de109dd_b.png\" alt=\"\"></p>\n<p>有了承诺，我们用”.then”扁平化回调。在某种程度上，因为没有回调嵌套，它看起来干净。当然，用 ES7 异步语法，可以让他看起来更简洁！</p>\n<h2 id=\"新家伙：Observables-观测值\"><a href=\"#新家伙：Observables-观测值\" class=\"headerlink\" title=\"新家伙：Observables 观测值\"></a>新家伙：Observables 观测值</h2><p>在 promise 已经让你很幸福的时候，Observables 这货来锦上添花，让处理异步数据量更容易。</p>\n<blockquote>\n<p>Observables 是懒惰的事件流，可以发出零个或多个事件，而且可能完成也可能不完成。</p>\n</blockquote>\n<p>promise 和 observable 的关键区别是：</p>\n<ul>\n<li>Observables 观测值是可以取消的</li>\n<li>Observable 是懒惰的</li>\n</ul>\n<p>不要害怕，让我们来看看 Observables 的案例。在这个例子中，关于 Observables 使用 RxJS。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-e7fc7687124a145f61c8ba55afedc011_b.png\" alt=\"\"></p>\n<p>Observables 观测值可以很容易的做一些时髦的东西。看案例：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-6c2ecaebec8cf5dbf0dbfc800bbd4204_b.png\" alt=\"\"></p>\n<p>好吧，咱们以后再接着讨论 Observables 观测值吧！</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>JavaScript Promises 其实不难。然而，很多人一开始就觉得有点难理解.。因此我想用一种假设的方式写下我理解 promise。</p>\n<h2 id=\"（一）理解-promises\"><a href=\"#（一）理解-promises\" class=\"headerlink\" title=\"（一）理解 promises\"></a>（一）理解 promises</h2><p>举个简单例子：</p>\n<p>想象你是一个孩子。你老妈承诺下礼拜 给你买个新手机。你 [不知道] 你是否会得到手机直到下礼拜。你老妈可以真的买你一个全新的手机，也可以让你滚蛋并告诉你不买了（如果她不高兴了）。</p>\n<p>这是一个承诺。一个承诺有 3 个状态。分别是:</p>\n<p>1.悬而未决：你 [不知道] 你是否会得到手机直到下礼拜。</p>\n<p>2.解决：你老妈可以真的买你一个全新的手机。</p>\n<p>3.拒绝：你老妈拒绝给你买，因为你惹她不高兴。</p>\n<p>（二）创建一个 promise</p>\n<p>咱们把上面的例子转换成 JavaScript.</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-bddd640f82f57be2996015b83b80c232_b.png\" alt=\"\"></p>\n<p>–&gt; 代码表现力挺强的嘛！</p>\n<ol>\n<li>“isMomHappy”是个布尔值，定义老妈是否开心。</li>\n<li>“willIGetNewPhone”是一个 promise，这个承诺可以解决(给你买)，也可以拒绝(老妈不开心就不给你买)。.</li>\n<li>还有一个标准语法去定义一个新的 promise，参考<a href=\"http://link.zhihu.com/?target=https%3A//developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise\">MDN documentation</a>，看下面代码：</li>\n</ol>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-c5447368a938c1e4637c958bf7309b20_b.png\" alt=\"\"></p>\n<ol>\n<li>需要记住的是，在你定义的 promise 里，当结果是成功的，叫 解决(你的成功值)，如果结果失败了，叫 拒绝（你的失败值）。</li>\n<li>在我们的例子中，如果老妈高兴，我们会得到一个电话。因此，我们称 resolvefunction（电话变量）。如果老妈不高兴，我们称为 拒绝函数（拒绝的理由）；</li>\n</ol>\n<h2 id=\"（三）玩转-promises\"><a href=\"#（三）玩转-promises\" class=\"headerlink\" title=\"（三）玩转 promises\"></a>（三）玩转 promises</h2><p>现在有了 promise，咱们就开始玩一玩。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-dd6de543c36c77e4977b9dc160e36992_b.png\" alt=\"\"></p>\n<ol>\n<li>我们有一个函数“askmom”。在这个函数中，我们将使用我们的承诺“ willigetnewphone”。</li>\n<li>当我们的 promise 是解决或者拒绝的时候，我们要做点事儿，我们用“.then &amp; .catch ”来处理我们的行动；</li>\n<li>在“.then”里面有函数“ function(fulfilled) { … } ”。这个函数的返回值是啥呢？返回值是 promise 解决的值（你的成功时候的值）；在我们的案例中它是一部新电话 。</li>\n<li>在 “.catch”里面有函数”function(error){ … } “。猜测一下，其实这个返回的是错误值，就是 promise 拒绝的值。</li>\n</ol>\n<p>走一下案例看下结果!</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-045efcf752f1e929d6cd45d94004a703_b.jpg\" alt=\"\"></p>\n<h2 id=\"（四）链接-promises\"><a href=\"#（四）链接-promises\" class=\"headerlink\" title=\"（四）链接 promises\"></a>（四）链接 promises</h2><p>Promises 都是可链的。</p>\n<p>这样说吧，你，咱例子中的孩子，承诺给你的朋友说：如果你老妈给你买了新手机，就让你的朋友过过眼瘾，你要显摆显摆！</p>\n<p>这又是另外一个 promise 了，写成代码看下!</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-9f4668dd366b16e12155fda0e0bf50bd_b.png\" alt=\"\"></p>\n<p>注意：</p>\n<ul>\n<li>在这个例子中，你可能会意识到我们不叫 拒绝。因为它是可选的。</li>\n<li>我们可以缩短这个案例，看代码：</li>\n</ul>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-a47456668347170c874ace6938f1ea3c_b.png\" alt=\"\"></p>\n<p>咱们现在链接 promise。你，这个孩子只能在得到手机后才能显摆手机。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-c0980c53aa2343c9bf98766fdeb01340_b.png\" alt=\"\"></p>\n<p>–&gt; 简单吧！</p>\n<h2 id=\"（五）promises-都是异步的\"><a href=\"#（五）promises-都是异步的\" class=\"headerlink\" title=\"（五）promises 都是异步的\"></a>（五）promises 都是异步的</h2><p>Promises 都是异步的，咱们在这个 promise 开始和结束前写一段信息。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-8f7031b7feb2f9138e9fbf9e43cea4ba_b.png\" alt=\"\"></p>\n<p>期望输出的顺序是什么？也许你以为：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-ab5f509dd4b7fa340e70f18464a7feef_b.png\" alt=\"\"></p>\n<p>然而，实际的输出序列是：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-5112fc6cb9fe8362dde307decef8cb31_b.png\" alt=\"\">)<img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-dcc2a769de96a95e5e313175803175f3_b.jpg\" alt=\"\"></p>\n<h4 id=\"为啥？因为生活就是不等人的，JavaScript-也是！\"><a href=\"#为啥？因为生活就是不等人的，JavaScript-也是！\" class=\"headerlink\" title=\"为啥？因为生活就是不等人的，JavaScript 也是！\"></a>为啥？因为生活就是不等人的，JavaScript 也是！</h4><p>你，孩子，不会说不去玩了就干等你老妈的承诺（新手机），对吧。这就是 异步调用，代码将无阻塞运行或等待结果。任何需要等 promise 的行为放在”.then”里面。</p>\n<h2 id=\"Promise-在-ES5-ES6-ES7-下：\"><a href=\"#Promise-在-ES5-ES6-ES7-下：\" class=\"headerlink\" title=\"Promise 在 ES5 /ES6 /ES7 下：\"></a>Promise 在 ES5 /ES6 /ES7 下：</h2><h4 id=\"ES5-大多数的浏览器\"><a href=\"#ES5-大多数的浏览器\" class=\"headerlink\" title=\"ES5 - 大多数的浏览器\"></a>ES5 - 大多数的浏览器</h4><p>ES5 不支持 promise，大多数浏览器借助第三方库（<a href=\"http://link.zhihu.com/?target=http%3A//bluebirdjs.com/docs/getting-started.html\">Bluebird</a> 、<a href=\"http://link.zhihu.com/?target=https%3A//github.com/kriskowal/q\">Q</a>）的话可以实现；</p>\n<h4 id=\"ES6-现代浏览器\"><a href=\"#ES6-现代浏览器\" class=\"headerlink\" title=\"ES6 - 现代浏览器\"></a>ES6 - 现代浏览器</h4><p>演示代码是 ok 的，因为 ES6 支持 promise。此外，我们也可以用 ES6 的箭头函数来简化代码。也可以用上 let 和 const。</p>\n<p>下面是 ES6 的演示代码：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-f7a80927108438f8adc8d56aff34d545_b.png\" alt=\"\"></p>\n<p>–&gt; 注意到所有的 var 都被 const 取代。所有的函数（解决，拒绝） 都使用箭头函数简化。</p>\n<h4 id=\"ES7-异步等待使语法看起来更漂亮！\"><a href=\"#ES7-异步等待使语法看起来更漂亮！\" class=\"headerlink\" title=\"ES7 - 异步等待使语法看起来更漂亮！\"></a>ES7 - 异步等待使语法看起来更漂亮！</h4><p>ES7 介绍 异步 和 等待 语法。它使异步语法看起来更漂亮、更容易理解，没有 “.then” 和”.catch”。</p>\n<p>用 ES7 语法来重写我们的例子：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-ad5f551844f352ed5879b9296160e9e1_b.png\" alt=\"\"></p>\n<ol>\n<li>当你需要在一个函数里面返回一个 promise，你在异步 调用这个函数。例如 案例中的异步函数”function showOff(phone)”。</li>\n<li>当你需要一个 promise，你就在等待着 。例如 “let phone = await willIGetNewPhone;” &amp; “ let message = await showOff(phone)”。</li>\n<li>使用 “ try { … } catch(error) { … } “ 捕捉 promise 错误/拒绝 。</li>\n</ol>\n<h2 id=\"为什么使用-promise？什么时候使用它们？\"><a href=\"#为什么使用-promise？什么时候使用它们？\" class=\"headerlink\" title=\"为什么使用 promise？什么时候使用它们？\"></a>为什么使用 promise？什么时候使用它们？</h2><p>为什么我们需要 promise？promise 之前的世界是怎样的？在回答这些问题之前，让我们回到最基础的地方。</p>\n<h3 id=\"对比正常函数和异步函数\"><a href=\"#对比正常函数和异步函数\" class=\"headerlink\" title=\"对比正常函数和异步函数\"></a>对比正常函数和异步函数</h3><p>让我们来看看这两个例子，这两个例子执行两个数字相加：</p>\n<p>正常函数两个数相加：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-7655e97e8eac3bad9bf7c6462c71471c_b.png\" alt=\"\"></p>\n<p>异步函数两个数相加：<img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-cfc0dae019c56b1bacb9af1b94ae593c_b.png\" alt=\"\"></p>\n<p>如果你用正常的函数让两个数字，你会立即得到结果.。但是，当你发出远程调用来得到结果时，你需要等待，你不能立即得到结果.。</p>\n<p>或者这样说，你不知道你是否会得到结果，因为服务器可能会下降，响应速度慢等，你不希望在等待结果的时候，整个进程被阻止。调用 API，下载文件，读取文件中的一些你要执行的常用的异步操作。</p>\n<p>Promises 之前的世界：Callback 回调</p>\n<p>我们必须使用 promise 来实现异步调用吗？不是的，在 promise 之前，我们使用回调。回调函数只是你得到返回结果时调用的函数.。让我们使用回调修改前面的例子。<br><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-a0c0cc78e15e5ce37898520f433ee9f0_b.png\" alt=\"\"></p>\n<p>异步看起来 ok，为啥还要用 promise 呢?</p>\n<h3 id=\"如果你想进行后续的异步操作怎么办？\"><a href=\"#如果你想进行后续的异步操作怎么办？\" class=\"headerlink\" title=\"如果你想进行后续的异步操作怎么办？\"></a>如果你想进行后续的异步操作怎么办？</h3><p>三个数相加，正常函数这样写：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-59dc79d91bc6308f1f9dcab7c1f526ec_b.png\" alt=\"\"></p>\n<p>怎么看起来像回调？</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-e49abd186159baff398864f7493f5cf0_b.png\" alt=\"\"></p>\n<p>语法对用户是友好的。有一个更好的术语，它看起来像一个金字塔，但人们通常把这称为“回调地狱”，因为回调嵌套到另一个回调。假设你有 10 的回调，你的代码将嵌套的 10 倍！</p>\n<h3 id=\"逃离回调地狱吧！\"><a href=\"#逃离回调地狱吧！\" class=\"headerlink\" title=\"逃离回调地狱吧！\"></a>逃离回调地狱吧！</h3><p>让 promise 来拯救。让我们来看看同样的例子的 promise 版本。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-137fc3c1c3f2a3064c3c56c19de109dd_b.png\" alt=\"\"></p>\n<p>有了承诺，我们用”.then”扁平化回调。在某种程度上，因为没有回调嵌套，它看起来干净。当然，用 ES7 异步语法，可以让他看起来更简洁！</p>\n<h2 id=\"新家伙：Observables-观测值\"><a href=\"#新家伙：Observables-观测值\" class=\"headerlink\" title=\"新家伙：Observables 观测值\"></a>新家伙：Observables 观测值</h2><p>在 promise 已经让你很幸福的时候，Observables 这货来锦上添花，让处理异步数据量更容易。</p>\n<blockquote>\n<p>Observables 是懒惰的事件流，可以发出零个或多个事件，而且可能完成也可能不完成。</p>\n</blockquote>\n<p>promise 和 observable 的关键区别是：</p>\n<ul>\n<li>Observables 观测值是可以取消的</li>\n<li>Observable 是懒惰的</li>\n</ul>\n<p>不要害怕，让我们来看看 Observables 的案例。在这个例子中，关于 Observables 使用 RxJS。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-e7fc7687124a145f61c8ba55afedc011_b.png\" alt=\"\"></p>\n<p>Observables 观测值可以很容易的做一些时髦的东西。看案例：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/v2-6c2ecaebec8cf5dbf0dbfc800bbd4204_b.png\" alt=\"\"></p>\n<p>好吧，咱们以后再接着讨论 Observables 观测值吧！</p>\n"},{"title":"编辑器之战:Vim 的复仇","date":"2017-09-09T08:53:00.000Z","_content":"\n**文本编辑编程**  \nVim 的神秘之处在于它普通模式时使用一种介于自然语言和编程语言中间的语言。\n\n它包含动词（方法）、形容词（修饰语）、和名词（对象）。输入**c**命令代表“编辑”某些文本。但是仅仅输入一个 c 不起作用，因为它还需要一个对象。但如果你输入**caw**（“修改一个单词”），光标所选中的单词将被删除，Vim 进入插入模式，等待你键入单词的替换词，通过按 Esc 键（退出键）就可以返回普通模式。如果你想编辑整句，输入**cas**来删除它然后然后输入新句子即可。想改变 C 函数括号内的所有参数吗？**ci)**“改变括号内的内容”. **(ca)**删除整体，括号和所有。数字也同样适用。通过**c5w**命令可以修改后面的 5 个单词。就 Vim 的语法是模块化且可拓展的角度而言，它还是挺容易学的。\n\n以上那些只是雕虫小技。**.**命令才是亮点。编辑动作的阶段性重复构成了一个单元。所以如果你仅仅想把一个单词改为“Hackaday”后返回到普通模式，就把光标移动到那个单词上键入 cawHackaday 后再按**.**键就可将其修改为“Hackaday”。将移动命令也加入其中，**w**命令将光标移动到下一个单词的开头。现在如果交换**.**和**w**那么文档中所有单词都会变成“Hackaday”。只需要按两个键。试想一下如果杰克·尼克尔逊在《闪灵》中用 Vim 和**.**命令写作，那该多高效啊。\n\n虽然听起来好像不是特别实用，但是想想有多少次你需要把所有“foo()”方法替换为“getFooInstantanceMethod()”方法就不难理解了。\n\n当然了在 Vim 中那只是很“普通”的搜索和替换方法，但是其实大多数情况下你没必要那样做。为啥呢？因为**/foo**搜索“foo”而且**caw**将修改光标选中的单词。  \n通过**;**可以实现搜索的可重复性。在搜索和替换部分（几乎）同时是任意编辑动作的情况下，交替使用**;** 和**.**与搜索和替换是等价的。\n\n不需要输入“y”和“n”来对每个匹配的单词进行修改确认，你只需要找到需要的地方输入**.**即可。\n\n关于 vim 的讨论非常热闹，以至于在 StackOverflow 上，它已经成为一个经典的热门话题，在另一方面，文本编辑经常视为一贯重复性行为。Vim 却将这些动作作为单一的单元，使得复现和将它们链接在一起非常容易。如果你是一个程序员，这很像编程里的活动 — 将整个任务拆分成多个方法并运行。如果你理解编程，你就更容易理解 Vim。\n\n**可视模式和命令模式**\n\n在你通往精通 Vim 的路上，你会接触到更多模式。可视模式下你可以先选择文本的区域然后再使用命令来操作它。偶尔用用挺好的，因为可视模式下选择区域很难转换成普通方法，所以不要像我学习的时候那样用的那么频繁。然而有很多针对可视模式有用的插件。\n\n命令模式是 Vim 的主要模式。它本质上像 ed 这种原始的行编辑器。**:17,25d**在不移动鼠标情况下删除 17 到 25 行。**:-3t.**复制当行的前面三行。**:v/foobar/s/thang/thing/g** 将不含有“foobar”的文档里所有“thang”替换为 “foobar”。在这里你也可以使用所有存储的正则表达式。\n\n另外，如全局搜索、替换、删除或者复制整行文字这样的简单的操作在命令行下非常容易。**%s/one/two/gc**把所有的“one”替换成 “two”，每个搜索和替换需要用户确认。**(%**代表整篇文章。这里你也可以使用行数范围。当然**:e**命令功能是打开一个文件编辑， **:wq** 的功能是保存当前文件并退出。你不需要记住太多的命令行模式的命令，但是有些命令超实用。\n\n**寄存器和宏**\n\n接下来将介绍寄存器。像编程语言的变量那样，Vim 在寄存器中存储文本（或命令）。你可以从寄存器剪切或者粘贴数据，前十个主要是一个剪切缓冲区。寄存器是存储你剪切但不确定是否扔掉的文本的好地方。**“zdi}** 将删除所有方法括号内的所有代码，保存在“z”寄存器中。你可以在任何时候通过**“zp**将其粘贴回来。\n\n你也可以像宏一样记录和回放寄存器中的 Vim 的命令序列。毕竟 Vim 命令大多数情况下都仅仅是文字。**q**用来开始和停止宏的录制，**qw**将一个宏录制到“w”寄存器中。\n\n在此之后你可以用**@w**来重复运行。宏像其编写者那样强大。我只用一些宏，但是只要我用过的都会频繁使用。\n\n例如，有一个宏我一天用无数次。我用 Markdown 写 Hackaday 文章然后将其编译成 HTML 语言发表。在 Markdown 中超链接的用法类似这样：\\[link text\\]( [https://www.example.com](https://www.example.com) )。\n\n**S\\]f\\]a(“+pa)**用“\\[\\]”将当前选中的文本括在里面。添加一个左圆括号，退出插入模式，粘贴粘贴板中的内容，添加一个右圆括号，返回到普通模式。但是现在，我复制浏览器中一个超链接，选择文本然后在 Vim 中键入**@l** 这样获得了链接到该网址的 Markdown 超链接。\n\n**插件**  \n想其他任何的编辑器一样，Vim 也拥有难以置信的可拓展性。如果有任何不能制作成宏的特性，用户通常都可以为此编写插件。依我看来，Vimscript 没 Lisp 那样好编写，所以我就把拓展的编写留个其他用户吧。有人已经写了一个几乎你所需的所有模块。但是在刚开始的时候不要过度使用插件。即使你是刚学习 Vim，它也会使你的工作量减轻很多。  \n如果你经不住诱惑安装了一些插件，我建议你一次只装一个，直到能给非常熟练的使用后再安装另外的插件。我建议依次安装和学习如下插件：vim-sensible, vim-airline, vim-abolish, ctrlp.vim, UltiSnips, vim-surround, vim-easy-align。\n\n**VIM 最佳命令**\n\n如果你在用 Vim，但是没充分使用如下的命令，说明你还没用好它。\n\nl **I**和 **A** 分别插入文本到行首或尾部。\n\nl **m**设置标记然后通过**“`**就可以跳回到此标记位置。 这对轻松在长篇文章中跳转非常有效。\n\nl **g;** 跳转到上次编辑位置。就是说“在去其他地方之前，先返回之前编辑的地方”。这非常有用。但这还不是全部–它追踪编辑历史以便可以复现前 5 此编辑。g,返回前一个编辑历史。\n\nl **CTRL-\\]** 跳转到鼠标所在函数的定义位置，**CTRL-t**跳回。**CTRL-t**可以使你会一直返回，直到返回到开始位置。(为了使其生效你需要一个标签文件。) 这几乎达到像 eclipse 这种 IDE 价值的一半，却没他们那样造成屏幕凌乱。\n\nl 一个 IDE 的另外一半是长变量或者方法名的 tab 完成功能。在 Vim 中用**CTRL-n**和 **CTRL-p** 来预选列表中上滚和下滚。如果你使用的是标签文件或者如果你在 Vim 中其他文件定义了标签，它将对变量名和方法名自动完成。\n\nl **gg=G**跳转到文档顶部(**gg**) 自动缩进(**=**) 直到到达文档末尾 (**G**)。这使得你打开和关闭的大括号排成一行，很容易找到你忘记配对的大括号。\n\nl **U**撤销最后一个命令。**CTRL-r**重做。**:earlier 2m** 恢复到两分钟前的状态。如果你不再进行撤销，继续编辑然后想重做之前的一些改动，就可以考虑用这个命令。**g+** 和**g-** 则在恢复树种上下切换。它变得更加复杂。\n\nl **/**和**f** 都是搜索命令，这两个命令在符合命令中起着至关重要的作用。**df,**从当前光标位置上的字符一直删除到遇到逗号（包括逗号)。**d/foo** 一直删除直到第一次匹配“foo”的位置。如果你喜欢，你可以用这来代替其他动作。\n\nl **:r** 读取一个文件。**:!**在 shell 中运行命令。**:r!** 粘贴命令的结果输出到文档中。**:r!ls whatever\\***比输入文件名更快。在此我并不打算介绍 UNIXy 中怎样通过 shell 脚本运行文本。\n\n**无处不在的 VI**  \n一旦你习惯于 Vim 的移动命令，你会乐在其中。当然了你也可以直接使用鼠标，但如果你能熟练使用 Vim 移动命令，你将很少用鼠标了。手一直在键盘上比时不时腾出手来操作鼠标操作要会更快很多。铁杆 Vim 用户会重新映射 Escape 键（返回到普通模式）到其他更加方便的功能。我设置的是 Caps Lock 键，在我左手小手指下面。  \n(我其实是通过 xcapse 插件映射它和 Control 键复合键使用。)  \n是的，这确实有点极端，但是比 现在已经不存在的避免 Emacs 导致腕管综合征的键盘设计 强多了。  \n如果你在 Unix 使用 Bash shell，**set -o vi** 这种用法来读取行的方法几乎和 vi 一样。你的浏览器也可以 Vim 化，火狐浏览器、cVim 或 vimium 中有 Vimperator 和 Pentadactyl 插件。谷歌浏览器中有 ViChrome 插件 。如果你想合二为一，qutebrowser 是目前最好的原生 Vim 风格网页浏览器，而且还将会更加完善。  \n你若搜索 “vi keybindings”你会发现它不仅支持 Visual Studio、Eclipse 还支持 Emacs。  \n为什么 Emacs 里有 Vi 模拟模式，但 Vim 中却没 Emacs 的模拟模式呢？  \n稍加思索你就会明白，编辑器之战已经有了结果。  \n想用惯 Vim 需要花费一些时日。程序员想要擅长 Vim，需要要摆正心态勤加练习。从 1994 到 20011 年间我用 Emacs 写代码、写我的学位论文、我所代课的学生的论文和学术论文。从 2011 年起我就开始用 Vim 来编写更多代码、写书、写邮件和我在 Hackaday 上的文章。  \n我仍然在不断提高，五六年间每天使用 Vim 6 到 8 小时，每月将自己总结的技巧写在指令表中。虽然 Vim 像任何值其他值得深入探索的东西一样，用起来有点难，但是却非常值得。不要轻信任何人告诉你他们“懂”Vim。**:wq**.\n\n**资源**  \nThere’s really too much to say about Vim. Here’s a short list of great resources:  \n关于 Vim 要说的实在是太多了，这里提供一些相关极有价值的参考资源：  \n如果你刚开始用输入 **:help tutor**\n\n作者：Aieru  \n链接：http://www.jianshu.com/p/c5edef62bdd7  \n來源：简书  \n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","source":"_posts/2017-09-09-编辑器之战: Vim 的复仇.md","raw":"---\ntitle: 编辑器之战:Vim 的复仇\ntags:\n  - 工具\ndate: 2017-09-09 16:53:00\ncategories: 工具\n---\n\n**文本编辑编程**  \nVim 的神秘之处在于它普通模式时使用一种介于自然语言和编程语言中间的语言。\n\n它包含动词（方法）、形容词（修饰语）、和名词（对象）。输入**c**命令代表“编辑”某些文本。但是仅仅输入一个 c 不起作用，因为它还需要一个对象。但如果你输入**caw**（“修改一个单词”），光标所选中的单词将被删除，Vim 进入插入模式，等待你键入单词的替换词，通过按 Esc 键（退出键）就可以返回普通模式。如果你想编辑整句，输入**cas**来删除它然后然后输入新句子即可。想改变 C 函数括号内的所有参数吗？**ci)**“改变括号内的内容”. **(ca)**删除整体，括号和所有。数字也同样适用。通过**c5w**命令可以修改后面的 5 个单词。就 Vim 的语法是模块化且可拓展的角度而言，它还是挺容易学的。\n\n以上那些只是雕虫小技。**.**命令才是亮点。编辑动作的阶段性重复构成了一个单元。所以如果你仅仅想把一个单词改为“Hackaday”后返回到普通模式，就把光标移动到那个单词上键入 cawHackaday 后再按**.**键就可将其修改为“Hackaday”。将移动命令也加入其中，**w**命令将光标移动到下一个单词的开头。现在如果交换**.**和**w**那么文档中所有单词都会变成“Hackaday”。只需要按两个键。试想一下如果杰克·尼克尔逊在《闪灵》中用 Vim 和**.**命令写作，那该多高效啊。\n\n虽然听起来好像不是特别实用，但是想想有多少次你需要把所有“foo()”方法替换为“getFooInstantanceMethod()”方法就不难理解了。\n\n当然了在 Vim 中那只是很“普通”的搜索和替换方法，但是其实大多数情况下你没必要那样做。为啥呢？因为**/foo**搜索“foo”而且**caw**将修改光标选中的单词。  \n通过**;**可以实现搜索的可重复性。在搜索和替换部分（几乎）同时是任意编辑动作的情况下，交替使用**;** 和**.**与搜索和替换是等价的。\n\n不需要输入“y”和“n”来对每个匹配的单词进行修改确认，你只需要找到需要的地方输入**.**即可。\n\n关于 vim 的讨论非常热闹，以至于在 StackOverflow 上，它已经成为一个经典的热门话题，在另一方面，文本编辑经常视为一贯重复性行为。Vim 却将这些动作作为单一的单元，使得复现和将它们链接在一起非常容易。如果你是一个程序员，这很像编程里的活动 — 将整个任务拆分成多个方法并运行。如果你理解编程，你就更容易理解 Vim。\n\n**可视模式和命令模式**\n\n在你通往精通 Vim 的路上，你会接触到更多模式。可视模式下你可以先选择文本的区域然后再使用命令来操作它。偶尔用用挺好的，因为可视模式下选择区域很难转换成普通方法，所以不要像我学习的时候那样用的那么频繁。然而有很多针对可视模式有用的插件。\n\n命令模式是 Vim 的主要模式。它本质上像 ed 这种原始的行编辑器。**:17,25d**在不移动鼠标情况下删除 17 到 25 行。**:-3t.**复制当行的前面三行。**:v/foobar/s/thang/thing/g** 将不含有“foobar”的文档里所有“thang”替换为 “foobar”。在这里你也可以使用所有存储的正则表达式。\n\n另外，如全局搜索、替换、删除或者复制整行文字这样的简单的操作在命令行下非常容易。**%s/one/two/gc**把所有的“one”替换成 “two”，每个搜索和替换需要用户确认。**(%**代表整篇文章。这里你也可以使用行数范围。当然**:e**命令功能是打开一个文件编辑， **:wq** 的功能是保存当前文件并退出。你不需要记住太多的命令行模式的命令，但是有些命令超实用。\n\n**寄存器和宏**\n\n接下来将介绍寄存器。像编程语言的变量那样，Vim 在寄存器中存储文本（或命令）。你可以从寄存器剪切或者粘贴数据，前十个主要是一个剪切缓冲区。寄存器是存储你剪切但不确定是否扔掉的文本的好地方。**“zdi}** 将删除所有方法括号内的所有代码，保存在“z”寄存器中。你可以在任何时候通过**“zp**将其粘贴回来。\n\n你也可以像宏一样记录和回放寄存器中的 Vim 的命令序列。毕竟 Vim 命令大多数情况下都仅仅是文字。**q**用来开始和停止宏的录制，**qw**将一个宏录制到“w”寄存器中。\n\n在此之后你可以用**@w**来重复运行。宏像其编写者那样强大。我只用一些宏，但是只要我用过的都会频繁使用。\n\n例如，有一个宏我一天用无数次。我用 Markdown 写 Hackaday 文章然后将其编译成 HTML 语言发表。在 Markdown 中超链接的用法类似这样：\\[link text\\]( [https://www.example.com](https://www.example.com) )。\n\n**S\\]f\\]a(“+pa)**用“\\[\\]”将当前选中的文本括在里面。添加一个左圆括号，退出插入模式，粘贴粘贴板中的内容，添加一个右圆括号，返回到普通模式。但是现在，我复制浏览器中一个超链接，选择文本然后在 Vim 中键入**@l** 这样获得了链接到该网址的 Markdown 超链接。\n\n**插件**  \n想其他任何的编辑器一样，Vim 也拥有难以置信的可拓展性。如果有任何不能制作成宏的特性，用户通常都可以为此编写插件。依我看来，Vimscript 没 Lisp 那样好编写，所以我就把拓展的编写留个其他用户吧。有人已经写了一个几乎你所需的所有模块。但是在刚开始的时候不要过度使用插件。即使你是刚学习 Vim，它也会使你的工作量减轻很多。  \n如果你经不住诱惑安装了一些插件，我建议你一次只装一个，直到能给非常熟练的使用后再安装另外的插件。我建议依次安装和学习如下插件：vim-sensible, vim-airline, vim-abolish, ctrlp.vim, UltiSnips, vim-surround, vim-easy-align。\n\n**VIM 最佳命令**\n\n如果你在用 Vim，但是没充分使用如下的命令，说明你还没用好它。\n\nl **I**和 **A** 分别插入文本到行首或尾部。\n\nl **m**设置标记然后通过**“`**就可以跳回到此标记位置。 这对轻松在长篇文章中跳转非常有效。\n\nl **g;** 跳转到上次编辑位置。就是说“在去其他地方之前，先返回之前编辑的地方”。这非常有用。但这还不是全部–它追踪编辑历史以便可以复现前 5 此编辑。g,返回前一个编辑历史。\n\nl **CTRL-\\]** 跳转到鼠标所在函数的定义位置，**CTRL-t**跳回。**CTRL-t**可以使你会一直返回，直到返回到开始位置。(为了使其生效你需要一个标签文件。) 这几乎达到像 eclipse 这种 IDE 价值的一半，却没他们那样造成屏幕凌乱。\n\nl 一个 IDE 的另外一半是长变量或者方法名的 tab 完成功能。在 Vim 中用**CTRL-n**和 **CTRL-p** 来预选列表中上滚和下滚。如果你使用的是标签文件或者如果你在 Vim 中其他文件定义了标签，它将对变量名和方法名自动完成。\n\nl **gg=G**跳转到文档顶部(**gg**) 自动缩进(**=**) 直到到达文档末尾 (**G**)。这使得你打开和关闭的大括号排成一行，很容易找到你忘记配对的大括号。\n\nl **U**撤销最后一个命令。**CTRL-r**重做。**:earlier 2m** 恢复到两分钟前的状态。如果你不再进行撤销，继续编辑然后想重做之前的一些改动，就可以考虑用这个命令。**g+** 和**g-** 则在恢复树种上下切换。它变得更加复杂。\n\nl **/**和**f** 都是搜索命令，这两个命令在符合命令中起着至关重要的作用。**df,**从当前光标位置上的字符一直删除到遇到逗号（包括逗号)。**d/foo** 一直删除直到第一次匹配“foo”的位置。如果你喜欢，你可以用这来代替其他动作。\n\nl **:r** 读取一个文件。**:!**在 shell 中运行命令。**:r!** 粘贴命令的结果输出到文档中。**:r!ls whatever\\***比输入文件名更快。在此我并不打算介绍 UNIXy 中怎样通过 shell 脚本运行文本。\n\n**无处不在的 VI**  \n一旦你习惯于 Vim 的移动命令，你会乐在其中。当然了你也可以直接使用鼠标，但如果你能熟练使用 Vim 移动命令，你将很少用鼠标了。手一直在键盘上比时不时腾出手来操作鼠标操作要会更快很多。铁杆 Vim 用户会重新映射 Escape 键（返回到普通模式）到其他更加方便的功能。我设置的是 Caps Lock 键，在我左手小手指下面。  \n(我其实是通过 xcapse 插件映射它和 Control 键复合键使用。)  \n是的，这确实有点极端，但是比 现在已经不存在的避免 Emacs 导致腕管综合征的键盘设计 强多了。  \n如果你在 Unix 使用 Bash shell，**set -o vi** 这种用法来读取行的方法几乎和 vi 一样。你的浏览器也可以 Vim 化，火狐浏览器、cVim 或 vimium 中有 Vimperator 和 Pentadactyl 插件。谷歌浏览器中有 ViChrome 插件 。如果你想合二为一，qutebrowser 是目前最好的原生 Vim 风格网页浏览器，而且还将会更加完善。  \n你若搜索 “vi keybindings”你会发现它不仅支持 Visual Studio、Eclipse 还支持 Emacs。  \n为什么 Emacs 里有 Vi 模拟模式，但 Vim 中却没 Emacs 的模拟模式呢？  \n稍加思索你就会明白，编辑器之战已经有了结果。  \n想用惯 Vim 需要花费一些时日。程序员想要擅长 Vim，需要要摆正心态勤加练习。从 1994 到 20011 年间我用 Emacs 写代码、写我的学位论文、我所代课的学生的论文和学术论文。从 2011 年起我就开始用 Vim 来编写更多代码、写书、写邮件和我在 Hackaday 上的文章。  \n我仍然在不断提高，五六年间每天使用 Vim 6 到 8 小时，每月将自己总结的技巧写在指令表中。虽然 Vim 像任何值其他值得深入探索的东西一样，用起来有点难，但是却非常值得。不要轻信任何人告诉你他们“懂”Vim。**:wq**.\n\n**资源**  \nThere’s really too much to say about Vim. Here’s a short list of great resources:  \n关于 Vim 要说的实在是太多了，这里提供一些相关极有价值的参考资源：  \n如果你刚开始用输入 **:help tutor**\n\n作者：Aieru  \n链接：http://www.jianshu.com/p/c5edef62bdd7  \n來源：简书  \n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","slug":"2017-09-09-编辑器之战: Vim 的复仇","published":1,"updated":"2020-03-14T07:06:01.217Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvms004k4k8yh9ythba8","content":"<p><strong>文本编辑编程</strong><br>Vim 的神秘之处在于它普通模式时使用一种介于自然语言和编程语言中间的语言。</p>\n<p>它包含动词（方法）、形容词（修饰语）、和名词（对象）。输入<strong>c</strong>命令代表“编辑”某些文本。但是仅仅输入一个 c 不起作用，因为它还需要一个对象。但如果你输入<strong>caw</strong>（“修改一个单词”），光标所选中的单词将被删除，Vim 进入插入模式，等待你键入单词的替换词，通过按 Esc 键（退出键）就可以返回普通模式。如果你想编辑整句，输入<strong>cas</strong>来删除它然后然后输入新句子即可。想改变 C 函数括号内的所有参数吗？<strong>ci)</strong>“改变括号内的内容”. <strong>(ca)</strong>删除整体，括号和所有。数字也同样适用。通过<strong>c5w</strong>命令可以修改后面的 5 个单词。就 Vim 的语法是模块化且可拓展的角度而言，它还是挺容易学的。</p>\n<p>以上那些只是雕虫小技。<strong>.</strong>命令才是亮点。编辑动作的阶段性重复构成了一个单元。所以如果你仅仅想把一个单词改为“Hackaday”后返回到普通模式，就把光标移动到那个单词上键入 cawHackaday 后再按<strong>.</strong>键就可将其修改为“Hackaday”。将移动命令也加入其中，<strong>w</strong>命令将光标移动到下一个单词的开头。现在如果交换<strong>.</strong>和<strong>w</strong>那么文档中所有单词都会变成“Hackaday”。只需要按两个键。试想一下如果杰克·尼克尔逊在《闪灵》中用 Vim 和<strong>.</strong>命令写作，那该多高效啊。</p>\n<p>虽然听起来好像不是特别实用，但是想想有多少次你需要把所有“foo()”方法替换为“getFooInstantanceMethod()”方法就不难理解了。</p>\n<p>当然了在 Vim 中那只是很“普通”的搜索和替换方法，但是其实大多数情况下你没必要那样做。为啥呢？因为<strong>/foo</strong>搜索“foo”而且<strong>caw</strong>将修改光标选中的单词。<br>通过<strong>;</strong>可以实现搜索的可重复性。在搜索和替换部分（几乎）同时是任意编辑动作的情况下，交替使用<strong>;</strong> 和<strong>.</strong>与搜索和替换是等价的。</p>\n<p>不需要输入“y”和“n”来对每个匹配的单词进行修改确认，你只需要找到需要的地方输入<strong>.</strong>即可。</p>\n<p>关于 vim 的讨论非常热闹，以至于在 StackOverflow 上，它已经成为一个经典的热门话题，在另一方面，文本编辑经常视为一贯重复性行为。Vim 却将这些动作作为单一的单元，使得复现和将它们链接在一起非常容易。如果你是一个程序员，这很像编程里的活动 — 将整个任务拆分成多个方法并运行。如果你理解编程，你就更容易理解 Vim。</p>\n<p><strong>可视模式和命令模式</strong></p>\n<p>在你通往精通 Vim 的路上，你会接触到更多模式。可视模式下你可以先选择文本的区域然后再使用命令来操作它。偶尔用用挺好的，因为可视模式下选择区域很难转换成普通方法，所以不要像我学习的时候那样用的那么频繁。然而有很多针对可视模式有用的插件。</p>\n<p>命令模式是 Vim 的主要模式。它本质上像 ed 这种原始的行编辑器。<strong>:17,25d</strong>在不移动鼠标情况下删除 17 到 25 行。<strong>:-3t.</strong>复制当行的前面三行。<strong>:v/foobar/s/thang/thing/g</strong> 将不含有“foobar”的文档里所有“thang”替换为 “foobar”。在这里你也可以使用所有存储的正则表达式。</p>\n<p>另外，如全局搜索、替换、删除或者复制整行文字这样的简单的操作在命令行下非常容易。<strong>%s/one/two/gc</strong>把所有的“one”替换成 “two”，每个搜索和替换需要用户确认。<strong>(%</strong>代表整篇文章。这里你也可以使用行数范围。当然<strong>:e</strong>命令功能是打开一个文件编辑， <strong>:wq</strong> 的功能是保存当前文件并退出。你不需要记住太多的命令行模式的命令，但是有些命令超实用。</p>\n<p><strong>寄存器和宏</strong></p>\n<p>接下来将介绍寄存器。像编程语言的变量那样，Vim 在寄存器中存储文本（或命令）。你可以从寄存器剪切或者粘贴数据，前十个主要是一个剪切缓冲区。寄存器是存储你剪切但不确定是否扔掉的文本的好地方。<strong>“zdi}</strong> 将删除所有方法括号内的所有代码，保存在“z”寄存器中。你可以在任何时候通过<strong>“zp</strong>将其粘贴回来。</p>\n<p>你也可以像宏一样记录和回放寄存器中的 Vim 的命令序列。毕竟 Vim 命令大多数情况下都仅仅是文字。<strong>q</strong>用来开始和停止宏的录制，<strong>qw</strong>将一个宏录制到“w”寄存器中。</p>\n<p>在此之后你可以用<strong>@w</strong>来重复运行。宏像其编写者那样强大。我只用一些宏，但是只要我用过的都会频繁使用。</p>\n<p>例如，有一个宏我一天用无数次。我用 Markdown 写 Hackaday 文章然后将其编译成 HTML 语言发表。在 Markdown 中超链接的用法类似这样：[link text]( <a href=\"https://www.example.com\" target=\"_blank\" rel=\"noopener\">https://www.example.com</a> )。</p>\n<p><strong>S]f]a(“+pa)</strong>用“[]”将当前选中的文本括在里面。添加一个左圆括号，退出插入模式，粘贴粘贴板中的内容，添加一个右圆括号，返回到普通模式。但是现在，我复制浏览器中一个超链接，选择文本然后在 Vim 中键入<strong>@l</strong> 这样获得了链接到该网址的 Markdown 超链接。</p>\n<p><strong>插件</strong><br>想其他任何的编辑器一样，Vim 也拥有难以置信的可拓展性。如果有任何不能制作成宏的特性，用户通常都可以为此编写插件。依我看来，Vimscript 没 Lisp 那样好编写，所以我就把拓展的编写留个其他用户吧。有人已经写了一个几乎你所需的所有模块。但是在刚开始的时候不要过度使用插件。即使你是刚学习 Vim，它也会使你的工作量减轻很多。<br>如果你经不住诱惑安装了一些插件，我建议你一次只装一个，直到能给非常熟练的使用后再安装另外的插件。我建议依次安装和学习如下插件：vim-sensible, vim-airline, vim-abolish, ctrlp.vim, UltiSnips, vim-surround, vim-easy-align。</p>\n<p><strong>VIM 最佳命令</strong></p>\n<p>如果你在用 Vim，但是没充分使用如下的命令，说明你还没用好它。</p>\n<p>l <strong>I</strong>和 <strong>A</strong> 分别插入文本到行首或尾部。</p>\n<p>l <strong>m</strong>设置标记然后通过<strong>“`</strong>就可以跳回到此标记位置。 这对轻松在长篇文章中跳转非常有效。</p>\n<p>l <strong>g;</strong> 跳转到上次编辑位置。就是说“在去其他地方之前，先返回之前编辑的地方”。这非常有用。但这还不是全部–它追踪编辑历史以便可以复现前 5 此编辑。g,返回前一个编辑历史。</p>\n<p>l <strong>CTRL-]</strong> 跳转到鼠标所在函数的定义位置，<strong>CTRL-t</strong>跳回。<strong>CTRL-t</strong>可以使你会一直返回，直到返回到开始位置。(为了使其生效你需要一个标签文件。) 这几乎达到像 eclipse 这种 IDE 价值的一半，却没他们那样造成屏幕凌乱。</p>\n<p>l 一个 IDE 的另外一半是长变量或者方法名的 tab 完成功能。在 Vim 中用<strong>CTRL-n</strong>和 <strong>CTRL-p</strong> 来预选列表中上滚和下滚。如果你使用的是标签文件或者如果你在 Vim 中其他文件定义了标签，它将对变量名和方法名自动完成。</p>\n<p>l <strong>gg=G</strong>跳转到文档顶部(<strong>gg</strong>) 自动缩进(<strong>=</strong>) 直到到达文档末尾 (<strong>G</strong>)。这使得你打开和关闭的大括号排成一行，很容易找到你忘记配对的大括号。</p>\n<p>l <strong>U</strong>撤销最后一个命令。<strong>CTRL-r</strong>重做。<strong>:earlier 2m</strong> 恢复到两分钟前的状态。如果你不再进行撤销，继续编辑然后想重做之前的一些改动，就可以考虑用这个命令。<strong>g+</strong> 和<strong>g-</strong> 则在恢复树种上下切换。它变得更加复杂。</p>\n<p>l <strong>/</strong>和<strong>f</strong> 都是搜索命令，这两个命令在符合命令中起着至关重要的作用。<strong>df,</strong>从当前光标位置上的字符一直删除到遇到逗号（包括逗号)。<strong>d/foo</strong> 一直删除直到第一次匹配“foo”的位置。如果你喜欢，你可以用这来代替其他动作。</p>\n<p>l <strong>:r</strong> 读取一个文件。<strong>:!</strong>在 shell 中运行命令。<strong>:r!</strong> 粘贴命令的结果输出到文档中。<strong>:r!ls whatever*</strong>比输入文件名更快。在此我并不打算介绍 UNIXy 中怎样通过 shell 脚本运行文本。</p>\n<p><strong>无处不在的 VI</strong><br>一旦你习惯于 Vim 的移动命令，你会乐在其中。当然了你也可以直接使用鼠标，但如果你能熟练使用 Vim 移动命令，你将很少用鼠标了。手一直在键盘上比时不时腾出手来操作鼠标操作要会更快很多。铁杆 Vim 用户会重新映射 Escape 键（返回到普通模式）到其他更加方便的功能。我设置的是 Caps Lock 键，在我左手小手指下面。<br>(我其实是通过 xcapse 插件映射它和 Control 键复合键使用。)<br>是的，这确实有点极端，但是比 现在已经不存在的避免 Emacs 导致腕管综合征的键盘设计 强多了。<br>如果你在 Unix 使用 Bash shell，<strong>set -o vi</strong> 这种用法来读取行的方法几乎和 vi 一样。你的浏览器也可以 Vim 化，火狐浏览器、cVim 或 vimium 中有 Vimperator 和 Pentadactyl 插件。谷歌浏览器中有 ViChrome 插件 。如果你想合二为一，qutebrowser 是目前最好的原生 Vim 风格网页浏览器，而且还将会更加完善。<br>你若搜索 “vi keybindings”你会发现它不仅支持 Visual Studio、Eclipse 还支持 Emacs。<br>为什么 Emacs 里有 Vi 模拟模式，但 Vim 中却没 Emacs 的模拟模式呢？<br>稍加思索你就会明白，编辑器之战已经有了结果。<br>想用惯 Vim 需要花费一些时日。程序员想要擅长 Vim，需要要摆正心态勤加练习。从 1994 到 20011 年间我用 Emacs 写代码、写我的学位论文、我所代课的学生的论文和学术论文。从 2011 年起我就开始用 Vim 来编写更多代码、写书、写邮件和我在 Hackaday 上的文章。<br>我仍然在不断提高，五六年间每天使用 Vim 6 到 8 小时，每月将自己总结的技巧写在指令表中。虽然 Vim 像任何值其他值得深入探索的东西一样，用起来有点难，但是却非常值得。不要轻信任何人告诉你他们“懂”Vim。<strong>:wq</strong>.</p>\n<p><strong>资源</strong><br>There’s really too much to say about Vim. Here’s a short list of great resources:<br>关于 Vim 要说的实在是太多了，这里提供一些相关极有价值的参考资源：<br>如果你刚开始用输入 <strong>:help tutor</strong></p>\n<p>作者：Aieru<br>链接：<a href=\"http://www.jianshu.com/p/c5edef62bdd7\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/c5edef62bdd7</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p><strong>文本编辑编程</strong><br>Vim 的神秘之处在于它普通模式时使用一种介于自然语言和编程语言中间的语言。</p>\n<p>它包含动词（方法）、形容词（修饰语）、和名词（对象）。输入<strong>c</strong>命令代表“编辑”某些文本。但是仅仅输入一个 c 不起作用，因为它还需要一个对象。但如果你输入<strong>caw</strong>（“修改一个单词”），光标所选中的单词将被删除，Vim 进入插入模式，等待你键入单词的替换词，通过按 Esc 键（退出键）就可以返回普通模式。如果你想编辑整句，输入<strong>cas</strong>来删除它然后然后输入新句子即可。想改变 C 函数括号内的所有参数吗？<strong>ci)</strong>“改变括号内的内容”. <strong>(ca)</strong>删除整体，括号和所有。数字也同样适用。通过<strong>c5w</strong>命令可以修改后面的 5 个单词。就 Vim 的语法是模块化且可拓展的角度而言，它还是挺容易学的。</p>\n<p>以上那些只是雕虫小技。<strong>.</strong>命令才是亮点。编辑动作的阶段性重复构成了一个单元。所以如果你仅仅想把一个单词改为“Hackaday”后返回到普通模式，就把光标移动到那个单词上键入 cawHackaday 后再按<strong>.</strong>键就可将其修改为“Hackaday”。将移动命令也加入其中，<strong>w</strong>命令将光标移动到下一个单词的开头。现在如果交换<strong>.</strong>和<strong>w</strong>那么文档中所有单词都会变成“Hackaday”。只需要按两个键。试想一下如果杰克·尼克尔逊在《闪灵》中用 Vim 和<strong>.</strong>命令写作，那该多高效啊。</p>\n<p>虽然听起来好像不是特别实用，但是想想有多少次你需要把所有“foo()”方法替换为“getFooInstantanceMethod()”方法就不难理解了。</p>\n<p>当然了在 Vim 中那只是很“普通”的搜索和替换方法，但是其实大多数情况下你没必要那样做。为啥呢？因为<strong>/foo</strong>搜索“foo”而且<strong>caw</strong>将修改光标选中的单词。<br>通过<strong>;</strong>可以实现搜索的可重复性。在搜索和替换部分（几乎）同时是任意编辑动作的情况下，交替使用<strong>;</strong> 和<strong>.</strong>与搜索和替换是等价的。</p>\n<p>不需要输入“y”和“n”来对每个匹配的单词进行修改确认，你只需要找到需要的地方输入<strong>.</strong>即可。</p>\n<p>关于 vim 的讨论非常热闹，以至于在 StackOverflow 上，它已经成为一个经典的热门话题，在另一方面，文本编辑经常视为一贯重复性行为。Vim 却将这些动作作为单一的单元，使得复现和将它们链接在一起非常容易。如果你是一个程序员，这很像编程里的活动 — 将整个任务拆分成多个方法并运行。如果你理解编程，你就更容易理解 Vim。</p>\n<p><strong>可视模式和命令模式</strong></p>\n<p>在你通往精通 Vim 的路上，你会接触到更多模式。可视模式下你可以先选择文本的区域然后再使用命令来操作它。偶尔用用挺好的，因为可视模式下选择区域很难转换成普通方法，所以不要像我学习的时候那样用的那么频繁。然而有很多针对可视模式有用的插件。</p>\n<p>命令模式是 Vim 的主要模式。它本质上像 ed 这种原始的行编辑器。<strong>:17,25d</strong>在不移动鼠标情况下删除 17 到 25 行。<strong>:-3t.</strong>复制当行的前面三行。<strong>:v/foobar/s/thang/thing/g</strong> 将不含有“foobar”的文档里所有“thang”替换为 “foobar”。在这里你也可以使用所有存储的正则表达式。</p>\n<p>另外，如全局搜索、替换、删除或者复制整行文字这样的简单的操作在命令行下非常容易。<strong>%s/one/two/gc</strong>把所有的“one”替换成 “two”，每个搜索和替换需要用户确认。<strong>(%</strong>代表整篇文章。这里你也可以使用行数范围。当然<strong>:e</strong>命令功能是打开一个文件编辑， <strong>:wq</strong> 的功能是保存当前文件并退出。你不需要记住太多的命令行模式的命令，但是有些命令超实用。</p>\n<p><strong>寄存器和宏</strong></p>\n<p>接下来将介绍寄存器。像编程语言的变量那样，Vim 在寄存器中存储文本（或命令）。你可以从寄存器剪切或者粘贴数据，前十个主要是一个剪切缓冲区。寄存器是存储你剪切但不确定是否扔掉的文本的好地方。<strong>“zdi}</strong> 将删除所有方法括号内的所有代码，保存在“z”寄存器中。你可以在任何时候通过<strong>“zp</strong>将其粘贴回来。</p>\n<p>你也可以像宏一样记录和回放寄存器中的 Vim 的命令序列。毕竟 Vim 命令大多数情况下都仅仅是文字。<strong>q</strong>用来开始和停止宏的录制，<strong>qw</strong>将一个宏录制到“w”寄存器中。</p>\n<p>在此之后你可以用<strong>@w</strong>来重复运行。宏像其编写者那样强大。我只用一些宏，但是只要我用过的都会频繁使用。</p>\n<p>例如，有一个宏我一天用无数次。我用 Markdown 写 Hackaday 文章然后将其编译成 HTML 语言发表。在 Markdown 中超链接的用法类似这样：[link text]( <a href=\"https://www.example.com\" target=\"_blank\" rel=\"noopener\">https://www.example.com</a> )。</p>\n<p><strong>S]f]a(“+pa)</strong>用“[]”将当前选中的文本括在里面。添加一个左圆括号，退出插入模式，粘贴粘贴板中的内容，添加一个右圆括号，返回到普通模式。但是现在，我复制浏览器中一个超链接，选择文本然后在 Vim 中键入<strong>@l</strong> 这样获得了链接到该网址的 Markdown 超链接。</p>\n<p><strong>插件</strong><br>想其他任何的编辑器一样，Vim 也拥有难以置信的可拓展性。如果有任何不能制作成宏的特性，用户通常都可以为此编写插件。依我看来，Vimscript 没 Lisp 那样好编写，所以我就把拓展的编写留个其他用户吧。有人已经写了一个几乎你所需的所有模块。但是在刚开始的时候不要过度使用插件。即使你是刚学习 Vim，它也会使你的工作量减轻很多。<br>如果你经不住诱惑安装了一些插件，我建议你一次只装一个，直到能给非常熟练的使用后再安装另外的插件。我建议依次安装和学习如下插件：vim-sensible, vim-airline, vim-abolish, ctrlp.vim, UltiSnips, vim-surround, vim-easy-align。</p>\n<p><strong>VIM 最佳命令</strong></p>\n<p>如果你在用 Vim，但是没充分使用如下的命令，说明你还没用好它。</p>\n<p>l <strong>I</strong>和 <strong>A</strong> 分别插入文本到行首或尾部。</p>\n<p>l <strong>m</strong>设置标记然后通过<strong>“`</strong>就可以跳回到此标记位置。 这对轻松在长篇文章中跳转非常有效。</p>\n<p>l <strong>g;</strong> 跳转到上次编辑位置。就是说“在去其他地方之前，先返回之前编辑的地方”。这非常有用。但这还不是全部–它追踪编辑历史以便可以复现前 5 此编辑。g,返回前一个编辑历史。</p>\n<p>l <strong>CTRL-]</strong> 跳转到鼠标所在函数的定义位置，<strong>CTRL-t</strong>跳回。<strong>CTRL-t</strong>可以使你会一直返回，直到返回到开始位置。(为了使其生效你需要一个标签文件。) 这几乎达到像 eclipse 这种 IDE 价值的一半，却没他们那样造成屏幕凌乱。</p>\n<p>l 一个 IDE 的另外一半是长变量或者方法名的 tab 完成功能。在 Vim 中用<strong>CTRL-n</strong>和 <strong>CTRL-p</strong> 来预选列表中上滚和下滚。如果你使用的是标签文件或者如果你在 Vim 中其他文件定义了标签，它将对变量名和方法名自动完成。</p>\n<p>l <strong>gg=G</strong>跳转到文档顶部(<strong>gg</strong>) 自动缩进(<strong>=</strong>) 直到到达文档末尾 (<strong>G</strong>)。这使得你打开和关闭的大括号排成一行，很容易找到你忘记配对的大括号。</p>\n<p>l <strong>U</strong>撤销最后一个命令。<strong>CTRL-r</strong>重做。<strong>:earlier 2m</strong> 恢复到两分钟前的状态。如果你不再进行撤销，继续编辑然后想重做之前的一些改动，就可以考虑用这个命令。<strong>g+</strong> 和<strong>g-</strong> 则在恢复树种上下切换。它变得更加复杂。</p>\n<p>l <strong>/</strong>和<strong>f</strong> 都是搜索命令，这两个命令在符合命令中起着至关重要的作用。<strong>df,</strong>从当前光标位置上的字符一直删除到遇到逗号（包括逗号)。<strong>d/foo</strong> 一直删除直到第一次匹配“foo”的位置。如果你喜欢，你可以用这来代替其他动作。</p>\n<p>l <strong>:r</strong> 读取一个文件。<strong>:!</strong>在 shell 中运行命令。<strong>:r!</strong> 粘贴命令的结果输出到文档中。<strong>:r!ls whatever*</strong>比输入文件名更快。在此我并不打算介绍 UNIXy 中怎样通过 shell 脚本运行文本。</p>\n<p><strong>无处不在的 VI</strong><br>一旦你习惯于 Vim 的移动命令，你会乐在其中。当然了你也可以直接使用鼠标，但如果你能熟练使用 Vim 移动命令，你将很少用鼠标了。手一直在键盘上比时不时腾出手来操作鼠标操作要会更快很多。铁杆 Vim 用户会重新映射 Escape 键（返回到普通模式）到其他更加方便的功能。我设置的是 Caps Lock 键，在我左手小手指下面。<br>(我其实是通过 xcapse 插件映射它和 Control 键复合键使用。)<br>是的，这确实有点极端，但是比 现在已经不存在的避免 Emacs 导致腕管综合征的键盘设计 强多了。<br>如果你在 Unix 使用 Bash shell，<strong>set -o vi</strong> 这种用法来读取行的方法几乎和 vi 一样。你的浏览器也可以 Vim 化，火狐浏览器、cVim 或 vimium 中有 Vimperator 和 Pentadactyl 插件。谷歌浏览器中有 ViChrome 插件 。如果你想合二为一，qutebrowser 是目前最好的原生 Vim 风格网页浏览器，而且还将会更加完善。<br>你若搜索 “vi keybindings”你会发现它不仅支持 Visual Studio、Eclipse 还支持 Emacs。<br>为什么 Emacs 里有 Vi 模拟模式，但 Vim 中却没 Emacs 的模拟模式呢？<br>稍加思索你就会明白，编辑器之战已经有了结果。<br>想用惯 Vim 需要花费一些时日。程序员想要擅长 Vim，需要要摆正心态勤加练习。从 1994 到 20011 年间我用 Emacs 写代码、写我的学位论文、我所代课的学生的论文和学术论文。从 2011 年起我就开始用 Vim 来编写更多代码、写书、写邮件和我在 Hackaday 上的文章。<br>我仍然在不断提高，五六年间每天使用 Vim 6 到 8 小时，每月将自己总结的技巧写在指令表中。虽然 Vim 像任何值其他值得深入探索的东西一样，用起来有点难，但是却非常值得。不要轻信任何人告诉你他们“懂”Vim。<strong>:wq</strong>.</p>\n<p><strong>资源</strong><br>There’s really too much to say about Vim. Here’s a short list of great resources:<br>关于 Vim 要说的实在是太多了，这里提供一些相关极有价值的参考资源：<br>如果你刚开始用输入 <strong>:help tutor</strong></p>\n<p>作者：Aieru<br>链接：<a href=\"http://www.jianshu.com/p/c5edef62bdd7\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/c5edef62bdd7</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n"},{"title":"JS异步加载的三种方式","date":"2017-09-21T00:49:00.000Z","_content":"\n## 一：同步加载\n\n我们平时使用的最多的一种方式。\n\n同步模式，又称阻塞模式，会阻止浏览器的后续处理，停止后续的解析，只有当当前加载完成，才能进行下一步操作。所以默认同步执行才是安全的。但这样如果 js 中有输出 document 内容、修改 dom、重定向等行为，就会造成页面堵塞。所以一般建议把标签放在<body>结尾处，这样尽可能减少页面阻塞。</p> </div> <hr /> <h2><a name=\"t1\" target=\"\\_blank\"></a>二：异步加载</h2> <div> <p>异步加载又叫非阻塞加载，浏览器在下载执行 js 的同时，还会继续进行后续页面的处理。主要有三种方式。</p> <h3><a name=\"t2\" target=\"\\_blank\"></a>方法一：也叫 Script DOM Element</h3> <pre>(function(){ var scriptEle = document.createElement(\"script\"); scriptEle.type = \"text/javasctipt\"; scriptEle.async = true; scriptEle.src = \"http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js\"; var x = document.getElementsByTagName(\"head\")\\[0\\]; x.insertBefore(scriptEle, x.firstChild); })();</pre> <p><async>属性是 HTML5 中新增的异步支持。此方法被称为 Script DOM Element 方法。Google Analytics 和 Google+ Badge 都使用了这种异步加载代码</p> <pre>(function(){; var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')\\[0\\]; s.parentNode.insertBefore(ga, s); })();</pre> <p>但是这种加载方式执行完之前会阻止 onload 事件的触发，而现在很多页面的代码都在 onload 时还执行额外的渲染工作，所以还是会阻塞部分页面的初始化处理。</p> <h3><a name=\"t3\" target=\"\\_blank\"></a>方法二：onload 时的异步加载</h3> <pre>(function(){ if(window.attachEvent){ window.attachEvent(\"load\", asyncLoad); }else{ window.addEventListener(\"load\", asyncLoad); } var asyncLoad = function(){ var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')\\[0\\]; s.parentNode.insertBefore(ga, s); } )();</pre> <p>这种方法只是把插入 script 的方法放在一个函数里面，然后放在 window 的 onload 方法里面执行，这样就解决了阻塞 onload 事件触发的问题。</p> <p>注:DOMContentLoaded 与 load 的区别。前者是在 document 已经解析完成，页面中的 dom 元素可用，但是页面中的图片，视频，音频等资源未加载完，作用同 jQuery 中的 ready 事件；后者的区别在于页面所有资源全部加载完毕。</p> <p>&nbsp;</p> <h3><a name=\"t4\" target=\"\\_blank\"></a>方法三：其他方法</h3> <p>由于 JavaScript 的动态性，还有很多异步加载方法：&nbsp;<abbr title=\"XMLHttpRequest\">XHR</abbr>&nbsp;Injection、&nbsp;<abbr title=\"XMLHttpRequest\">XHR</abbr>&nbsp;Eval、&nbsp;Script In Iframe、&nbsp;Script defer 属性、&nbsp;document.write(script tag)。</p> <p>XHR Injection(XHR 注入)：通过 XMLHttpRequest 来获取 javascript，然后创建一个 script 元素插入到 DOM 结构中。ajax 请求成功后设置 script.text 为请求成功后返回的 responseText。</p> <pre> //获取 XMLHttpRequest 对象，考虑兼容性。 var getXmlHttp = function(){ var obj; if (window.XMLHttpRequest) obj = new XMLHttpRequest(); else obj = new ActiveXObject(\"Microsoft.XMLHTTP\"); return obj; }; //采用 Http 请求 get 方式;open()方法的第三个参数表示采用异步(true)还是同步(false)处理 var xmlHttp = getXmlHttp(); xmlHttp.open(\"GET\", \"http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js\", true); xmlHttp.send(); xmlHttp.onreadystatechange = function(){ if (xmlHttp.readyState == 4 && xmlHttp.status == 200){ var script = document.createElement(\"script\"); script.text = xmlHttp.responseText; document.getElementsByTagName(\"head\")\\[0\\].appendChild(script); } } </pre> <p>&nbsp;</p> <p>&nbsp;</p> <p>XHR Eval：与 XHR Injection 对 responseText 的执行方式不同，直接把 responseText 放在 eval()函数里面执行。</p> <pre> //获取 XMLHttpRequest 对象，考虑兼容性。 var getXmlHttp = function(){ var obj; if (window.XMLHttpRequest) obj = new XMLHttpRequest(); else obj = new ActiveXObject(\"Microsoft.XMLHTTP\"); return obj; }; //采用 Http 请求 get 方式;open()方法的第三个参数表示采用异步(true)还是同步(false)处理 var xmlHttp = getXmlHttp(); xmlHttp.open(\"GET\", \"http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js\", true); xmlHttp.send(); xmlHttp.onreadystatechange = function(){ if (xmlHttp.readyState == 4 && xmlHttp.status == 200){ eval(xmlHttp.responseText); //alert($);//可以弹出$,表明 JS 已经加载进来。click 事件放在其它出会出问题，应该是还没加载进来 $(\"#btn1\").click(function(){ alert($(this).text()); }); } } </pre> <p>&nbsp;</p> <p>&nbsp;</p> <p>Script In Irame：在父窗口插入一个 iframe 元素，然后再 iframe 中执行加载 JS 的操作。</p> <pre> var insertJS = function(){alert(2)}; var iframe = document.createElement(\"iframe\"); document.body.appendChild(iframe); var doc = iframe.contentWindow.document;//获取 iframe 中的 window 要用 contentWindow 属性。 doc.open(); doc.write(\"<script>var insertJS = function(){};<\\\\/script><body onload='insertJS()'></body>\"); doc.close();</pre> <p>&nbsp;</p> <p>&nbsp;</p> <p>GMail Mobile：业内 JS 内容被注释，所以不会执行，在需要的时候，获取 script 中的 text 内容去掉注释，调用 eval()执行。</p> <pre> <script type=\"text/javascript\"> /_ var ... _/\n\n### HTML5 新属性：async 和 defer 属性\n\ndefer 属性：IE4.0 就出现。defer 属声明脚本中将不会有 document.write 和 dom 修改。浏览器会并行下载其他有 defer 属性的 script。而不会阻塞页面后续处理。注：所有的 defer 脚本必须保证按顺序执行的。\n\nasync 属性：HTML5 新属性。脚本将在下载后尽快执行，作用同 defer，但是不能保证脚本按顺序执行。他们将在 onload 事件之前完成。\n\nFirefox 3.6、Opera 10.5、IE 9 和最新的 Chrome 和 Safari 都支持 async 属性。可以同时使用 async 和 defer，这样 IE 4 之后的所有 IE 都支持异步加载。\n\n没有 async 属性，script 将立即获取（下载）并执行，期间阻塞了浏览器的后续处理。如果有 async 属性，那么 script 将被异步下载并执行，同时浏览器继续后续的处理。\n\n总结： 对于支持 HTML5 的浏览器，实现 JS 的异步加载只需要在 script 元素中加上 async 属性，为了兼容老版本的 IE 还需加上 defer 属性；对于不支持 HTML5 的浏览器(IE 可以用 defer 实现)，可以采用以上几种方法实现。原理基本上都是向 DOM 中写入 script 或者通过 eval 函数执行 JS 代码，你可以把它放在匿名函数中执行，也可以在 onload 中执行，也可以通过 XHR 注入实现，也可以创建一个 iframe 元素，然后在 iframe 中执行插入 JS 代码。\n\n---\n\n## 三：延迟加载\n\n有些 JS 代码在某些情况在需要使用，并不是页面初始化的时候就要用到。延迟加载就是为了解决这个问题。将 JS 切分成许多模块，页面初始化时只加载需要立即执行的 JS，然后其它 JS 的加载延迟到第一次需要用到的时候再加载。类似图片的延迟加载。\n\nJS 的加载分为两个部分：下载和执行。异步加载只是解决了下载的问题，但是代码在下载完成后就会立即执行，在执行过程中浏览器处于阻塞状态，响应不了任何需求。\n\n解决思路：为了解决 JS 延迟加载的问题，可以利用异步加载缓存起来，但不立即执行，需要的时候在执行。如何进行缓存呢？将 JS 内容作为 Image 或者 Object 对象加载缓存起来，所以不会立即执行，然后在第一次需要的时候在执行。\n\n    1：模拟较长的下载时间：\n    利用thread让其sleep一段时间在执行下载操作。\n    2：模拟较长的JS代码执行时间\n    var start = Number(new Date());\n    while(start + 5000 > Number(new Date())){//执行JS}\n    这段代码将使JS执行5秒才完成！\n\nJS 延迟加载机制(LazyLoad)：简单来说，就是在浏览器滚动到某个位置在触发相关的函数，实现页面元素的加载或者某些动作的执行。如何实现浏览器滚动位置的检测呢？可以通过一个定时器来实现，通过比较某一时刻页面目标节点位置和浏览器滚动条高度来判断是否需要执行函数。\n","source":"_posts/2017-09-21-JS异步加载的三种方式.md","raw":"---\ntitle: JS异步加载的三种方式\ntags:\n  - 技术\ndate: 2017-09-21 08:49:00\ncategories: 前端\n---\n\n## 一：同步加载\n\n我们平时使用的最多的一种方式。\n\n同步模式，又称阻塞模式，会阻止浏览器的后续处理，停止后续的解析，只有当当前加载完成，才能进行下一步操作。所以默认同步执行才是安全的。但这样如果 js 中有输出 document 内容、修改 dom、重定向等行为，就会造成页面堵塞。所以一般建议把标签放在<body>结尾处，这样尽可能减少页面阻塞。</p> </div> <hr /> <h2><a name=\"t1\" target=\"\\_blank\"></a>二：异步加载</h2> <div> <p>异步加载又叫非阻塞加载，浏览器在下载执行 js 的同时，还会继续进行后续页面的处理。主要有三种方式。</p> <h3><a name=\"t2\" target=\"\\_blank\"></a>方法一：也叫 Script DOM Element</h3> <pre>(function(){ var scriptEle = document.createElement(\"script\"); scriptEle.type = \"text/javasctipt\"; scriptEle.async = true; scriptEle.src = \"http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js\"; var x = document.getElementsByTagName(\"head\")\\[0\\]; x.insertBefore(scriptEle, x.firstChild); })();</pre> <p><async>属性是 HTML5 中新增的异步支持。此方法被称为 Script DOM Element 方法。Google Analytics 和 Google+ Badge 都使用了这种异步加载代码</p> <pre>(function(){; var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')\\[0\\]; s.parentNode.insertBefore(ga, s); })();</pre> <p>但是这种加载方式执行完之前会阻止 onload 事件的触发，而现在很多页面的代码都在 onload 时还执行额外的渲染工作，所以还是会阻塞部分页面的初始化处理。</p> <h3><a name=\"t3\" target=\"\\_blank\"></a>方法二：onload 时的异步加载</h3> <pre>(function(){ if(window.attachEvent){ window.attachEvent(\"load\", asyncLoad); }else{ window.addEventListener(\"load\", asyncLoad); } var asyncLoad = function(){ var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')\\[0\\]; s.parentNode.insertBefore(ga, s); } )();</pre> <p>这种方法只是把插入 script 的方法放在一个函数里面，然后放在 window 的 onload 方法里面执行，这样就解决了阻塞 onload 事件触发的问题。</p> <p>注:DOMContentLoaded 与 load 的区别。前者是在 document 已经解析完成，页面中的 dom 元素可用，但是页面中的图片，视频，音频等资源未加载完，作用同 jQuery 中的 ready 事件；后者的区别在于页面所有资源全部加载完毕。</p> <p>&nbsp;</p> <h3><a name=\"t4\" target=\"\\_blank\"></a>方法三：其他方法</h3> <p>由于 JavaScript 的动态性，还有很多异步加载方法：&nbsp;<abbr title=\"XMLHttpRequest\">XHR</abbr>&nbsp;Injection、&nbsp;<abbr title=\"XMLHttpRequest\">XHR</abbr>&nbsp;Eval、&nbsp;Script In Iframe、&nbsp;Script defer 属性、&nbsp;document.write(script tag)。</p> <p>XHR Injection(XHR 注入)：通过 XMLHttpRequest 来获取 javascript，然后创建一个 script 元素插入到 DOM 结构中。ajax 请求成功后设置 script.text 为请求成功后返回的 responseText。</p> <pre> //获取 XMLHttpRequest 对象，考虑兼容性。 var getXmlHttp = function(){ var obj; if (window.XMLHttpRequest) obj = new XMLHttpRequest(); else obj = new ActiveXObject(\"Microsoft.XMLHTTP\"); return obj; }; //采用 Http 请求 get 方式;open()方法的第三个参数表示采用异步(true)还是同步(false)处理 var xmlHttp = getXmlHttp(); xmlHttp.open(\"GET\", \"http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js\", true); xmlHttp.send(); xmlHttp.onreadystatechange = function(){ if (xmlHttp.readyState == 4 && xmlHttp.status == 200){ var script = document.createElement(\"script\"); script.text = xmlHttp.responseText; document.getElementsByTagName(\"head\")\\[0\\].appendChild(script); } } </pre> <p>&nbsp;</p> <p>&nbsp;</p> <p>XHR Eval：与 XHR Injection 对 responseText 的执行方式不同，直接把 responseText 放在 eval()函数里面执行。</p> <pre> //获取 XMLHttpRequest 对象，考虑兼容性。 var getXmlHttp = function(){ var obj; if (window.XMLHttpRequest) obj = new XMLHttpRequest(); else obj = new ActiveXObject(\"Microsoft.XMLHTTP\"); return obj; }; //采用 Http 请求 get 方式;open()方法的第三个参数表示采用异步(true)还是同步(false)处理 var xmlHttp = getXmlHttp(); xmlHttp.open(\"GET\", \"http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js\", true); xmlHttp.send(); xmlHttp.onreadystatechange = function(){ if (xmlHttp.readyState == 4 && xmlHttp.status == 200){ eval(xmlHttp.responseText); //alert($);//可以弹出$,表明 JS 已经加载进来。click 事件放在其它出会出问题，应该是还没加载进来 $(\"#btn1\").click(function(){ alert($(this).text()); }); } } </pre> <p>&nbsp;</p> <p>&nbsp;</p> <p>Script In Irame：在父窗口插入一个 iframe 元素，然后再 iframe 中执行加载 JS 的操作。</p> <pre> var insertJS = function(){alert(2)}; var iframe = document.createElement(\"iframe\"); document.body.appendChild(iframe); var doc = iframe.contentWindow.document;//获取 iframe 中的 window 要用 contentWindow 属性。 doc.open(); doc.write(\"<script>var insertJS = function(){};<\\\\/script><body onload='insertJS()'></body>\"); doc.close();</pre> <p>&nbsp;</p> <p>&nbsp;</p> <p>GMail Mobile：业内 JS 内容被注释，所以不会执行，在需要的时候，获取 script 中的 text 内容去掉注释，调用 eval()执行。</p> <pre> <script type=\"text/javascript\"> /_ var ... _/\n\n### HTML5 新属性：async 和 defer 属性\n\ndefer 属性：IE4.0 就出现。defer 属声明脚本中将不会有 document.write 和 dom 修改。浏览器会并行下载其他有 defer 属性的 script。而不会阻塞页面后续处理。注：所有的 defer 脚本必须保证按顺序执行的。\n\nasync 属性：HTML5 新属性。脚本将在下载后尽快执行，作用同 defer，但是不能保证脚本按顺序执行。他们将在 onload 事件之前完成。\n\nFirefox 3.6、Opera 10.5、IE 9 和最新的 Chrome 和 Safari 都支持 async 属性。可以同时使用 async 和 defer，这样 IE 4 之后的所有 IE 都支持异步加载。\n\n没有 async 属性，script 将立即获取（下载）并执行，期间阻塞了浏览器的后续处理。如果有 async 属性，那么 script 将被异步下载并执行，同时浏览器继续后续的处理。\n\n总结： 对于支持 HTML5 的浏览器，实现 JS 的异步加载只需要在 script 元素中加上 async 属性，为了兼容老版本的 IE 还需加上 defer 属性；对于不支持 HTML5 的浏览器(IE 可以用 defer 实现)，可以采用以上几种方法实现。原理基本上都是向 DOM 中写入 script 或者通过 eval 函数执行 JS 代码，你可以把它放在匿名函数中执行，也可以在 onload 中执行，也可以通过 XHR 注入实现，也可以创建一个 iframe 元素，然后在 iframe 中执行插入 JS 代码。\n\n---\n\n## 三：延迟加载\n\n有些 JS 代码在某些情况在需要使用，并不是页面初始化的时候就要用到。延迟加载就是为了解决这个问题。将 JS 切分成许多模块，页面初始化时只加载需要立即执行的 JS，然后其它 JS 的加载延迟到第一次需要用到的时候再加载。类似图片的延迟加载。\n\nJS 的加载分为两个部分：下载和执行。异步加载只是解决了下载的问题，但是代码在下载完成后就会立即执行，在执行过程中浏览器处于阻塞状态，响应不了任何需求。\n\n解决思路：为了解决 JS 延迟加载的问题，可以利用异步加载缓存起来，但不立即执行，需要的时候在执行。如何进行缓存呢？将 JS 内容作为 Image 或者 Object 对象加载缓存起来，所以不会立即执行，然后在第一次需要的时候在执行。\n\n    1：模拟较长的下载时间：\n    利用thread让其sleep一段时间在执行下载操作。\n    2：模拟较长的JS代码执行时间\n    var start = Number(new Date());\n    while(start + 5000 > Number(new Date())){//执行JS}\n    这段代码将使JS执行5秒才完成！\n\nJS 延迟加载机制(LazyLoad)：简单来说，就是在浏览器滚动到某个位置在触发相关的函数，实现页面元素的加载或者某些动作的执行。如何实现浏览器滚动位置的检测呢？可以通过一个定时器来实现，通过比较某一时刻页面目标节点位置和浏览器滚动条高度来判断是否需要执行函数。\n","slug":"2017-09-21-JS异步加载的三种方式","published":1,"updated":"2020-03-14T06:48:44.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvmu004o4k8y5gq45yuw","content":"<h2 id=\"一：同步加载\"><a href=\"#一：同步加载\" class=\"headerlink\" title=\"一：同步加载\"></a>一：同步加载</h2><p>我们平时使用的最多的一种方式。</p>\n<p>同步模式，又称阻塞模式，会阻止浏览器的后续处理，停止后续的解析，只有当当前加载完成，才能进行下一步操作。所以默认同步执行才是安全的。但这样如果 js 中有输出 document 内容、修改 dom、重定向等行为，就会造成页面堵塞。所以一般建议把标签放在<body>结尾处，这样尽可能减少页面阻塞。</p> </div> <hr /> <h2><a name=\"t1\" target=\"\\_blank\"></a>二：异步加载</h2> <div> <p>异步加载又叫非阻塞加载，浏览器在下载执行 js 的同时，还会继续进行后续页面的处理。主要有三种方式。</p> <h3><a name=\"t2\" target=\"\\_blank\"></a>方法一：也叫 Script DOM Element</h3> <pre>(function(){ var scriptEle = document.createElement(\"script\"); scriptEle.type = \"text/javasctipt\"; scriptEle.async = true; scriptEle.src = \"<a href=\"http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js&quot;\">http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js&quot;</a>; var x = document.getElementsByTagName(\"head\")[0]; x.insertBefore(scriptEle, x.firstChild); })();</pre> <p><async>属性是 HTML5 中新增的异步支持。此方法被称为 Script DOM Element 方法。Google Analytics 和 Google+ Badge 都使用了这种异步加载代码</p> <pre>(function(){; var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? '<a href=\"https://ssl&#39;\" target=\"_blank\" rel=\"noopener\">https://ssl&#39;</a> : '<a href=\"http://www&#39;\" target=\"_blank\" rel=\"noopener\">http://www&#39;</a>) + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</pre> <p>但是这种加载方式执行完之前会阻止 onload 事件的触发，而现在很多页面的代码都在 onload 时还执行额外的渲染工作，所以还是会阻塞部分页面的初始化处理。</p> <h3><a name=\"t3\" target=\"\\_blank\"></a>方法二：onload 时的异步加载</h3> <pre>(function(){ if(window.attachEvent){ window.attachEvent(\"load\", asyncLoad); }else{ window.addEventListener(\"load\", asyncLoad); } var asyncLoad = function(){ var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? '<a href=\"https://ssl&#39;\">https://ssl&#39;</a> : '<a href=\"http://www&#39;\" target=\"_blank\" rel=\"noopener\">http://www&#39;</a>) + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); } )();</pre> <p>这种方法只是把插入 script 的方法放在一个函数里面，然后放在 window 的 onload 方法里面执行，这样就解决了阻塞 onload 事件触发的问题。</p> <p>注:DOMContentLoaded 与 load 的区别。前者是在 document 已经解析完成，页面中的 dom 元素可用，但是页面中的图片，视频，音频等资源未加载完，作用同 jQuery 中的 ready 事件；后者的区别在于页面所有资源全部加载完毕。</p> <p>&nbsp;</p> <h3><a name=\"t4\" target=\"\\_blank\"></a>方法三：其他方法</h3> <p>由于 JavaScript 的动态性，还有很多异步加载方法：&nbsp;<abbr title=\"XMLHttpRequest\">XHR</abbr>&nbsp;Injection、&nbsp;<abbr title=\"XMLHttpRequest\">XHR</abbr>&nbsp;Eval、&nbsp;Script In Iframe、&nbsp;Script defer 属性、&nbsp;document.write(script tag)。</p> <p>XHR Injection(XHR 注入)：通过 XMLHttpRequest 来获取 javascript，然后创建一个 script 元素插入到 DOM 结构中。ajax 请求成功后设置 script.text 为请求成功后返回的 responseText。</p> <pre> //获取 XMLHttpRequest 对象，考虑兼容性。 var getXmlHttp = function(){ var obj; if (window.XMLHttpRequest) obj = new XMLHttpRequest(); else obj = new ActiveXObject(\"Microsoft.XMLHTTP\"); return obj; }; //采用 Http 请求 get 方式;open()方法的第三个参数表示采用异步(true)还是同步(false)处理 var xmlHttp = getXmlHttp(); xmlHttp.open(\"GET\", \"<a href=\"http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js&quot;\">http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js&quot;</a>, true); xmlHttp.send(); xmlHttp.onreadystatechange = function(){ if (xmlHttp.readyState == 4 && xmlHttp.status == 200){ var script = document.createElement(\"script\"); script.text = xmlHttp.responseText; document.getElementsByTagName(\"head\")[0].appendChild(script); } } </pre> <p>&nbsp;</p> <p>&nbsp;</p> <p>XHR Eval：与 XHR Injection 对 responseText 的执行方式不同，直接把 responseText 放在 eval()函数里面执行。</p> <pre> //获取 XMLHttpRequest 对象，考虑兼容性。 var getXmlHttp = function(){ var obj; if (window.XMLHttpRequest) obj = new XMLHttpRequest(); else obj = new ActiveXObject(\"Microsoft.XMLHTTP\"); return obj; }; //采用 Http 请求 get 方式;open()方法的第三个参数表示采用异步(true)还是同步(false)处理 var xmlHttp = getXmlHttp(); xmlHttp.open(\"GET\", \"<a href=\"http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js&quot;\" target=\"_blank\" rel=\"noopener\">http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js&quot;</a>, true); xmlHttp.send(); xmlHttp.onreadystatechange = function(){ if (xmlHttp.readyState == 4 && xmlHttp.status == 200){ eval(xmlHttp.responseText); //alert($);//可以弹出$,表明 JS 已经加载进来。click 事件放在其它出会出问题，应该是还没加载进来 $(\"#btn1\").click(function(){ alert($(this).text()); }); } } </pre> <p>&nbsp;</p> <p>&nbsp;</p> <p>Script In Irame：在父窗口插入一个 iframe 元素，然后再 iframe 中执行加载 JS 的操作。</p> <pre> var insertJS = function(){alert(2)}; var iframe = document.createElement(\"iframe\"); document.body.appendChild(iframe); var doc = iframe.contentWindow.document;//获取 iframe 中的 window 要用 contentWindow 属性。 doc.open(); doc.write(\"<script>var insertJS = function(){};<\\/script><body onload='insertJS()'></body>\"); doc.close();</pre> <p>&nbsp;</p> <p>&nbsp;</p> <p>GMail Mobile：业内 JS 内容被注释，所以不会执行，在需要的时候，获取 script 中的 text 内容去掉注释，调用 eval()执行。</p> <pre> <script type=\"text/javascript\"> /_ var ... _/</p>\n<h3 id=\"HTML5-新属性：async-和-defer-属性\"><a href=\"#HTML5-新属性：async-和-defer-属性\" class=\"headerlink\" title=\"HTML5 新属性：async 和 defer 属性\"></a>HTML5 新属性：async 和 defer 属性</h3><p>defer 属性：IE4.0 就出现。defer 属声明脚本中将不会有 document.write 和 dom 修改。浏览器会并行下载其他有 defer 属性的 script。而不会阻塞页面后续处理。注：所有的 defer 脚本必须保证按顺序执行的。</p>\n<p>async 属性：HTML5 新属性。脚本将在下载后尽快执行，作用同 defer，但是不能保证脚本按顺序执行。他们将在 onload 事件之前完成。</p>\n<p>Firefox 3.6、Opera 10.5、IE 9 和最新的 Chrome 和 Safari 都支持 async 属性。可以同时使用 async 和 defer，这样 IE 4 之后的所有 IE 都支持异步加载。</p>\n<p>没有 async 属性，script 将立即获取（下载）并执行，期间阻塞了浏览器的后续处理。如果有 async 属性，那么 script 将被异步下载并执行，同时浏览器继续后续的处理。</p>\n<p>总结： 对于支持 HTML5 的浏览器，实现 JS 的异步加载只需要在 script 元素中加上 async 属性，为了兼容老版本的 IE 还需加上 defer 属性；对于不支持 HTML5 的浏览器(IE 可以用 defer 实现)，可以采用以上几种方法实现。原理基本上都是向 DOM 中写入 script 或者通过 eval 函数执行 JS 代码，你可以把它放在匿名函数中执行，也可以在 onload 中执行，也可以通过 XHR 注入实现，也可以创建一个 iframe 元素，然后在 iframe 中执行插入 JS 代码。</p>\n<hr>\n<h2 id=\"三：延迟加载\"><a href=\"#三：延迟加载\" class=\"headerlink\" title=\"三：延迟加载\"></a>三：延迟加载</h2><p>有些 JS 代码在某些情况在需要使用，并不是页面初始化的时候就要用到。延迟加载就是为了解决这个问题。将 JS 切分成许多模块，页面初始化时只加载需要立即执行的 JS，然后其它 JS 的加载延迟到第一次需要用到的时候再加载。类似图片的延迟加载。</p>\n<p>JS 的加载分为两个部分：下载和执行。异步加载只是解决了下载的问题，但是代码在下载完成后就会立即执行，在执行过程中浏览器处于阻塞状态，响应不了任何需求。</p>\n<p>解决思路：为了解决 JS 延迟加载的问题，可以利用异步加载缓存起来，但不立即执行，需要的时候在执行。如何进行缓存呢？将 JS 内容作为 Image 或者 Object 对象加载缓存起来，所以不会立即执行，然后在第一次需要的时候在执行。</p>\n<pre><code>1：模拟较长的下载时间：\n利用thread让其sleep一段时间在执行下载操作。\n2：模拟较长的JS代码执行时间\nvar start = Number(new Date());\nwhile(start + 5000 &gt; Number(new Date())){//执行JS}\n这段代码将使JS执行5秒才完成！</code></pre><p>JS 延迟加载机制(LazyLoad)：简单来说，就是在浏览器滚动到某个位置在触发相关的函数，实现页面元素的加载或者某些动作的执行。如何实现浏览器滚动位置的检测呢？可以通过一个定时器来实现，通过比较某一时刻页面目标节点位置和浏览器滚动条高度来判断是否需要执行函数。</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h2 id=\"一：同步加载\"><a href=\"#一：同步加载\" class=\"headerlink\" title=\"一：同步加载\"></a>一：同步加载</h2><p>我们平时使用的最多的一种方式。</p>\n<p>同步模式，又称阻塞模式，会阻止浏览器的后续处理，停止后续的解析，只有当当前加载完成，才能进行下一步操作。所以默认同步执行才是安全的。但这样如果 js 中有输出 document 内容、修改 dom、重定向等行为，就会造成页面堵塞。所以一般建议把标签放在<body>结尾处，这样尽可能减少页面阻塞。</p> </div> <hr /> <h2><a name=\"t1\" target=\"\\_blank\"></a>二：异步加载</h2> <div> <p>异步加载又叫非阻塞加载，浏览器在下载执行 js 的同时，还会继续进行后续页面的处理。主要有三种方式。</p> <h3><a name=\"t2\" target=\"\\_blank\"></a>方法一：也叫 Script DOM Element</h3> <pre>(function(){ var scriptEle = document.createElement(\"script\"); scriptEle.type = \"text/javasctipt\"; scriptEle.async = true; scriptEle.src = \"<a href=\"http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js&quot;\">http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js&quot;</a>; var x = document.getElementsByTagName(\"head\")[0]; x.insertBefore(scriptEle, x.firstChild); })();</pre> <p><async>属性是 HTML5 中新增的异步支持。此方法被称为 Script DOM Element 方法。Google Analytics 和 Google+ Badge 都使用了这种异步加载代码</p> <pre>(function(){; var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? '<a href=\"https://ssl&#39;\" target=\"_blank\" rel=\"noopener\">https://ssl&#39;</a> : '<a href=\"http://www&#39;\" target=\"_blank\" rel=\"noopener\">http://www&#39;</a>) + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</pre> <p>但是这种加载方式执行完之前会阻止 onload 事件的触发，而现在很多页面的代码都在 onload 时还执行额外的渲染工作，所以还是会阻塞部分页面的初始化处理。</p> <h3><a name=\"t3\" target=\"\\_blank\"></a>方法二：onload 时的异步加载</h3> <pre>(function(){ if(window.attachEvent){ window.attachEvent(\"load\", asyncLoad); }else{ window.addEventListener(\"load\", asyncLoad); } var asyncLoad = function(){ var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? '<a href=\"https://ssl&#39;\">https://ssl&#39;</a> : '<a href=\"http://www&#39;\" target=\"_blank\" rel=\"noopener\">http://www&#39;</a>) + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); } )();</pre> <p>这种方法只是把插入 script 的方法放在一个函数里面，然后放在 window 的 onload 方法里面执行，这样就解决了阻塞 onload 事件触发的问题。</p> <p>注:DOMContentLoaded 与 load 的区别。前者是在 document 已经解析完成，页面中的 dom 元素可用，但是页面中的图片，视频，音频等资源未加载完，作用同 jQuery 中的 ready 事件；后者的区别在于页面所有资源全部加载完毕。</p> <p>&nbsp;</p> <h3><a name=\"t4\" target=\"\\_blank\"></a>方法三：其他方法</h3> <p>由于 JavaScript 的动态性，还有很多异步加载方法：&nbsp;<abbr title=\"XMLHttpRequest\">XHR</abbr>&nbsp;Injection、&nbsp;<abbr title=\"XMLHttpRequest\">XHR</abbr>&nbsp;Eval、&nbsp;Script In Iframe、&nbsp;Script defer 属性、&nbsp;document.write(script tag)。</p> <p>XHR Injection(XHR 注入)：通过 XMLHttpRequest 来获取 javascript，然后创建一个 script 元素插入到 DOM 结构中。ajax 请求成功后设置 script.text 为请求成功后返回的 responseText。</p> <pre> //获取 XMLHttpRequest 对象，考虑兼容性。 var getXmlHttp = function(){ var obj; if (window.XMLHttpRequest) obj = new XMLHttpRequest(); else obj = new ActiveXObject(\"Microsoft.XMLHTTP\"); return obj; }; //采用 Http 请求 get 方式;open()方法的第三个参数表示采用异步(true)还是同步(false)处理 var xmlHttp = getXmlHttp(); xmlHttp.open(\"GET\", \"<a href=\"http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js&quot;\">http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js&quot;</a>, true); xmlHttp.send(); xmlHttp.onreadystatechange = function(){ if (xmlHttp.readyState == 4 && xmlHttp.status == 200){ var script = document.createElement(\"script\"); script.text = xmlHttp.responseText; document.getElementsByTagName(\"head\")[0].appendChild(script); } } </pre> <p>&nbsp;</p> <p>&nbsp;</p> <p>XHR Eval：与 XHR Injection 对 responseText 的执行方式不同，直接把 responseText 放在 eval()函数里面执行。</p> <pre> //获取 XMLHttpRequest 对象，考虑兼容性。 var getXmlHttp = function(){ var obj; if (window.XMLHttpRequest) obj = new XMLHttpRequest(); else obj = new ActiveXObject(\"Microsoft.XMLHTTP\"); return obj; }; //采用 Http 请求 get 方式;open()方法的第三个参数表示采用异步(true)还是同步(false)处理 var xmlHttp = getXmlHttp(); xmlHttp.open(\"GET\", \"<a href=\"http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js&quot;\" target=\"_blank\" rel=\"noopener\">http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js&quot;</a>, true); xmlHttp.send(); xmlHttp.onreadystatechange = function(){ if (xmlHttp.readyState == 4 && xmlHttp.status == 200){ eval(xmlHttp.responseText); //alert($);//可以弹出$,表明 JS 已经加载进来。click 事件放在其它出会出问题，应该是还没加载进来 $(\"#btn1\").click(function(){ alert($(this).text()); }); } } </pre> <p>&nbsp;</p> <p>&nbsp;</p> <p>Script In Irame：在父窗口插入一个 iframe 元素，然后再 iframe 中执行加载 JS 的操作。</p> <pre> var insertJS = function(){alert(2)}; var iframe = document.createElement(\"iframe\"); document.body.appendChild(iframe); var doc = iframe.contentWindow.document;//获取 iframe 中的 window 要用 contentWindow 属性。 doc.open(); doc.write(\"<script>var insertJS = function(){};<\\/script><body onload='insertJS()'></body>\"); doc.close();</pre> <p>&nbsp;</p> <p>&nbsp;</p> <p>GMail Mobile：业内 JS 内容被注释，所以不会执行，在需要的时候，获取 script 中的 text 内容去掉注释，调用 eval()执行。</p> <pre> <script type=\"text/javascript\"> /_ var ... _/</p>\n<h3 id=\"HTML5-新属性：async-和-defer-属性\"><a href=\"#HTML5-新属性：async-和-defer-属性\" class=\"headerlink\" title=\"HTML5 新属性：async 和 defer 属性\"></a>HTML5 新属性：async 和 defer 属性</h3><p>defer 属性：IE4.0 就出现。defer 属声明脚本中将不会有 document.write 和 dom 修改。浏览器会并行下载其他有 defer 属性的 script。而不会阻塞页面后续处理。注：所有的 defer 脚本必须保证按顺序执行的。</p>\n<p>async 属性：HTML5 新属性。脚本将在下载后尽快执行，作用同 defer，但是不能保证脚本按顺序执行。他们将在 onload 事件之前完成。</p>\n<p>Firefox 3.6、Opera 10.5、IE 9 和最新的 Chrome 和 Safari 都支持 async 属性。可以同时使用 async 和 defer，这样 IE 4 之后的所有 IE 都支持异步加载。</p>\n<p>没有 async 属性，script 将立即获取（下载）并执行，期间阻塞了浏览器的后续处理。如果有 async 属性，那么 script 将被异步下载并执行，同时浏览器继续后续的处理。</p>\n<p>总结： 对于支持 HTML5 的浏览器，实现 JS 的异步加载只需要在 script 元素中加上 async 属性，为了兼容老版本的 IE 还需加上 defer 属性；对于不支持 HTML5 的浏览器(IE 可以用 defer 实现)，可以采用以上几种方法实现。原理基本上都是向 DOM 中写入 script 或者通过 eval 函数执行 JS 代码，你可以把它放在匿名函数中执行，也可以在 onload 中执行，也可以通过 XHR 注入实现，也可以创建一个 iframe 元素，然后在 iframe 中执行插入 JS 代码。</p>\n<hr>\n<h2 id=\"三：延迟加载\"><a href=\"#三：延迟加载\" class=\"headerlink\" title=\"三：延迟加载\"></a>三：延迟加载</h2><p>有些 JS 代码在某些情况在需要使用，并不是页面初始化的时候就要用到。延迟加载就是为了解决这个问题。将 JS 切分成许多模块，页面初始化时只加载需要立即执行的 JS，然后其它 JS 的加载延迟到第一次需要用到的时候再加载。类似图片的延迟加载。</p>\n<p>JS 的加载分为两个部分：下载和执行。异步加载只是解决了下载的问题，但是代码在下载完成后就会立即执行，在执行过程中浏览器处于阻塞状态，响应不了任何需求。</p>\n<p>解决思路：为了解决 JS 延迟加载的问题，可以利用异步加载缓存起来，但不立即执行，需要的时候在执行。如何进行缓存呢？将 JS 内容作为 Image 或者 Object 对象加载缓存起来，所以不会立即执行，然后在第一次需要的时候在执行。</p>\n<pre><code>1：模拟较长的下载时间：\n利用thread让其sleep一段时间在执行下载操作。\n2：模拟较长的JS代码执行时间\nvar start = Number(new Date());\nwhile(start + 5000 &gt; Number(new Date())){//执行JS}\n这段代码将使JS执行5秒才完成！</code></pre><p>JS 延迟加载机制(LazyLoad)：简单来说，就是在浏览器滚动到某个位置在触发相关的函数，实现页面元素的加载或者某些动作的执行。如何实现浏览器滚动位置的检测呢？可以通过一个定时器来实现，通过比较某一时刻页面目标节点位置和浏览器滚动条高度来判断是否需要执行函数。</p>\n"},{"title":"Chrome 控制台console的用法","date":"2017-11-12T04:55:00.000Z","_content":"\n大家都有用过各种类型的浏览器，每种浏览器都有自己的特色，本人拙见，在我用过的浏览器当中，我是最喜欢 Chrome 的，因为它对于调试脚本及前端设计调试都有它比其它浏览器有过之而无不及的地方。可能大家对 console.log 会有一定的了解，心里难免会想调试的时候用 alert 不就行了，干嘛还要用 console.log 这么一长串的字符串来替代 alert 输出信息呢，下面我就介绍一些调试的入门技巧，让你爱上 console.log\n\n先的简单介绍一下 chrome 的控制台，打开 chrome 浏览器，按 f12 就可以轻松的打开控制台\n\n![](https://segmentfault.com/img/bVkGtt)\n\n大家可以看到控制台里面有一首诗还有其它信息，如果想清空控制台，可以点击左上角那个![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230851146562060.png&objectId=1190000002511877&token=d9955a953261784a0bfc7458fd97b442)来清空，当然也可以通过在控制台输入 console.clear()来实现清空控制台信息。如下图所示\n\n![](https://segmentfault.com/img/bVkGtu)\n\n现在假设一个场景，如果一个数组里面有成百上千的元素，但是你想知道每个元素具体的值，这时候想想如果你用 alert 那将是多惨的一件事情，因为 alert 阻断线程运行，你不点击 alert 框的确定按钮下一个 alert 就不会出现。\n\n下面我们用 console.log 来替换，感受一下它的魅力。\n\n![](https://segmentfault.com/img/bVkGtv)\n\n看了上面这张图，是不是认识到 log 的强大之处了，下面我们来看看 console 里面具体提供了哪些方法可以供我们平时调试时使用。\n\n![](https://segmentfault.com/img/bVkGtH)\n\n# 目前控制台方法和属性有：\n\n\\[\"\\$$\", \"$x\", \"dir\", \"dirxml\", \"keys\", \"values\", \"profile\", \"profileEnd\", \"monitorEvents\", \"unmonitorEvents\", \"inspect\", \"copy\", \"clear\", \"getEventListeners\", \"undebug\", \"monitor\", \"unmonitor\", \"table\", \"$0\", \"$1\", \"$2\", \"$3\", \"$4\", \"$\\_\"\\]\n\n下面我们来一一介绍一下各个方法主要的用途。\n\n一般情况下我们用来输入信息的方法主要是用到如下四个\n\n**1、console.log**  用于输出普通信息\n\n**2、console.info **用于输出提示性信息\n\n**3、console.error**用于输出错误信息\n\n**4、console.warn**用于输出警示信息\n\n**5、console.debug**用于输出调试信息\n\n用图来说话\n\n![](https://segmentfault.com/img/bVkGtK)\n\nconsole 对象的上面 5 种方法，都可以使用 printf 风格的占位符。不过，占位符的种类比较少，**只支持字符（%s）、整数（%d 或%i）、浮点数（%f）和对象（%o）四种**。\n\n    console.log(\"%d年%d月%d日\",2011,3,26);\n    console.log(\"圆周率是%f\",3.1415926);\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201501/071628584845899.png&objectId=1190000002511877&token=5d84fec83bdaf09ef380abf408aef480)\n\n%o 占位符，可以用来查看一个对象内部情况\n\nvar dog = {};\ndog.name = \"大毛\";\ndog.color = \"黄色\";\nconsole.log(\"%o\", dog);\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201501/071629171711956.png&objectId=1190000002511877&token=d847680e87ce7804eecfc12cf136dc04)\n\n**6、**console.dirxml 用来显示网页的某个节点（node）所包含的 html/xml 代码\\*\\*\\*\\*\n\n    <body>\n        <table id=\"mytable\">\n            <tr>\n                <td>Atd>\n                <td>Atd>\n                <td>Atd>\n            tr>\n            <tr>\n                <td>bbbtd>\n                <td>aaatd>\n                <td>ccctd>\n            tr>\n            <tr>\n                <td>111td>\n                <td>333td>\n                <td>222td>\n            tr>\n        table>\n    body>\n    <script type=\"text/javascript\">\n        window.onload = function () {\n            var mytable = document.getElementById('mytable');\n            console.dirxml(mytable);\n        }\n    script>\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201501/071633365937534.png&objectId=1190000002511877&token=2e276ad833ec50c4aab7a1228de3b2bf)\n\n**7、console.group**输出一组信息的开头\n\n**8、console.groupEnd**结束一组输出信息\n\n看你需求选择不同的输出方法来使用，如果上述四个方法再配合 group 和 groupEnd 方法来一起使用就可以输入各种各样的不同形式的输出信息。\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230916203758554.jpg&objectId=1190000002511877&token=49e91f3be002204bdcbd873039895377)\n\n哈哈，是不是觉得很神奇呀！\n\n**9、console.assert**对输入的表达式进行断言，只有表达式为 false 时，才输出相应的信息到控制台\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230920471094898.jpg&objectId=1190000002511877&token=b473f990a80491b1b4a37772e7a382bb)\n\n**10、console.count**（这个方法非常实用哦）当你想统计代码被执行的次数\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230922575009930.jpg&objectId=1190000002511877&token=485de6bf631b90358eb2de9e8d36d926)\n\n**11、console.dir**(这个方法是我经常使用的 可不知道比 for in 方便了多少)直接将该 DOM 结点以 DOM 树的结构进行输出，可以详细查对象的方法发展等等\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230936046711444.jpg&objectId=1190000002511877&token=e1d0dbd1b6b68147b3028bb7501a2c0d)\n\n**12、console.time **计时开始\n\n**13、console.timeEnd**  计时结束（看了下面的图你瞬间就感受到它的厉害了）\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230941441714991.jpg&objectId=1190000002511877&token=7642ba7799c56505e4920a72475a51bd)\n\n**14、console.profile**和**console.profileEnd**配合一起使用来查看 CPU 使用相关信息\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230947391254586.jpg&objectId=1190000002511877&token=3207740cc153fa6f3b6576a52cad7f92)\n\n在 Profiles 面板里面查看就可以看到 cpu 相关使用信息\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230948160786229.jpg&objectId=1190000002511877&token=bc1a094bc9cc221cfc078fa7755204a5)\n\n**15、console.timeLine**和**console.timeLineEnd**配合一起记录一段时间轴\n\n**16、console.trace**  堆栈跟踪相关的调试\n\n上述方法只是我个人理解罢了。如果想查看具体 API，可以上官方看看，具体地址为：[https://developer.chrome.com/devtools/docs/console-api](https://developer.chrome.com/devtools/docs/console-api)\n\n# 控制台的一些快捷键\n\n**1、方向键盘的上下键**，大家一用就知晓。比如用上键就相当于使用上次在控制台的输入符号\n\n**2、\\$\\_**命令返回最近一次表达式执行的结果，功能跟按向上的方向键再回车是一样的\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230958084845245.jpg&objectId=1190000002511877&token=a0b26c6487a4618c276db6c29cd04dc4)\n\n上面的`$_`需要领悟其奥义才能使用得当，而 04 则代表了最近 5 个你选择过的 DOM 节点。\n\n什么意思？在页面右击选择`审查元素`，然后在弹出来的 DOM 结点树上面随便点选，这些被点过的节点会被记录下来，而`$0`会返回最近一次点选的 DOM 结点，以此类推，\\$1 返回的是上上次点选的 DOM 节点，最多保存了 5 个，如果不够 5 个，则返回`undefined`。\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/431064/201409/132239377465002.gif&objectId=1190000002511877&token=b533e2aab9af146a70246d329460dfb8)\n\n**3、Chrome 控制台中原生支持类 jQuery 的选择器**，也就是说你可以用`$`加上熟悉的 css 选择器来选择 DOM 节点\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231001310469893.jpg&objectId=1190000002511877&token=f76fc920968739f7baa1bcb71963e242)\n\n**4、copy**通过此命令可以将在控制台获取到的内容复制到剪贴板\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231004464535964.jpg&objectId=1190000002511877&token=e0108885b29ae4ab9dc51428f6801a7d)\n\n（哈哈 刚刚从控制台复制的 body 里面的 html 可以任意粘贴到哪, 比如记事本, 是不是觉得功能很强大）\n\n**5、keys 和 values**前者返回传入对象所有属性名组成的数据，后者返回所有属性值组成的数组\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231008342653765.jpg&objectId=1190000002511877&token=effde5e09dd13b2ba6e815101b997401)\n\n说到这，不免想起**console.table**方法了\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231012102186590.jpg&objectId=1190000002511877&token=556375fd7918ae7677206dbdd9c7e206)\n\n**6、monitor & unmonitor**\n\nmonitor(function)，它接收一个函数名作为参数，比如`function a`,每次`a`被执行了，都会在控制台输出一条信息，里面包含了函数的名称`a`及执行时所传入的参数。\n\n而 unmonitor(function)便是用来停止这一监听。\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231015303594113.jpg&objectId=1190000002511877&token=373000d3f444c974aefbe33ff44f6667)\n\n看了这张图，应该明白了，也就是说在 monitor 和 unmonitor 中间的代码，执行的时候会在控制台输出一条信息，里面包含了函数的名称`a`及执行时所传入的参数。当解除监视（也就是执行 unmonitor 时）就不再在控制台输出信息了。\n\n- \\$ // 简单理解就是 document.querySelector 而已。\n- $$\n  $$\n- \\$\\_ // 是上一个表达式的值\n- 0−4 // 是最近 5 个 Elements 面板选中的 DOM 元素，待会会讲。\n- dir // 其实就是 console.dir\n- keys // 取对象的键名, 返回键名组成的数组\n- values // 去对象的值, 返回值组成的数组\n\n下面看一下 console.log 的一些技巧\n\n**1、重写 console.log 改变输出文字的样式**\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231020045932166.png&objectId=1190000002511877&token=91bd45a689c10ada46699bcf697afa31)\n\n**2、利用控制台输出图片**\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/431064/201409/132234240277278.gif&objectId=1190000002511877&token=5af8c00ca9cbfed8e44c26de079f77f3)\n\n**3、指定输出文字的样式**\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231028494216061.png&objectId=1190000002511877&token=e1dfef3078ca896f98bd0fb8f43257e4)\n\n最后说一下 chrome 控制台一个简单的操作，如何查看页面元素，看下图就知道了\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/i/477954/201406/161255380974581.jpg&objectId=1190000002511877&token=d570e0c9c2de5d6e8108c1fd6d67369f)\n","source":"_posts/2017-11-12-控制台console的用法.md","raw":"---\ntitle: Chrome 控制台console的用法\ntags:\n  - 工具\ndate: 2017-11-12 12:55:00\ncategories: 教程\n---\n\n大家都有用过各种类型的浏览器，每种浏览器都有自己的特色，本人拙见，在我用过的浏览器当中，我是最喜欢 Chrome 的，因为它对于调试脚本及前端设计调试都有它比其它浏览器有过之而无不及的地方。可能大家对 console.log 会有一定的了解，心里难免会想调试的时候用 alert 不就行了，干嘛还要用 console.log 这么一长串的字符串来替代 alert 输出信息呢，下面我就介绍一些调试的入门技巧，让你爱上 console.log\n\n先的简单介绍一下 chrome 的控制台，打开 chrome 浏览器，按 f12 就可以轻松的打开控制台\n\n![](https://segmentfault.com/img/bVkGtt)\n\n大家可以看到控制台里面有一首诗还有其它信息，如果想清空控制台，可以点击左上角那个![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230851146562060.png&objectId=1190000002511877&token=d9955a953261784a0bfc7458fd97b442)来清空，当然也可以通过在控制台输入 console.clear()来实现清空控制台信息。如下图所示\n\n![](https://segmentfault.com/img/bVkGtu)\n\n现在假设一个场景，如果一个数组里面有成百上千的元素，但是你想知道每个元素具体的值，这时候想想如果你用 alert 那将是多惨的一件事情，因为 alert 阻断线程运行，你不点击 alert 框的确定按钮下一个 alert 就不会出现。\n\n下面我们用 console.log 来替换，感受一下它的魅力。\n\n![](https://segmentfault.com/img/bVkGtv)\n\n看了上面这张图，是不是认识到 log 的强大之处了，下面我们来看看 console 里面具体提供了哪些方法可以供我们平时调试时使用。\n\n![](https://segmentfault.com/img/bVkGtH)\n\n# 目前控制台方法和属性有：\n\n\\[\"\\$$\", \"$x\", \"dir\", \"dirxml\", \"keys\", \"values\", \"profile\", \"profileEnd\", \"monitorEvents\", \"unmonitorEvents\", \"inspect\", \"copy\", \"clear\", \"getEventListeners\", \"undebug\", \"monitor\", \"unmonitor\", \"table\", \"$0\", \"$1\", \"$2\", \"$3\", \"$4\", \"$\\_\"\\]\n\n下面我们来一一介绍一下各个方法主要的用途。\n\n一般情况下我们用来输入信息的方法主要是用到如下四个\n\n**1、console.log**  用于输出普通信息\n\n**2、console.info **用于输出提示性信息\n\n**3、console.error**用于输出错误信息\n\n**4、console.warn**用于输出警示信息\n\n**5、console.debug**用于输出调试信息\n\n用图来说话\n\n![](https://segmentfault.com/img/bVkGtK)\n\nconsole 对象的上面 5 种方法，都可以使用 printf 风格的占位符。不过，占位符的种类比较少，**只支持字符（%s）、整数（%d 或%i）、浮点数（%f）和对象（%o）四种**。\n\n    console.log(\"%d年%d月%d日\",2011,3,26);\n    console.log(\"圆周率是%f\",3.1415926);\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201501/071628584845899.png&objectId=1190000002511877&token=5d84fec83bdaf09ef380abf408aef480)\n\n%o 占位符，可以用来查看一个对象内部情况\n\nvar dog = {};\ndog.name = \"大毛\";\ndog.color = \"黄色\";\nconsole.log(\"%o\", dog);\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201501/071629171711956.png&objectId=1190000002511877&token=d847680e87ce7804eecfc12cf136dc04)\n\n**6、**console.dirxml 用来显示网页的某个节点（node）所包含的 html/xml 代码\\*\\*\\*\\*\n\n    <body>\n        <table id=\"mytable\">\n            <tr>\n                <td>Atd>\n                <td>Atd>\n                <td>Atd>\n            tr>\n            <tr>\n                <td>bbbtd>\n                <td>aaatd>\n                <td>ccctd>\n            tr>\n            <tr>\n                <td>111td>\n                <td>333td>\n                <td>222td>\n            tr>\n        table>\n    body>\n    <script type=\"text/javascript\">\n        window.onload = function () {\n            var mytable = document.getElementById('mytable');\n            console.dirxml(mytable);\n        }\n    script>\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201501/071633365937534.png&objectId=1190000002511877&token=2e276ad833ec50c4aab7a1228de3b2bf)\n\n**7、console.group**输出一组信息的开头\n\n**8、console.groupEnd**结束一组输出信息\n\n看你需求选择不同的输出方法来使用，如果上述四个方法再配合 group 和 groupEnd 方法来一起使用就可以输入各种各样的不同形式的输出信息。\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230916203758554.jpg&objectId=1190000002511877&token=49e91f3be002204bdcbd873039895377)\n\n哈哈，是不是觉得很神奇呀！\n\n**9、console.assert**对输入的表达式进行断言，只有表达式为 false 时，才输出相应的信息到控制台\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230920471094898.jpg&objectId=1190000002511877&token=b473f990a80491b1b4a37772e7a382bb)\n\n**10、console.count**（这个方法非常实用哦）当你想统计代码被执行的次数\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230922575009930.jpg&objectId=1190000002511877&token=485de6bf631b90358eb2de9e8d36d926)\n\n**11、console.dir**(这个方法是我经常使用的 可不知道比 for in 方便了多少)直接将该 DOM 结点以 DOM 树的结构进行输出，可以详细查对象的方法发展等等\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230936046711444.jpg&objectId=1190000002511877&token=e1d0dbd1b6b68147b3028bb7501a2c0d)\n\n**12、console.time **计时开始\n\n**13、console.timeEnd**  计时结束（看了下面的图你瞬间就感受到它的厉害了）\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230941441714991.jpg&objectId=1190000002511877&token=7642ba7799c56505e4920a72475a51bd)\n\n**14、console.profile**和**console.profileEnd**配合一起使用来查看 CPU 使用相关信息\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230947391254586.jpg&objectId=1190000002511877&token=3207740cc153fa6f3b6576a52cad7f92)\n\n在 Profiles 面板里面查看就可以看到 cpu 相关使用信息\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230948160786229.jpg&objectId=1190000002511877&token=bc1a094bc9cc221cfc078fa7755204a5)\n\n**15、console.timeLine**和**console.timeLineEnd**配合一起记录一段时间轴\n\n**16、console.trace**  堆栈跟踪相关的调试\n\n上述方法只是我个人理解罢了。如果想查看具体 API，可以上官方看看，具体地址为：[https://developer.chrome.com/devtools/docs/console-api](https://developer.chrome.com/devtools/docs/console-api)\n\n# 控制台的一些快捷键\n\n**1、方向键盘的上下键**，大家一用就知晓。比如用上键就相当于使用上次在控制台的输入符号\n\n**2、\\$\\_**命令返回最近一次表达式执行的结果，功能跟按向上的方向键再回车是一样的\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230958084845245.jpg&objectId=1190000002511877&token=a0b26c6487a4618c276db6c29cd04dc4)\n\n上面的`$_`需要领悟其奥义才能使用得当，而 04 则代表了最近 5 个你选择过的 DOM 节点。\n\n什么意思？在页面右击选择`审查元素`，然后在弹出来的 DOM 结点树上面随便点选，这些被点过的节点会被记录下来，而`$0`会返回最近一次点选的 DOM 结点，以此类推，\\$1 返回的是上上次点选的 DOM 节点，最多保存了 5 个，如果不够 5 个，则返回`undefined`。\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/431064/201409/132239377465002.gif&objectId=1190000002511877&token=b533e2aab9af146a70246d329460dfb8)\n\n**3、Chrome 控制台中原生支持类 jQuery 的选择器**，也就是说你可以用`$`加上熟悉的 css 选择器来选择 DOM 节点\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231001310469893.jpg&objectId=1190000002511877&token=f76fc920968739f7baa1bcb71963e242)\n\n**4、copy**通过此命令可以将在控制台获取到的内容复制到剪贴板\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231004464535964.jpg&objectId=1190000002511877&token=e0108885b29ae4ab9dc51428f6801a7d)\n\n（哈哈 刚刚从控制台复制的 body 里面的 html 可以任意粘贴到哪, 比如记事本, 是不是觉得功能很强大）\n\n**5、keys 和 values**前者返回传入对象所有属性名组成的数据，后者返回所有属性值组成的数组\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231008342653765.jpg&objectId=1190000002511877&token=effde5e09dd13b2ba6e815101b997401)\n\n说到这，不免想起**console.table**方法了\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231012102186590.jpg&objectId=1190000002511877&token=556375fd7918ae7677206dbdd9c7e206)\n\n**6、monitor & unmonitor**\n\nmonitor(function)，它接收一个函数名作为参数，比如`function a`,每次`a`被执行了，都会在控制台输出一条信息，里面包含了函数的名称`a`及执行时所传入的参数。\n\n而 unmonitor(function)便是用来停止这一监听。\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231015303594113.jpg&objectId=1190000002511877&token=373000d3f444c974aefbe33ff44f6667)\n\n看了这张图，应该明白了，也就是说在 monitor 和 unmonitor 中间的代码，执行的时候会在控制台输出一条信息，里面包含了函数的名称`a`及执行时所传入的参数。当解除监视（也就是执行 unmonitor 时）就不再在控制台输出信息了。\n\n- \\$ // 简单理解就是 document.querySelector 而已。\n- $$\n  $$\n- \\$\\_ // 是上一个表达式的值\n- 0−4 // 是最近 5 个 Elements 面板选中的 DOM 元素，待会会讲。\n- dir // 其实就是 console.dir\n- keys // 取对象的键名, 返回键名组成的数组\n- values // 去对象的值, 返回值组成的数组\n\n下面看一下 console.log 的一些技巧\n\n**1、重写 console.log 改变输出文字的样式**\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231020045932166.png&objectId=1190000002511877&token=91bd45a689c10ada46699bcf697afa31)\n\n**2、利用控制台输出图片**\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/431064/201409/132234240277278.gif&objectId=1190000002511877&token=5af8c00ca9cbfed8e44c26de079f77f3)\n\n**3、指定输出文字的样式**\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231028494216061.png&objectId=1190000002511877&token=e1dfef3078ca896f98bd0fb8f43257e4)\n\n最后说一下 chrome 控制台一个简单的操作，如何查看页面元素，看下图就知道了\n\n![](https://segmentfault.com/image?src=http://images.cnitblog.com/i/477954/201406/161255380974581.jpg&objectId=1190000002511877&token=d570e0c9c2de5d6e8108c1fd6d67369f)\n","slug":"2017-11-12-控制台console的用法","published":1,"updated":"2020-03-14T06:48:58.621Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvmv004r4k8yhfa5hy1v","content":"<p>大家都有用过各种类型的浏览器，每种浏览器都有自己的特色，本人拙见，在我用过的浏览器当中，我是最喜欢 Chrome 的，因为它对于调试脚本及前端设计调试都有它比其它浏览器有过之而无不及的地方。可能大家对 console.log 会有一定的了解，心里难免会想调试的时候用 alert 不就行了，干嘛还要用 console.log 这么一长串的字符串来替代 alert 输出信息呢，下面我就介绍一些调试的入门技巧，让你爱上 console.log</p>\n<p>先的简单介绍一下 chrome 的控制台，打开 chrome 浏览器，按 f12 就可以轻松的打开控制台</p>\n<p><img src=\"https://segmentfault.com/img/bVkGtt\" alt=\"\"></p>\n<p>大家可以看到控制台里面有一首诗还有其它信息，如果想清空控制台，可以点击左上角那个<img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230851146562060.png&objectId=1190000002511877&token=d9955a953261784a0bfc7458fd97b442\" alt=\"\">来清空，当然也可以通过在控制台输入 console.clear()来实现清空控制台信息。如下图所示</p>\n<p><img src=\"https://segmentfault.com/img/bVkGtu\" alt=\"\"></p>\n<p>现在假设一个场景，如果一个数组里面有成百上千的元素，但是你想知道每个元素具体的值，这时候想想如果你用 alert 那将是多惨的一件事情，因为 alert 阻断线程运行，你不点击 alert 框的确定按钮下一个 alert 就不会出现。</p>\n<p>下面我们用 console.log 来替换，感受一下它的魅力。</p>\n<p><img src=\"https://segmentfault.com/img/bVkGtv\" alt=\"\"></p>\n<p>看了上面这张图，是不是认识到 log 的强大之处了，下面我们来看看 console 里面具体提供了哪些方法可以供我们平时调试时使用。</p>\n<p><img src=\"https://segmentfault.com/img/bVkGtH\" alt=\"\"></p>\n<h1 id=\"目前控制台方法和属性有：\"><a href=\"#目前控制台方法和属性有：\" class=\"headerlink\" title=\"目前控制台方法和属性有：\"></a>目前控制台方法和属性有：</h1><p>[“$$”, “$x”, “dir”, “dirxml”, “keys”, “values”, “profile”, “profileEnd”, “monitorEvents”, “unmonitorEvents”, “inspect”, “copy”, “clear”, “getEventListeners”, “undebug”, “monitor”, “unmonitor”, “table”, “$0”, “$1”, “$2”, “$3”, “$4”, “$_“]</p>\n<p>下面我们来一一介绍一下各个方法主要的用途。</p>\n<p>一般情况下我们用来输入信息的方法主要是用到如下四个</p>\n<p><strong>1、console.log</strong>  用于输出普通信息</p>\n<p>*<em>2、console.info *</em>用于输出提示性信息</p>\n<p><strong>3、console.error</strong>用于输出错误信息</p>\n<p><strong>4、console.warn</strong>用于输出警示信息</p>\n<p><strong>5、console.debug</strong>用于输出调试信息</p>\n<p>用图来说话</p>\n<p><img src=\"https://segmentfault.com/img/bVkGtK\" alt=\"\"></p>\n<p>console 对象的上面 5 种方法，都可以使用 printf 风格的占位符。不过，占位符的种类比较少，<strong>只支持字符（%s）、整数（%d 或%i）、浮点数（%f）和对象（%o）四种</strong>。</p>\n<pre><code>console.log(&quot;%d年%d月%d日&quot;,2011,3,26);\nconsole.log(&quot;圆周率是%f&quot;,3.1415926);</code></pre><p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201501/071628584845899.png&objectId=1190000002511877&token=5d84fec83bdaf09ef380abf408aef480\" alt=\"\"></p>\n<p>%o 占位符，可以用来查看一个对象内部情况</p>\n<p>var dog = {};<br>dog.name = “大毛”;<br>dog.color = “黄色”;<br>console.log(“%o”, dog);</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201501/071629171711956.png&objectId=1190000002511877&token=d847680e87ce7804eecfc12cf136dc04\" alt=\"\"></p>\n<p><strong>6、</strong>console.dirxml 用来显示网页的某个节点（node）所包含的 html/xml 代码****</p>\n<pre><code>&lt;body&gt;\n    &lt;table id=&quot;mytable&quot;&gt;\n        &lt;tr&gt;\n            &lt;td&gt;Atd&gt;\n            &lt;td&gt;Atd&gt;\n            &lt;td&gt;Atd&gt;\n        tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;bbbtd&gt;\n            &lt;td&gt;aaatd&gt;\n            &lt;td&gt;ccctd&gt;\n        tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;111td&gt;\n            &lt;td&gt;333td&gt;\n            &lt;td&gt;222td&gt;\n        tr&gt;\n    table&gt;\nbody&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    window.onload = function () {\n        var mytable = document.getElementById(&#39;mytable&#39;);\n        console.dirxml(mytable);\n    }\nscript&gt;</code></pre><p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201501/071633365937534.png&objectId=1190000002511877&token=2e276ad833ec50c4aab7a1228de3b2bf\" alt=\"\"></p>\n<p><strong>7、console.group</strong>输出一组信息的开头</p>\n<p><strong>8、console.groupEnd</strong>结束一组输出信息</p>\n<p>看你需求选择不同的输出方法来使用，如果上述四个方法再配合 group 和 groupEnd 方法来一起使用就可以输入各种各样的不同形式的输出信息。</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230916203758554.jpg&objectId=1190000002511877&token=49e91f3be002204bdcbd873039895377\" alt=\"\"></p>\n<p>哈哈，是不是觉得很神奇呀！</p>\n<p><strong>9、console.assert</strong>对输入的表达式进行断言，只有表达式为 false 时，才输出相应的信息到控制台</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230920471094898.jpg&objectId=1190000002511877&token=b473f990a80491b1b4a37772e7a382bb\" alt=\"\"></p>\n<p><strong>10、console.count</strong>（这个方法非常实用哦）当你想统计代码被执行的次数</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230922575009930.jpg&objectId=1190000002511877&token=485de6bf631b90358eb2de9e8d36d926\" alt=\"\"></p>\n<p><strong>11、console.dir</strong>(这个方法是我经常使用的 可不知道比 for in 方便了多少)直接将该 DOM 结点以 DOM 树的结构进行输出，可以详细查对象的方法发展等等</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230936046711444.jpg&objectId=1190000002511877&token=e1d0dbd1b6b68147b3028bb7501a2c0d\" alt=\"\"></p>\n<p>*<em>12、console.time *</em>计时开始</p>\n<p><strong>13、console.timeEnd</strong>  计时结束（看了下面的图你瞬间就感受到它的厉害了）</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230941441714991.jpg&objectId=1190000002511877&token=7642ba7799c56505e4920a72475a51bd\" alt=\"\"></p>\n<p><strong>14、console.profile</strong>和<strong>console.profileEnd</strong>配合一起使用来查看 CPU 使用相关信息</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230947391254586.jpg&objectId=1190000002511877&token=3207740cc153fa6f3b6576a52cad7f92\" alt=\"\"></p>\n<p>在 Profiles 面板里面查看就可以看到 cpu 相关使用信息</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230948160786229.jpg&objectId=1190000002511877&token=bc1a094bc9cc221cfc078fa7755204a5\" alt=\"\"></p>\n<p><strong>15、console.timeLine</strong>和<strong>console.timeLineEnd</strong>配合一起记录一段时间轴</p>\n<p><strong>16、console.trace</strong>  堆栈跟踪相关的调试</p>\n<p>上述方法只是我个人理解罢了。如果想查看具体 API，可以上官方看看，具体地址为：<a href=\"https://developer.chrome.com/devtools/docs/console-api\" target=\"_blank\" rel=\"noopener\">https://developer.chrome.com/devtools/docs/console-api</a></p>\n<h1 id=\"控制台的一些快捷键\"><a href=\"#控制台的一些快捷键\" class=\"headerlink\" title=\"控制台的一些快捷键\"></a>控制台的一些快捷键</h1><p><strong>1、方向键盘的上下键</strong>，大家一用就知晓。比如用上键就相当于使用上次在控制台的输入符号</p>\n<p><strong>2、$_</strong>命令返回最近一次表达式执行的结果，功能跟按向上的方向键再回车是一样的</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230958084845245.jpg&objectId=1190000002511877&token=a0b26c6487a4618c276db6c29cd04dc4\" alt=\"\"></p>\n<p>上面的<code>$_</code>需要领悟其奥义才能使用得当，而 04 则代表了最近 5 个你选择过的 DOM 节点。</p>\n<p>什么意思？在页面右击选择<code>审查元素</code>，然后在弹出来的 DOM 结点树上面随便点选，这些被点过的节点会被记录下来，而<code>$0</code>会返回最近一次点选的 DOM 结点，以此类推，$1 返回的是上上次点选的 DOM 节点，最多保存了 5 个，如果不够 5 个，则返回<code>undefined</code>。</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/431064/201409/132239377465002.gif&objectId=1190000002511877&token=b533e2aab9af146a70246d329460dfb8\" alt=\"\"></p>\n<p><strong>3、Chrome 控制台中原生支持类 jQuery 的选择器</strong>，也就是说你可以用<code>$</code>加上熟悉的 css 选择器来选择 DOM 节点</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231001310469893.jpg&objectId=1190000002511877&token=f76fc920968739f7baa1bcb71963e242\" alt=\"\"></p>\n<p><strong>4、copy</strong>通过此命令可以将在控制台获取到的内容复制到剪贴板</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231004464535964.jpg&objectId=1190000002511877&token=e0108885b29ae4ab9dc51428f6801a7d\" alt=\"\"></p>\n<p>（哈哈 刚刚从控制台复制的 body 里面的 html 可以任意粘贴到哪, 比如记事本, 是不是觉得功能很强大）</p>\n<p><strong>5、keys 和 values</strong>前者返回传入对象所有属性名组成的数据，后者返回所有属性值组成的数组</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231008342653765.jpg&objectId=1190000002511877&token=effde5e09dd13b2ba6e815101b997401\" alt=\"\"></p>\n<p>说到这，不免想起<strong>console.table</strong>方法了</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231012102186590.jpg&objectId=1190000002511877&token=556375fd7918ae7677206dbdd9c7e206\" alt=\"\"></p>\n<p><strong>6、monitor &amp; unmonitor</strong></p>\n<p>monitor(function)，它接收一个函数名作为参数，比如<code>function a</code>,每次<code>a</code>被执行了，都会在控制台输出一条信息，里面包含了函数的名称<code>a</code>及执行时所传入的参数。</p>\n<p>而 unmonitor(function)便是用来停止这一监听。</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231015303594113.jpg&objectId=1190000002511877&token=373000d3f444c974aefbe33ff44f6667\" alt=\"\"></p>\n<p>看了这张图，应该明白了，也就是说在 monitor 和 unmonitor 中间的代码，执行的时候会在控制台输出一条信息，里面包含了函数的名称<code>a</code>及执行时所传入的参数。当解除监视（也就是执行 unmonitor 时）就不再在控制台输出信息了。</p>\n<ul>\n<li>$ // 简单理解就是 document.querySelector 而已。</li>\n<li>$$<br>$$</li>\n<li>$_ // 是上一个表达式的值</li>\n<li>0−4 // 是最近 5 个 Elements 面板选中的 DOM 元素，待会会讲。</li>\n<li>dir // 其实就是 console.dir</li>\n<li>keys // 取对象的键名, 返回键名组成的数组</li>\n<li>values // 去对象的值, 返回值组成的数组</li>\n</ul>\n<p>下面看一下 console.log 的一些技巧</p>\n<p><strong>1、重写 console.log 改变输出文字的样式</strong></p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231020045932166.png&objectId=1190000002511877&token=91bd45a689c10ada46699bcf697afa31\" alt=\"\"></p>\n<p><strong>2、利用控制台输出图片</strong></p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/431064/201409/132234240277278.gif&objectId=1190000002511877&token=5af8c00ca9cbfed8e44c26de079f77f3\" alt=\"\"></p>\n<p><strong>3、指定输出文字的样式</strong></p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231028494216061.png&objectId=1190000002511877&token=e1dfef3078ca896f98bd0fb8f43257e4\" alt=\"\"></p>\n<p>最后说一下 chrome 控制台一个简单的操作，如何查看页面元素，看下图就知道了</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/i/477954/201406/161255380974581.jpg&objectId=1190000002511877&token=d570e0c9c2de5d6e8108c1fd6d67369f\" alt=\"\"></p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>大家都有用过各种类型的浏览器，每种浏览器都有自己的特色，本人拙见，在我用过的浏览器当中，我是最喜欢 Chrome 的，因为它对于调试脚本及前端设计调试都有它比其它浏览器有过之而无不及的地方。可能大家对 console.log 会有一定的了解，心里难免会想调试的时候用 alert 不就行了，干嘛还要用 console.log 这么一长串的字符串来替代 alert 输出信息呢，下面我就介绍一些调试的入门技巧，让你爱上 console.log</p>\n<p>先的简单介绍一下 chrome 的控制台，打开 chrome 浏览器，按 f12 就可以轻松的打开控制台</p>\n<p><img src=\"https://segmentfault.com/img/bVkGtt\" alt=\"\"></p>\n<p>大家可以看到控制台里面有一首诗还有其它信息，如果想清空控制台，可以点击左上角那个<img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230851146562060.png&objectId=1190000002511877&token=d9955a953261784a0bfc7458fd97b442\" alt=\"\">来清空，当然也可以通过在控制台输入 console.clear()来实现清空控制台信息。如下图所示</p>\n<p><img src=\"https://segmentfault.com/img/bVkGtu\" alt=\"\"></p>\n<p>现在假设一个场景，如果一个数组里面有成百上千的元素，但是你想知道每个元素具体的值，这时候想想如果你用 alert 那将是多惨的一件事情，因为 alert 阻断线程运行，你不点击 alert 框的确定按钮下一个 alert 就不会出现。</p>\n<p>下面我们用 console.log 来替换，感受一下它的魅力。</p>\n<p><img src=\"https://segmentfault.com/img/bVkGtv\" alt=\"\"></p>\n<p>看了上面这张图，是不是认识到 log 的强大之处了，下面我们来看看 console 里面具体提供了哪些方法可以供我们平时调试时使用。</p>\n<p><img src=\"https://segmentfault.com/img/bVkGtH\" alt=\"\"></p>\n<h1 id=\"目前控制台方法和属性有：\"><a href=\"#目前控制台方法和属性有：\" class=\"headerlink\" title=\"目前控制台方法和属性有：\"></a>目前控制台方法和属性有：</h1><p>[“$$”, “$x”, “dir”, “dirxml”, “keys”, “values”, “profile”, “profileEnd”, “monitorEvents”, “unmonitorEvents”, “inspect”, “copy”, “clear”, “getEventListeners”, “undebug”, “monitor”, “unmonitor”, “table”, “$0”, “$1”, “$2”, “$3”, “$4”, “$_“]</p>\n<p>下面我们来一一介绍一下各个方法主要的用途。</p>\n<p>一般情况下我们用来输入信息的方法主要是用到如下四个</p>\n<p><strong>1、console.log</strong>  用于输出普通信息</p>\n<p>*<em>2、console.info *</em>用于输出提示性信息</p>\n<p><strong>3、console.error</strong>用于输出错误信息</p>\n<p><strong>4、console.warn</strong>用于输出警示信息</p>\n<p><strong>5、console.debug</strong>用于输出调试信息</p>\n<p>用图来说话</p>\n<p><img src=\"https://segmentfault.com/img/bVkGtK\" alt=\"\"></p>\n<p>console 对象的上面 5 种方法，都可以使用 printf 风格的占位符。不过，占位符的种类比较少，<strong>只支持字符（%s）、整数（%d 或%i）、浮点数（%f）和对象（%o）四种</strong>。</p>\n<pre><code>console.log(&quot;%d年%d月%d日&quot;,2011,3,26);\nconsole.log(&quot;圆周率是%f&quot;,3.1415926);</code></pre><p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201501/071628584845899.png&objectId=1190000002511877&token=5d84fec83bdaf09ef380abf408aef480\" alt=\"\"></p>\n<p>%o 占位符，可以用来查看一个对象内部情况</p>\n<p>var dog = {};<br>dog.name = “大毛”;<br>dog.color = “黄色”;<br>console.log(“%o”, dog);</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201501/071629171711956.png&objectId=1190000002511877&token=d847680e87ce7804eecfc12cf136dc04\" alt=\"\"></p>\n<p><strong>6、</strong>console.dirxml 用来显示网页的某个节点（node）所包含的 html/xml 代码****</p>\n<pre><code>&lt;body&gt;\n    &lt;table id=&quot;mytable&quot;&gt;\n        &lt;tr&gt;\n            &lt;td&gt;Atd&gt;\n            &lt;td&gt;Atd&gt;\n            &lt;td&gt;Atd&gt;\n        tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;bbbtd&gt;\n            &lt;td&gt;aaatd&gt;\n            &lt;td&gt;ccctd&gt;\n        tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;111td&gt;\n            &lt;td&gt;333td&gt;\n            &lt;td&gt;222td&gt;\n        tr&gt;\n    table&gt;\nbody&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    window.onload = function () {\n        var mytable = document.getElementById(&#39;mytable&#39;);\n        console.dirxml(mytable);\n    }\nscript&gt;</code></pre><p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201501/071633365937534.png&objectId=1190000002511877&token=2e276ad833ec50c4aab7a1228de3b2bf\" alt=\"\"></p>\n<p><strong>7、console.group</strong>输出一组信息的开头</p>\n<p><strong>8、console.groupEnd</strong>结束一组输出信息</p>\n<p>看你需求选择不同的输出方法来使用，如果上述四个方法再配合 group 和 groupEnd 方法来一起使用就可以输入各种各样的不同形式的输出信息。</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230916203758554.jpg&objectId=1190000002511877&token=49e91f3be002204bdcbd873039895377\" alt=\"\"></p>\n<p>哈哈，是不是觉得很神奇呀！</p>\n<p><strong>9、console.assert</strong>对输入的表达式进行断言，只有表达式为 false 时，才输出相应的信息到控制台</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230920471094898.jpg&objectId=1190000002511877&token=b473f990a80491b1b4a37772e7a382bb\" alt=\"\"></p>\n<p><strong>10、console.count</strong>（这个方法非常实用哦）当你想统计代码被执行的次数</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230922575009930.jpg&objectId=1190000002511877&token=485de6bf631b90358eb2de9e8d36d926\" alt=\"\"></p>\n<p><strong>11、console.dir</strong>(这个方法是我经常使用的 可不知道比 for in 方便了多少)直接将该 DOM 结点以 DOM 树的结构进行输出，可以详细查对象的方法发展等等</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230936046711444.jpg&objectId=1190000002511877&token=e1d0dbd1b6b68147b3028bb7501a2c0d\" alt=\"\"></p>\n<p>*<em>12、console.time *</em>计时开始</p>\n<p><strong>13、console.timeEnd</strong>  计时结束（看了下面的图你瞬间就感受到它的厉害了）</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230941441714991.jpg&objectId=1190000002511877&token=7642ba7799c56505e4920a72475a51bd\" alt=\"\"></p>\n<p><strong>14、console.profile</strong>和<strong>console.profileEnd</strong>配合一起使用来查看 CPU 使用相关信息</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230947391254586.jpg&objectId=1190000002511877&token=3207740cc153fa6f3b6576a52cad7f92\" alt=\"\"></p>\n<p>在 Profiles 面板里面查看就可以看到 cpu 相关使用信息</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230948160786229.jpg&objectId=1190000002511877&token=bc1a094bc9cc221cfc078fa7755204a5\" alt=\"\"></p>\n<p><strong>15、console.timeLine</strong>和<strong>console.timeLineEnd</strong>配合一起记录一段时间轴</p>\n<p><strong>16、console.trace</strong>  堆栈跟踪相关的调试</p>\n<p>上述方法只是我个人理解罢了。如果想查看具体 API，可以上官方看看，具体地址为：<a href=\"https://developer.chrome.com/devtools/docs/console-api\" target=\"_blank\" rel=\"noopener\">https://developer.chrome.com/devtools/docs/console-api</a></p>\n<h1 id=\"控制台的一些快捷键\"><a href=\"#控制台的一些快捷键\" class=\"headerlink\" title=\"控制台的一些快捷键\"></a>控制台的一些快捷键</h1><p><strong>1、方向键盘的上下键</strong>，大家一用就知晓。比如用上键就相当于使用上次在控制台的输入符号</p>\n<p><strong>2、$_</strong>命令返回最近一次表达式执行的结果，功能跟按向上的方向键再回车是一样的</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/230958084845245.jpg&objectId=1190000002511877&token=a0b26c6487a4618c276db6c29cd04dc4\" alt=\"\"></p>\n<p>上面的<code>$_</code>需要领悟其奥义才能使用得当，而 04 则代表了最近 5 个你选择过的 DOM 节点。</p>\n<p>什么意思？在页面右击选择<code>审查元素</code>，然后在弹出来的 DOM 结点树上面随便点选，这些被点过的节点会被记录下来，而<code>$0</code>会返回最近一次点选的 DOM 结点，以此类推，$1 返回的是上上次点选的 DOM 节点，最多保存了 5 个，如果不够 5 个，则返回<code>undefined</code>。</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/431064/201409/132239377465002.gif&objectId=1190000002511877&token=b533e2aab9af146a70246d329460dfb8\" alt=\"\"></p>\n<p><strong>3、Chrome 控制台中原生支持类 jQuery 的选择器</strong>，也就是说你可以用<code>$</code>加上熟悉的 css 选择器来选择 DOM 节点</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231001310469893.jpg&objectId=1190000002511877&token=f76fc920968739f7baa1bcb71963e242\" alt=\"\"></p>\n<p><strong>4、copy</strong>通过此命令可以将在控制台获取到的内容复制到剪贴板</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231004464535964.jpg&objectId=1190000002511877&token=e0108885b29ae4ab9dc51428f6801a7d\" alt=\"\"></p>\n<p>（哈哈 刚刚从控制台复制的 body 里面的 html 可以任意粘贴到哪, 比如记事本, 是不是觉得功能很强大）</p>\n<p><strong>5、keys 和 values</strong>前者返回传入对象所有属性名组成的数据，后者返回所有属性值组成的数组</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231008342653765.jpg&objectId=1190000002511877&token=effde5e09dd13b2ba6e815101b997401\" alt=\"\"></p>\n<p>说到这，不免想起<strong>console.table</strong>方法了</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231012102186590.jpg&objectId=1190000002511877&token=556375fd7918ae7677206dbdd9c7e206\" alt=\"\"></p>\n<p><strong>6、monitor &amp; unmonitor</strong></p>\n<p>monitor(function)，它接收一个函数名作为参数，比如<code>function a</code>,每次<code>a</code>被执行了，都会在控制台输出一条信息，里面包含了函数的名称<code>a</code>及执行时所传入的参数。</p>\n<p>而 unmonitor(function)便是用来停止这一监听。</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231015303594113.jpg&objectId=1190000002511877&token=373000d3f444c974aefbe33ff44f6667\" alt=\"\"></p>\n<p>看了这张图，应该明白了，也就是说在 monitor 和 unmonitor 中间的代码，执行的时候会在控制台输出一条信息，里面包含了函数的名称<code>a</code>及执行时所传入的参数。当解除监视（也就是执行 unmonitor 时）就不再在控制台输出信息了。</p>\n<ul>\n<li>$ // 简单理解就是 document.querySelector 而已。</li>\n<li>$$<br>$$</li>\n<li>$_ // 是上一个表达式的值</li>\n<li>0−4 // 是最近 5 个 Elements 面板选中的 DOM 元素，待会会讲。</li>\n<li>dir // 其实就是 console.dir</li>\n<li>keys // 取对象的键名, 返回键名组成的数组</li>\n<li>values // 去对象的值, 返回值组成的数组</li>\n</ul>\n<p>下面看一下 console.log 的一些技巧</p>\n<p><strong>1、重写 console.log 改变输出文字的样式</strong></p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231020045932166.png&objectId=1190000002511877&token=91bd45a689c10ada46699bcf697afa31\" alt=\"\"></p>\n<p><strong>2、利用控制台输出图片</strong></p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/431064/201409/132234240277278.gif&objectId=1190000002511877&token=5af8c00ca9cbfed8e44c26de079f77f3\" alt=\"\"></p>\n<p><strong>3、指定输出文字的样式</strong></p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/blog/457824/201411/231028494216061.png&objectId=1190000002511877&token=e1dfef3078ca896f98bd0fb8f43257e4\" alt=\"\"></p>\n<p>最后说一下 chrome 控制台一个简单的操作，如何查看页面元素，看下图就知道了</p>\n<p><img src=\"https://segmentfault.com/image?src=http://images.cnitblog.com/i/477954/201406/161255380974581.jpg&objectId=1190000002511877&token=d570e0c9c2de5d6e8108c1fd6d67369f\" alt=\"\"></p>\n"},{"title":"Linux 运维人员最常用 150 个命令汇总","date":"2017-11-22T18:16:00.000Z","_content":"\nlinux 命令是对 Linux 系统进行管理的命令。对于 Linux 系统来说，无论是中央处理器、内存、磁盘驱动器、键盘、鼠标，还是用户等都是文件， Linux 系统管理的命令是它正常运行的核心，与之前的 DOS 命令类似。linux 命令在系统中有两种类型：内置 Shell 命令和 Linux 命令。\n\n命令\n\n功能说明\n\n**线上查询及帮助命令 (2 个)**\n\nman\n\n查看命令帮助，命令的词典，更复杂的还有 info，但不常用。\n\nhelp\n\n查看 Linux 内置命令的帮助，比如 cd 命令。\n\n**文件和目录操作命令 (18 个)**\n\nls\n\n全拼 list，功能是列出目录的内容及其内容属性信息。\n\ncd\n\n全拼 change directory，功能是从当前工作目录切换到指定的工作目录。\n\ncp\n\n全拼 copy，其功能为复制文件或目录。\n\nfind\n\n查找的意思，用于查找目录及目录下的文件。\n\nmkdir\n\n全拼 make directories，其功能是创建目录。\n\nmv\n\n全拼 move，其功能是移动或重命名文件。\n\npwd\n\n全拼 print working directory，其功能是显示当前工作目录的绝对路径。\n\nrename\n\n用于重命名文件。\n\nrm\n\n全拼 remove，其功能是删除一个或多个文件或目录。\n\nrmdir\n\n全拼 remove empty directories，功能是删除空目录。\n\ntouch\n\n创建新的空文件，改变已有文件的时间戳属性。\n\ntree\n\n功能是以树形结构显示目录下的内容。\n\nbasename\n\n显示文件名或目录名。\n\ndirname\n\n显示文件或目录路径。\n\nchattr\n\n改变文件的扩展属性。\n\nlsattr\n\n查看文件扩展属性。\n\nfile\n\n显示文件的类型。\n\nmd5sum\n\n计算和校验文件的 MD5 值。\n\n**查看文件及内容处理命令（21 个）**\n\ncat\n\n全拼 concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。\n\ntac\n\ntac 是 cat 的反向拼写，因此命令的功能为反向显示文件内容。\n\nmore\n\n分页显示文件内容。\n\nless\n\n分页显示文件内容，more 命令的相反用法。\n\nhead\n\n显示文件内容的头部。\n\ntail\n\n显示文件内容的尾部。\n\ncut\n\n将文件的每一行按指定分隔符分割并输出。\n\nsplit\n\n分割文件为不同的小片段。\n\npaste\n\n按行合并文件内容。\n\nsort\n\n对文件的文本内容排序。\n\nuniq\n\n去除重复行。oldboy\n\nwc\n\n统计文件的行数、单词数或字节数。\n\niconv\n\n转换文件的编码格式。\n\ndos2unix\n\n将 DOS 格式文件转换成 UNIX 格式。\n\ndiff\n\n全拼 difference，比较文件的差异，常用于文本文件。\n\nvimdiff\n\n命令行可视化文件比较工具，常用于文本文件。\n\nrev\n\n反向输出文件内容。\n\ngrep/egrep\n\n过滤字符串，三剑客老三。\n\njoin\n\n按两个文件的相同字段合并。\n\ntr\n\n替换或删除字符。\n\nvi/vim\n\n命令行文本编辑器。\n\n**文件压缩及解压缩命令（4 个）**\n\ntar\n\n打包压缩。oldboy\n\nunzip\n\n解压文件。\n\ngzip\n\ngzip 压缩工具。\n\nzip\n\n压缩工具。\n\n**信息显示命令（11 个）**\n\nuname\n\n显示操作系统相关信息的命令。\n\nhostname\n\n显示或者设置当前系统的主机名。\n\ndmesg\n\n显示开机信息，用于诊断系统故障。\n\nuptime\n\n显示系统运行时间及负载。\n\nstat\n\n显示文件或文件系统的状态。\n\ndu\n\n计算磁盘空间使用情况。\n\ndf\n\n报告文件系统磁盘空间的使用情况。\n\ntop\n\n实时显示系统资源使用情况。\n\nfree\n\n查看系统内存。\n\ndate\n\n显示与设置系统时间。\n\ncal\n\n查看日历等时间信息。\n\n**搜索文件命令（4 个）**\n\nwhich\n\n查找二进制命令，按环境变量 PATH 路径查找。\n\nfind\n\n从磁盘遍历查找文件或目录。\n\nwhereis\n\n查找二进制命令，按环境变量 PATH 路径查找。\n\nlocate\n\n从数据库  (/var/lib/mlocate/mlocate.db)  查找命令，使用 updatedb 更新库。\n\n**用户管理命令（10 个）**\n\nuseradd\n\n添加用户。\n\nusermod\n\n修改系统已经存在的用户属性。\n\nuserdel\n\n删除用户。\n\ngroupadd\n\n添加用户组。\n\npasswd\n\n修改用户密码。\n\nchage\n\n修改用户密码有效期限。\n\nid\n\n查看用户的 uid,gid 及归属的用户组。\n\nsu\n\n切换用户身份。\n\nvisudo\n\n编辑 / etc/sudoers 文件的专属命令。\n\nsudo\n\n以另外一个用户身份（默认 root 用户）执行事先在 sudoers 文件允许的命令。\n\n**基础网络操作命令（11 个）**\n\ntelnet\n\n使用 TELNET 协议远程登录。\n\nssh\n\n使用 SSH 加密协议远程登录。\n\nscp\n\n全拼 secure copy，用于不同主机之间复制文件。\n\nwget\n\n命令行下载文件。\n\nping\n\n测试主机之间网络的连通性。\n\nroute\n\n显示和设置 linux 系统的路由表。\n\nifconfig\n\n查看、配置、启用或禁用网络接口的命令。\n\nifup\n\n启动网卡。\n\nifdown\n\n关闭网卡。\n\nnetstat\n\n查看网络状态。\n\nss\n\n查看网络状态。\n\n**深入网络操作命令（9 个）**\n\nnmap\n\n网络扫描命令。\n\nlsof\n\n全名 list open files，也就是列举系统中已经被打开的文件。\n\nmail\n\n发送和接收邮件。\n\nmutt\n\n邮件管理命令。\n\nnslookup\n\n交互式查询互联网 DNS 服务器的命令。\n\ndig\n\n查找 DNS 解析过程。\n\nhost\n\n查询 DNS 的命令。\n\ntraceroute\n\n追踪数据传输路由状况。\n\ntcpdump\n\n命令行的抓包工具。\n\n**有关磁盘与文件系统的命令（16 个）**\n\nmount\n\n挂载文件系统。\n\numount\n\n卸载文件系统。\n\nfsck\n\n检查并修复 Linux 文件系统。\n\ndd\n\n转换或复制文件。\n\ndumpe2fs\n\n导出 ext2/ext3/ext4 文件系统信息。\n\ndump\n\next2/3/4 文件系统备份工具。\n\nfdisk\n\n磁盘分区命令，适用于 2TB 以下磁盘分区。\n\nparted\n\n磁盘分区命令，没有磁盘大小限制，常用于 2TB 以下磁盘分区。\n\nmkfs\n\n格式化创建 Linux 文件系统。\n\npartprobe\n\n更新内核的硬盘分区表信息。\n\ne2fsck\n\n检查 ext2/ext3/ext4 类型文件系统。\n\nmkswap\n\n创建 Linux 交换分区。\n\nswapon\n\n启用交换分区。\n\nswapoff\n\n关闭交换分区。\n\nsync\n\n将内存缓冲区内的数据写入磁盘。\n\nresize2fs\n\n调整 ext2/ext3/ext4 文件系统大小。\n\n**系统权限及用户授权相关命令（4 个）**\n\nchmod\n\n改变文件或目录权限。\n\nchown\n\n改变文件或目录的属主和属组。\n\nchgrp\n\n更改文件用户组。\n\numask\n\n显示或设置权限掩码。\n\n**查看系统用户登陆信息的命令（7 个）**\n\nwhoami\n\n显示当前有效的用户名称，相当于执行 id -un 命令。\n\nwho\n\n显示目前登录系统的用户信息。\n\nw\n\n显示已经登陆系统的用户列表，并显示用户正在执行的指令。\n\nlast\n\n显示登入系统的用户。\n\nlastlog\n\n显示系统中所有用户最近一次登录信息。\n\nusers\n\n显示当前登录系统的所有用户的用户列表。\n\nfinger\n\n查找并显示用户信息。\n\n**内置命令及其它（19 个）**\n\necho\n\n打印变量，或直接输出指定的字符串\n\nprintf\n\n将结果格式化输出到标准输出。\n\nrpm\n\n管理 rpm 包的命令。\n\nyum\n\n自动化简单化地管理 rpm 包的命令。\n\nwatch\n\n周期性的执行给定的命令，并将命令的输出以全屏方式显示。\n\nalias\n\n设置系统别名。\n\nunalias\n\n取消系统别名。\n\ndate\n\n查看或设置系统时间。\n\nclear\n\n清除屏幕，简称清屏。\n\nhistory\n\n查看命令执行的历史纪录。\n\neject\n\n弹出光驱。\n\ntime\n\n计算命令执行时间。\n\nnc\n\n功能强大的网络工具。\n\nxargs\n\n将标准输入转换成命令行参数。\n\nexec\n\n调用并执行指令的命令。\n\nexport\n\n设置或者显示环境变量。\n\nunset\n\n删除变量或函数。\n\ntype\n\n用于判断另外一个命令是否是内置命令。\n\nbc\n\n命令行科学计算器\n\n**系统管理与性能监视命令 (9 个)**\n\nchkconfig\n\n管理 Linux 系统开机启动项。\n\nvmstat\n\n虚拟内存统计。\n\nmpstat\n\n显示各个可用 CPU 的状态统计。\n\niostat\n\n统计系统 IO。\n\nsar\n\n全面地获取系统的 CPU、运行队列、磁盘  I/O、分页（交换区）、内存、 CPU 中断和网络等性能数据。\n\nipcs\n\n用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。\n\nipcrm\n\n用来删除一个或更多的消息队列、信号量集或者共享内存标识。\n\nstrace\n\n用于诊断、调试 Linux 用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。\n\nltrace\n\n命令会跟踪进程的库函数调用, 它会显现出哪个库函数被调用。\n\n**关机 / 重启 / 注销和查看系统信息的命令（6 个）**\n\nshutdown\n\n关机。\n\nhalt\n\n关机。\n\npoweroff\n\n关闭电源。\n\nlogout\n\n退出当前登录的 Shell。\n\nexit\n\n退出当前登录的 Shell。\n\nCtrl+d\n\n退出当前登录的 Shell 的快捷键。\n\n**进程管理相关命令（15 个）**\n\nbg\n\n将一个在后台暂停的命令，变成继续执行   （在后台执行）。\n\nfg\n\n将后台中的命令调至前台继续运行。\n\njobs\n\n查看当前有多少在后台运行的命令。\n\nkill\n\n终止进程。\n\nkillall\n\n通过进程名终止进程。\n\npkill\n\n通过进程名终止进程。\n\ncrontab\n\n定时任务命令。\n\nps\n\n显示进程的快照。\n\npstree\n\n树形显示进程。\n\nnice/renice\n\n调整程序运行的优先级。\n\nnohup\n\n忽略挂起信号运行指定的命令。\n\npgrep\n\n查找匹配条件的进程。\n\nrunlevel\n\n查看系统当前运行级别。\n\ninit\n\n切换运行级别。\n\nservice\n\n启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。\n","source":"_posts/2017-11-23-Linux 运维人员最常用 150 个命令汇总.md","raw":"---\ntitle: Linux 运维人员最常用 150 个命令汇总\ntags:\n  - 技术\n  - Linux\ndate: 2017-11-23 02:16:00\ncategories: 教程\n---\n\nlinux 命令是对 Linux 系统进行管理的命令。对于 Linux 系统来说，无论是中央处理器、内存、磁盘驱动器、键盘、鼠标，还是用户等都是文件， Linux 系统管理的命令是它正常运行的核心，与之前的 DOS 命令类似。linux 命令在系统中有两种类型：内置 Shell 命令和 Linux 命令。\n\n命令\n\n功能说明\n\n**线上查询及帮助命令 (2 个)**\n\nman\n\n查看命令帮助，命令的词典，更复杂的还有 info，但不常用。\n\nhelp\n\n查看 Linux 内置命令的帮助，比如 cd 命令。\n\n**文件和目录操作命令 (18 个)**\n\nls\n\n全拼 list，功能是列出目录的内容及其内容属性信息。\n\ncd\n\n全拼 change directory，功能是从当前工作目录切换到指定的工作目录。\n\ncp\n\n全拼 copy，其功能为复制文件或目录。\n\nfind\n\n查找的意思，用于查找目录及目录下的文件。\n\nmkdir\n\n全拼 make directories，其功能是创建目录。\n\nmv\n\n全拼 move，其功能是移动或重命名文件。\n\npwd\n\n全拼 print working directory，其功能是显示当前工作目录的绝对路径。\n\nrename\n\n用于重命名文件。\n\nrm\n\n全拼 remove，其功能是删除一个或多个文件或目录。\n\nrmdir\n\n全拼 remove empty directories，功能是删除空目录。\n\ntouch\n\n创建新的空文件，改变已有文件的时间戳属性。\n\ntree\n\n功能是以树形结构显示目录下的内容。\n\nbasename\n\n显示文件名或目录名。\n\ndirname\n\n显示文件或目录路径。\n\nchattr\n\n改变文件的扩展属性。\n\nlsattr\n\n查看文件扩展属性。\n\nfile\n\n显示文件的类型。\n\nmd5sum\n\n计算和校验文件的 MD5 值。\n\n**查看文件及内容处理命令（21 个）**\n\ncat\n\n全拼 concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。\n\ntac\n\ntac 是 cat 的反向拼写，因此命令的功能为反向显示文件内容。\n\nmore\n\n分页显示文件内容。\n\nless\n\n分页显示文件内容，more 命令的相反用法。\n\nhead\n\n显示文件内容的头部。\n\ntail\n\n显示文件内容的尾部。\n\ncut\n\n将文件的每一行按指定分隔符分割并输出。\n\nsplit\n\n分割文件为不同的小片段。\n\npaste\n\n按行合并文件内容。\n\nsort\n\n对文件的文本内容排序。\n\nuniq\n\n去除重复行。oldboy\n\nwc\n\n统计文件的行数、单词数或字节数。\n\niconv\n\n转换文件的编码格式。\n\ndos2unix\n\n将 DOS 格式文件转换成 UNIX 格式。\n\ndiff\n\n全拼 difference，比较文件的差异，常用于文本文件。\n\nvimdiff\n\n命令行可视化文件比较工具，常用于文本文件。\n\nrev\n\n反向输出文件内容。\n\ngrep/egrep\n\n过滤字符串，三剑客老三。\n\njoin\n\n按两个文件的相同字段合并。\n\ntr\n\n替换或删除字符。\n\nvi/vim\n\n命令行文本编辑器。\n\n**文件压缩及解压缩命令（4 个）**\n\ntar\n\n打包压缩。oldboy\n\nunzip\n\n解压文件。\n\ngzip\n\ngzip 压缩工具。\n\nzip\n\n压缩工具。\n\n**信息显示命令（11 个）**\n\nuname\n\n显示操作系统相关信息的命令。\n\nhostname\n\n显示或者设置当前系统的主机名。\n\ndmesg\n\n显示开机信息，用于诊断系统故障。\n\nuptime\n\n显示系统运行时间及负载。\n\nstat\n\n显示文件或文件系统的状态。\n\ndu\n\n计算磁盘空间使用情况。\n\ndf\n\n报告文件系统磁盘空间的使用情况。\n\ntop\n\n实时显示系统资源使用情况。\n\nfree\n\n查看系统内存。\n\ndate\n\n显示与设置系统时间。\n\ncal\n\n查看日历等时间信息。\n\n**搜索文件命令（4 个）**\n\nwhich\n\n查找二进制命令，按环境变量 PATH 路径查找。\n\nfind\n\n从磁盘遍历查找文件或目录。\n\nwhereis\n\n查找二进制命令，按环境变量 PATH 路径查找。\n\nlocate\n\n从数据库  (/var/lib/mlocate/mlocate.db)  查找命令，使用 updatedb 更新库。\n\n**用户管理命令（10 个）**\n\nuseradd\n\n添加用户。\n\nusermod\n\n修改系统已经存在的用户属性。\n\nuserdel\n\n删除用户。\n\ngroupadd\n\n添加用户组。\n\npasswd\n\n修改用户密码。\n\nchage\n\n修改用户密码有效期限。\n\nid\n\n查看用户的 uid,gid 及归属的用户组。\n\nsu\n\n切换用户身份。\n\nvisudo\n\n编辑 / etc/sudoers 文件的专属命令。\n\nsudo\n\n以另外一个用户身份（默认 root 用户）执行事先在 sudoers 文件允许的命令。\n\n**基础网络操作命令（11 个）**\n\ntelnet\n\n使用 TELNET 协议远程登录。\n\nssh\n\n使用 SSH 加密协议远程登录。\n\nscp\n\n全拼 secure copy，用于不同主机之间复制文件。\n\nwget\n\n命令行下载文件。\n\nping\n\n测试主机之间网络的连通性。\n\nroute\n\n显示和设置 linux 系统的路由表。\n\nifconfig\n\n查看、配置、启用或禁用网络接口的命令。\n\nifup\n\n启动网卡。\n\nifdown\n\n关闭网卡。\n\nnetstat\n\n查看网络状态。\n\nss\n\n查看网络状态。\n\n**深入网络操作命令（9 个）**\n\nnmap\n\n网络扫描命令。\n\nlsof\n\n全名 list open files，也就是列举系统中已经被打开的文件。\n\nmail\n\n发送和接收邮件。\n\nmutt\n\n邮件管理命令。\n\nnslookup\n\n交互式查询互联网 DNS 服务器的命令。\n\ndig\n\n查找 DNS 解析过程。\n\nhost\n\n查询 DNS 的命令。\n\ntraceroute\n\n追踪数据传输路由状况。\n\ntcpdump\n\n命令行的抓包工具。\n\n**有关磁盘与文件系统的命令（16 个）**\n\nmount\n\n挂载文件系统。\n\numount\n\n卸载文件系统。\n\nfsck\n\n检查并修复 Linux 文件系统。\n\ndd\n\n转换或复制文件。\n\ndumpe2fs\n\n导出 ext2/ext3/ext4 文件系统信息。\n\ndump\n\next2/3/4 文件系统备份工具。\n\nfdisk\n\n磁盘分区命令，适用于 2TB 以下磁盘分区。\n\nparted\n\n磁盘分区命令，没有磁盘大小限制，常用于 2TB 以下磁盘分区。\n\nmkfs\n\n格式化创建 Linux 文件系统。\n\npartprobe\n\n更新内核的硬盘分区表信息。\n\ne2fsck\n\n检查 ext2/ext3/ext4 类型文件系统。\n\nmkswap\n\n创建 Linux 交换分区。\n\nswapon\n\n启用交换分区。\n\nswapoff\n\n关闭交换分区。\n\nsync\n\n将内存缓冲区内的数据写入磁盘。\n\nresize2fs\n\n调整 ext2/ext3/ext4 文件系统大小。\n\n**系统权限及用户授权相关命令（4 个）**\n\nchmod\n\n改变文件或目录权限。\n\nchown\n\n改变文件或目录的属主和属组。\n\nchgrp\n\n更改文件用户组。\n\numask\n\n显示或设置权限掩码。\n\n**查看系统用户登陆信息的命令（7 个）**\n\nwhoami\n\n显示当前有效的用户名称，相当于执行 id -un 命令。\n\nwho\n\n显示目前登录系统的用户信息。\n\nw\n\n显示已经登陆系统的用户列表，并显示用户正在执行的指令。\n\nlast\n\n显示登入系统的用户。\n\nlastlog\n\n显示系统中所有用户最近一次登录信息。\n\nusers\n\n显示当前登录系统的所有用户的用户列表。\n\nfinger\n\n查找并显示用户信息。\n\n**内置命令及其它（19 个）**\n\necho\n\n打印变量，或直接输出指定的字符串\n\nprintf\n\n将结果格式化输出到标准输出。\n\nrpm\n\n管理 rpm 包的命令。\n\nyum\n\n自动化简单化地管理 rpm 包的命令。\n\nwatch\n\n周期性的执行给定的命令，并将命令的输出以全屏方式显示。\n\nalias\n\n设置系统别名。\n\nunalias\n\n取消系统别名。\n\ndate\n\n查看或设置系统时间。\n\nclear\n\n清除屏幕，简称清屏。\n\nhistory\n\n查看命令执行的历史纪录。\n\neject\n\n弹出光驱。\n\ntime\n\n计算命令执行时间。\n\nnc\n\n功能强大的网络工具。\n\nxargs\n\n将标准输入转换成命令行参数。\n\nexec\n\n调用并执行指令的命令。\n\nexport\n\n设置或者显示环境变量。\n\nunset\n\n删除变量或函数。\n\ntype\n\n用于判断另外一个命令是否是内置命令。\n\nbc\n\n命令行科学计算器\n\n**系统管理与性能监视命令 (9 个)**\n\nchkconfig\n\n管理 Linux 系统开机启动项。\n\nvmstat\n\n虚拟内存统计。\n\nmpstat\n\n显示各个可用 CPU 的状态统计。\n\niostat\n\n统计系统 IO。\n\nsar\n\n全面地获取系统的 CPU、运行队列、磁盘  I/O、分页（交换区）、内存、 CPU 中断和网络等性能数据。\n\nipcs\n\n用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。\n\nipcrm\n\n用来删除一个或更多的消息队列、信号量集或者共享内存标识。\n\nstrace\n\n用于诊断、调试 Linux 用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。\n\nltrace\n\n命令会跟踪进程的库函数调用, 它会显现出哪个库函数被调用。\n\n**关机 / 重启 / 注销和查看系统信息的命令（6 个）**\n\nshutdown\n\n关机。\n\nhalt\n\n关机。\n\npoweroff\n\n关闭电源。\n\nlogout\n\n退出当前登录的 Shell。\n\nexit\n\n退出当前登录的 Shell。\n\nCtrl+d\n\n退出当前登录的 Shell 的快捷键。\n\n**进程管理相关命令（15 个）**\n\nbg\n\n将一个在后台暂停的命令，变成继续执行   （在后台执行）。\n\nfg\n\n将后台中的命令调至前台继续运行。\n\njobs\n\n查看当前有多少在后台运行的命令。\n\nkill\n\n终止进程。\n\nkillall\n\n通过进程名终止进程。\n\npkill\n\n通过进程名终止进程。\n\ncrontab\n\n定时任务命令。\n\nps\n\n显示进程的快照。\n\npstree\n\n树形显示进程。\n\nnice/renice\n\n调整程序运行的优先级。\n\nnohup\n\n忽略挂起信号运行指定的命令。\n\npgrep\n\n查找匹配条件的进程。\n\nrunlevel\n\n查看系统当前运行级别。\n\ninit\n\n切换运行级别。\n\nservice\n\n启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。\n","slug":"2017-11-23-Linux 运维人员最常用 150 个命令汇总","published":1,"updated":"2020-03-14T06:49:30.983Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvmw004u4k8yb4fgc6mq","content":"<p>linux 命令是对 Linux 系统进行管理的命令。对于 Linux 系统来说，无论是中央处理器、内存、磁盘驱动器、键盘、鼠标，还是用户等都是文件， Linux 系统管理的命令是它正常运行的核心，与之前的 DOS 命令类似。linux 命令在系统中有两种类型：内置 Shell 命令和 Linux 命令。</p>\n<p>命令</p>\n<p>功能说明</p>\n<p><strong>线上查询及帮助命令 (2 个)</strong></p>\n<p>man</p>\n<p>查看命令帮助，命令的词典，更复杂的还有 info，但不常用。</p>\n<p>help</p>\n<p>查看 Linux 内置命令的帮助，比如 cd 命令。</p>\n<p><strong>文件和目录操作命令 (18 个)</strong></p>\n<p>ls</p>\n<p>全拼 list，功能是列出目录的内容及其内容属性信息。</p>\n<p>cd</p>\n<p>全拼 change directory，功能是从当前工作目录切换到指定的工作目录。</p>\n<p>cp</p>\n<p>全拼 copy，其功能为复制文件或目录。</p>\n<p>find</p>\n<p>查找的意思，用于查找目录及目录下的文件。</p>\n<p>mkdir</p>\n<p>全拼 make directories，其功能是创建目录。</p>\n<p>mv</p>\n<p>全拼 move，其功能是移动或重命名文件。</p>\n<p>pwd</p>\n<p>全拼 print working directory，其功能是显示当前工作目录的绝对路径。</p>\n<p>rename</p>\n<p>用于重命名文件。</p>\n<p>rm</p>\n<p>全拼 remove，其功能是删除一个或多个文件或目录。</p>\n<p>rmdir</p>\n<p>全拼 remove empty directories，功能是删除空目录。</p>\n<p>touch</p>\n<p>创建新的空文件，改变已有文件的时间戳属性。</p>\n<p>tree</p>\n<p>功能是以树形结构显示目录下的内容。</p>\n<p>basename</p>\n<p>显示文件名或目录名。</p>\n<p>dirname</p>\n<p>显示文件或目录路径。</p>\n<p>chattr</p>\n<p>改变文件的扩展属性。</p>\n<p>lsattr</p>\n<p>查看文件扩展属性。</p>\n<p>file</p>\n<p>显示文件的类型。</p>\n<p>md5sum</p>\n<p>计算和校验文件的 MD5 值。</p>\n<p><strong>查看文件及内容处理命令（21 个）</strong></p>\n<p>cat</p>\n<p>全拼 concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。</p>\n<p>tac</p>\n<p>tac 是 cat 的反向拼写，因此命令的功能为反向显示文件内容。</p>\n<p>more</p>\n<p>分页显示文件内容。</p>\n<p>less</p>\n<p>分页显示文件内容，more 命令的相反用法。</p>\n<p>head</p>\n<p>显示文件内容的头部。</p>\n<p>tail</p>\n<p>显示文件内容的尾部。</p>\n<p>cut</p>\n<p>将文件的每一行按指定分隔符分割并输出。</p>\n<p>split</p>\n<p>分割文件为不同的小片段。</p>\n<p>paste</p>\n<p>按行合并文件内容。</p>\n<p>sort</p>\n<p>对文件的文本内容排序。</p>\n<p>uniq</p>\n<p>去除重复行。oldboy</p>\n<p>wc</p>\n<p>统计文件的行数、单词数或字节数。</p>\n<p>iconv</p>\n<p>转换文件的编码格式。</p>\n<p>dos2unix</p>\n<p>将 DOS 格式文件转换成 UNIX 格式。</p>\n<p>diff</p>\n<p>全拼 difference，比较文件的差异，常用于文本文件。</p>\n<p>vimdiff</p>\n<p>命令行可视化文件比较工具，常用于文本文件。</p>\n<p>rev</p>\n<p>反向输出文件内容。</p>\n<p>grep/egrep</p>\n<p>过滤字符串，三剑客老三。</p>\n<p>join</p>\n<p>按两个文件的相同字段合并。</p>\n<p>tr</p>\n<p>替换或删除字符。</p>\n<p>vi/vim</p>\n<p>命令行文本编辑器。</p>\n<p><strong>文件压缩及解压缩命令（4 个）</strong></p>\n<p>tar</p>\n<p>打包压缩。oldboy</p>\n<p>unzip</p>\n<p>解压文件。</p>\n<p>gzip</p>\n<p>gzip 压缩工具。</p>\n<p>zip</p>\n<p>压缩工具。</p>\n<p><strong>信息显示命令（11 个）</strong></p>\n<p>uname</p>\n<p>显示操作系统相关信息的命令。</p>\n<p>hostname</p>\n<p>显示或者设置当前系统的主机名。</p>\n<p>dmesg</p>\n<p>显示开机信息，用于诊断系统故障。</p>\n<p>uptime</p>\n<p>显示系统运行时间及负载。</p>\n<p>stat</p>\n<p>显示文件或文件系统的状态。</p>\n<p>du</p>\n<p>计算磁盘空间使用情况。</p>\n<p>df</p>\n<p>报告文件系统磁盘空间的使用情况。</p>\n<p>top</p>\n<p>实时显示系统资源使用情况。</p>\n<p>free</p>\n<p>查看系统内存。</p>\n<p>date</p>\n<p>显示与设置系统时间。</p>\n<p>cal</p>\n<p>查看日历等时间信息。</p>\n<p><strong>搜索文件命令（4 个）</strong></p>\n<p>which</p>\n<p>查找二进制命令，按环境变量 PATH 路径查找。</p>\n<p>find</p>\n<p>从磁盘遍历查找文件或目录。</p>\n<p>whereis</p>\n<p>查找二进制命令，按环境变量 PATH 路径查找。</p>\n<p>locate</p>\n<p>从数据库  (/var/lib/mlocate/mlocate.db)  查找命令，使用 updatedb 更新库。</p>\n<p><strong>用户管理命令（10 个）</strong></p>\n<p>useradd</p>\n<p>添加用户。</p>\n<p>usermod</p>\n<p>修改系统已经存在的用户属性。</p>\n<p>userdel</p>\n<p>删除用户。</p>\n<p>groupadd</p>\n<p>添加用户组。</p>\n<p>passwd</p>\n<p>修改用户密码。</p>\n<p>chage</p>\n<p>修改用户密码有效期限。</p>\n<p>id</p>\n<p>查看用户的 uid,gid 及归属的用户组。</p>\n<p>su</p>\n<p>切换用户身份。</p>\n<p>visudo</p>\n<p>编辑 / etc/sudoers 文件的专属命令。</p>\n<p>sudo</p>\n<p>以另外一个用户身份（默认 root 用户）执行事先在 sudoers 文件允许的命令。</p>\n<p><strong>基础网络操作命令（11 个）</strong></p>\n<p>telnet</p>\n<p>使用 TELNET 协议远程登录。</p>\n<p>ssh</p>\n<p>使用 SSH 加密协议远程登录。</p>\n<p>scp</p>\n<p>全拼 secure copy，用于不同主机之间复制文件。</p>\n<p>wget</p>\n<p>命令行下载文件。</p>\n<p>ping</p>\n<p>测试主机之间网络的连通性。</p>\n<p>route</p>\n<p>显示和设置 linux 系统的路由表。</p>\n<p>ifconfig</p>\n<p>查看、配置、启用或禁用网络接口的命令。</p>\n<p>ifup</p>\n<p>启动网卡。</p>\n<p>ifdown</p>\n<p>关闭网卡。</p>\n<p>netstat</p>\n<p>查看网络状态。</p>\n<p>ss</p>\n<p>查看网络状态。</p>\n<p><strong>深入网络操作命令（9 个）</strong></p>\n<p>nmap</p>\n<p>网络扫描命令。</p>\n<p>lsof</p>\n<p>全名 list open files，也就是列举系统中已经被打开的文件。</p>\n<p>mail</p>\n<p>发送和接收邮件。</p>\n<p>mutt</p>\n<p>邮件管理命令。</p>\n<p>nslookup</p>\n<p>交互式查询互联网 DNS 服务器的命令。</p>\n<p>dig</p>\n<p>查找 DNS 解析过程。</p>\n<p>host</p>\n<p>查询 DNS 的命令。</p>\n<p>traceroute</p>\n<p>追踪数据传输路由状况。</p>\n<p>tcpdump</p>\n<p>命令行的抓包工具。</p>\n<p><strong>有关磁盘与文件系统的命令（16 个）</strong></p>\n<p>mount</p>\n<p>挂载文件系统。</p>\n<p>umount</p>\n<p>卸载文件系统。</p>\n<p>fsck</p>\n<p>检查并修复 Linux 文件系统。</p>\n<p>dd</p>\n<p>转换或复制文件。</p>\n<p>dumpe2fs</p>\n<p>导出 ext2/ext3/ext4 文件系统信息。</p>\n<p>dump</p>\n<p>ext2/3/4 文件系统备份工具。</p>\n<p>fdisk</p>\n<p>磁盘分区命令，适用于 2TB 以下磁盘分区。</p>\n<p>parted</p>\n<p>磁盘分区命令，没有磁盘大小限制，常用于 2TB 以下磁盘分区。</p>\n<p>mkfs</p>\n<p>格式化创建 Linux 文件系统。</p>\n<p>partprobe</p>\n<p>更新内核的硬盘分区表信息。</p>\n<p>e2fsck</p>\n<p>检查 ext2/ext3/ext4 类型文件系统。</p>\n<p>mkswap</p>\n<p>创建 Linux 交换分区。</p>\n<p>swapon</p>\n<p>启用交换分区。</p>\n<p>swapoff</p>\n<p>关闭交换分区。</p>\n<p>sync</p>\n<p>将内存缓冲区内的数据写入磁盘。</p>\n<p>resize2fs</p>\n<p>调整 ext2/ext3/ext4 文件系统大小。</p>\n<p><strong>系统权限及用户授权相关命令（4 个）</strong></p>\n<p>chmod</p>\n<p>改变文件或目录权限。</p>\n<p>chown</p>\n<p>改变文件或目录的属主和属组。</p>\n<p>chgrp</p>\n<p>更改文件用户组。</p>\n<p>umask</p>\n<p>显示或设置权限掩码。</p>\n<p><strong>查看系统用户登陆信息的命令（7 个）</strong></p>\n<p>whoami</p>\n<p>显示当前有效的用户名称，相当于执行 id -un 命令。</p>\n<p>who</p>\n<p>显示目前登录系统的用户信息。</p>\n<p>w</p>\n<p>显示已经登陆系统的用户列表，并显示用户正在执行的指令。</p>\n<p>last</p>\n<p>显示登入系统的用户。</p>\n<p>lastlog</p>\n<p>显示系统中所有用户最近一次登录信息。</p>\n<p>users</p>\n<p>显示当前登录系统的所有用户的用户列表。</p>\n<p>finger</p>\n<p>查找并显示用户信息。</p>\n<p><strong>内置命令及其它（19 个）</strong></p>\n<p>echo</p>\n<p>打印变量，或直接输出指定的字符串</p>\n<p>printf</p>\n<p>将结果格式化输出到标准输出。</p>\n<p>rpm</p>\n<p>管理 rpm 包的命令。</p>\n<p>yum</p>\n<p>自动化简单化地管理 rpm 包的命令。</p>\n<p>watch</p>\n<p>周期性的执行给定的命令，并将命令的输出以全屏方式显示。</p>\n<p>alias</p>\n<p>设置系统别名。</p>\n<p>unalias</p>\n<p>取消系统别名。</p>\n<p>date</p>\n<p>查看或设置系统时间。</p>\n<p>clear</p>\n<p>清除屏幕，简称清屏。</p>\n<p>history</p>\n<p>查看命令执行的历史纪录。</p>\n<p>eject</p>\n<p>弹出光驱。</p>\n<p>time</p>\n<p>计算命令执行时间。</p>\n<p>nc</p>\n<p>功能强大的网络工具。</p>\n<p>xargs</p>\n<p>将标准输入转换成命令行参数。</p>\n<p>exec</p>\n<p>调用并执行指令的命令。</p>\n<p>export</p>\n<p>设置或者显示环境变量。</p>\n<p>unset</p>\n<p>删除变量或函数。</p>\n<p>type</p>\n<p>用于判断另外一个命令是否是内置命令。</p>\n<p>bc</p>\n<p>命令行科学计算器</p>\n<p><strong>系统管理与性能监视命令 (9 个)</strong></p>\n<p>chkconfig</p>\n<p>管理 Linux 系统开机启动项。</p>\n<p>vmstat</p>\n<p>虚拟内存统计。</p>\n<p>mpstat</p>\n<p>显示各个可用 CPU 的状态统计。</p>\n<p>iostat</p>\n<p>统计系统 IO。</p>\n<p>sar</p>\n<p>全面地获取系统的 CPU、运行队列、磁盘  I/O、分页（交换区）、内存、 CPU 中断和网络等性能数据。</p>\n<p>ipcs</p>\n<p>用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。</p>\n<p>ipcrm</p>\n<p>用来删除一个或更多的消息队列、信号量集或者共享内存标识。</p>\n<p>strace</p>\n<p>用于诊断、调试 Linux 用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</p>\n<p>ltrace</p>\n<p>命令会跟踪进程的库函数调用, 它会显现出哪个库函数被调用。</p>\n<p><strong>关机 / 重启 / 注销和查看系统信息的命令（6 个）</strong></p>\n<p>shutdown</p>\n<p>关机。</p>\n<p>halt</p>\n<p>关机。</p>\n<p>poweroff</p>\n<p>关闭电源。</p>\n<p>logout</p>\n<p>退出当前登录的 Shell。</p>\n<p>exit</p>\n<p>退出当前登录的 Shell。</p>\n<p>Ctrl+d</p>\n<p>退出当前登录的 Shell 的快捷键。</p>\n<p><strong>进程管理相关命令（15 个）</strong></p>\n<p>bg</p>\n<p>将一个在后台暂停的命令，变成继续执行   （在后台执行）。</p>\n<p>fg</p>\n<p>将后台中的命令调至前台继续运行。</p>\n<p>jobs</p>\n<p>查看当前有多少在后台运行的命令。</p>\n<p>kill</p>\n<p>终止进程。</p>\n<p>killall</p>\n<p>通过进程名终止进程。</p>\n<p>pkill</p>\n<p>通过进程名终止进程。</p>\n<p>crontab</p>\n<p>定时任务命令。</p>\n<p>ps</p>\n<p>显示进程的快照。</p>\n<p>pstree</p>\n<p>树形显示进程。</p>\n<p>nice/renice</p>\n<p>调整程序运行的优先级。</p>\n<p>nohup</p>\n<p>忽略挂起信号运行指定的命令。</p>\n<p>pgrep</p>\n<p>查找匹配条件的进程。</p>\n<p>runlevel</p>\n<p>查看系统当前运行级别。</p>\n<p>init</p>\n<p>切换运行级别。</p>\n<p>service</p>\n<p>启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>linux 命令是对 Linux 系统进行管理的命令。对于 Linux 系统来说，无论是中央处理器、内存、磁盘驱动器、键盘、鼠标，还是用户等都是文件， Linux 系统管理的命令是它正常运行的核心，与之前的 DOS 命令类似。linux 命令在系统中有两种类型：内置 Shell 命令和 Linux 命令。</p>\n<p>命令</p>\n<p>功能说明</p>\n<p><strong>线上查询及帮助命令 (2 个)</strong></p>\n<p>man</p>\n<p>查看命令帮助，命令的词典，更复杂的还有 info，但不常用。</p>\n<p>help</p>\n<p>查看 Linux 内置命令的帮助，比如 cd 命令。</p>\n<p><strong>文件和目录操作命令 (18 个)</strong></p>\n<p>ls</p>\n<p>全拼 list，功能是列出目录的内容及其内容属性信息。</p>\n<p>cd</p>\n<p>全拼 change directory，功能是从当前工作目录切换到指定的工作目录。</p>\n<p>cp</p>\n<p>全拼 copy，其功能为复制文件或目录。</p>\n<p>find</p>\n<p>查找的意思，用于查找目录及目录下的文件。</p>\n<p>mkdir</p>\n<p>全拼 make directories，其功能是创建目录。</p>\n<p>mv</p>\n<p>全拼 move，其功能是移动或重命名文件。</p>\n<p>pwd</p>\n<p>全拼 print working directory，其功能是显示当前工作目录的绝对路径。</p>\n<p>rename</p>\n<p>用于重命名文件。</p>\n<p>rm</p>\n<p>全拼 remove，其功能是删除一个或多个文件或目录。</p>\n<p>rmdir</p>\n<p>全拼 remove empty directories，功能是删除空目录。</p>\n<p>touch</p>\n<p>创建新的空文件，改变已有文件的时间戳属性。</p>\n<p>tree</p>\n<p>功能是以树形结构显示目录下的内容。</p>\n<p>basename</p>\n<p>显示文件名或目录名。</p>\n<p>dirname</p>\n<p>显示文件或目录路径。</p>\n<p>chattr</p>\n<p>改变文件的扩展属性。</p>\n<p>lsattr</p>\n<p>查看文件扩展属性。</p>\n<p>file</p>\n<p>显示文件的类型。</p>\n<p>md5sum</p>\n<p>计算和校验文件的 MD5 值。</p>\n<p><strong>查看文件及内容处理命令（21 个）</strong></p>\n<p>cat</p>\n<p>全拼 concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。</p>\n<p>tac</p>\n<p>tac 是 cat 的反向拼写，因此命令的功能为反向显示文件内容。</p>\n<p>more</p>\n<p>分页显示文件内容。</p>\n<p>less</p>\n<p>分页显示文件内容，more 命令的相反用法。</p>\n<p>head</p>\n<p>显示文件内容的头部。</p>\n<p>tail</p>\n<p>显示文件内容的尾部。</p>\n<p>cut</p>\n<p>将文件的每一行按指定分隔符分割并输出。</p>\n<p>split</p>\n<p>分割文件为不同的小片段。</p>\n<p>paste</p>\n<p>按行合并文件内容。</p>\n<p>sort</p>\n<p>对文件的文本内容排序。</p>\n<p>uniq</p>\n<p>去除重复行。oldboy</p>\n<p>wc</p>\n<p>统计文件的行数、单词数或字节数。</p>\n<p>iconv</p>\n<p>转换文件的编码格式。</p>\n<p>dos2unix</p>\n<p>将 DOS 格式文件转换成 UNIX 格式。</p>\n<p>diff</p>\n<p>全拼 difference，比较文件的差异，常用于文本文件。</p>\n<p>vimdiff</p>\n<p>命令行可视化文件比较工具，常用于文本文件。</p>\n<p>rev</p>\n<p>反向输出文件内容。</p>\n<p>grep/egrep</p>\n<p>过滤字符串，三剑客老三。</p>\n<p>join</p>\n<p>按两个文件的相同字段合并。</p>\n<p>tr</p>\n<p>替换或删除字符。</p>\n<p>vi/vim</p>\n<p>命令行文本编辑器。</p>\n<p><strong>文件压缩及解压缩命令（4 个）</strong></p>\n<p>tar</p>\n<p>打包压缩。oldboy</p>\n<p>unzip</p>\n<p>解压文件。</p>\n<p>gzip</p>\n<p>gzip 压缩工具。</p>\n<p>zip</p>\n<p>压缩工具。</p>\n<p><strong>信息显示命令（11 个）</strong></p>\n<p>uname</p>\n<p>显示操作系统相关信息的命令。</p>\n<p>hostname</p>\n<p>显示或者设置当前系统的主机名。</p>\n<p>dmesg</p>\n<p>显示开机信息，用于诊断系统故障。</p>\n<p>uptime</p>\n<p>显示系统运行时间及负载。</p>\n<p>stat</p>\n<p>显示文件或文件系统的状态。</p>\n<p>du</p>\n<p>计算磁盘空间使用情况。</p>\n<p>df</p>\n<p>报告文件系统磁盘空间的使用情况。</p>\n<p>top</p>\n<p>实时显示系统资源使用情况。</p>\n<p>free</p>\n<p>查看系统内存。</p>\n<p>date</p>\n<p>显示与设置系统时间。</p>\n<p>cal</p>\n<p>查看日历等时间信息。</p>\n<p><strong>搜索文件命令（4 个）</strong></p>\n<p>which</p>\n<p>查找二进制命令，按环境变量 PATH 路径查找。</p>\n<p>find</p>\n<p>从磁盘遍历查找文件或目录。</p>\n<p>whereis</p>\n<p>查找二进制命令，按环境变量 PATH 路径查找。</p>\n<p>locate</p>\n<p>从数据库  (/var/lib/mlocate/mlocate.db)  查找命令，使用 updatedb 更新库。</p>\n<p><strong>用户管理命令（10 个）</strong></p>\n<p>useradd</p>\n<p>添加用户。</p>\n<p>usermod</p>\n<p>修改系统已经存在的用户属性。</p>\n<p>userdel</p>\n<p>删除用户。</p>\n<p>groupadd</p>\n<p>添加用户组。</p>\n<p>passwd</p>\n<p>修改用户密码。</p>\n<p>chage</p>\n<p>修改用户密码有效期限。</p>\n<p>id</p>\n<p>查看用户的 uid,gid 及归属的用户组。</p>\n<p>su</p>\n<p>切换用户身份。</p>\n<p>visudo</p>\n<p>编辑 / etc/sudoers 文件的专属命令。</p>\n<p>sudo</p>\n<p>以另外一个用户身份（默认 root 用户）执行事先在 sudoers 文件允许的命令。</p>\n<p><strong>基础网络操作命令（11 个）</strong></p>\n<p>telnet</p>\n<p>使用 TELNET 协议远程登录。</p>\n<p>ssh</p>\n<p>使用 SSH 加密协议远程登录。</p>\n<p>scp</p>\n<p>全拼 secure copy，用于不同主机之间复制文件。</p>\n<p>wget</p>\n<p>命令行下载文件。</p>\n<p>ping</p>\n<p>测试主机之间网络的连通性。</p>\n<p>route</p>\n<p>显示和设置 linux 系统的路由表。</p>\n<p>ifconfig</p>\n<p>查看、配置、启用或禁用网络接口的命令。</p>\n<p>ifup</p>\n<p>启动网卡。</p>\n<p>ifdown</p>\n<p>关闭网卡。</p>\n<p>netstat</p>\n<p>查看网络状态。</p>\n<p>ss</p>\n<p>查看网络状态。</p>\n<p><strong>深入网络操作命令（9 个）</strong></p>\n<p>nmap</p>\n<p>网络扫描命令。</p>\n<p>lsof</p>\n<p>全名 list open files，也就是列举系统中已经被打开的文件。</p>\n<p>mail</p>\n<p>发送和接收邮件。</p>\n<p>mutt</p>\n<p>邮件管理命令。</p>\n<p>nslookup</p>\n<p>交互式查询互联网 DNS 服务器的命令。</p>\n<p>dig</p>\n<p>查找 DNS 解析过程。</p>\n<p>host</p>\n<p>查询 DNS 的命令。</p>\n<p>traceroute</p>\n<p>追踪数据传输路由状况。</p>\n<p>tcpdump</p>\n<p>命令行的抓包工具。</p>\n<p><strong>有关磁盘与文件系统的命令（16 个）</strong></p>\n<p>mount</p>\n<p>挂载文件系统。</p>\n<p>umount</p>\n<p>卸载文件系统。</p>\n<p>fsck</p>\n<p>检查并修复 Linux 文件系统。</p>\n<p>dd</p>\n<p>转换或复制文件。</p>\n<p>dumpe2fs</p>\n<p>导出 ext2/ext3/ext4 文件系统信息。</p>\n<p>dump</p>\n<p>ext2/3/4 文件系统备份工具。</p>\n<p>fdisk</p>\n<p>磁盘分区命令，适用于 2TB 以下磁盘分区。</p>\n<p>parted</p>\n<p>磁盘分区命令，没有磁盘大小限制，常用于 2TB 以下磁盘分区。</p>\n<p>mkfs</p>\n<p>格式化创建 Linux 文件系统。</p>\n<p>partprobe</p>\n<p>更新内核的硬盘分区表信息。</p>\n<p>e2fsck</p>\n<p>检查 ext2/ext3/ext4 类型文件系统。</p>\n<p>mkswap</p>\n<p>创建 Linux 交换分区。</p>\n<p>swapon</p>\n<p>启用交换分区。</p>\n<p>swapoff</p>\n<p>关闭交换分区。</p>\n<p>sync</p>\n<p>将内存缓冲区内的数据写入磁盘。</p>\n<p>resize2fs</p>\n<p>调整 ext2/ext3/ext4 文件系统大小。</p>\n<p><strong>系统权限及用户授权相关命令（4 个）</strong></p>\n<p>chmod</p>\n<p>改变文件或目录权限。</p>\n<p>chown</p>\n<p>改变文件或目录的属主和属组。</p>\n<p>chgrp</p>\n<p>更改文件用户组。</p>\n<p>umask</p>\n<p>显示或设置权限掩码。</p>\n<p><strong>查看系统用户登陆信息的命令（7 个）</strong></p>\n<p>whoami</p>\n<p>显示当前有效的用户名称，相当于执行 id -un 命令。</p>\n<p>who</p>\n<p>显示目前登录系统的用户信息。</p>\n<p>w</p>\n<p>显示已经登陆系统的用户列表，并显示用户正在执行的指令。</p>\n<p>last</p>\n<p>显示登入系统的用户。</p>\n<p>lastlog</p>\n<p>显示系统中所有用户最近一次登录信息。</p>\n<p>users</p>\n<p>显示当前登录系统的所有用户的用户列表。</p>\n<p>finger</p>\n<p>查找并显示用户信息。</p>\n<p><strong>内置命令及其它（19 个）</strong></p>\n<p>echo</p>\n<p>打印变量，或直接输出指定的字符串</p>\n<p>printf</p>\n<p>将结果格式化输出到标准输出。</p>\n<p>rpm</p>\n<p>管理 rpm 包的命令。</p>\n<p>yum</p>\n<p>自动化简单化地管理 rpm 包的命令。</p>\n<p>watch</p>\n<p>周期性的执行给定的命令，并将命令的输出以全屏方式显示。</p>\n<p>alias</p>\n<p>设置系统别名。</p>\n<p>unalias</p>\n<p>取消系统别名。</p>\n<p>date</p>\n<p>查看或设置系统时间。</p>\n<p>clear</p>\n<p>清除屏幕，简称清屏。</p>\n<p>history</p>\n<p>查看命令执行的历史纪录。</p>\n<p>eject</p>\n<p>弹出光驱。</p>\n<p>time</p>\n<p>计算命令执行时间。</p>\n<p>nc</p>\n<p>功能强大的网络工具。</p>\n<p>xargs</p>\n<p>将标准输入转换成命令行参数。</p>\n<p>exec</p>\n<p>调用并执行指令的命令。</p>\n<p>export</p>\n<p>设置或者显示环境变量。</p>\n<p>unset</p>\n<p>删除变量或函数。</p>\n<p>type</p>\n<p>用于判断另外一个命令是否是内置命令。</p>\n<p>bc</p>\n<p>命令行科学计算器</p>\n<p><strong>系统管理与性能监视命令 (9 个)</strong></p>\n<p>chkconfig</p>\n<p>管理 Linux 系统开机启动项。</p>\n<p>vmstat</p>\n<p>虚拟内存统计。</p>\n<p>mpstat</p>\n<p>显示各个可用 CPU 的状态统计。</p>\n<p>iostat</p>\n<p>统计系统 IO。</p>\n<p>sar</p>\n<p>全面地获取系统的 CPU、运行队列、磁盘  I/O、分页（交换区）、内存、 CPU 中断和网络等性能数据。</p>\n<p>ipcs</p>\n<p>用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。</p>\n<p>ipcrm</p>\n<p>用来删除一个或更多的消息队列、信号量集或者共享内存标识。</p>\n<p>strace</p>\n<p>用于诊断、调试 Linux 用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</p>\n<p>ltrace</p>\n<p>命令会跟踪进程的库函数调用, 它会显现出哪个库函数被调用。</p>\n<p><strong>关机 / 重启 / 注销和查看系统信息的命令（6 个）</strong></p>\n<p>shutdown</p>\n<p>关机。</p>\n<p>halt</p>\n<p>关机。</p>\n<p>poweroff</p>\n<p>关闭电源。</p>\n<p>logout</p>\n<p>退出当前登录的 Shell。</p>\n<p>exit</p>\n<p>退出当前登录的 Shell。</p>\n<p>Ctrl+d</p>\n<p>退出当前登录的 Shell 的快捷键。</p>\n<p><strong>进程管理相关命令（15 个）</strong></p>\n<p>bg</p>\n<p>将一个在后台暂停的命令，变成继续执行   （在后台执行）。</p>\n<p>fg</p>\n<p>将后台中的命令调至前台继续运行。</p>\n<p>jobs</p>\n<p>查看当前有多少在后台运行的命令。</p>\n<p>kill</p>\n<p>终止进程。</p>\n<p>killall</p>\n<p>通过进程名终止进程。</p>\n<p>pkill</p>\n<p>通过进程名终止进程。</p>\n<p>crontab</p>\n<p>定时任务命令。</p>\n<p>ps</p>\n<p>显示进程的快照。</p>\n<p>pstree</p>\n<p>树形显示进程。</p>\n<p>nice/renice</p>\n<p>调整程序运行的优先级。</p>\n<p>nohup</p>\n<p>忽略挂起信号运行指定的命令。</p>\n<p>pgrep</p>\n<p>查找匹配条件的进程。</p>\n<p>runlevel</p>\n<p>查看系统当前运行级别。</p>\n<p>init</p>\n<p>切换运行级别。</p>\n<p>service</p>\n<p>启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。</p>\n"},{"title":"小程序开发wepy框架类vue的开发方式","date":"2018-01-18T21:34:00.000Z","_content":"\n## 1.node 的安装\n\n[节点网官](https://nodejs.org/en/)下载  \n![节点官网截取](http://img.blog.csdn.net/20170602210731167?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcmVzX21pbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n推荐左边的安装方式，因为右边的最新版本在有些电脑上运行不稳定。\n\n下载到本地一直继续就好。\n\n安装好后就可以直接在命令行运行查看结果\n\n![这里写图片描述](http://img.blog.csdn.net/20170602211312287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcmVzX21pbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 2.快速入门\n\n> WePY 是一款让小程序支持组件化开发的框架，通过预编译的手段让开发者可以选择自己喜欢的开发风格去开发小程序。框架的细节优化，无极，异步功能的引入都是为了能让开发小程序项目变得更加简单，高效。\n>\n> 同时 WePY 也是一款成长中的框架，大量吸收借鉴了一些优化前端工具以及框架的设计理念和思想。如果 WePY 有不足地方，或者你有更好的想法，欢迎提交发行或者 PR。\n\n**安装（更新）wepy 命令行工具。**\n\n    npm install wepy-cli -g\n\n**在开发目录生成开发 DEMO。**\n\n    wepy new demo\n\n**切换至项目目录。**\n\n    cd demo\n\n**打开目录**   \n窗口\n\n     dir\n\n**项目目录结构**\n\n    ├── dist                   微信开发者工具指定的目录\n    ├── node_modules\n    ├── src                    代码编写的目录\n    |   ├── components         组件文件夹（非完整页面）\n    |   |   ├── com_a.wpy      可复用组件 a\n    |   |   └── com_b.wpy      可复用组件 b\n    |   ├── pages              页面文件夹（完整页面）\n    |   |   ├── index.wpy      页面 index\n    |   |   └── page.wpy       页面 page\n    |   └── app.wpy            小程序配置项（全局样式配置、声明钩子等）\n    └── package.json           package 配置\n\n**开发使用说明**\n\n1.  使用`微信开发者工具`新建项目，开发本地选择`dist`目录。\n2.  `微信开发者工具` \\- >项目 \\- >关闭 ES6 转 ES5。\n3.  本地项目根目录运行`wepy build --watch`，开启实时编译。\n\n**代码高亮**\n\n> VScode 下代码高亮\n\n**先下载**\n\n![这里写图片描述](http://img.blog.csdn.net/20170602212828288?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcmVzX21pbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n> 配置展示进入设置  \n> 在 settings.js 文件下添加如下代码\n\n    \"files.associations\": {\n            \"*.vue\": \"vue\",\n            \"*.wpy\": \"vue\",\n            \"*.wxml\": \"html\",\n            \"*.wxss\": \"css\"\n        },\n        \"emmet.syntaxProfiles\": {\n            \"vue-html\": \"html\",\n            \"vue\": \"html\"\n        }\n\n后就保存在可以中页面看待`.wpy`后缀代码高亮\n\n> Sublime 下载码高亮  \n> 文件后缀为.wpy，可共用 vue 高亮，但需要手动安装。  \n> 打开 Sublime-> Preferences-> Browse Packages ..进入用户包文件夹。  \n> 在此文件夹下打开 cmd，运行 git clone git@github.com：vuejs / VUE -句法- highlight.git，无 GIT 用户可以直接下载拉链包解压至当前文件夹。  \n> 关闭.wpy 文件重新打开即可高亮。\n>\n> WebStorm 下代码高亮  \n> 打开首选项，搜索插件，搜索 Vue.js 插件并安装。  \n> 打开首选项，搜索文件类型，找到 Vue.js 模板，在注册模式添加\\* .wpy，即可高亮。\n>\n> Atom 下代码高亮  \n> 在 Atom 里先安装 vue 的语法高亮 - language-vue，如果装过了就忽略这一步。  \n> 打开 Atom - >配置菜单。在 core 键下添加：\n\n    customFileTypes:\n       \"text.html.vue\": [\n          \"wpy\"\n       ]\n\n## 3，代码规范\n\n1.  变量与方法使用尽量使用驼峰式命名，避免使用\\$开头。\n2.  入口，页面，组件的命名后缀为.wpy。外链的文件可以是其它后缀。\n3.  使用 ES6 语法开发。框架在 ES6 下开发，因此也需要使用 ES6 开发小程序，ES6 中有大量的语法糖可以让我们的代码更加简洁高效。\n4.  甚至可以直接使用异步/等待等新特性进行开发。\n5.  事件绑定语法使用优化语法代替：原 bindtap =“click”替换为@ tap =“click”，原 catchtap =“click”替换为@ tap.stop =“click”。更多@符用法\n6.  事件传参使用优化后语法代替：原 bindtap =“click”data-index = { {index}}替换为@ tap =“click（{ {index}}）”。\n7.  自定义组件命名应避开微信原生组件以及功能标签。不可以使用输入，按钮，查看，重复等命名自定义组件。\n\n## 4.优点\n\n1.  支持组件化开发。\n2.  支持加载外部 NPM 包。\n3.  单文件模式，使得目录结构更加清晰。\n4.  默认使用巴别编译，支持 ES6 / 7 的一些新特性。\n5.  针对原生 API 进行优化。\n\n## 5.wpy 文件说明\n\n一个`.wpy`文件分为三个部分：  \n1 .样式对应原有 wxss。2.   \n模板对应原有 wxml。3.   \n代码对应原有 js。\n\n其中入口文件 app.wpy 不需要模板，所以编译时会被忽略。这三个标签都支持郎和 SRC 属性，郎决定了其代码编译过程，SRC 决定是否外联代码，存在 SRC 属性且有效时，忽略内联代码，示例如下：\n\n    <style lang=\"less\" src=\"page1.less\">style>\n    <template lang=\"wxml\" src=\"page1.wxml\">template>\n    <script>\n        // some code\n    script>\n\n标签对应 lang 值如下表所示：\n\n标签\n\n郎默认值\n\n郎支持值\n\n样式\n\nCSS\n\nCSS，少，上海社会科学院，手写笔\n\n模板\n\nwxml\n\nwxml，XML，哈巴狗（原玉）\n\n脚本\n\n巴布尔\n\n巴布尔，打字稿\n\n## 演示\n\nindex.wpy\n\n    <style lang=\"less\">\n    .userinfo {\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n    }\n\n    .userinfo-avatar {\n      width: 80rpx;\n      height: 80rpx;\n      border-radius: 50%;\n    }\n\n    .userinfo-nickname {\n      color: #aaa;\n    }\n    style>\n    <template>\n      <view class=\"container\">\n        <view class=\"userinfo\" @tap=\"handleViewTap\">\n          <image class=\"userinfo-avatar\" src=\"{ { userInfo.avatarUrl }}\" background-size=\"cover\" />\n          <view class=\"userinfo-nickname\">{ { userInfo.nickName }}view>\n        view>\n        <panel>\n          <view>{ { datas }}'111'view>\n          <view @tap=\"doLogin\" class=\"item\">\n            <view class=\"item-inner\">登录view>\n          view>\n           <view @tap=\"enevts\" class=\"item\">\n            <view class=\"item-inner\">用户信息view>\n          view>\n        panel>\n        <panel>\n                <view class=\"title\" slot=\"title\">测试数据绑定view>\n                <text class=\"info\">{ {normalTitle}}text>\n                <text class=\"info\">{ {setTimeoutTitle}}text>\n                <text class=\"info\">{ {mixin}}text>\n                <text class=\"info\">{ {mynum}}text>\n                <text class=\"info\">{ {now}}text>\n                <button @tap=\"plus('a')\" size=\"mini\"> + button>\n              panel>\n\n              <panel>\n                <view class=\"title\" slot=\"title\">其它测试view>\n                <button @tap=\"toast\" size=\"mini\">第三方组件button>\n                <button @tap=\"communicate\" size=\"mini\">组件通信button>\n                <button @tap=\"tap\" size=\"mini\">混合TAP事件button>\n              panel>\n\n              <panel>\n                <view class=\"title\" slot=\"title\">测试并发网络请求view>\n                <view>返回结果:\n                  <text>{ {netrst}}text>\n                view>\n                <button @tap=\"request\" size=\"mini\"> 点我发起10个请求 button>\n              panel>\n\n              <panel>\n                <view class=\"title\" slot=\"title\">测试组件view>\n\n                <text class=\"testcounter\">计数组件1: text>\n                <view class=\"counterview\">\n                  <counter1 @index-emit=\"counterEmit\" />\n                view>\n\n                <text class=\"testcounter\">计数组件2: text>\n\n                <view class=\"counterview\">\n                  <counter2 :num.sync=\"mynum\">counter2>\n                view>\n              panel>\n\n              <panel>\n                <view class=\"title\" slot=\"title\">测试组件Repeatview>\n                <repeat for=\"{ {groupList}}\" index=\"index\" item=\"item\" key=\"key\">\n                  <group :grouplist=\"item\" :indexa=\"index\">group>\n                repeat>\n              panel>\n\n              <panel>\n                <view class=\"title\" slot=\"title\">测试列表view>\n                <list>list>\n              panel>\n\n        <toast />\n      view>\n    template>\n\n    <script>\n    import wepy from 'wepy'\n    import List from '../components/list'\n    import Panel from '../components/panel'\n    import Counter from '../components/counter'\n    import Group from '../components/group'\n    import Toast from 'wepy-com-toast'\n    import testMixin from '../mixins/test'\n    // 引入 QCloud 小程序增强 SDK\n    import qcloud from '../assets/qcloud-weapp-client-sdk/index'\n    export default class Index extends wepy.page {\n      config = {\n        navigationBarTitleText: 'test'\n      }\n      components = {\n        panel: Panel,\n        counter1: Counter,\n        counter2: Counter,\n        list: List,\n        group: Group,\n        toast: Toast\n      }\n      mixins = [testMixin]\n\n      data = {\n        datas: '',\n        mynum: 20,\n        userInfo: {\n          nickName: '加载中...'\n        },\n        normalTitle: '原始标题',\n        setTimeoutTitle: '标题三秒后会被修改',\n        count: 0,\n        netrst: '',\n        groupList: [\n          {\n            id: 1,\n            name: '点击改变',\n            list: [\n              {\n                childid: '1.1',\n                childname: '子项，点我改变'\n              }, {\n                childid: '1.2',\n                childname: '子项，点我改变'\n              }, {\n                childid: '1.3',\n                childname: '子项，点我改变'\n              }\n            ]\n          },\n          {\n            id: 2,\n            name: '点击改变',\n            list: [\n              {\n                childid: '2.1',\n                childname: '子项，点我改变'\n              }, {\n                childid: '2.2',\n                childname: '子项，点我改变'\n              }, {\n                childid: '2.3',\n                childname: '子项，点我改变'\n              }\n            ]\n          },\n          {\n            id: 3,\n            name: '点击改变',\n            list: [\n              {\n                childid: '3.1',\n                childname: '子项，点我改变'\n              }\n            ]\n          }\n        ]\n      }\n\n      computed = {\n        now() {\n          return +new Date()\n        }\n      }\n\n      methods = {\n        doLogin() {\n          qcloud.setLoginUrl('https://66280981.qcloud.la/api/user/login');\n          qcloud.login({\n            success: function (userInfo) {\n              console.log('登录成功', userInfo);\n            },\n            fail: function (err) {\n              console.log('登录失败', err);\n            }\n          });\n        },\n        enevts() {\n           qcloud.request({\n            url: `https://66280981.qcloud.la/api/user/info`,\n            login: true,\n            success: (response) => {\n              console.log(response.data.data.userInfo)\n              // this.me = response.data.data.userInfo;\n              // this.connect();\n            }\n          });\n        },\n        plus() {\n          this.mynum++\n        },\n        toast() {\n          let promise = this.$invoke('toast', 'show', {\n            title: '自定义标题',\n            img: 'https://raw.githubusercontent.com/kiinlam/wetoast/master/images/star.png'\n          })\n\n          promise.then((d) => {\n            console.log('toast done')\n          })\n        },\n        tap() {\n          console.log('do noting from ' + this.$name)\n        },\n        communicate() {\n          console.log(this.$name + ' tap')\n\n          this.$invoke('counter2', 'minus', 45, 6)\n          this.$invoke('counter1', 'plus', 45, 6)\n\n          this.$broadcast('index-broadcast', 1, 3, 4)\n        },\n        request() {\n          let self = this\n          let i = 10\n          let map = ['MA==', 'MQo=', 'Mg==', 'Mw==', 'NA==', 'NQ==', 'Ng==', 'Nw==', 'OA==', 'OQ==']\n          while (i--) {\n            wepy.request({\n              url: 'https://www.madcoder.cn/tests/sleep.php?time=1&t=css&c=' + map[i] + '&i=' + i,\n              success: function (d) {\n                self.netrst += d.data + '.'\n                self.$apply()\n              }\n            })\n          }\n        },\n        counterEmit(...args) {\n          let $event = args[args.length - 1]\n          console.log(`${this.$name} receive ${$event.name} from ${$event.source.$name}`)\n        }\n      }\n\n      events = {\n        'index-emit': (...args) => {\n          let $event = args[args.length - 1]\n          console.log(`${this.$name} receive ${$event.name} from ${$event.source.$name}`)\n        }\n      }\n\n      onLoad() {\n        let self = this\n        this.$parent.getUserInfo(function (userInfo) {\n          if (userInfo) {\n            self.userInfo = userInfo\n          }\n          self.normalTitle = '标题已被修改'\n\n          self.setTimeoutTitle = '标题三秒后会被修改'\n          setTimeout(() => {\n            self.setTimeoutTitle = '到三秒了'\n            self.$apply()\n          }, 3000)\n\n          self.$apply()\n        })\n      }\n    }\n    script>\n","source":"_posts/2018-01-19-小程序开发wepy框架类vue的开发方式.md","raw":"---\ntitle: 小程序开发wepy框架类vue的开发方式\ntags:\n  - 前端\ndate: 2018-01-19 05:34:00\ncategories: 前端\n---\n\n## 1.node 的安装\n\n[节点网官](https://nodejs.org/en/)下载  \n![节点官网截取](http://img.blog.csdn.net/20170602210731167?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcmVzX21pbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n推荐左边的安装方式，因为右边的最新版本在有些电脑上运行不稳定。\n\n下载到本地一直继续就好。\n\n安装好后就可以直接在命令行运行查看结果\n\n![这里写图片描述](http://img.blog.csdn.net/20170602211312287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcmVzX21pbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## 2.快速入门\n\n> WePY 是一款让小程序支持组件化开发的框架，通过预编译的手段让开发者可以选择自己喜欢的开发风格去开发小程序。框架的细节优化，无极，异步功能的引入都是为了能让开发小程序项目变得更加简单，高效。\n>\n> 同时 WePY 也是一款成长中的框架，大量吸收借鉴了一些优化前端工具以及框架的设计理念和思想。如果 WePY 有不足地方，或者你有更好的想法，欢迎提交发行或者 PR。\n\n**安装（更新）wepy 命令行工具。**\n\n    npm install wepy-cli -g\n\n**在开发目录生成开发 DEMO。**\n\n    wepy new demo\n\n**切换至项目目录。**\n\n    cd demo\n\n**打开目录**   \n窗口\n\n     dir\n\n**项目目录结构**\n\n    ├── dist                   微信开发者工具指定的目录\n    ├── node_modules\n    ├── src                    代码编写的目录\n    |   ├── components         组件文件夹（非完整页面）\n    |   |   ├── com_a.wpy      可复用组件 a\n    |   |   └── com_b.wpy      可复用组件 b\n    |   ├── pages              页面文件夹（完整页面）\n    |   |   ├── index.wpy      页面 index\n    |   |   └── page.wpy       页面 page\n    |   └── app.wpy            小程序配置项（全局样式配置、声明钩子等）\n    └── package.json           package 配置\n\n**开发使用说明**\n\n1.  使用`微信开发者工具`新建项目，开发本地选择`dist`目录。\n2.  `微信开发者工具` \\- >项目 \\- >关闭 ES6 转 ES5。\n3.  本地项目根目录运行`wepy build --watch`，开启实时编译。\n\n**代码高亮**\n\n> VScode 下代码高亮\n\n**先下载**\n\n![这里写图片描述](http://img.blog.csdn.net/20170602212828288?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcmVzX21pbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n> 配置展示进入设置  \n> 在 settings.js 文件下添加如下代码\n\n    \"files.associations\": {\n            \"*.vue\": \"vue\",\n            \"*.wpy\": \"vue\",\n            \"*.wxml\": \"html\",\n            \"*.wxss\": \"css\"\n        },\n        \"emmet.syntaxProfiles\": {\n            \"vue-html\": \"html\",\n            \"vue\": \"html\"\n        }\n\n后就保存在可以中页面看待`.wpy`后缀代码高亮\n\n> Sublime 下载码高亮  \n> 文件后缀为.wpy，可共用 vue 高亮，但需要手动安装。  \n> 打开 Sublime-> Preferences-> Browse Packages ..进入用户包文件夹。  \n> 在此文件夹下打开 cmd，运行 git clone git@github.com：vuejs / VUE -句法- highlight.git，无 GIT 用户可以直接下载拉链包解压至当前文件夹。  \n> 关闭.wpy 文件重新打开即可高亮。\n>\n> WebStorm 下代码高亮  \n> 打开首选项，搜索插件，搜索 Vue.js 插件并安装。  \n> 打开首选项，搜索文件类型，找到 Vue.js 模板，在注册模式添加\\* .wpy，即可高亮。\n>\n> Atom 下代码高亮  \n> 在 Atom 里先安装 vue 的语法高亮 - language-vue，如果装过了就忽略这一步。  \n> 打开 Atom - >配置菜单。在 core 键下添加：\n\n    customFileTypes:\n       \"text.html.vue\": [\n          \"wpy\"\n       ]\n\n## 3，代码规范\n\n1.  变量与方法使用尽量使用驼峰式命名，避免使用\\$开头。\n2.  入口，页面，组件的命名后缀为.wpy。外链的文件可以是其它后缀。\n3.  使用 ES6 语法开发。框架在 ES6 下开发，因此也需要使用 ES6 开发小程序，ES6 中有大量的语法糖可以让我们的代码更加简洁高效。\n4.  甚至可以直接使用异步/等待等新特性进行开发。\n5.  事件绑定语法使用优化语法代替：原 bindtap =“click”替换为@ tap =“click”，原 catchtap =“click”替换为@ tap.stop =“click”。更多@符用法\n6.  事件传参使用优化后语法代替：原 bindtap =“click”data-index = { {index}}替换为@ tap =“click（{ {index}}）”。\n7.  自定义组件命名应避开微信原生组件以及功能标签。不可以使用输入，按钮，查看，重复等命名自定义组件。\n\n## 4.优点\n\n1.  支持组件化开发。\n2.  支持加载外部 NPM 包。\n3.  单文件模式，使得目录结构更加清晰。\n4.  默认使用巴别编译，支持 ES6 / 7 的一些新特性。\n5.  针对原生 API 进行优化。\n\n## 5.wpy 文件说明\n\n一个`.wpy`文件分为三个部分：  \n1 .样式对应原有 wxss。2.   \n模板对应原有 wxml。3.   \n代码对应原有 js。\n\n其中入口文件 app.wpy 不需要模板，所以编译时会被忽略。这三个标签都支持郎和 SRC 属性，郎决定了其代码编译过程，SRC 决定是否外联代码，存在 SRC 属性且有效时，忽略内联代码，示例如下：\n\n    <style lang=\"less\" src=\"page1.less\">style>\n    <template lang=\"wxml\" src=\"page1.wxml\">template>\n    <script>\n        // some code\n    script>\n\n标签对应 lang 值如下表所示：\n\n标签\n\n郎默认值\n\n郎支持值\n\n样式\n\nCSS\n\nCSS，少，上海社会科学院，手写笔\n\n模板\n\nwxml\n\nwxml，XML，哈巴狗（原玉）\n\n脚本\n\n巴布尔\n\n巴布尔，打字稿\n\n## 演示\n\nindex.wpy\n\n    <style lang=\"less\">\n    .userinfo {\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n    }\n\n    .userinfo-avatar {\n      width: 80rpx;\n      height: 80rpx;\n      border-radius: 50%;\n    }\n\n    .userinfo-nickname {\n      color: #aaa;\n    }\n    style>\n    <template>\n      <view class=\"container\">\n        <view class=\"userinfo\" @tap=\"handleViewTap\">\n          <image class=\"userinfo-avatar\" src=\"{ { userInfo.avatarUrl }}\" background-size=\"cover\" />\n          <view class=\"userinfo-nickname\">{ { userInfo.nickName }}view>\n        view>\n        <panel>\n          <view>{ { datas }}'111'view>\n          <view @tap=\"doLogin\" class=\"item\">\n            <view class=\"item-inner\">登录view>\n          view>\n           <view @tap=\"enevts\" class=\"item\">\n            <view class=\"item-inner\">用户信息view>\n          view>\n        panel>\n        <panel>\n                <view class=\"title\" slot=\"title\">测试数据绑定view>\n                <text class=\"info\">{ {normalTitle}}text>\n                <text class=\"info\">{ {setTimeoutTitle}}text>\n                <text class=\"info\">{ {mixin}}text>\n                <text class=\"info\">{ {mynum}}text>\n                <text class=\"info\">{ {now}}text>\n                <button @tap=\"plus('a')\" size=\"mini\"> + button>\n              panel>\n\n              <panel>\n                <view class=\"title\" slot=\"title\">其它测试view>\n                <button @tap=\"toast\" size=\"mini\">第三方组件button>\n                <button @tap=\"communicate\" size=\"mini\">组件通信button>\n                <button @tap=\"tap\" size=\"mini\">混合TAP事件button>\n              panel>\n\n              <panel>\n                <view class=\"title\" slot=\"title\">测试并发网络请求view>\n                <view>返回结果:\n                  <text>{ {netrst}}text>\n                view>\n                <button @tap=\"request\" size=\"mini\"> 点我发起10个请求 button>\n              panel>\n\n              <panel>\n                <view class=\"title\" slot=\"title\">测试组件view>\n\n                <text class=\"testcounter\">计数组件1: text>\n                <view class=\"counterview\">\n                  <counter1 @index-emit=\"counterEmit\" />\n                view>\n\n                <text class=\"testcounter\">计数组件2: text>\n\n                <view class=\"counterview\">\n                  <counter2 :num.sync=\"mynum\">counter2>\n                view>\n              panel>\n\n              <panel>\n                <view class=\"title\" slot=\"title\">测试组件Repeatview>\n                <repeat for=\"{ {groupList}}\" index=\"index\" item=\"item\" key=\"key\">\n                  <group :grouplist=\"item\" :indexa=\"index\">group>\n                repeat>\n              panel>\n\n              <panel>\n                <view class=\"title\" slot=\"title\">测试列表view>\n                <list>list>\n              panel>\n\n        <toast />\n      view>\n    template>\n\n    <script>\n    import wepy from 'wepy'\n    import List from '../components/list'\n    import Panel from '../components/panel'\n    import Counter from '../components/counter'\n    import Group from '../components/group'\n    import Toast from 'wepy-com-toast'\n    import testMixin from '../mixins/test'\n    // 引入 QCloud 小程序增强 SDK\n    import qcloud from '../assets/qcloud-weapp-client-sdk/index'\n    export default class Index extends wepy.page {\n      config = {\n        navigationBarTitleText: 'test'\n      }\n      components = {\n        panel: Panel,\n        counter1: Counter,\n        counter2: Counter,\n        list: List,\n        group: Group,\n        toast: Toast\n      }\n      mixins = [testMixin]\n\n      data = {\n        datas: '',\n        mynum: 20,\n        userInfo: {\n          nickName: '加载中...'\n        },\n        normalTitle: '原始标题',\n        setTimeoutTitle: '标题三秒后会被修改',\n        count: 0,\n        netrst: '',\n        groupList: [\n          {\n            id: 1,\n            name: '点击改变',\n            list: [\n              {\n                childid: '1.1',\n                childname: '子项，点我改变'\n              }, {\n                childid: '1.2',\n                childname: '子项，点我改变'\n              }, {\n                childid: '1.3',\n                childname: '子项，点我改变'\n              }\n            ]\n          },\n          {\n            id: 2,\n            name: '点击改变',\n            list: [\n              {\n                childid: '2.1',\n                childname: '子项，点我改变'\n              }, {\n                childid: '2.2',\n                childname: '子项，点我改变'\n              }, {\n                childid: '2.3',\n                childname: '子项，点我改变'\n              }\n            ]\n          },\n          {\n            id: 3,\n            name: '点击改变',\n            list: [\n              {\n                childid: '3.1',\n                childname: '子项，点我改变'\n              }\n            ]\n          }\n        ]\n      }\n\n      computed = {\n        now() {\n          return +new Date()\n        }\n      }\n\n      methods = {\n        doLogin() {\n          qcloud.setLoginUrl('https://66280981.qcloud.la/api/user/login');\n          qcloud.login({\n            success: function (userInfo) {\n              console.log('登录成功', userInfo);\n            },\n            fail: function (err) {\n              console.log('登录失败', err);\n            }\n          });\n        },\n        enevts() {\n           qcloud.request({\n            url: `https://66280981.qcloud.la/api/user/info`,\n            login: true,\n            success: (response) => {\n              console.log(response.data.data.userInfo)\n              // this.me = response.data.data.userInfo;\n              // this.connect();\n            }\n          });\n        },\n        plus() {\n          this.mynum++\n        },\n        toast() {\n          let promise = this.$invoke('toast', 'show', {\n            title: '自定义标题',\n            img: 'https://raw.githubusercontent.com/kiinlam/wetoast/master/images/star.png'\n          })\n\n          promise.then((d) => {\n            console.log('toast done')\n          })\n        },\n        tap() {\n          console.log('do noting from ' + this.$name)\n        },\n        communicate() {\n          console.log(this.$name + ' tap')\n\n          this.$invoke('counter2', 'minus', 45, 6)\n          this.$invoke('counter1', 'plus', 45, 6)\n\n          this.$broadcast('index-broadcast', 1, 3, 4)\n        },\n        request() {\n          let self = this\n          let i = 10\n          let map = ['MA==', 'MQo=', 'Mg==', 'Mw==', 'NA==', 'NQ==', 'Ng==', 'Nw==', 'OA==', 'OQ==']\n          while (i--) {\n            wepy.request({\n              url: 'https://www.madcoder.cn/tests/sleep.php?time=1&t=css&c=' + map[i] + '&i=' + i,\n              success: function (d) {\n                self.netrst += d.data + '.'\n                self.$apply()\n              }\n            })\n          }\n        },\n        counterEmit(...args) {\n          let $event = args[args.length - 1]\n          console.log(`${this.$name} receive ${$event.name} from ${$event.source.$name}`)\n        }\n      }\n\n      events = {\n        'index-emit': (...args) => {\n          let $event = args[args.length - 1]\n          console.log(`${this.$name} receive ${$event.name} from ${$event.source.$name}`)\n        }\n      }\n\n      onLoad() {\n        let self = this\n        this.$parent.getUserInfo(function (userInfo) {\n          if (userInfo) {\n            self.userInfo = userInfo\n          }\n          self.normalTitle = '标题已被修改'\n\n          self.setTimeoutTitle = '标题三秒后会被修改'\n          setTimeout(() => {\n            self.setTimeoutTitle = '到三秒了'\n            self.$apply()\n          }, 3000)\n\n          self.$apply()\n        })\n      }\n    }\n    script>\n","slug":"2018-01-19-小程序开发wepy框架类vue的开发方式","published":1,"updated":"2020-03-14T06:49:39.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvmy004x4k8ybmxt5ip8","content":"<h2 id=\"1-node-的安装\"><a href=\"#1-node-的安装\" class=\"headerlink\" title=\"1.node 的安装\"></a>1.node 的安装</h2><p><a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">节点网官</a>下载<br><img src=\"http://img.blog.csdn.net/20170602210731167?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcmVzX21pbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"节点官网截取\"></p>\n<p>推荐左边的安装方式，因为右边的最新版本在有些电脑上运行不稳定。</p>\n<p>下载到本地一直继续就好。</p>\n<p>安装好后就可以直接在命令行运行查看结果</p>\n<p><img src=\"http://img.blog.csdn.net/20170602211312287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcmVzX21pbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2 id=\"2-快速入门\"><a href=\"#2-快速入门\" class=\"headerlink\" title=\"2.快速入门\"></a>2.快速入门</h2><blockquote>\n<p>WePY 是一款让小程序支持组件化开发的框架，通过预编译的手段让开发者可以选择自己喜欢的开发风格去开发小程序。框架的细节优化，无极，异步功能的引入都是为了能让开发小程序项目变得更加简单，高效。</p>\n<p>同时 WePY 也是一款成长中的框架，大量吸收借鉴了一些优化前端工具以及框架的设计理念和思想。如果 WePY 有不足地方，或者你有更好的想法，欢迎提交发行或者 PR。</p>\n</blockquote>\n<p><strong>安装（更新）wepy 命令行工具。</strong></p>\n<pre><code>npm install wepy-cli -g</code></pre><p><strong>在开发目录生成开发 DEMO。</strong></p>\n<pre><code>wepy new demo</code></pre><p><strong>切换至项目目录。</strong></p>\n<pre><code>cd demo</code></pre><p><strong>打开目录</strong><br>窗口</p>\n<pre><code> dir</code></pre><p><strong>项目目录结构</strong></p>\n<pre><code>├── dist                   微信开发者工具指定的目录\n├── node_modules\n├── src                    代码编写的目录\n|   ├── components         组件文件夹（非完整页面）\n|   |   ├── com_a.wpy      可复用组件 a\n|   |   └── com_b.wpy      可复用组件 b\n|   ├── pages              页面文件夹（完整页面）\n|   |   ├── index.wpy      页面 index\n|   |   └── page.wpy       页面 page\n|   └── app.wpy            小程序配置项（全局样式配置、声明钩子等）\n└── package.json           package 配置</code></pre><p><strong>开发使用说明</strong></p>\n<ol>\n<li>使用<code>微信开发者工具</code>新建项目，开发本地选择<code>dist</code>目录。</li>\n<li><code>微信开发者工具</code> - &gt;项目 - &gt;关闭 ES6 转 ES5。</li>\n<li>本地项目根目录运行<code>wepy build --watch</code>，开启实时编译。</li>\n</ol>\n<p><strong>代码高亮</strong></p>\n<blockquote>\n<p>VScode 下代码高亮</p>\n</blockquote>\n<p><strong>先下载</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20170602212828288?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcmVzX21pbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<blockquote>\n<p>配置展示进入设置<br>在 settings.js 文件下添加如下代码</p>\n</blockquote>\n<pre><code>&quot;files.associations&quot;: {\n        &quot;*.vue&quot;: &quot;vue&quot;,\n        &quot;*.wpy&quot;: &quot;vue&quot;,\n        &quot;*.wxml&quot;: &quot;html&quot;,\n        &quot;*.wxss&quot;: &quot;css&quot;\n    },\n    &quot;emmet.syntaxProfiles&quot;: {\n        &quot;vue-html&quot;: &quot;html&quot;,\n        &quot;vue&quot;: &quot;html&quot;\n    }</code></pre><p>后就保存在可以中页面看待<code>.wpy</code>后缀代码高亮</p>\n<blockquote>\n<p>Sublime 下载码高亮<br>文件后缀为.wpy，可共用 vue 高亮，但需要手动安装。<br>打开 Sublime-&gt; Preferences-&gt; Browse Packages ..进入用户包文件夹。<br>在此文件夹下打开 cmd，运行 git clone <a href=\"mailto:git@github.com\">git@github.com</a>：vuejs / VUE -句法- highlight.git，无 GIT 用户可以直接下载拉链包解压至当前文件夹。<br>关闭.wpy 文件重新打开即可高亮。</p>\n<p>WebStorm 下代码高亮<br>打开首选项，搜索插件，搜索 Vue.js 插件并安装。<br>打开首选项，搜索文件类型，找到 Vue.js 模板，在注册模式添加* .wpy，即可高亮。</p>\n<p>Atom 下代码高亮<br>在 Atom 里先安装 vue 的语法高亮 - language-vue，如果装过了就忽略这一步。<br>打开 Atom - &gt;配置菜单。在 core 键下添加：</p>\n</blockquote>\n<pre><code>customFileTypes:\n   &quot;text.html.vue&quot;: [\n      &quot;wpy&quot;\n   ]</code></pre><h2 id=\"3，代码规范\"><a href=\"#3，代码规范\" class=\"headerlink\" title=\"3，代码规范\"></a>3，代码规范</h2><ol>\n<li>变量与方法使用尽量使用驼峰式命名，避免使用$开头。</li>\n<li>入口，页面，组件的命名后缀为.wpy。外链的文件可以是其它后缀。</li>\n<li>使用 ES6 语法开发。框架在 ES6 下开发，因此也需要使用 ES6 开发小程序，ES6 中有大量的语法糖可以让我们的代码更加简洁高效。</li>\n<li>甚至可以直接使用异步/等待等新特性进行开发。</li>\n<li>事件绑定语法使用优化语法代替：原 bindtap =“click”替换为@ tap =“click”，原 catchtap =“click”替换为@ tap.stop =“click”。更多@符用法</li>\n<li>事件传参使用优化后语法代替：原 bindtap =“click”data-index = { {index}}替换为@ tap =“click（{ {index}}）”。</li>\n<li>自定义组件命名应避开微信原生组件以及功能标签。不可以使用输入，按钮，查看，重复等命名自定义组件。</li>\n</ol>\n<h2 id=\"4-优点\"><a href=\"#4-优点\" class=\"headerlink\" title=\"4.优点\"></a>4.优点</h2><ol>\n<li>支持组件化开发。</li>\n<li>支持加载外部 NPM 包。</li>\n<li>单文件模式，使得目录结构更加清晰。</li>\n<li>默认使用巴别编译，支持 ES6 / 7 的一些新特性。</li>\n<li>针对原生 API 进行优化。</li>\n</ol>\n<h2 id=\"5-wpy-文件说明\"><a href=\"#5-wpy-文件说明\" class=\"headerlink\" title=\"5.wpy 文件说明\"></a>5.wpy 文件说明</h2><p>一个<code>.wpy</code>文件分为三个部分：<br>1 .样式对应原有 wxss。2.<br>模板对应原有 wxml。3.<br>代码对应原有 js。</p>\n<p>其中入口文件 app.wpy 不需要模板，所以编译时会被忽略。这三个标签都支持郎和 SRC 属性，郎决定了其代码编译过程，SRC 决定是否外联代码，存在 SRC 属性且有效时，忽略内联代码，示例如下：</p>\n<pre><code>&lt;style lang=&quot;less&quot; src=&quot;page1.less&quot;&gt;style&gt;\n&lt;template lang=&quot;wxml&quot; src=&quot;page1.wxml&quot;&gt;template&gt;\n&lt;script&gt;\n    // some code\nscript&gt;</code></pre><p>标签对应 lang 值如下表所示：</p>\n<p>标签</p>\n<p>郎默认值</p>\n<p>郎支持值</p>\n<p>样式</p>\n<p>CSS</p>\n<p>CSS，少，上海社会科学院，手写笔</p>\n<p>模板</p>\n<p>wxml</p>\n<p>wxml，XML，哈巴狗（原玉）</p>\n<p>脚本</p>\n<p>巴布尔</p>\n<p>巴布尔，打字稿</p>\n<h2 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h2><p>index.wpy</p>\n<pre><code>&lt;style lang=&quot;less&quot;&gt;\n.userinfo {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.userinfo-avatar {\n  width: 80rpx;\n  height: 80rpx;\n  border-radius: 50%;\n}\n\n.userinfo-nickname {\n  color: #aaa;\n}\nstyle&gt;\n&lt;template&gt;\n  &lt;view class=&quot;container&quot;&gt;\n    &lt;view class=&quot;userinfo&quot; @tap=&quot;handleViewTap&quot;&gt;\n      &lt;image class=&quot;userinfo-avatar&quot; src=&quot;{ { userInfo.avatarUrl }}&quot; background-size=&quot;cover&quot; /&gt;\n      &lt;view class=&quot;userinfo-nickname&quot;&gt;{ { userInfo.nickName }}view&gt;\n    view&gt;\n    &lt;panel&gt;\n      &lt;view&gt;{ { datas }}&#39;111&#39;view&gt;\n      &lt;view @tap=&quot;doLogin&quot; class=&quot;item&quot;&gt;\n        &lt;view class=&quot;item-inner&quot;&gt;登录view&gt;\n      view&gt;\n       &lt;view @tap=&quot;enevts&quot; class=&quot;item&quot;&gt;\n        &lt;view class=&quot;item-inner&quot;&gt;用户信息view&gt;\n      view&gt;\n    panel&gt;\n    &lt;panel&gt;\n            &lt;view class=&quot;title&quot; slot=&quot;title&quot;&gt;测试数据绑定view&gt;\n            &lt;text class=&quot;info&quot;&gt;{ {normalTitle}}text&gt;\n            &lt;text class=&quot;info&quot;&gt;{ {setTimeoutTitle}}text&gt;\n            &lt;text class=&quot;info&quot;&gt;{ {mixin}}text&gt;\n            &lt;text class=&quot;info&quot;&gt;{ {mynum}}text&gt;\n            &lt;text class=&quot;info&quot;&gt;{ {now}}text&gt;\n            &lt;button @tap=&quot;plus(&#39;a&#39;)&quot; size=&quot;mini&quot;&gt; + button&gt;\n          panel&gt;\n\n          &lt;panel&gt;\n            &lt;view class=&quot;title&quot; slot=&quot;title&quot;&gt;其它测试view&gt;\n            &lt;button @tap=&quot;toast&quot; size=&quot;mini&quot;&gt;第三方组件button&gt;\n            &lt;button @tap=&quot;communicate&quot; size=&quot;mini&quot;&gt;组件通信button&gt;\n            &lt;button @tap=&quot;tap&quot; size=&quot;mini&quot;&gt;混合TAP事件button&gt;\n          panel&gt;\n\n          &lt;panel&gt;\n            &lt;view class=&quot;title&quot; slot=&quot;title&quot;&gt;测试并发网络请求view&gt;\n            &lt;view&gt;返回结果:\n              &lt;text&gt;{ {netrst}}text&gt;\n            view&gt;\n            &lt;button @tap=&quot;request&quot; size=&quot;mini&quot;&gt; 点我发起10个请求 button&gt;\n          panel&gt;\n\n          &lt;panel&gt;\n            &lt;view class=&quot;title&quot; slot=&quot;title&quot;&gt;测试组件view&gt;\n\n            &lt;text class=&quot;testcounter&quot;&gt;计数组件1: text&gt;\n            &lt;view class=&quot;counterview&quot;&gt;\n              &lt;counter1 @index-emit=&quot;counterEmit&quot; /&gt;\n            view&gt;\n\n            &lt;text class=&quot;testcounter&quot;&gt;计数组件2: text&gt;\n\n            &lt;view class=&quot;counterview&quot;&gt;\n              &lt;counter2 :num.sync=&quot;mynum&quot;&gt;counter2&gt;\n            view&gt;\n          panel&gt;\n\n          &lt;panel&gt;\n            &lt;view class=&quot;title&quot; slot=&quot;title&quot;&gt;测试组件Repeatview&gt;\n            &lt;repeat for=&quot;{ {groupList}}&quot; index=&quot;index&quot; item=&quot;item&quot; key=&quot;key&quot;&gt;\n              &lt;group :grouplist=&quot;item&quot; :indexa=&quot;index&quot;&gt;group&gt;\n            repeat&gt;\n          panel&gt;\n\n          &lt;panel&gt;\n            &lt;view class=&quot;title&quot; slot=&quot;title&quot;&gt;测试列表view&gt;\n            &lt;list&gt;list&gt;\n          panel&gt;\n\n    &lt;toast /&gt;\n  view&gt;\ntemplate&gt;\n\n&lt;script&gt;\nimport wepy from &#39;wepy&#39;\nimport List from &#39;../components/list&#39;\nimport Panel from &#39;../components/panel&#39;\nimport Counter from &#39;../components/counter&#39;\nimport Group from &#39;../components/group&#39;\nimport Toast from &#39;wepy-com-toast&#39;\nimport testMixin from &#39;../mixins/test&#39;\n// 引入 QCloud 小程序增强 SDK\nimport qcloud from &#39;../assets/qcloud-weapp-client-sdk/index&#39;\nexport default class Index extends wepy.page {\n  config = {\n    navigationBarTitleText: &#39;test&#39;\n  }\n  components = {\n    panel: Panel,\n    counter1: Counter,\n    counter2: Counter,\n    list: List,\n    group: Group,\n    toast: Toast\n  }\n  mixins = [testMixin]\n\n  data = {\n    datas: &#39;&#39;,\n    mynum: 20,\n    userInfo: {\n      nickName: &#39;加载中...&#39;\n    },\n    normalTitle: &#39;原始标题&#39;,\n    setTimeoutTitle: &#39;标题三秒后会被修改&#39;,\n    count: 0,\n    netrst: &#39;&#39;,\n    groupList: [\n      {\n        id: 1,\n        name: &#39;点击改变&#39;,\n        list: [\n          {\n            childid: &#39;1.1&#39;,\n            childname: &#39;子项，点我改变&#39;\n          }, {\n            childid: &#39;1.2&#39;,\n            childname: &#39;子项，点我改变&#39;\n          }, {\n            childid: &#39;1.3&#39;,\n            childname: &#39;子项，点我改变&#39;\n          }\n        ]\n      },\n      {\n        id: 2,\n        name: &#39;点击改变&#39;,\n        list: [\n          {\n            childid: &#39;2.1&#39;,\n            childname: &#39;子项，点我改变&#39;\n          }, {\n            childid: &#39;2.2&#39;,\n            childname: &#39;子项，点我改变&#39;\n          }, {\n            childid: &#39;2.3&#39;,\n            childname: &#39;子项，点我改变&#39;\n          }\n        ]\n      },\n      {\n        id: 3,\n        name: &#39;点击改变&#39;,\n        list: [\n          {\n            childid: &#39;3.1&#39;,\n            childname: &#39;子项，点我改变&#39;\n          }\n        ]\n      }\n    ]\n  }\n\n  computed = {\n    now() {\n      return +new Date()\n    }\n  }\n\n  methods = {\n    doLogin() {\n      qcloud.setLoginUrl(&#39;https://66280981.qcloud.la/api/user/login&#39;);\n      qcloud.login({\n        success: function (userInfo) {\n          console.log(&#39;登录成功&#39;, userInfo);\n        },\n        fail: function (err) {\n          console.log(&#39;登录失败&#39;, err);\n        }\n      });\n    },\n    enevts() {\n       qcloud.request({\n        url: `https://66280981.qcloud.la/api/user/info`,\n        login: true,\n        success: (response) =&gt; {\n          console.log(response.data.data.userInfo)\n          // this.me = response.data.data.userInfo;\n          // this.connect();\n        }\n      });\n    },\n    plus() {\n      this.mynum++\n    },\n    toast() {\n      let promise = this.$invoke(&#39;toast&#39;, &#39;show&#39;, {\n        title: &#39;自定义标题&#39;,\n        img: &#39;https://raw.githubusercontent.com/kiinlam/wetoast/master/images/star.png&#39;\n      })\n\n      promise.then((d) =&gt; {\n        console.log(&#39;toast done&#39;)\n      })\n    },\n    tap() {\n      console.log(&#39;do noting from &#39; + this.$name)\n    },\n    communicate() {\n      console.log(this.$name + &#39; tap&#39;)\n\n      this.$invoke(&#39;counter2&#39;, &#39;minus&#39;, 45, 6)\n      this.$invoke(&#39;counter1&#39;, &#39;plus&#39;, 45, 6)\n\n      this.$broadcast(&#39;index-broadcast&#39;, 1, 3, 4)\n    },\n    request() {\n      let self = this\n      let i = 10\n      let map = [&#39;MA==&#39;, &#39;MQo=&#39;, &#39;Mg==&#39;, &#39;Mw==&#39;, &#39;NA==&#39;, &#39;NQ==&#39;, &#39;Ng==&#39;, &#39;Nw==&#39;, &#39;OA==&#39;, &#39;OQ==&#39;]\n      while (i--) {\n        wepy.request({\n          url: &#39;https://www.madcoder.cn/tests/sleep.php?time=1&amp;t=css&amp;c=&#39; + map[i] + &#39;&amp;i=&#39; + i,\n          success: function (d) {\n            self.netrst += d.data + &#39;.&#39;\n            self.$apply()\n          }\n        })\n      }\n    },\n    counterEmit(...args) {\n      let $event = args[args.length - 1]\n      console.log(`${this.$name} receive ${$event.name} from ${$event.source.$name}`)\n    }\n  }\n\n  events = {\n    &#39;index-emit&#39;: (...args) =&gt; {\n      let $event = args[args.length - 1]\n      console.log(`${this.$name} receive ${$event.name} from ${$event.source.$name}`)\n    }\n  }\n\n  onLoad() {\n    let self = this\n    this.$parent.getUserInfo(function (userInfo) {\n      if (userInfo) {\n        self.userInfo = userInfo\n      }\n      self.normalTitle = &#39;标题已被修改&#39;\n\n      self.setTimeoutTitle = &#39;标题三秒后会被修改&#39;\n      setTimeout(() =&gt; {\n        self.setTimeoutTitle = &#39;到三秒了&#39;\n        self.$apply()\n      }, 3000)\n\n      self.$apply()\n    })\n  }\n}\nscript&gt;</code></pre>","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h2 id=\"1-node-的安装\"><a href=\"#1-node-的安装\" class=\"headerlink\" title=\"1.node 的安装\"></a>1.node 的安装</h2><p><a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">节点网官</a>下载<br><img src=\"http://img.blog.csdn.net/20170602210731167?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcmVzX21pbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"节点官网截取\"></p>\n<p>推荐左边的安装方式，因为右边的最新版本在有些电脑上运行不稳定。</p>\n<p>下载到本地一直继续就好。</p>\n<p>安装好后就可以直接在命令行运行查看结果</p>\n<p><img src=\"http://img.blog.csdn.net/20170602211312287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcmVzX21pbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2 id=\"2-快速入门\"><a href=\"#2-快速入门\" class=\"headerlink\" title=\"2.快速入门\"></a>2.快速入门</h2><blockquote>\n<p>WePY 是一款让小程序支持组件化开发的框架，通过预编译的手段让开发者可以选择自己喜欢的开发风格去开发小程序。框架的细节优化，无极，异步功能的引入都是为了能让开发小程序项目变得更加简单，高效。</p>\n<p>同时 WePY 也是一款成长中的框架，大量吸收借鉴了一些优化前端工具以及框架的设计理念和思想。如果 WePY 有不足地方，或者你有更好的想法，欢迎提交发行或者 PR。</p>\n</blockquote>\n<p><strong>安装（更新）wepy 命令行工具。</strong></p>\n<pre><code>npm install wepy-cli -g</code></pre><p><strong>在开发目录生成开发 DEMO。</strong></p>\n<pre><code>wepy new demo</code></pre><p><strong>切换至项目目录。</strong></p>\n<pre><code>cd demo</code></pre><p><strong>打开目录</strong><br>窗口</p>\n<pre><code> dir</code></pre><p><strong>项目目录结构</strong></p>\n<pre><code>├── dist                   微信开发者工具指定的目录\n├── node_modules\n├── src                    代码编写的目录\n|   ├── components         组件文件夹（非完整页面）\n|   |   ├── com_a.wpy      可复用组件 a\n|   |   └── com_b.wpy      可复用组件 b\n|   ├── pages              页面文件夹（完整页面）\n|   |   ├── index.wpy      页面 index\n|   |   └── page.wpy       页面 page\n|   └── app.wpy            小程序配置项（全局样式配置、声明钩子等）\n└── package.json           package 配置</code></pre><p><strong>开发使用说明</strong></p>\n<ol>\n<li>使用<code>微信开发者工具</code>新建项目，开发本地选择<code>dist</code>目录。</li>\n<li><code>微信开发者工具</code> - &gt;项目 - &gt;关闭 ES6 转 ES5。</li>\n<li>本地项目根目录运行<code>wepy build --watch</code>，开启实时编译。</li>\n</ol>\n<p><strong>代码高亮</strong></p>\n<blockquote>\n<p>VScode 下代码高亮</p>\n</blockquote>\n<p><strong>先下载</strong></p>\n<p><img src=\"http://img.blog.csdn.net/20170602212828288?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcmVzX21pbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<blockquote>\n<p>配置展示进入设置<br>在 settings.js 文件下添加如下代码</p>\n</blockquote>\n<pre><code>&quot;files.associations&quot;: {\n        &quot;*.vue&quot;: &quot;vue&quot;,\n        &quot;*.wpy&quot;: &quot;vue&quot;,\n        &quot;*.wxml&quot;: &quot;html&quot;,\n        &quot;*.wxss&quot;: &quot;css&quot;\n    },\n    &quot;emmet.syntaxProfiles&quot;: {\n        &quot;vue-html&quot;: &quot;html&quot;,\n        &quot;vue&quot;: &quot;html&quot;\n    }</code></pre><p>后就保存在可以中页面看待<code>.wpy</code>后缀代码高亮</p>\n<blockquote>\n<p>Sublime 下载码高亮<br>文件后缀为.wpy，可共用 vue 高亮，但需要手动安装。<br>打开 Sublime-&gt; Preferences-&gt; Browse Packages ..进入用户包文件夹。<br>在此文件夹下打开 cmd，运行 git clone <a href=\"mailto:git@github.com\">git@github.com</a>：vuejs / VUE -句法- highlight.git，无 GIT 用户可以直接下载拉链包解压至当前文件夹。<br>关闭.wpy 文件重新打开即可高亮。</p>\n<p>WebStorm 下代码高亮<br>打开首选项，搜索插件，搜索 Vue.js 插件并安装。<br>打开首选项，搜索文件类型，找到 Vue.js 模板，在注册模式添加* .wpy，即可高亮。</p>\n<p>Atom 下代码高亮<br>在 Atom 里先安装 vue 的语法高亮 - language-vue，如果装过了就忽略这一步。<br>打开 Atom - &gt;配置菜单。在 core 键下添加：</p>\n</blockquote>\n<pre><code>customFileTypes:\n   &quot;text.html.vue&quot;: [\n      &quot;wpy&quot;\n   ]</code></pre><h2 id=\"3，代码规范\"><a href=\"#3，代码规范\" class=\"headerlink\" title=\"3，代码规范\"></a>3，代码规范</h2><ol>\n<li>变量与方法使用尽量使用驼峰式命名，避免使用$开头。</li>\n<li>入口，页面，组件的命名后缀为.wpy。外链的文件可以是其它后缀。</li>\n<li>使用 ES6 语法开发。框架在 ES6 下开发，因此也需要使用 ES6 开发小程序，ES6 中有大量的语法糖可以让我们的代码更加简洁高效。</li>\n<li>甚至可以直接使用异步/等待等新特性进行开发。</li>\n<li>事件绑定语法使用优化语法代替：原 bindtap =“click”替换为@ tap =“click”，原 catchtap =“click”替换为@ tap.stop =“click”。更多@符用法</li>\n<li>事件传参使用优化后语法代替：原 bindtap =“click”data-index = { {index}}替换为@ tap =“click（{ {index}}）”。</li>\n<li>自定义组件命名应避开微信原生组件以及功能标签。不可以使用输入，按钮，查看，重复等命名自定义组件。</li>\n</ol>\n<h2 id=\"4-优点\"><a href=\"#4-优点\" class=\"headerlink\" title=\"4.优点\"></a>4.优点</h2><ol>\n<li>支持组件化开发。</li>\n<li>支持加载外部 NPM 包。</li>\n<li>单文件模式，使得目录结构更加清晰。</li>\n<li>默认使用巴别编译，支持 ES6 / 7 的一些新特性。</li>\n<li>针对原生 API 进行优化。</li>\n</ol>\n<h2 id=\"5-wpy-文件说明\"><a href=\"#5-wpy-文件说明\" class=\"headerlink\" title=\"5.wpy 文件说明\"></a>5.wpy 文件说明</h2><p>一个<code>.wpy</code>文件分为三个部分：<br>1 .样式对应原有 wxss。2.<br>模板对应原有 wxml。3.<br>代码对应原有 js。</p>\n<p>其中入口文件 app.wpy 不需要模板，所以编译时会被忽略。这三个标签都支持郎和 SRC 属性，郎决定了其代码编译过程，SRC 决定是否外联代码，存在 SRC 属性且有效时，忽略内联代码，示例如下：</p>\n<pre><code>&lt;style lang=&quot;less&quot; src=&quot;page1.less&quot;&gt;style&gt;\n&lt;template lang=&quot;wxml&quot; src=&quot;page1.wxml&quot;&gt;template&gt;\n&lt;script&gt;\n    // some code\nscript&gt;</code></pre><p>标签对应 lang 值如下表所示：</p>\n<p>标签</p>\n<p>郎默认值</p>\n<p>郎支持值</p>\n<p>样式</p>\n<p>CSS</p>\n<p>CSS，少，上海社会科学院，手写笔</p>\n<p>模板</p>\n<p>wxml</p>\n<p>wxml，XML，哈巴狗（原玉）</p>\n<p>脚本</p>\n<p>巴布尔</p>\n<p>巴布尔，打字稿</p>\n<h2 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h2><p>index.wpy</p>\n<pre><code>&lt;style lang=&quot;less&quot;&gt;\n.userinfo {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.userinfo-avatar {\n  width: 80rpx;\n  height: 80rpx;\n  border-radius: 50%;\n}\n\n.userinfo-nickname {\n  color: #aaa;\n}\nstyle&gt;\n&lt;template&gt;\n  &lt;view class=&quot;container&quot;&gt;\n    &lt;view class=&quot;userinfo&quot; @tap=&quot;handleViewTap&quot;&gt;\n      &lt;image class=&quot;userinfo-avatar&quot; src=&quot;{ { userInfo.avatarUrl }}&quot; background-size=&quot;cover&quot; /&gt;\n      &lt;view class=&quot;userinfo-nickname&quot;&gt;{ { userInfo.nickName }}view&gt;\n    view&gt;\n    &lt;panel&gt;\n      &lt;view&gt;{ { datas }}&#39;111&#39;view&gt;\n      &lt;view @tap=&quot;doLogin&quot; class=&quot;item&quot;&gt;\n        &lt;view class=&quot;item-inner&quot;&gt;登录view&gt;\n      view&gt;\n       &lt;view @tap=&quot;enevts&quot; class=&quot;item&quot;&gt;\n        &lt;view class=&quot;item-inner&quot;&gt;用户信息view&gt;\n      view&gt;\n    panel&gt;\n    &lt;panel&gt;\n            &lt;view class=&quot;title&quot; slot=&quot;title&quot;&gt;测试数据绑定view&gt;\n            &lt;text class=&quot;info&quot;&gt;{ {normalTitle}}text&gt;\n            &lt;text class=&quot;info&quot;&gt;{ {setTimeoutTitle}}text&gt;\n            &lt;text class=&quot;info&quot;&gt;{ {mixin}}text&gt;\n            &lt;text class=&quot;info&quot;&gt;{ {mynum}}text&gt;\n            &lt;text class=&quot;info&quot;&gt;{ {now}}text&gt;\n            &lt;button @tap=&quot;plus(&#39;a&#39;)&quot; size=&quot;mini&quot;&gt; + button&gt;\n          panel&gt;\n\n          &lt;panel&gt;\n            &lt;view class=&quot;title&quot; slot=&quot;title&quot;&gt;其它测试view&gt;\n            &lt;button @tap=&quot;toast&quot; size=&quot;mini&quot;&gt;第三方组件button&gt;\n            &lt;button @tap=&quot;communicate&quot; size=&quot;mini&quot;&gt;组件通信button&gt;\n            &lt;button @tap=&quot;tap&quot; size=&quot;mini&quot;&gt;混合TAP事件button&gt;\n          panel&gt;\n\n          &lt;panel&gt;\n            &lt;view class=&quot;title&quot; slot=&quot;title&quot;&gt;测试并发网络请求view&gt;\n            &lt;view&gt;返回结果:\n              &lt;text&gt;{ {netrst}}text&gt;\n            view&gt;\n            &lt;button @tap=&quot;request&quot; size=&quot;mini&quot;&gt; 点我发起10个请求 button&gt;\n          panel&gt;\n\n          &lt;panel&gt;\n            &lt;view class=&quot;title&quot; slot=&quot;title&quot;&gt;测试组件view&gt;\n\n            &lt;text class=&quot;testcounter&quot;&gt;计数组件1: text&gt;\n            &lt;view class=&quot;counterview&quot;&gt;\n              &lt;counter1 @index-emit=&quot;counterEmit&quot; /&gt;\n            view&gt;\n\n            &lt;text class=&quot;testcounter&quot;&gt;计数组件2: text&gt;\n\n            &lt;view class=&quot;counterview&quot;&gt;\n              &lt;counter2 :num.sync=&quot;mynum&quot;&gt;counter2&gt;\n            view&gt;\n          panel&gt;\n\n          &lt;panel&gt;\n            &lt;view class=&quot;title&quot; slot=&quot;title&quot;&gt;测试组件Repeatview&gt;\n            &lt;repeat for=&quot;{ {groupList}}&quot; index=&quot;index&quot; item=&quot;item&quot; key=&quot;key&quot;&gt;\n              &lt;group :grouplist=&quot;item&quot; :indexa=&quot;index&quot;&gt;group&gt;\n            repeat&gt;\n          panel&gt;\n\n          &lt;panel&gt;\n            &lt;view class=&quot;title&quot; slot=&quot;title&quot;&gt;测试列表view&gt;\n            &lt;list&gt;list&gt;\n          panel&gt;\n\n    &lt;toast /&gt;\n  view&gt;\ntemplate&gt;\n\n&lt;script&gt;\nimport wepy from &#39;wepy&#39;\nimport List from &#39;../components/list&#39;\nimport Panel from &#39;../components/panel&#39;\nimport Counter from &#39;../components/counter&#39;\nimport Group from &#39;../components/group&#39;\nimport Toast from &#39;wepy-com-toast&#39;\nimport testMixin from &#39;../mixins/test&#39;\n// 引入 QCloud 小程序增强 SDK\nimport qcloud from &#39;../assets/qcloud-weapp-client-sdk/index&#39;\nexport default class Index extends wepy.page {\n  config = {\n    navigationBarTitleText: &#39;test&#39;\n  }\n  components = {\n    panel: Panel,\n    counter1: Counter,\n    counter2: Counter,\n    list: List,\n    group: Group,\n    toast: Toast\n  }\n  mixins = [testMixin]\n\n  data = {\n    datas: &#39;&#39;,\n    mynum: 20,\n    userInfo: {\n      nickName: &#39;加载中...&#39;\n    },\n    normalTitle: &#39;原始标题&#39;,\n    setTimeoutTitle: &#39;标题三秒后会被修改&#39;,\n    count: 0,\n    netrst: &#39;&#39;,\n    groupList: [\n      {\n        id: 1,\n        name: &#39;点击改变&#39;,\n        list: [\n          {\n            childid: &#39;1.1&#39;,\n            childname: &#39;子项，点我改变&#39;\n          }, {\n            childid: &#39;1.2&#39;,\n            childname: &#39;子项，点我改变&#39;\n          }, {\n            childid: &#39;1.3&#39;,\n            childname: &#39;子项，点我改变&#39;\n          }\n        ]\n      },\n      {\n        id: 2,\n        name: &#39;点击改变&#39;,\n        list: [\n          {\n            childid: &#39;2.1&#39;,\n            childname: &#39;子项，点我改变&#39;\n          }, {\n            childid: &#39;2.2&#39;,\n            childname: &#39;子项，点我改变&#39;\n          }, {\n            childid: &#39;2.3&#39;,\n            childname: &#39;子项，点我改变&#39;\n          }\n        ]\n      },\n      {\n        id: 3,\n        name: &#39;点击改变&#39;,\n        list: [\n          {\n            childid: &#39;3.1&#39;,\n            childname: &#39;子项，点我改变&#39;\n          }\n        ]\n      }\n    ]\n  }\n\n  computed = {\n    now() {\n      return +new Date()\n    }\n  }\n\n  methods = {\n    doLogin() {\n      qcloud.setLoginUrl(&#39;https://66280981.qcloud.la/api/user/login&#39;);\n      qcloud.login({\n        success: function (userInfo) {\n          console.log(&#39;登录成功&#39;, userInfo);\n        },\n        fail: function (err) {\n          console.log(&#39;登录失败&#39;, err);\n        }\n      });\n    },\n    enevts() {\n       qcloud.request({\n        url: `https://66280981.qcloud.la/api/user/info`,\n        login: true,\n        success: (response) =&gt; {\n          console.log(response.data.data.userInfo)\n          // this.me = response.data.data.userInfo;\n          // this.connect();\n        }\n      });\n    },\n    plus() {\n      this.mynum++\n    },\n    toast() {\n      let promise = this.$invoke(&#39;toast&#39;, &#39;show&#39;, {\n        title: &#39;自定义标题&#39;,\n        img: &#39;https://raw.githubusercontent.com/kiinlam/wetoast/master/images/star.png&#39;\n      })\n\n      promise.then((d) =&gt; {\n        console.log(&#39;toast done&#39;)\n      })\n    },\n    tap() {\n      console.log(&#39;do noting from &#39; + this.$name)\n    },\n    communicate() {\n      console.log(this.$name + &#39; tap&#39;)\n\n      this.$invoke(&#39;counter2&#39;, &#39;minus&#39;, 45, 6)\n      this.$invoke(&#39;counter1&#39;, &#39;plus&#39;, 45, 6)\n\n      this.$broadcast(&#39;index-broadcast&#39;, 1, 3, 4)\n    },\n    request() {\n      let self = this\n      let i = 10\n      let map = [&#39;MA==&#39;, &#39;MQo=&#39;, &#39;Mg==&#39;, &#39;Mw==&#39;, &#39;NA==&#39;, &#39;NQ==&#39;, &#39;Ng==&#39;, &#39;Nw==&#39;, &#39;OA==&#39;, &#39;OQ==&#39;]\n      while (i--) {\n        wepy.request({\n          url: &#39;https://www.madcoder.cn/tests/sleep.php?time=1&amp;t=css&amp;c=&#39; + map[i] + &#39;&amp;i=&#39; + i,\n          success: function (d) {\n            self.netrst += d.data + &#39;.&#39;\n            self.$apply()\n          }\n        })\n      }\n    },\n    counterEmit(...args) {\n      let $event = args[args.length - 1]\n      console.log(`${this.$name} receive ${$event.name} from ${$event.source.$name}`)\n    }\n  }\n\n  events = {\n    &#39;index-emit&#39;: (...args) =&gt; {\n      let $event = args[args.length - 1]\n      console.log(`${this.$name} receive ${$event.name} from ${$event.source.$name}`)\n    }\n  }\n\n  onLoad() {\n    let self = this\n    this.$parent.getUserInfo(function (userInfo) {\n      if (userInfo) {\n        self.userInfo = userInfo\n      }\n      self.normalTitle = &#39;标题已被修改&#39;\n\n      self.setTimeoutTitle = &#39;标题三秒后会被修改&#39;\n      setTimeout(() =&gt; {\n        self.setTimeoutTitle = &#39;到三秒了&#39;\n        self.$apply()\n      }, 3000)\n\n      self.$apply()\n    })\n  }\n}\nscript&gt;</code></pre>"},{"title":"六个月产出","date":"2018-01-27T00:23:00.000Z","_content":"\n冀小康近六个月工作报告  \n一、入职时间  \n自 2017 年 8 月 11 号入职到 2018 年 1 月 22 号共 165 天  \n二、重要产出及工作内容  \n2017 年  \n8 月：  \n点将啦 V1.0 版本上线（手机端账户管理充值提现个人中心）\n\n9 月：  \n点将啦 pc（支付宝绑定、充值结构重构，评价，个人简历，设计师入驻流程以及资金相关模块）\n\n10 月：  \n点将啦业务后台（设计师管理，财务中心）\n\n11 月：  \n设计师入驻 v2.0 版本上线（信息迁移流程，入驻，设计师个人中心，薪资比例）\n\n12 月：  \n2.建德版本上线（建德后台框架搭建，企业信息导入）\n\n2018 年  \n1 月：  \n1.点将啦 V2.1.2 和 V2.1.3 版本版本上线（作品审核，薪资详情）\n\n2017 年  \n8 月：  \n1.点将啦 WAP 版本 V1.0 版本上线  \n（1）首页-平台规则  \n（2）账户管理-立即充值，申请提现  \n（3）需求模块-发布需求，待审核需求  \n（4）个人中心模块，展示修改用户信息  \n9 月：  \n1.点将啦 Node 版本版本上线  \n（1）作品列表页-详情页  \n（2）我的设计师-评价功能  \n（3）待发工资页面，需求记录列表重构  \n2.点将啦业务后台版本版本上线  \n（1）业务后台-新增人员管理，首页设计师推荐功能调整  \n（2）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）  \n（3）超级管理-系统配置，权限配置  \n（4）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构  \n10 月：  \n1.点将啦 Node 版本和业务后台 Vue 版本上线  \n（1）雇主管理平台—交易记录—新增支付宝提现（交易状态变更）  \n（2）雇主管理平台—个人信息—新增支付宝绑绑定/修改功能  \n（3）个人设计师简历重绘分栏，个人展示栏，作品推荐栏，侧边栏  \n（4）业务后台-新增人员管理，首页设计师推荐功能调整  \n（5）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）  \n（6）超级管理-系统配置，权限配置  \n（7）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构  \n11 月：  \n1.设计师入驻 v2.0 版本上线  \n（1）设计师填写个人资料表单验证，图片上传，提交成功信息确认  \n（2）后台加盟设计师管理，信息审核及等级认证  \n（3）后台财务中心，薪资管理  \n（4）设计师个人中心-薪资模块  \n（5）设计师个人中心-提现模块  \n（6）外部（自营）设计师需求定制包月分成比例订单  \n（7）运营后台--个人信息--信息迁移一整套流程  \n12 月：  \n1.点将啦 V2.1.1 版本版本上线  \n（1）外部（自营）设计师需求定制包月分成比例订单  \n（2）运营后台--个人信息--信息迁移一整套流程  \n（3）点将啦自营设计师自定义薪资比例调整  \n（4）点将啦增加设置生效时间功能  \n（5）点将啦增加总监审核功能  \n2.建德版本上线  \n（1）建德后台框架搭建  \n（2）建德企业信息导入  \n（3）建德企业信息录入表单  \n2018 年  \n1 月：  \n1.点将啦 V2.1.2 和 V2.1.3 版本版本上线  \n（1）点将啦增加设置生效时间功能  \n（2）点将啦增加总监审核功能  \n（3）wap 端跳转问题  \n（4）后台文案修改  \n（5）前台设计师简历调整  \n（6）后台审核状态，表格新增字段  \n（7）添加薪资详情页  \n（8）点击头像跳转到对应个人中心增加设计师中心入口  \n（9）后台作品审核，状态  \n（10）后台作品列表，审核，文案字段调整  \n（11）作品审核权限设置优秀作品审核作品\n\n二、重要产出及工作内容（按月份）  \n1.点将啦 WAP 版本 V1.0 版本上线（2017 年 8 月）  \n（1）首页-平台规则  \n（2）账户管理-立即充值，申请提现  \n（3）需求模块-发布需求，待审核需求  \n（4）个人中心模块，展示修改用户信息\n\n2.点将啦 Node 版本和业务后台 Vue 版本上线（2017 年 9 月）  \n（1）作品列表页-详情页  \n（2）我的设计师-评价功能  \n（3）待发工资页面，需求记录列表重构  \n（4）业务后台-新增人员管理，首页设计师推荐功能调整  \n（5）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）  \n（6）超级管理-系统配置，权限配置  \n（7）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构\n\n3.点将啦 Node 版本和业务后台 Vue 版本上线（2017 年 10 月）  \n（1）雇主管理平台—交易记录—新增支付宝提现（交易状态变更）  \n（2）雇主管理平台—个人信息—新增支付宝绑绑定/修改功能  \n（3）个人设计师简历重绘分栏，个人展示栏，作品推荐栏，侧边栏  \n（4）业务后台-新增人员管理，首页设计师推荐功能调整  \n（5）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）  \n（6）超级管理-系统配置，权限配置  \n（7）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构\n\n4.Vue 设计师入驻 v2.0 版本上线（2017 年 11 月）  \n（1）设计师填写个人资料表单验证，图片上传，提交成功信息确认  \n（2）后台加盟设计师管理，信息审核及等级认证  \n（3）后台财务中心，薪资管理  \n（4）设计师个人中心-薪资模块  \n（5）设计师个人中心-提现模块  \n（6）外部（自营）设计师需求定制包月分成比例订单  \n（7）运营后台--个人信息--信息迁移一整套流程\n\n5.点将啦 V2.1.1 版本版本上线建德版本上线（2017 年 12 月）  \n（1）外部（自营）设计师需求定制包月分成比例订单  \n（2）运营后台--个人信息--信息迁移一整套流程  \n（3）建德后台框架搭建  \n（4）建德企业信息导入  \n（5）建德企业信息录入表单  \n（6）点将啦自营设计师自定义薪资比例调整  \n（7）点将啦增加设置生效时间功能  \n（8）点将啦增加总监审核功能  \n5.点将啦 V2.1.2 和 V2.1.3 版本版本上线（2018 年 1 月）  \n（1）点将啦增加设置生效时间功能  \n（2）点将啦增加总监审核功能  \n（3）wap 端跳转问题  \n（4）后台文案修改  \n（5）前台设计师简历调整  \n（6）后台审核状态，表格新增字段  \n（7）添加薪资详情页  \n（8）点击头像跳转到对应个人中心增加设计师中心入口  \n（9）后台作品审核，状态  \n（10）后台作品列表，审核，文案字段调整  \n（11）作品审核权限设置优秀作品审核作品\n\n三、重要产出及工作内容（详情）  \n1.2017 年 8 月 11 号至 9 月 11 号  \n点将啦 WAP 版本 V1.0 版本上线  \n所负责模块有  \n（1）首页-平台规则  \n（2）账户管理-立即充值，申请提现  \n（3）需求模块-发布需求，待审核需求  \n（4）个人中心模块，展示修改用户信息\n\n2.2017 年 9 月 11 号至 10 月 11 号  \n点将啦 Node 版本和业务后台 Vue 版本上线  \n所负责模块有  \n（1）作品列表页-详情页  \n（2）我的设计师-评价功能  \n（3）待发工资页面，需求记录列表重构  \n（4）业务后台-新增人员管理，首页设计师推荐功能调整  \n（5）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）  \n（6）超级管理-系统配置，权限配置  \n（7）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构\n\n3.2017 年 10 月 12 号至 10 月 30 号  \n点将啦 Node 版本和业务后台 Vue 版本上线  \n所负责模块有  \n（1）雇主管理平台—交易记录—新增支付宝提现（交易状态变更）  \n（2）雇主管理平台—个人信息—新增支付宝绑绑定/修改功能  \n（3）个人设计师简历重绘分栏，个人展示栏，作品推荐栏，侧边栏\n\n4.2017 年 11 月 1 号至 11 月 20 号  \nVue 设计师入驻版本上线  \n所负责模块有  \n（1）设计师填写个人资料表单验证，图片上传，提交成功信息确认  \n（2）后台加盟设计师管理，信息审核及等级认证  \n（3）后台财务中心，薪资管理  \n（4）设计师个人中心-薪资模块  \n（5）设计师个人中心-提现模块\n\n5.2017 年 11 月 27 号至 12 月 10 号  \n业务后台设计师分成比例以及设计师迁移版本上线  \n所负责模块有  \n（1）外部（自营）设计师需求定制包月分成比例订单  \n（2）运营后台--个人信息--信息迁移一整套流程\n\n6.2017 年 12 月 12 号至 12 月 20 号  \n建德企业版本上线  \n所负责模块有  \n（1）建德后台框架搭建  \n（2）建德企业信息导入  \n（3）建德企业信息录入表单\n\n7.2017 年 12 月 20 号至 12 月 27 号  \n点将啦 V2.1 版本上线  \n所负责模块有  \n（1）自营设计师自定义薪资比例调整  \n（2）增加设置生效时间功能  \n（3）增加总监审核功能\n\n8.2018 年 1 月 2 号至 1 月 7 号  \n点将啦 V2.1.1 版本版本上线  \n所负责模块有  \n（1）wap 端跳转问题  \n（2）后台文案修改  \n（3）前台设计师简历调整\n\n9.2018 年 1 月 8 号至 1 月 15 号  \n点将啦 V2.1.2 版本版本上线  \n所负责模块有  \n（1）后台审核状态，表格新增字段  \n（2）添加薪资详情页  \n（3）点击头像跳转到对应个人中心增加设计师中心入口\n\n10.2018 年 1 月 15 号至 1 月 20 号  \n点将啦 V2.1.3 版本版本上线  \n所负责模块有  \n（1）后台作品审核，状态  \n（2）后台作品列表，审核，文案字段调整  \n（3）作品审核权限设置优秀作品审核作品\n","source":"_posts/2018-01-27-六个月产出.md","raw":"---\ntitle: 六个月产出\ntags:\n  - 生活\ndate: 2018-01-27 08:23:00\ncategories: 琐碎\n---\n\n冀小康近六个月工作报告  \n一、入职时间  \n自 2017 年 8 月 11 号入职到 2018 年 1 月 22 号共 165 天  \n二、重要产出及工作内容  \n2017 年  \n8 月：  \n点将啦 V1.0 版本上线（手机端账户管理充值提现个人中心）\n\n9 月：  \n点将啦 pc（支付宝绑定、充值结构重构，评价，个人简历，设计师入驻流程以及资金相关模块）\n\n10 月：  \n点将啦业务后台（设计师管理，财务中心）\n\n11 月：  \n设计师入驻 v2.0 版本上线（信息迁移流程，入驻，设计师个人中心，薪资比例）\n\n12 月：  \n2.建德版本上线（建德后台框架搭建，企业信息导入）\n\n2018 年  \n1 月：  \n1.点将啦 V2.1.2 和 V2.1.3 版本版本上线（作品审核，薪资详情）\n\n2017 年  \n8 月：  \n1.点将啦 WAP 版本 V1.0 版本上线  \n（1）首页-平台规则  \n（2）账户管理-立即充值，申请提现  \n（3）需求模块-发布需求，待审核需求  \n（4）个人中心模块，展示修改用户信息  \n9 月：  \n1.点将啦 Node 版本版本上线  \n（1）作品列表页-详情页  \n（2）我的设计师-评价功能  \n（3）待发工资页面，需求记录列表重构  \n2.点将啦业务后台版本版本上线  \n（1）业务后台-新增人员管理，首页设计师推荐功能调整  \n（2）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）  \n（3）超级管理-系统配置，权限配置  \n（4）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构  \n10 月：  \n1.点将啦 Node 版本和业务后台 Vue 版本上线  \n（1）雇主管理平台—交易记录—新增支付宝提现（交易状态变更）  \n（2）雇主管理平台—个人信息—新增支付宝绑绑定/修改功能  \n（3）个人设计师简历重绘分栏，个人展示栏，作品推荐栏，侧边栏  \n（4）业务后台-新增人员管理，首页设计师推荐功能调整  \n（5）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）  \n（6）超级管理-系统配置，权限配置  \n（7）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构  \n11 月：  \n1.设计师入驻 v2.0 版本上线  \n（1）设计师填写个人资料表单验证，图片上传，提交成功信息确认  \n（2）后台加盟设计师管理，信息审核及等级认证  \n（3）后台财务中心，薪资管理  \n（4）设计师个人中心-薪资模块  \n（5）设计师个人中心-提现模块  \n（6）外部（自营）设计师需求定制包月分成比例订单  \n（7）运营后台--个人信息--信息迁移一整套流程  \n12 月：  \n1.点将啦 V2.1.1 版本版本上线  \n（1）外部（自营）设计师需求定制包月分成比例订单  \n（2）运营后台--个人信息--信息迁移一整套流程  \n（3）点将啦自营设计师自定义薪资比例调整  \n（4）点将啦增加设置生效时间功能  \n（5）点将啦增加总监审核功能  \n2.建德版本上线  \n（1）建德后台框架搭建  \n（2）建德企业信息导入  \n（3）建德企业信息录入表单  \n2018 年  \n1 月：  \n1.点将啦 V2.1.2 和 V2.1.3 版本版本上线  \n（1）点将啦增加设置生效时间功能  \n（2）点将啦增加总监审核功能  \n（3）wap 端跳转问题  \n（4）后台文案修改  \n（5）前台设计师简历调整  \n（6）后台审核状态，表格新增字段  \n（7）添加薪资详情页  \n（8）点击头像跳转到对应个人中心增加设计师中心入口  \n（9）后台作品审核，状态  \n（10）后台作品列表，审核，文案字段调整  \n（11）作品审核权限设置优秀作品审核作品\n\n二、重要产出及工作内容（按月份）  \n1.点将啦 WAP 版本 V1.0 版本上线（2017 年 8 月）  \n（1）首页-平台规则  \n（2）账户管理-立即充值，申请提现  \n（3）需求模块-发布需求，待审核需求  \n（4）个人中心模块，展示修改用户信息\n\n2.点将啦 Node 版本和业务后台 Vue 版本上线（2017 年 9 月）  \n（1）作品列表页-详情页  \n（2）我的设计师-评价功能  \n（3）待发工资页面，需求记录列表重构  \n（4）业务后台-新增人员管理，首页设计师推荐功能调整  \n（5）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）  \n（6）超级管理-系统配置，权限配置  \n（7）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构\n\n3.点将啦 Node 版本和业务后台 Vue 版本上线（2017 年 10 月）  \n（1）雇主管理平台—交易记录—新增支付宝提现（交易状态变更）  \n（2）雇主管理平台—个人信息—新增支付宝绑绑定/修改功能  \n（3）个人设计师简历重绘分栏，个人展示栏，作品推荐栏，侧边栏  \n（4）业务后台-新增人员管理，首页设计师推荐功能调整  \n（5）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）  \n（6）超级管理-系统配置，权限配置  \n（7）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构\n\n4.Vue 设计师入驻 v2.0 版本上线（2017 年 11 月）  \n（1）设计师填写个人资料表单验证，图片上传，提交成功信息确认  \n（2）后台加盟设计师管理，信息审核及等级认证  \n（3）后台财务中心，薪资管理  \n（4）设计师个人中心-薪资模块  \n（5）设计师个人中心-提现模块  \n（6）外部（自营）设计师需求定制包月分成比例订单  \n（7）运营后台--个人信息--信息迁移一整套流程\n\n5.点将啦 V2.1.1 版本版本上线建德版本上线（2017 年 12 月）  \n（1）外部（自营）设计师需求定制包月分成比例订单  \n（2）运营后台--个人信息--信息迁移一整套流程  \n（3）建德后台框架搭建  \n（4）建德企业信息导入  \n（5）建德企业信息录入表单  \n（6）点将啦自营设计师自定义薪资比例调整  \n（7）点将啦增加设置生效时间功能  \n（8）点将啦增加总监审核功能  \n5.点将啦 V2.1.2 和 V2.1.3 版本版本上线（2018 年 1 月）  \n（1）点将啦增加设置生效时间功能  \n（2）点将啦增加总监审核功能  \n（3）wap 端跳转问题  \n（4）后台文案修改  \n（5）前台设计师简历调整  \n（6）后台审核状态，表格新增字段  \n（7）添加薪资详情页  \n（8）点击头像跳转到对应个人中心增加设计师中心入口  \n（9）后台作品审核，状态  \n（10）后台作品列表，审核，文案字段调整  \n（11）作品审核权限设置优秀作品审核作品\n\n三、重要产出及工作内容（详情）  \n1.2017 年 8 月 11 号至 9 月 11 号  \n点将啦 WAP 版本 V1.0 版本上线  \n所负责模块有  \n（1）首页-平台规则  \n（2）账户管理-立即充值，申请提现  \n（3）需求模块-发布需求，待审核需求  \n（4）个人中心模块，展示修改用户信息\n\n2.2017 年 9 月 11 号至 10 月 11 号  \n点将啦 Node 版本和业务后台 Vue 版本上线  \n所负责模块有  \n（1）作品列表页-详情页  \n（2）我的设计师-评价功能  \n（3）待发工资页面，需求记录列表重构  \n（4）业务后台-新增人员管理，首页设计师推荐功能调整  \n（5）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）  \n（6）超级管理-系统配置，权限配置  \n（7）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构\n\n3.2017 年 10 月 12 号至 10 月 30 号  \n点将啦 Node 版本和业务后台 Vue 版本上线  \n所负责模块有  \n（1）雇主管理平台—交易记录—新增支付宝提现（交易状态变更）  \n（2）雇主管理平台—个人信息—新增支付宝绑绑定/修改功能  \n（3）个人设计师简历重绘分栏，个人展示栏，作品推荐栏，侧边栏\n\n4.2017 年 11 月 1 号至 11 月 20 号  \nVue 设计师入驻版本上线  \n所负责模块有  \n（1）设计师填写个人资料表单验证，图片上传，提交成功信息确认  \n（2）后台加盟设计师管理，信息审核及等级认证  \n（3）后台财务中心，薪资管理  \n（4）设计师个人中心-薪资模块  \n（5）设计师个人中心-提现模块\n\n5.2017 年 11 月 27 号至 12 月 10 号  \n业务后台设计师分成比例以及设计师迁移版本上线  \n所负责模块有  \n（1）外部（自营）设计师需求定制包月分成比例订单  \n（2）运营后台--个人信息--信息迁移一整套流程\n\n6.2017 年 12 月 12 号至 12 月 20 号  \n建德企业版本上线  \n所负责模块有  \n（1）建德后台框架搭建  \n（2）建德企业信息导入  \n（3）建德企业信息录入表单\n\n7.2017 年 12 月 20 号至 12 月 27 号  \n点将啦 V2.1 版本上线  \n所负责模块有  \n（1）自营设计师自定义薪资比例调整  \n（2）增加设置生效时间功能  \n（3）增加总监审核功能\n\n8.2018 年 1 月 2 号至 1 月 7 号  \n点将啦 V2.1.1 版本版本上线  \n所负责模块有  \n（1）wap 端跳转问题  \n（2）后台文案修改  \n（3）前台设计师简历调整\n\n9.2018 年 1 月 8 号至 1 月 15 号  \n点将啦 V2.1.2 版本版本上线  \n所负责模块有  \n（1）后台审核状态，表格新增字段  \n（2）添加薪资详情页  \n（3）点击头像跳转到对应个人中心增加设计师中心入口\n\n10.2018 年 1 月 15 号至 1 月 20 号  \n点将啦 V2.1.3 版本版本上线  \n所负责模块有  \n（1）后台作品审核，状态  \n（2）后台作品列表，审核，文案字段调整  \n（3）作品审核权限设置优秀作品审核作品\n","slug":"2018-01-27-六个月产出","published":1,"updated":"2020-03-14T06:50:02.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvn000514k8yh7gg783w","content":"<p>冀小康近六个月工作报告<br>一、入职时间<br>自 2017 年 8 月 11 号入职到 2018 年 1 月 22 号共 165 天<br>二、重要产出及工作内容<br>2017 年<br>8 月：<br>点将啦 V1.0 版本上线（手机端账户管理充值提现个人中心）</p>\n<p>9 月：<br>点将啦 pc（支付宝绑定、充值结构重构，评价，个人简历，设计师入驻流程以及资金相关模块）</p>\n<p>10 月：<br>点将啦业务后台（设计师管理，财务中心）</p>\n<p>11 月：<br>设计师入驻 v2.0 版本上线（信息迁移流程，入驻，设计师个人中心，薪资比例）</p>\n<p>12 月：<br>2.建德版本上线（建德后台框架搭建，企业信息导入）</p>\n<p>2018 年<br>1 月：<br>1.点将啦 V2.1.2 和 V2.1.3 版本版本上线（作品审核，薪资详情）</p>\n<p>2017 年<br>8 月：<br>1.点将啦 WAP 版本 V1.0 版本上线<br>（1）首页-平台规则<br>（2）账户管理-立即充值，申请提现<br>（3）需求模块-发布需求，待审核需求<br>（4）个人中心模块，展示修改用户信息<br>9 月：<br>1.点将啦 Node 版本版本上线<br>（1）作品列表页-详情页<br>（2）我的设计师-评价功能<br>（3）待发工资页面，需求记录列表重构<br>2.点将啦业务后台版本版本上线<br>（1）业务后台-新增人员管理，首页设计师推荐功能调整<br>（2）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）<br>（3）超级管理-系统配置，权限配置<br>（4）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构<br>10 月：<br>1.点将啦 Node 版本和业务后台 Vue 版本上线<br>（1）雇主管理平台—交易记录—新增支付宝提现（交易状态变更）<br>（2）雇主管理平台—个人信息—新增支付宝绑绑定/修改功能<br>（3）个人设计师简历重绘分栏，个人展示栏，作品推荐栏，侧边栏<br>（4）业务后台-新增人员管理，首页设计师推荐功能调整<br>（5）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）<br>（6）超级管理-系统配置，权限配置<br>（7）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构<br>11 月：<br>1.设计师入驻 v2.0 版本上线<br>（1）设计师填写个人资料表单验证，图片上传，提交成功信息确认<br>（2）后台加盟设计师管理，信息审核及等级认证<br>（3）后台财务中心，薪资管理<br>（4）设计师个人中心-薪资模块<br>（5）设计师个人中心-提现模块<br>（6）外部（自营）设计师需求定制包月分成比例订单<br>（7）运营后台–个人信息–信息迁移一整套流程<br>12 月：<br>1.点将啦 V2.1.1 版本版本上线<br>（1）外部（自营）设计师需求定制包月分成比例订单<br>（2）运营后台–个人信息–信息迁移一整套流程<br>（3）点将啦自营设计师自定义薪资比例调整<br>（4）点将啦增加设置生效时间功能<br>（5）点将啦增加总监审核功能<br>2.建德版本上线<br>（1）建德后台框架搭建<br>（2）建德企业信息导入<br>（3）建德企业信息录入表单<br>2018 年<br>1 月：<br>1.点将啦 V2.1.2 和 V2.1.3 版本版本上线<br>（1）点将啦增加设置生效时间功能<br>（2）点将啦增加总监审核功能<br>（3）wap 端跳转问题<br>（4）后台文案修改<br>（5）前台设计师简历调整<br>（6）后台审核状态，表格新增字段<br>（7）添加薪资详情页<br>（8）点击头像跳转到对应个人中心增加设计师中心入口<br>（9）后台作品审核，状态<br>（10）后台作品列表，审核，文案字段调整<br>（11）作品审核权限设置优秀作品审核作品</p>\n<p>二、重要产出及工作内容（按月份）<br>1.点将啦 WAP 版本 V1.0 版本上线（2017 年 8 月）<br>（1）首页-平台规则<br>（2）账户管理-立即充值，申请提现<br>（3）需求模块-发布需求，待审核需求<br>（4）个人中心模块，展示修改用户信息</p>\n<p>2.点将啦 Node 版本和业务后台 Vue 版本上线（2017 年 9 月）<br>（1）作品列表页-详情页<br>（2）我的设计师-评价功能<br>（3）待发工资页面，需求记录列表重构<br>（4）业务后台-新增人员管理，首页设计师推荐功能调整<br>（5）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）<br>（6）超级管理-系统配置，权限配置<br>（7）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构</p>\n<p>3.点将啦 Node 版本和业务后台 Vue 版本上线（2017 年 10 月）<br>（1）雇主管理平台—交易记录—新增支付宝提现（交易状态变更）<br>（2）雇主管理平台—个人信息—新增支付宝绑绑定/修改功能<br>（3）个人设计师简历重绘分栏，个人展示栏，作品推荐栏，侧边栏<br>（4）业务后台-新增人员管理，首页设计师推荐功能调整<br>（5）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）<br>（6）超级管理-系统配置，权限配置<br>（7）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构</p>\n<p>4.Vue 设计师入驻 v2.0 版本上线（2017 年 11 月）<br>（1）设计师填写个人资料表单验证，图片上传，提交成功信息确认<br>（2）后台加盟设计师管理，信息审核及等级认证<br>（3）后台财务中心，薪资管理<br>（4）设计师个人中心-薪资模块<br>（5）设计师个人中心-提现模块<br>（6）外部（自营）设计师需求定制包月分成比例订单<br>（7）运营后台–个人信息–信息迁移一整套流程</p>\n<p>5.点将啦 V2.1.1 版本版本上线建德版本上线（2017 年 12 月）<br>（1）外部（自营）设计师需求定制包月分成比例订单<br>（2）运营后台–个人信息–信息迁移一整套流程<br>（3）建德后台框架搭建<br>（4）建德企业信息导入<br>（5）建德企业信息录入表单<br>（6）点将啦自营设计师自定义薪资比例调整<br>（7）点将啦增加设置生效时间功能<br>（8）点将啦增加总监审核功能<br>5.点将啦 V2.1.2 和 V2.1.3 版本版本上线（2018 年 1 月）<br>（1）点将啦增加设置生效时间功能<br>（2）点将啦增加总监审核功能<br>（3）wap 端跳转问题<br>（4）后台文案修改<br>（5）前台设计师简历调整<br>（6）后台审核状态，表格新增字段<br>（7）添加薪资详情页<br>（8）点击头像跳转到对应个人中心增加设计师中心入口<br>（9）后台作品审核，状态<br>（10）后台作品列表，审核，文案字段调整<br>（11）作品审核权限设置优秀作品审核作品</p>\n<p>三、重要产出及工作内容（详情）<br>1.2017 年 8 月 11 号至 9 月 11 号<br>点将啦 WAP 版本 V1.0 版本上线<br>所负责模块有<br>（1）首页-平台规则<br>（2）账户管理-立即充值，申请提现<br>（3）需求模块-发布需求，待审核需求<br>（4）个人中心模块，展示修改用户信息</p>\n<p>2.2017 年 9 月 11 号至 10 月 11 号<br>点将啦 Node 版本和业务后台 Vue 版本上线<br>所负责模块有<br>（1）作品列表页-详情页<br>（2）我的设计师-评价功能<br>（3）待发工资页面，需求记录列表重构<br>（4）业务后台-新增人员管理，首页设计师推荐功能调整<br>（5）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）<br>（6）超级管理-系统配置，权限配置<br>（7）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构</p>\n<p>3.2017 年 10 月 12 号至 10 月 30 号<br>点将啦 Node 版本和业务后台 Vue 版本上线<br>所负责模块有<br>（1）雇主管理平台—交易记录—新增支付宝提现（交易状态变更）<br>（2）雇主管理平台—个人信息—新增支付宝绑绑定/修改功能<br>（3）个人设计师简历重绘分栏，个人展示栏，作品推荐栏，侧边栏</p>\n<p>4.2017 年 11 月 1 号至 11 月 20 号<br>Vue 设计师入驻版本上线<br>所负责模块有<br>（1）设计师填写个人资料表单验证，图片上传，提交成功信息确认<br>（2）后台加盟设计师管理，信息审核及等级认证<br>（3）后台财务中心，薪资管理<br>（4）设计师个人中心-薪资模块<br>（5）设计师个人中心-提现模块</p>\n<p>5.2017 年 11 月 27 号至 12 月 10 号<br>业务后台设计师分成比例以及设计师迁移版本上线<br>所负责模块有<br>（1）外部（自营）设计师需求定制包月分成比例订单<br>（2）运营后台–个人信息–信息迁移一整套流程</p>\n<p>6.2017 年 12 月 12 号至 12 月 20 号<br>建德企业版本上线<br>所负责模块有<br>（1）建德后台框架搭建<br>（2）建德企业信息导入<br>（3）建德企业信息录入表单</p>\n<p>7.2017 年 12 月 20 号至 12 月 27 号<br>点将啦 V2.1 版本上线<br>所负责模块有<br>（1）自营设计师自定义薪资比例调整<br>（2）增加设置生效时间功能<br>（3）增加总监审核功能</p>\n<p>8.2018 年 1 月 2 号至 1 月 7 号<br>点将啦 V2.1.1 版本版本上线<br>所负责模块有<br>（1）wap 端跳转问题<br>（2）后台文案修改<br>（3）前台设计师简历调整</p>\n<p>9.2018 年 1 月 8 号至 1 月 15 号<br>点将啦 V2.1.2 版本版本上线<br>所负责模块有<br>（1）后台审核状态，表格新增字段<br>（2）添加薪资详情页<br>（3）点击头像跳转到对应个人中心增加设计师中心入口</p>\n<p>10.2018 年 1 月 15 号至 1 月 20 号<br>点将啦 V2.1.3 版本版本上线<br>所负责模块有<br>（1）后台作品审核，状态<br>（2）后台作品列表，审核，文案字段调整<br>（3）作品审核权限设置优秀作品审核作品</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>冀小康近六个月工作报告<br>一、入职时间<br>自 2017 年 8 月 11 号入职到 2018 年 1 月 22 号共 165 天<br>二、重要产出及工作内容<br>2017 年<br>8 月：<br>点将啦 V1.0 版本上线（手机端账户管理充值提现个人中心）</p>\n<p>9 月：<br>点将啦 pc（支付宝绑定、充值结构重构，评价，个人简历，设计师入驻流程以及资金相关模块）</p>\n<p>10 月：<br>点将啦业务后台（设计师管理，财务中心）</p>\n<p>11 月：<br>设计师入驻 v2.0 版本上线（信息迁移流程，入驻，设计师个人中心，薪资比例）</p>\n<p>12 月：<br>2.建德版本上线（建德后台框架搭建，企业信息导入）</p>\n<p>2018 年<br>1 月：<br>1.点将啦 V2.1.2 和 V2.1.3 版本版本上线（作品审核，薪资详情）</p>\n<p>2017 年<br>8 月：<br>1.点将啦 WAP 版本 V1.0 版本上线<br>（1）首页-平台规则<br>（2）账户管理-立即充值，申请提现<br>（3）需求模块-发布需求，待审核需求<br>（4）个人中心模块，展示修改用户信息<br>9 月：<br>1.点将啦 Node 版本版本上线<br>（1）作品列表页-详情页<br>（2）我的设计师-评价功能<br>（3）待发工资页面，需求记录列表重构<br>2.点将啦业务后台版本版本上线<br>（1）业务后台-新增人员管理，首页设计师推荐功能调整<br>（2）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）<br>（3）超级管理-系统配置，权限配置<br>（4）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构<br>10 月：<br>1.点将啦 Node 版本和业务后台 Vue 版本上线<br>（1）雇主管理平台—交易记录—新增支付宝提现（交易状态变更）<br>（2）雇主管理平台—个人信息—新增支付宝绑绑定/修改功能<br>（3）个人设计师简历重绘分栏，个人展示栏，作品推荐栏，侧边栏<br>（4）业务后台-新增人员管理，首页设计师推荐功能调整<br>（5）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）<br>（6）超级管理-系统配置，权限配置<br>（7）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构<br>11 月：<br>1.设计师入驻 v2.0 版本上线<br>（1）设计师填写个人资料表单验证，图片上传，提交成功信息确认<br>（2）后台加盟设计师管理，信息审核及等级认证<br>（3）后台财务中心，薪资管理<br>（4）设计师个人中心-薪资模块<br>（5）设计师个人中心-提现模块<br>（6）外部（自营）设计师需求定制包月分成比例订单<br>（7）运营后台–个人信息–信息迁移一整套流程<br>12 月：<br>1.点将啦 V2.1.1 版本版本上线<br>（1）外部（自营）设计师需求定制包月分成比例订单<br>（2）运营后台–个人信息–信息迁移一整套流程<br>（3）点将啦自营设计师自定义薪资比例调整<br>（4）点将啦增加设置生效时间功能<br>（5）点将啦增加总监审核功能<br>2.建德版本上线<br>（1）建德后台框架搭建<br>（2）建德企业信息导入<br>（3）建德企业信息录入表单<br>2018 年<br>1 月：<br>1.点将啦 V2.1.2 和 V2.1.3 版本版本上线<br>（1）点将啦增加设置生效时间功能<br>（2）点将啦增加总监审核功能<br>（3）wap 端跳转问题<br>（4）后台文案修改<br>（5）前台设计师简历调整<br>（6）后台审核状态，表格新增字段<br>（7）添加薪资详情页<br>（8）点击头像跳转到对应个人中心增加设计师中心入口<br>（9）后台作品审核，状态<br>（10）后台作品列表，审核，文案字段调整<br>（11）作品审核权限设置优秀作品审核作品</p>\n<p>二、重要产出及工作内容（按月份）<br>1.点将啦 WAP 版本 V1.0 版本上线（2017 年 8 月）<br>（1）首页-平台规则<br>（2）账户管理-立即充值，申请提现<br>（3）需求模块-发布需求，待审核需求<br>（4）个人中心模块，展示修改用户信息</p>\n<p>2.点将啦 Node 版本和业务后台 Vue 版本上线（2017 年 9 月）<br>（1）作品列表页-详情页<br>（2）我的设计师-评价功能<br>（3）待发工资页面，需求记录列表重构<br>（4）业务后台-新增人员管理，首页设计师推荐功能调整<br>（5）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）<br>（6）超级管理-系统配置，权限配置<br>（7）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构</p>\n<p>3.点将啦 Node 版本和业务后台 Vue 版本上线（2017 年 10 月）<br>（1）雇主管理平台—交易记录—新增支付宝提现（交易状态变更）<br>（2）雇主管理平台—个人信息—新增支付宝绑绑定/修改功能<br>（3）个人设计师简历重绘分栏，个人展示栏，作品推荐栏，侧边栏<br>（4）业务后台-新增人员管理，首页设计师推荐功能调整<br>（5）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）<br>（6）超级管理-系统配置，权限配置<br>（7）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构</p>\n<p>4.Vue 设计师入驻 v2.0 版本上线（2017 年 11 月）<br>（1）设计师填写个人资料表单验证，图片上传，提交成功信息确认<br>（2）后台加盟设计师管理，信息审核及等级认证<br>（3）后台财务中心，薪资管理<br>（4）设计师个人中心-薪资模块<br>（5）设计师个人中心-提现模块<br>（6）外部（自营）设计师需求定制包月分成比例订单<br>（7）运营后台–个人信息–信息迁移一整套流程</p>\n<p>5.点将啦 V2.1.1 版本版本上线建德版本上线（2017 年 12 月）<br>（1）外部（自营）设计师需求定制包月分成比例订单<br>（2）运营后台–个人信息–信息迁移一整套流程<br>（3）建德后台框架搭建<br>（4）建德企业信息导入<br>（5）建德企业信息录入表单<br>（6）点将啦自营设计师自定义薪资比例调整<br>（7）点将啦增加设置生效时间功能<br>（8）点将啦增加总监审核功能<br>5.点将啦 V2.1.2 和 V2.1.3 版本版本上线（2018 年 1 月）<br>（1）点将啦增加设置生效时间功能<br>（2）点将啦增加总监审核功能<br>（3）wap 端跳转问题<br>（4）后台文案修改<br>（5）前台设计师简历调整<br>（6）后台审核状态，表格新增字段<br>（7）添加薪资详情页<br>（8）点击头像跳转到对应个人中心增加设计师中心入口<br>（9）后台作品审核，状态<br>（10）后台作品列表，审核，文案字段调整<br>（11）作品审核权限设置优秀作品审核作品</p>\n<p>三、重要产出及工作内容（详情）<br>1.2017 年 8 月 11 号至 9 月 11 号<br>点将啦 WAP 版本 V1.0 版本上线<br>所负责模块有<br>（1）首页-平台规则<br>（2）账户管理-立即充值，申请提现<br>（3）需求模块-发布需求，待审核需求<br>（4）个人中心模块，展示修改用户信息</p>\n<p>2.2017 年 9 月 11 号至 10 月 11 号<br>点将啦 Node 版本和业务后台 Vue 版本上线<br>所负责模块有<br>（1）作品列表页-详情页<br>（2）我的设计师-评价功能<br>（3）待发工资页面，需求记录列表重构<br>（4）业务后台-新增人员管理，首页设计师推荐功能调整<br>（5）业务后台-角色权限管理，充值、直接付款 增加渠道信息（微信、支付宝）<br>（6）超级管理-系统配置，权限配置<br>（7）交易记录 - 充值去支付的选择页面（加微信充值)，整个充值结构重构</p>\n<p>3.2017 年 10 月 12 号至 10 月 30 号<br>点将啦 Node 版本和业务后台 Vue 版本上线<br>所负责模块有<br>（1）雇主管理平台—交易记录—新增支付宝提现（交易状态变更）<br>（2）雇主管理平台—个人信息—新增支付宝绑绑定/修改功能<br>（3）个人设计师简历重绘分栏，个人展示栏，作品推荐栏，侧边栏</p>\n<p>4.2017 年 11 月 1 号至 11 月 20 号<br>Vue 设计师入驻版本上线<br>所负责模块有<br>（1）设计师填写个人资料表单验证，图片上传，提交成功信息确认<br>（2）后台加盟设计师管理，信息审核及等级认证<br>（3）后台财务中心，薪资管理<br>（4）设计师个人中心-薪资模块<br>（5）设计师个人中心-提现模块</p>\n<p>5.2017 年 11 月 27 号至 12 月 10 号<br>业务后台设计师分成比例以及设计师迁移版本上线<br>所负责模块有<br>（1）外部（自营）设计师需求定制包月分成比例订单<br>（2）运营后台–个人信息–信息迁移一整套流程</p>\n<p>6.2017 年 12 月 12 号至 12 月 20 号<br>建德企业版本上线<br>所负责模块有<br>（1）建德后台框架搭建<br>（2）建德企业信息导入<br>（3）建德企业信息录入表单</p>\n<p>7.2017 年 12 月 20 号至 12 月 27 号<br>点将啦 V2.1 版本上线<br>所负责模块有<br>（1）自营设计师自定义薪资比例调整<br>（2）增加设置生效时间功能<br>（3）增加总监审核功能</p>\n<p>8.2018 年 1 月 2 号至 1 月 7 号<br>点将啦 V2.1.1 版本版本上线<br>所负责模块有<br>（1）wap 端跳转问题<br>（2）后台文案修改<br>（3）前台设计师简历调整</p>\n<p>9.2018 年 1 月 8 号至 1 月 15 号<br>点将啦 V2.1.2 版本版本上线<br>所负责模块有<br>（1）后台审核状态，表格新增字段<br>（2）添加薪资详情页<br>（3）点击头像跳转到对应个人中心增加设计师中心入口</p>\n<p>10.2018 年 1 月 15 号至 1 月 20 号<br>点将啦 V2.1.3 版本版本上线<br>所负责模块有<br>（1）后台作品审核，状态<br>（2）后台作品列表，审核，文案字段调整<br>（3）作品审核权限设置优秀作品审核作品</p>\n"},{"title":"数组方法","date":"2018-02-26T03:02:00.000Z","_content":"\n## 前言：\n\n> 定义：数组是值的有序集合。 `JS`的数组是无类型的，数组元素可以是任意类型，并且同一个数组的不同元素也可能有不同的类型，每一个值叫做元素（数组元素），每个元素在数组中有一个位置。数组在平常的`coding`中是比较常用的数据格式，尤其式在解析后台数据时。之所以叫“教科书式的数组方法”，是因为每个方法我都配有示例，希望能通过示例的解析，让大家对方法能有更清晰对理解。除此之外，字符串和对象的方法也会在过两天分享，希望能对您有些许帮助，这将是我莫大的荣幸！\n\n## 一、创建数组 `x=[ ]`\n\n    var a=[\"333\",\"999\"];        // 直接写在[ ]中\n\n    var aa=new Array(4,8,9);    // 通过实例传入Array中\n\n    var aaa=new Array(5);       // 传入的5为array的个数\n\n        aaa[0]=6;               // 给aaa的第0个赋值为6\n\n    console.log(aaa);           //  [6,,,,,]\n\n    console.log(aa);            //  [4,8,9]\n\n## 二、 访问数组元素 `x.[index]`\n\n    var a=[\"333\",\"999\"];\n\n    var b=a[0];              // 访问数组的第一个元素\n\n    var c=a[a.length-1];     // 访问数组的最后一个元素\n\n    var f=a[\"1\"]===a[1];     // a[\"1\"]会自动转为数字1\n\n    console.log(f);          //  true\n\n**当然，如果我们通过以下方式去访问时，会被解析成连续运算返回最后一个值**\n\n`console.log([2,3,4,5][1,2]) // 4`\n\n**数组也是一种特殊的对象，因此我们也可以通过键值对的形式去访问**\n\n    var arr9 = [];\n\n        arr9.say = 'Hello';\n\n    console.log(arr9.say)    // Hello\n\n## 三、遍历数组 `x.forEach(function(item,index,array){})`\n\n`es6写法 forEach((item,index)=>{dosomething.....})`\n\n    var a=[\"333\",\"999\"];\n\n       a.forEach(function (item,index,array) {\n\n               console.log(item,index)\n\n     });\n           //333 0  999 1\n\n## 四、添加元素到数组的末尾 `x.push(...)`\n\n    var a=[\"333\",\"999\"];\n\n        a.push(\"我是新元素\",\"666\");\n\n    console.log(a);    //[\"333\",\"999\",\"我是新元素\",\"666\"]\n\n    console.log(a.push(\"我\",\"690\"),a.length,a);  //6,[\"333\",\"666\",\"我是新元素\",\"666\",\"我\",\"690\"]\n\n    //返回新数组长度6，会执行一次a.push\n\n## 五、在末尾删除数组(只能删除 1 个) `x.pop()`\n\n    var a=[\"333\",\"999\"];\n\n        a.pop();\n\n    console.log(a);            // [\"333\"];  返回新数组\n\n    console.log( a.pop(),a);   //333 []\n\n    //会执行一次a.pop()，返回本次被删除元素\n\n## 六、删除数组最前面元素 `x.shift()`\n\n    var a=[\"333\",\"999\"];\n\n        a.shift();\n\n    console.log(a);            //  [\"999\"]\n\n    console.log( a.shift());   //  \"999\"\n\n      //返回被删除元素，不会执行a.shift()\n\n## 七、添加到数组的前面（头部）`x.unshift(\"...\")`\n\n    var a=[\"333\",\"999\"];\n\n        a.unshift(\"000\",\"888\",\"777\");\n\n    console.log(a);\n\n    // [\"000\",\"888\",\"777\",\"333\",\"999\"]\n\n    console.log(a.unshift(\"111\"),a.length,a);\n\n    //[\"111\",\"000\",\"888\",\"777\",\"333\",\"999\"]\n\n       //会执行一次a.unshift，返回数组长度,\n\n## 八、找到某个元素在数组中的索引 `indexOf`\n\n    var a=[\"333\",\"999\"];\n\n    var d=a.indexOf(\"333\");   // 通过元素查找在当前数组的索引值\n\n    console.log(d);           // 0\n\n    var e=a.indexOf(\"654\");   // 如果查不到返回-1\n\n    console.log(e);           // -1\n\n## 九、复制数组 `slice()` , `Array.from()` \\[...\\]\n\n    var a=[1,2,8];\n\n    var newArray=a.slice();\n\n    console.log(newArray);   //第一种方法  [1,2,8]\n\n    -----------------------------------\n\n    var newArray2=Array.from(a);\n\n    console.log(newArray2);  //第二种方法 [1,2,8]\n\n    ------------------------------------\n\n    var newArray3=[...a];\n\n    console.log(newArray3);  //第三种方法 [1,2,8]\n\n## 十、清空数组\n\n    // 两种方法都可以实现，但第二种比较优雅\n\n    var arr=[1,2,3,3,4,5];\n\n        arr=[];\n\n    console.log(arr)     //  []\n\n    ------------------------------------\n\n    var arr=[888,99];\n\n        arr.length=0;\n\n    console.log(arr)     //  []\n\n## 十一、合并数组\n\n    var arr=[1];\n\n    var arr2=[2];\n\n    var arr3=[3];\n\n    var arr4=arr.concat(arr2,arr3)\n\n    console.log(arr4)     // [1,2,3]\n\n    ---------------------------------------\n    // 下面这个方法也可以实现，但只能合并两个数组\n\n    var arr1=[1,2,3];\n\n    var arr2=[4,5,6];\n\n        arr1.push.apply(arr1,arr2);\n\n    console.log(arr1);   // [1, 2, 3, 4, 5, 6]\n\n## 十二、在数组中找到最大值和最小值\n\n    //方法1\n    var array1 = [1,2,3,4];\n\n    var array2 = Math.max.apply(null,array1);  // 最大值\n\n    var array3 = Math.min.apply(null,array1);  // 最小值\n\n    console.log(array2,array3);                // 4 ,1\n\n    --------------------------------------------------\n\n    //方法2\n    var array4 =Math.max(...array1);         // 最大值\n\n    var array5 =Math.min(...array1);         // 最小值\n\n    console.log(array4,array5);              // 4 ,1\n\n## 十三、判断是不是数组\n\n    // 在javascript中，如何判断一个变量是否是数组\n\n    (1)Array.isArray()方法\n\n        var a = [0, 1, 2];\n\n        console.log(Array.isArray(a));   // true\n\n    (2)typeof  toString 方法\n\n**由于低版本的`IE`不支持`ES5`，如需要兼容，用`typeof`，我们都知道，数组是特殊的对象，所以数组的`typeof`结果也是`object`，而因为`null`的结果也是`object`，所以需要加判断是 `object`同时排除`null`、排除纯对象,先判断`a`是不是`object`,并且`a!==null`, 并且`toString.call`判断`a`等于 `[object Array]`**\n\n    var a = [0, 1, 2];\n\n    console.log( typeof a ==='object' &&  a !==null  &&  Object.prototype.toString.call(a) ==='[object Array]');   //  true\n\n## 十四、数组与其他值的运算(使用\"+\"会自动转为`string`,\"-\"会自动转为`number`)\n\n    // 数组和任何值相加都会将数组转换成字符串再进行拼接\n\n    console.log([1,2,3] + 6) ;       // \"1,2,36\"\n\n    console.log([1,2,3] + {}) ;      // \"1,2,3[object Object]\"\n\n    console.log([1,2,3] + [1,2,3])； // \"1,2,31,2,3\"\n\n    如果数组只有一个值，那么当这个数组和其他值相减相乘等时会被转换为数字，如果为空会被转换为0\n\n    console.log([5] - 2)          // 3\n\n## 十五、数组去重\n\n    // ES6新增的Set数据结构，类似于数组，但是里面的元素都是唯一的，其构造函数可以接受一个数组作为参数\n\n    let arr1=[1,2,1,2,6,3,5,69,66,7,2,1,4,3,6,8,9663,8]\n\n    let set = new Set(arr1);\n\n    console.log(set)       //  {1,2,6,3,5,69,66,7,4,8,9663,8]\n\n    // ES6中Array新增了一个静态方法from，可以把类似数组的对象转换为数组\n\n    var arr=[1,2,1,2,6,3,5,69,66,7,2,1,4,3,6,8,9663,8]\n\n    console.log(Array.from( new Set(arr)))  // {1,2,6,3,5,69,66,7,4,8,9663,8]\n\n    //函数去重：\n\n    function removeRepeatArray(arr){\n            return Array.from(new Set(arr))\n    }\n    console.log(removeRepeatArray([1,5,9,8,6,2,5,1,2,5,8,65,3,5,5,2,2,5]))\n        //  [1, 5, 9, 8, 6, 2, 65, 3]\n\n## 十六、将数组顺序打乱\n\n    function upsetArr(arr){\n        return arr.sort(function(){ return Math.random() - 0.5});\n    }\n\n> 解析：沿用原`sort`的 a-b 的方法，先生成一个随机数，然后将其与随机数进行 比较，如果 Math.random() - 0.5 是 true，则返回前者，否则比较下一个\n\n## 十七 实现将数组中数字求和，字母忽略。\n\n    var arr=[\"a\",3,4,5,9,\"d\"];\n    function sum(arr){\n        var a=0;\n        for(var i=0;iif(typeof arr[i]===\"number\"){\n                a+=arr[i]\n            }\n        }\n        return a;\n    }\n\n    sum(arr)  //21\n\n> 通过循环遍历判断数组中的每个值是否是数字，如果是的赋值到变量上进行加法计算\n\n## 十八、`delete`，`splice`删除数组内指定的某个值。\n\n> 使用`delete`删除数组内的制定索引的值后，直接改的是原数组，而且删除值的位置仍然保留，为`undefined`。\n\n    var arr=[1,2,3,45,5,2];\n\n        delete arr[0]\n\n    console.log(arr,arr[0]).   // [empty,2,3,45,5],undefined\n\n> 如果要彻底删除，可以使用`splice()`方法 `splice(开始位置，删除个数，添加的值)`，如果没有第三个值，可以只传前两个值\n\n**两个值的示例：**\n\n    var arr=[1,2,3,45,5,2];\n\n        arr.splice(0,1)\n\n    console.log(arr)    //  [2, 3, 45, 5, 2]\n\n**三个值的示例：**\n\n    var arr=[1,2,3,45,5,2];\n\n        arr.splice(0,1,100)\n\n    console.log(arr)     //  [100 ,2, 3, 45, 5, 2]\n\n## 十九、`slice()`截取数组，可选择开始位置和结束位置\n\n`slice()`接收两个参数，第一个是开始位置，第二个是结束位置\n\n    var arr=[1,2,3,45,5,2];\n\n        arr.slice(0,4)\n\n    console.log(arr). //  [1, 2, 3, 45]\n\n如果`slice()`括号中不传参数，将会全部截取\n\n    var arr=[1,2,3,45,5,2];\n\n        arr.slice()\n\n    console.log(arr).  //  [1, 2, 3, 45, 5, 2]\n\n## 二十、颠倒数组的顺序，也称数组的反转\n\n    var arr=[1,2,3,45,5,2];\n\n        arr.reverse()\n\n    console.log(arr)   // [2, 5, 45, 3, 2, 1]\n\n## 二十一、`join()`将数组以括号中的值分割成字符串(不会改变原数组)\n\n    var arr=[1,2,3,45,5,2];\n\n    console.log(arr.join(\"_”));  //  \"1_2_3_45_5_2\"\n\n    console.log(arr);   //  [1, 2, 3, 45, 5, 2]\n\n## 二十二、`sort()`排序，将数组中的值进行排序，从大到小或从小到大(会改变原本的数组)\n\n> `sort`原本的排序功能只能识别到个位数做比较，所以扩展使用以下方法：（排序方法有很多，这是最传统，也是使用频率较多的，其他的方法不再赘述）\n\n    var arr=[1,2,3,45,5,2];\n\n        arr.sort(function(a,b){\n            return a-b\n        })\n       //  [1, 2, 2, 3, 5, 45]\n\n    查看此时的arr数组：\n        console.log(arr)  //   [1, 2, 2, 3, 5, 45]\n\n        arr.sort(function(a,b){\n            return b-a\n        })\n      //  [45, 5, 3, 2, 2, 1]\n\n    查看此时的arr数组：\n        console.log(arr)  //   [45, 5, 3, 2, 2, 1]\n\n> 当然我们有时是不可以改变原数组的，那么可以试试下面的方法将需要的内容拷贝出来即可：\n\n    var arr=[1,3,6,8,45,34,90,122,9,0];\n\n    var array=arr.slice();\n\n        array.push(34)\n\n    console.log(arr，array)\n\n    // [1,3,6,8,45,34,90,122,9,0],[1,3,6,8,45,34,90,122,9,0,34]\n\n---\n\n## 数组中的迭代方法`filter()`, `every()`,`forEach()`,`map()`,`some()`\n\n`filter()`：对数组中的每一项运行给定函数，返回该函数会返回`true` 的项组成的数组。\n\n`every()`：对数组中的每一项运行给定函数，如果该函数对每一项都返回`true`，则返回`true`。\n\n`forEach()`：对数组中的每一项运行给定函数。这个方法没有返回值。\n\n`map()`：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。\n\n`some()`：对数组中的每一项运行给定函数，如果该函数对任一项返回`true`，则返回 true.\n\n## 一、数组迭代方法之`filter()`\n\n（`filter`返回的是一个符合某种条件的数组，并返回，不会更改原数组）\n\n    var arr=[1,3,6,8,45,34,90,122,9,0];\n\n    var array = arr.filter(function(element){\n\n            return element>10\n        })\n    console.log(array)\n\n    //筛选数组中大于10的值， [45, 34, 90, 122]\n\n    //查看原数组，并没有改变\n\n    console.log(arr)    //  [1,3,6,8,45,34,90,122,9,0]\n\n## 二、数组迭代方法之`every()`\n\n（主要是用于判断一个素组中的值是否符合某个标准。必须是每个值都符合才会返回`true`。否则返回`false`）\n\n    var arr = [1,2,3,4,5,4,3,2,1];\n\n    var everyResult = arr.every(function(item, index, array){\n        return (item > 2);\n    });\n\n    //判断数组中所有的值是否都大于2，如果都大于2，返回true，反之返回false.\n\n    console.log(everyResult)     //false\n\n## 三、数组迭代方法之`forEach()`\n\n（数组的循环遍历,对数组中的每一项运行给定函数。这个方法没有返回值。)\n\n    var arr=[1,3,6,8,45,34,90,122,9,0];\n\n        arr.forEach(function(item,index,array){\n            console.log(item,index,array)\n        })\n    /*\n     0 1 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     1 3 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     2 6 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     3 8 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     4 45 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     5 34 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     6 90 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     7 122 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     8 9 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     9 0 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n    */\n\n## 四、数组迭代方法之`map()`\n\n（数组的循环遍历,对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。)\n\n    var arr=[1,3,6,8,45,34,90,122,9,0];\n\n        arr.map(function(item,index,array){\n            console.log(index,item,array)\n        })\n     /*\n     0 1 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     1 3 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     2 6 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     3 8 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     4 45 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     5 34 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     6 90 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     7 122 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     8 9 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     9 0 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     */\n\n## 五、数组迭代方法之`some()`\n\n(对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true)\n\n    var numbers = [1,2,3,4,5,4,3,2,1];\n\n    var someResult = numbers.some(function(item, index, array){\n        return (item > 2);\n    });\n\n    //只要有一个返回true，则返回true\n\n    console.log(someResult); // true\n\n## **归并：迭代数组中的所有值，返回一个按条件计算的最终值。**\n\n**reduce:**\n\n    var values = [1,2,3,4,5];\n\n    var sum = reduce(function(prev, cur, index, array){\n        return prev + cur;\n    });\n\n    //第一次执行回调函数，prev 是1，cur 是2。第二次，prev 是3（1 加2 的结果），cur 是3（数组的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。\n    //通过循环遍历，返回数组中所有值的总和  15\n\n**reduceRight:**\n\n    var values = [1,2,3,4,5];\n\n    var sum = reduceRight(function(prev, cur, index, array){\n        return prev + cur;\n    });\n\n    //第一次执行回调函数，prev 是5，cur 是4。第二次，prev 是9（5加4 的结果），cur 是3（数组的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。\n    //通过循环遍历，返回数组中所有值的总和  15\n","source":"_posts/2018-02-26-数组方法.md","raw":"---\ntitle: 数组方法\ntags:\n  - 技术\ndate: 2018-02-26 11:02:00\ncategories: 前端\n---\n\n## 前言：\n\n> 定义：数组是值的有序集合。 `JS`的数组是无类型的，数组元素可以是任意类型，并且同一个数组的不同元素也可能有不同的类型，每一个值叫做元素（数组元素），每个元素在数组中有一个位置。数组在平常的`coding`中是比较常用的数据格式，尤其式在解析后台数据时。之所以叫“教科书式的数组方法”，是因为每个方法我都配有示例，希望能通过示例的解析，让大家对方法能有更清晰对理解。除此之外，字符串和对象的方法也会在过两天分享，希望能对您有些许帮助，这将是我莫大的荣幸！\n\n## 一、创建数组 `x=[ ]`\n\n    var a=[\"333\",\"999\"];        // 直接写在[ ]中\n\n    var aa=new Array(4,8,9);    // 通过实例传入Array中\n\n    var aaa=new Array(5);       // 传入的5为array的个数\n\n        aaa[0]=6;               // 给aaa的第0个赋值为6\n\n    console.log(aaa);           //  [6,,,,,]\n\n    console.log(aa);            //  [4,8,9]\n\n## 二、 访问数组元素 `x.[index]`\n\n    var a=[\"333\",\"999\"];\n\n    var b=a[0];              // 访问数组的第一个元素\n\n    var c=a[a.length-1];     // 访问数组的最后一个元素\n\n    var f=a[\"1\"]===a[1];     // a[\"1\"]会自动转为数字1\n\n    console.log(f);          //  true\n\n**当然，如果我们通过以下方式去访问时，会被解析成连续运算返回最后一个值**\n\n`console.log([2,3,4,5][1,2]) // 4`\n\n**数组也是一种特殊的对象，因此我们也可以通过键值对的形式去访问**\n\n    var arr9 = [];\n\n        arr9.say = 'Hello';\n\n    console.log(arr9.say)    // Hello\n\n## 三、遍历数组 `x.forEach(function(item,index,array){})`\n\n`es6写法 forEach((item,index)=>{dosomething.....})`\n\n    var a=[\"333\",\"999\"];\n\n       a.forEach(function (item,index,array) {\n\n               console.log(item,index)\n\n     });\n           //333 0  999 1\n\n## 四、添加元素到数组的末尾 `x.push(...)`\n\n    var a=[\"333\",\"999\"];\n\n        a.push(\"我是新元素\",\"666\");\n\n    console.log(a);    //[\"333\",\"999\",\"我是新元素\",\"666\"]\n\n    console.log(a.push(\"我\",\"690\"),a.length,a);  //6,[\"333\",\"666\",\"我是新元素\",\"666\",\"我\",\"690\"]\n\n    //返回新数组长度6，会执行一次a.push\n\n## 五、在末尾删除数组(只能删除 1 个) `x.pop()`\n\n    var a=[\"333\",\"999\"];\n\n        a.pop();\n\n    console.log(a);            // [\"333\"];  返回新数组\n\n    console.log( a.pop(),a);   //333 []\n\n    //会执行一次a.pop()，返回本次被删除元素\n\n## 六、删除数组最前面元素 `x.shift()`\n\n    var a=[\"333\",\"999\"];\n\n        a.shift();\n\n    console.log(a);            //  [\"999\"]\n\n    console.log( a.shift());   //  \"999\"\n\n      //返回被删除元素，不会执行a.shift()\n\n## 七、添加到数组的前面（头部）`x.unshift(\"...\")`\n\n    var a=[\"333\",\"999\"];\n\n        a.unshift(\"000\",\"888\",\"777\");\n\n    console.log(a);\n\n    // [\"000\",\"888\",\"777\",\"333\",\"999\"]\n\n    console.log(a.unshift(\"111\"),a.length,a);\n\n    //[\"111\",\"000\",\"888\",\"777\",\"333\",\"999\"]\n\n       //会执行一次a.unshift，返回数组长度,\n\n## 八、找到某个元素在数组中的索引 `indexOf`\n\n    var a=[\"333\",\"999\"];\n\n    var d=a.indexOf(\"333\");   // 通过元素查找在当前数组的索引值\n\n    console.log(d);           // 0\n\n    var e=a.indexOf(\"654\");   // 如果查不到返回-1\n\n    console.log(e);           // -1\n\n## 九、复制数组 `slice()` , `Array.from()` \\[...\\]\n\n    var a=[1,2,8];\n\n    var newArray=a.slice();\n\n    console.log(newArray);   //第一种方法  [1,2,8]\n\n    -----------------------------------\n\n    var newArray2=Array.from(a);\n\n    console.log(newArray2);  //第二种方法 [1,2,8]\n\n    ------------------------------------\n\n    var newArray3=[...a];\n\n    console.log(newArray3);  //第三种方法 [1,2,8]\n\n## 十、清空数组\n\n    // 两种方法都可以实现，但第二种比较优雅\n\n    var arr=[1,2,3,3,4,5];\n\n        arr=[];\n\n    console.log(arr)     //  []\n\n    ------------------------------------\n\n    var arr=[888,99];\n\n        arr.length=0;\n\n    console.log(arr)     //  []\n\n## 十一、合并数组\n\n    var arr=[1];\n\n    var arr2=[2];\n\n    var arr3=[3];\n\n    var arr4=arr.concat(arr2,arr3)\n\n    console.log(arr4)     // [1,2,3]\n\n    ---------------------------------------\n    // 下面这个方法也可以实现，但只能合并两个数组\n\n    var arr1=[1,2,3];\n\n    var arr2=[4,5,6];\n\n        arr1.push.apply(arr1,arr2);\n\n    console.log(arr1);   // [1, 2, 3, 4, 5, 6]\n\n## 十二、在数组中找到最大值和最小值\n\n    //方法1\n    var array1 = [1,2,3,4];\n\n    var array2 = Math.max.apply(null,array1);  // 最大值\n\n    var array3 = Math.min.apply(null,array1);  // 最小值\n\n    console.log(array2,array3);                // 4 ,1\n\n    --------------------------------------------------\n\n    //方法2\n    var array4 =Math.max(...array1);         // 最大值\n\n    var array5 =Math.min(...array1);         // 最小值\n\n    console.log(array4,array5);              // 4 ,1\n\n## 十三、判断是不是数组\n\n    // 在javascript中，如何判断一个变量是否是数组\n\n    (1)Array.isArray()方法\n\n        var a = [0, 1, 2];\n\n        console.log(Array.isArray(a));   // true\n\n    (2)typeof  toString 方法\n\n**由于低版本的`IE`不支持`ES5`，如需要兼容，用`typeof`，我们都知道，数组是特殊的对象，所以数组的`typeof`结果也是`object`，而因为`null`的结果也是`object`，所以需要加判断是 `object`同时排除`null`、排除纯对象,先判断`a`是不是`object`,并且`a!==null`, 并且`toString.call`判断`a`等于 `[object Array]`**\n\n    var a = [0, 1, 2];\n\n    console.log( typeof a ==='object' &&  a !==null  &&  Object.prototype.toString.call(a) ==='[object Array]');   //  true\n\n## 十四、数组与其他值的运算(使用\"+\"会自动转为`string`,\"-\"会自动转为`number`)\n\n    // 数组和任何值相加都会将数组转换成字符串再进行拼接\n\n    console.log([1,2,3] + 6) ;       // \"1,2,36\"\n\n    console.log([1,2,3] + {}) ;      // \"1,2,3[object Object]\"\n\n    console.log([1,2,3] + [1,2,3])； // \"1,2,31,2,3\"\n\n    如果数组只有一个值，那么当这个数组和其他值相减相乘等时会被转换为数字，如果为空会被转换为0\n\n    console.log([5] - 2)          // 3\n\n## 十五、数组去重\n\n    // ES6新增的Set数据结构，类似于数组，但是里面的元素都是唯一的，其构造函数可以接受一个数组作为参数\n\n    let arr1=[1,2,1,2,6,3,5,69,66,7,2,1,4,3,6,8,9663,8]\n\n    let set = new Set(arr1);\n\n    console.log(set)       //  {1,2,6,3,5,69,66,7,4,8,9663,8]\n\n    // ES6中Array新增了一个静态方法from，可以把类似数组的对象转换为数组\n\n    var arr=[1,2,1,2,6,3,5,69,66,7,2,1,4,3,6,8,9663,8]\n\n    console.log(Array.from( new Set(arr)))  // {1,2,6,3,5,69,66,7,4,8,9663,8]\n\n    //函数去重：\n\n    function removeRepeatArray(arr){\n            return Array.from(new Set(arr))\n    }\n    console.log(removeRepeatArray([1,5,9,8,6,2,5,1,2,5,8,65,3,5,5,2,2,5]))\n        //  [1, 5, 9, 8, 6, 2, 65, 3]\n\n## 十六、将数组顺序打乱\n\n    function upsetArr(arr){\n        return arr.sort(function(){ return Math.random() - 0.5});\n    }\n\n> 解析：沿用原`sort`的 a-b 的方法，先生成一个随机数，然后将其与随机数进行 比较，如果 Math.random() - 0.5 是 true，则返回前者，否则比较下一个\n\n## 十七 实现将数组中数字求和，字母忽略。\n\n    var arr=[\"a\",3,4,5,9,\"d\"];\n    function sum(arr){\n        var a=0;\n        for(var i=0;iif(typeof arr[i]===\"number\"){\n                a+=arr[i]\n            }\n        }\n        return a;\n    }\n\n    sum(arr)  //21\n\n> 通过循环遍历判断数组中的每个值是否是数字，如果是的赋值到变量上进行加法计算\n\n## 十八、`delete`，`splice`删除数组内指定的某个值。\n\n> 使用`delete`删除数组内的制定索引的值后，直接改的是原数组，而且删除值的位置仍然保留，为`undefined`。\n\n    var arr=[1,2,3,45,5,2];\n\n        delete arr[0]\n\n    console.log(arr,arr[0]).   // [empty,2,3,45,5],undefined\n\n> 如果要彻底删除，可以使用`splice()`方法 `splice(开始位置，删除个数，添加的值)`，如果没有第三个值，可以只传前两个值\n\n**两个值的示例：**\n\n    var arr=[1,2,3,45,5,2];\n\n        arr.splice(0,1)\n\n    console.log(arr)    //  [2, 3, 45, 5, 2]\n\n**三个值的示例：**\n\n    var arr=[1,2,3,45,5,2];\n\n        arr.splice(0,1,100)\n\n    console.log(arr)     //  [100 ,2, 3, 45, 5, 2]\n\n## 十九、`slice()`截取数组，可选择开始位置和结束位置\n\n`slice()`接收两个参数，第一个是开始位置，第二个是结束位置\n\n    var arr=[1,2,3,45,5,2];\n\n        arr.slice(0,4)\n\n    console.log(arr). //  [1, 2, 3, 45]\n\n如果`slice()`括号中不传参数，将会全部截取\n\n    var arr=[1,2,3,45,5,2];\n\n        arr.slice()\n\n    console.log(arr).  //  [1, 2, 3, 45, 5, 2]\n\n## 二十、颠倒数组的顺序，也称数组的反转\n\n    var arr=[1,2,3,45,5,2];\n\n        arr.reverse()\n\n    console.log(arr)   // [2, 5, 45, 3, 2, 1]\n\n## 二十一、`join()`将数组以括号中的值分割成字符串(不会改变原数组)\n\n    var arr=[1,2,3,45,5,2];\n\n    console.log(arr.join(\"_”));  //  \"1_2_3_45_5_2\"\n\n    console.log(arr);   //  [1, 2, 3, 45, 5, 2]\n\n## 二十二、`sort()`排序，将数组中的值进行排序，从大到小或从小到大(会改变原本的数组)\n\n> `sort`原本的排序功能只能识别到个位数做比较，所以扩展使用以下方法：（排序方法有很多，这是最传统，也是使用频率较多的，其他的方法不再赘述）\n\n    var arr=[1,2,3,45,5,2];\n\n        arr.sort(function(a,b){\n            return a-b\n        })\n       //  [1, 2, 2, 3, 5, 45]\n\n    查看此时的arr数组：\n        console.log(arr)  //   [1, 2, 2, 3, 5, 45]\n\n        arr.sort(function(a,b){\n            return b-a\n        })\n      //  [45, 5, 3, 2, 2, 1]\n\n    查看此时的arr数组：\n        console.log(arr)  //   [45, 5, 3, 2, 2, 1]\n\n> 当然我们有时是不可以改变原数组的，那么可以试试下面的方法将需要的内容拷贝出来即可：\n\n    var arr=[1,3,6,8,45,34,90,122,9,0];\n\n    var array=arr.slice();\n\n        array.push(34)\n\n    console.log(arr，array)\n\n    // [1,3,6,8,45,34,90,122,9,0],[1,3,6,8,45,34,90,122,9,0,34]\n\n---\n\n## 数组中的迭代方法`filter()`, `every()`,`forEach()`,`map()`,`some()`\n\n`filter()`：对数组中的每一项运行给定函数，返回该函数会返回`true` 的项组成的数组。\n\n`every()`：对数组中的每一项运行给定函数，如果该函数对每一项都返回`true`，则返回`true`。\n\n`forEach()`：对数组中的每一项运行给定函数。这个方法没有返回值。\n\n`map()`：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。\n\n`some()`：对数组中的每一项运行给定函数，如果该函数对任一项返回`true`，则返回 true.\n\n## 一、数组迭代方法之`filter()`\n\n（`filter`返回的是一个符合某种条件的数组，并返回，不会更改原数组）\n\n    var arr=[1,3,6,8,45,34,90,122,9,0];\n\n    var array = arr.filter(function(element){\n\n            return element>10\n        })\n    console.log(array)\n\n    //筛选数组中大于10的值， [45, 34, 90, 122]\n\n    //查看原数组，并没有改变\n\n    console.log(arr)    //  [1,3,6,8,45,34,90,122,9,0]\n\n## 二、数组迭代方法之`every()`\n\n（主要是用于判断一个素组中的值是否符合某个标准。必须是每个值都符合才会返回`true`。否则返回`false`）\n\n    var arr = [1,2,3,4,5,4,3,2,1];\n\n    var everyResult = arr.every(function(item, index, array){\n        return (item > 2);\n    });\n\n    //判断数组中所有的值是否都大于2，如果都大于2，返回true，反之返回false.\n\n    console.log(everyResult)     //false\n\n## 三、数组迭代方法之`forEach()`\n\n（数组的循环遍历,对数组中的每一项运行给定函数。这个方法没有返回值。)\n\n    var arr=[1,3,6,8,45,34,90,122,9,0];\n\n        arr.forEach(function(item,index,array){\n            console.log(item,index,array)\n        })\n    /*\n     0 1 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     1 3 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     2 6 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     3 8 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     4 45 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     5 34 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     6 90 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     7 122 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     8 9 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     9 0 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n    */\n\n## 四、数组迭代方法之`map()`\n\n（数组的循环遍历,对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。)\n\n    var arr=[1,3,6,8,45,34,90,122,9,0];\n\n        arr.map(function(item,index,array){\n            console.log(index,item,array)\n        })\n     /*\n     0 1 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     1 3 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     2 6 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     3 8 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     4 45 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     5 34 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     6 90 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     7 122 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     8 9 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     9 0 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n     */\n\n## 五、数组迭代方法之`some()`\n\n(对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true)\n\n    var numbers = [1,2,3,4,5,4,3,2,1];\n\n    var someResult = numbers.some(function(item, index, array){\n        return (item > 2);\n    });\n\n    //只要有一个返回true，则返回true\n\n    console.log(someResult); // true\n\n## **归并：迭代数组中的所有值，返回一个按条件计算的最终值。**\n\n**reduce:**\n\n    var values = [1,2,3,4,5];\n\n    var sum = reduce(function(prev, cur, index, array){\n        return prev + cur;\n    });\n\n    //第一次执行回调函数，prev 是1，cur 是2。第二次，prev 是3（1 加2 的结果），cur 是3（数组的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。\n    //通过循环遍历，返回数组中所有值的总和  15\n\n**reduceRight:**\n\n    var values = [1,2,3,4,5];\n\n    var sum = reduceRight(function(prev, cur, index, array){\n        return prev + cur;\n    });\n\n    //第一次执行回调函数，prev 是5，cur 是4。第二次，prev 是9（5加4 的结果），cur 是3（数组的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。\n    //通过循环遍历，返回数组中所有值的总和  15\n","slug":"2018-02-26-数组方法","published":1,"updated":"2020-03-14T06:50:22.132Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvn100544k8ygwmc1d18","content":"<h2 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h2><blockquote>\n<p>定义：数组是值的有序集合。 <code>JS</code>的数组是无类型的，数组元素可以是任意类型，并且同一个数组的不同元素也可能有不同的类型，每一个值叫做元素（数组元素），每个元素在数组中有一个位置。数组在平常的<code>coding</code>中是比较常用的数据格式，尤其式在解析后台数据时。之所以叫“教科书式的数组方法”，是因为每个方法我都配有示例，希望能通过示例的解析，让大家对方法能有更清晰对理解。除此之外，字符串和对象的方法也会在过两天分享，希望能对您有些许帮助，这将是我莫大的荣幸！</p>\n</blockquote>\n<h2 id=\"一、创建数组-x\"><a href=\"#一、创建数组-x\" class=\"headerlink\" title=\"一、创建数组 x=[ ]\"></a>一、创建数组 <code>x=[ ]</code></h2><pre><code>var a=[&quot;333&quot;,&quot;999&quot;];        // 直接写在[ ]中\n\nvar aa=new Array(4,8,9);    // 通过实例传入Array中\n\nvar aaa=new Array(5);       // 传入的5为array的个数\n\n    aaa[0]=6;               // 给aaa的第0个赋值为6\n\nconsole.log(aaa);           //  [6,,,,,]\n\nconsole.log(aa);            //  [4,8,9]</code></pre><h2 id=\"二、-访问数组元素-x-index\"><a href=\"#二、-访问数组元素-x-index\" class=\"headerlink\" title=\"二、 访问数组元素 x.[index]\"></a>二、 访问数组元素 <code>x.[index]</code></h2><pre><code>var a=[&quot;333&quot;,&quot;999&quot;];\n\nvar b=a[0];              // 访问数组的第一个元素\n\nvar c=a[a.length-1];     // 访问数组的最后一个元素\n\nvar f=a[&quot;1&quot;]===a[1];     // a[&quot;1&quot;]会自动转为数字1\n\nconsole.log(f);          //  true</code></pre><p><strong>当然，如果我们通过以下方式去访问时，会被解析成连续运算返回最后一个值</strong></p>\n<p><code>console.log([2,3,4,5][1,2]) // 4</code></p>\n<p><strong>数组也是一种特殊的对象，因此我们也可以通过键值对的形式去访问</strong></p>\n<pre><code>var arr9 = [];\n\n    arr9.say = &#39;Hello&#39;;\n\nconsole.log(arr9.say)    // Hello</code></pre><h2 id=\"三、遍历数组-x-forEach-function-item-index-array\"><a href=\"#三、遍历数组-x-forEach-function-item-index-array\" class=\"headerlink\" title=\"三、遍历数组 x.forEach(function(item,index,array){})\"></a>三、遍历数组 <code>x.forEach(function(item,index,array){})</code></h2><p><code>es6写法 forEach((item,index)=&gt;{dosomething.....})</code></p>\n<pre><code>var a=[&quot;333&quot;,&quot;999&quot;];\n\n   a.forEach(function (item,index,array) {\n\n           console.log(item,index)\n\n });\n       //333 0  999 1</code></pre><h2 id=\"四、添加元素到数组的末尾-x-push\"><a href=\"#四、添加元素到数组的末尾-x-push\" class=\"headerlink\" title=\"四、添加元素到数组的末尾 x.push(...)\"></a>四、添加元素到数组的末尾 <code>x.push(...)</code></h2><pre><code>var a=[&quot;333&quot;,&quot;999&quot;];\n\n    a.push(&quot;我是新元素&quot;,&quot;666&quot;);\n\nconsole.log(a);    //[&quot;333&quot;,&quot;999&quot;,&quot;我是新元素&quot;,&quot;666&quot;]\n\nconsole.log(a.push(&quot;我&quot;,&quot;690&quot;),a.length,a);  //6,[&quot;333&quot;,&quot;666&quot;,&quot;我是新元素&quot;,&quot;666&quot;,&quot;我&quot;,&quot;690&quot;]\n\n//返回新数组长度6，会执行一次a.push</code></pre><h2 id=\"五、在末尾删除数组-只能删除-1-个-x-pop\"><a href=\"#五、在末尾删除数组-只能删除-1-个-x-pop\" class=\"headerlink\" title=\"五、在末尾删除数组(只能删除 1 个) x.pop()\"></a>五、在末尾删除数组(只能删除 1 个) <code>x.pop()</code></h2><pre><code>var a=[&quot;333&quot;,&quot;999&quot;];\n\n    a.pop();\n\nconsole.log(a);            // [&quot;333&quot;];  返回新数组\n\nconsole.log( a.pop(),a);   //333 []\n\n//会执行一次a.pop()，返回本次被删除元素</code></pre><h2 id=\"六、删除数组最前面元素-x-shift\"><a href=\"#六、删除数组最前面元素-x-shift\" class=\"headerlink\" title=\"六、删除数组最前面元素 x.shift()\"></a>六、删除数组最前面元素 <code>x.shift()</code></h2><pre><code>var a=[&quot;333&quot;,&quot;999&quot;];\n\n    a.shift();\n\nconsole.log(a);            //  [&quot;999&quot;]\n\nconsole.log( a.shift());   //  &quot;999&quot;\n\n  //返回被删除元素，不会执行a.shift()</code></pre><h2 id=\"七、添加到数组的前面（头部）x-unshift-quot-quot\"><a href=\"#七、添加到数组的前面（头部）x-unshift-quot-quot\" class=\"headerlink\" title=\"七、添加到数组的前面（头部）x.unshift(&quot;...&quot;)\"></a>七、添加到数组的前面（头部）<code>x.unshift(&quot;...&quot;)</code></h2><pre><code>var a=[&quot;333&quot;,&quot;999&quot;];\n\n    a.unshift(&quot;000&quot;,&quot;888&quot;,&quot;777&quot;);\n\nconsole.log(a);\n\n// [&quot;000&quot;,&quot;888&quot;,&quot;777&quot;,&quot;333&quot;,&quot;999&quot;]\n\nconsole.log(a.unshift(&quot;111&quot;),a.length,a);\n\n//[&quot;111&quot;,&quot;000&quot;,&quot;888&quot;,&quot;777&quot;,&quot;333&quot;,&quot;999&quot;]\n\n   //会执行一次a.unshift，返回数组长度,</code></pre><h2 id=\"八、找到某个元素在数组中的索引-indexOf\"><a href=\"#八、找到某个元素在数组中的索引-indexOf\" class=\"headerlink\" title=\"八、找到某个元素在数组中的索引 indexOf\"></a>八、找到某个元素在数组中的索引 <code>indexOf</code></h2><pre><code>var a=[&quot;333&quot;,&quot;999&quot;];\n\nvar d=a.indexOf(&quot;333&quot;);   // 通过元素查找在当前数组的索引值\n\nconsole.log(d);           // 0\n\nvar e=a.indexOf(&quot;654&quot;);   // 如果查不到返回-1\n\nconsole.log(e);           // -1</code></pre><h2 id=\"九、复制数组-slice-Array-from-…\"><a href=\"#九、复制数组-slice-Array-from-…\" class=\"headerlink\" title=\"九、复制数组 slice() , Array.from() […]\"></a>九、复制数组 <code>slice()</code> , <code>Array.from()</code> […]</h2><pre><code>var a=[1,2,8];\n\nvar newArray=a.slice();\n\nconsole.log(newArray);   //第一种方法  [1,2,8]\n\n-----------------------------------\n\nvar newArray2=Array.from(a);\n\nconsole.log(newArray2);  //第二种方法 [1,2,8]\n\n------------------------------------\n\nvar newArray3=[...a];\n\nconsole.log(newArray3);  //第三种方法 [1,2,8]</code></pre><h2 id=\"十、清空数组\"><a href=\"#十、清空数组\" class=\"headerlink\" title=\"十、清空数组\"></a>十、清空数组</h2><pre><code>// 两种方法都可以实现，但第二种比较优雅\n\nvar arr=[1,2,3,3,4,5];\n\n    arr=[];\n\nconsole.log(arr)     //  []\n\n------------------------------------\n\nvar arr=[888,99];\n\n    arr.length=0;\n\nconsole.log(arr)     //  []</code></pre><h2 id=\"十一、合并数组\"><a href=\"#十一、合并数组\" class=\"headerlink\" title=\"十一、合并数组\"></a>十一、合并数组</h2><pre><code>var arr=[1];\n\nvar arr2=[2];\n\nvar arr3=[3];\n\nvar arr4=arr.concat(arr2,arr3)\n\nconsole.log(arr4)     // [1,2,3]\n\n---------------------------------------\n// 下面这个方法也可以实现，但只能合并两个数组\n\nvar arr1=[1,2,3];\n\nvar arr2=[4,5,6];\n\n    arr1.push.apply(arr1,arr2);\n\nconsole.log(arr1);   // [1, 2, 3, 4, 5, 6]</code></pre><h2 id=\"十二、在数组中找到最大值和最小值\"><a href=\"#十二、在数组中找到最大值和最小值\" class=\"headerlink\" title=\"十二、在数组中找到最大值和最小值\"></a>十二、在数组中找到最大值和最小值</h2><pre><code>//方法1\nvar array1 = [1,2,3,4];\n\nvar array2 = Math.max.apply(null,array1);  // 最大值\n\nvar array3 = Math.min.apply(null,array1);  // 最小值\n\nconsole.log(array2,array3);                // 4 ,1\n\n--------------------------------------------------\n\n//方法2\nvar array4 =Math.max(...array1);         // 最大值\n\nvar array5 =Math.min(...array1);         // 最小值\n\nconsole.log(array4,array5);              // 4 ,1</code></pre><h2 id=\"十三、判断是不是数组\"><a href=\"#十三、判断是不是数组\" class=\"headerlink\" title=\"十三、判断是不是数组\"></a>十三、判断是不是数组</h2><pre><code>// 在javascript中，如何判断一个变量是否是数组\n\n(1)Array.isArray()方法\n\n    var a = [0, 1, 2];\n\n    console.log(Array.isArray(a));   // true\n\n(2)typeof  toString 方法</code></pre><p><strong>由于低版本的<code>IE</code>不支持<code>ES5</code>，如需要兼容，用<code>typeof</code>，我们都知道，数组是特殊的对象，所以数组的<code>typeof</code>结果也是<code>object</code>，而因为<code>null</code>的结果也是<code>object</code>，所以需要加判断是 <code>object</code>同时排除<code>null</code>、排除纯对象,先判断<code>a</code>是不是<code>object</code>,并且<code>a!==null</code>, 并且<code>toString.call</code>判断<code>a</code>等于 <code>[object Array]</code></strong></p>\n<pre><code>var a = [0, 1, 2];\n\nconsole.log( typeof a ===&#39;object&#39; &amp;&amp;  a !==null  &amp;&amp;  Object.prototype.toString.call(a) ===&#39;[object Array]&#39;);   //  true</code></pre><h2 id=\"十四、数组与其他值的运算-使用”-”会自动转为string-”-“会自动转为number\"><a href=\"#十四、数组与其他值的运算-使用”-”会自动转为string-”-“会自动转为number\" class=\"headerlink\" title=\"十四、数组与其他值的运算(使用”+”会自动转为string,”-“会自动转为number)\"></a>十四、数组与其他值的运算(使用”+”会自动转为<code>string</code>,”-“会自动转为<code>number</code>)</h2><pre><code>// 数组和任何值相加都会将数组转换成字符串再进行拼接\n\nconsole.log([1,2,3] + 6) ;       // &quot;1,2,36&quot;\n\nconsole.log([1,2,3] + {}) ;      // &quot;1,2,3[object Object]&quot;\n\nconsole.log([1,2,3] + [1,2,3])； // &quot;1,2,31,2,3&quot;\n\n如果数组只有一个值，那么当这个数组和其他值相减相乘等时会被转换为数字，如果为空会被转换为0\n\nconsole.log([5] - 2)          // 3</code></pre><h2 id=\"十五、数组去重\"><a href=\"#十五、数组去重\" class=\"headerlink\" title=\"十五、数组去重\"></a>十五、数组去重</h2><pre><code>// ES6新增的Set数据结构，类似于数组，但是里面的元素都是唯一的，其构造函数可以接受一个数组作为参数\n\nlet arr1=[1,2,1,2,6,3,5,69,66,7,2,1,4,3,6,8,9663,8]\n\nlet set = new Set(arr1);\n\nconsole.log(set)       //  {1,2,6,3,5,69,66,7,4,8,9663,8]\n\n// ES6中Array新增了一个静态方法from，可以把类似数组的对象转换为数组\n\nvar arr=[1,2,1,2,6,3,5,69,66,7,2,1,4,3,6,8,9663,8]\n\nconsole.log(Array.from( new Set(arr)))  // {1,2,6,3,5,69,66,7,4,8,9663,8]\n\n//函数去重：\n\nfunction removeRepeatArray(arr){\n        return Array.from(new Set(arr))\n}\nconsole.log(removeRepeatArray([1,5,9,8,6,2,5,1,2,5,8,65,3,5,5,2,2,5]))\n    //  [1, 5, 9, 8, 6, 2, 65, 3]</code></pre><h2 id=\"十六、将数组顺序打乱\"><a href=\"#十六、将数组顺序打乱\" class=\"headerlink\" title=\"十六、将数组顺序打乱\"></a>十六、将数组顺序打乱</h2><pre><code>function upsetArr(arr){\n    return arr.sort(function(){ return Math.random() - 0.5});\n}</code></pre><blockquote>\n<p>解析：沿用原<code>sort</code>的 a-b 的方法，先生成一个随机数，然后将其与随机数进行 比较，如果 Math.random() - 0.5 是 true，则返回前者，否则比较下一个</p>\n</blockquote>\n<h2 id=\"十七-实现将数组中数字求和，字母忽略。\"><a href=\"#十七-实现将数组中数字求和，字母忽略。\" class=\"headerlink\" title=\"十七 实现将数组中数字求和，字母忽略。\"></a>十七 实现将数组中数字求和，字母忽略。</h2><pre><code>var arr=[&quot;a&quot;,3,4,5,9,&quot;d&quot;];\nfunction sum(arr){\n    var a=0;\n    for(var i=0;iif(typeof arr[i]===&quot;number&quot;){\n            a+=arr[i]\n        }\n    }\n    return a;\n}\n\nsum(arr)  //21</code></pre><blockquote>\n<p>通过循环遍历判断数组中的每个值是否是数字，如果是的赋值到变量上进行加法计算</p>\n</blockquote>\n<h2 id=\"十八、delete，splice删除数组内指定的某个值。\"><a href=\"#十八、delete，splice删除数组内指定的某个值。\" class=\"headerlink\" title=\"十八、delete，splice删除数组内指定的某个值。\"></a>十八、<code>delete</code>，<code>splice</code>删除数组内指定的某个值。</h2><blockquote>\n<p>使用<code>delete</code>删除数组内的制定索引的值后，直接改的是原数组，而且删除值的位置仍然保留，为<code>undefined</code>。</p>\n</blockquote>\n<pre><code>var arr=[1,2,3,45,5,2];\n\n    delete arr[0]\n\nconsole.log(arr,arr[0]).   // [empty,2,3,45,5],undefined</code></pre><blockquote>\n<p>如果要彻底删除，可以使用<code>splice()</code>方法 <code>splice(开始位置，删除个数，添加的值)</code>，如果没有第三个值，可以只传前两个值</p>\n</blockquote>\n<p><strong>两个值的示例：</strong></p>\n<pre><code>var arr=[1,2,3,45,5,2];\n\n    arr.splice(0,1)\n\nconsole.log(arr)    //  [2, 3, 45, 5, 2]</code></pre><p><strong>三个值的示例：</strong></p>\n<pre><code>var arr=[1,2,3,45,5,2];\n\n    arr.splice(0,1,100)\n\nconsole.log(arr)     //  [100 ,2, 3, 45, 5, 2]</code></pre><h2 id=\"十九、slice-截取数组，可选择开始位置和结束位置\"><a href=\"#十九、slice-截取数组，可选择开始位置和结束位置\" class=\"headerlink\" title=\"十九、slice()截取数组，可选择开始位置和结束位置\"></a>十九、<code>slice()</code>截取数组，可选择开始位置和结束位置</h2><p><code>slice()</code>接收两个参数，第一个是开始位置，第二个是结束位置</p>\n<pre><code>var arr=[1,2,3,45,5,2];\n\n    arr.slice(0,4)\n\nconsole.log(arr). //  [1, 2, 3, 45]</code></pre><p>如果<code>slice()</code>括号中不传参数，将会全部截取</p>\n<pre><code>var arr=[1,2,3,45,5,2];\n\n    arr.slice()\n\nconsole.log(arr).  //  [1, 2, 3, 45, 5, 2]</code></pre><h2 id=\"二十、颠倒数组的顺序，也称数组的反转\"><a href=\"#二十、颠倒数组的顺序，也称数组的反转\" class=\"headerlink\" title=\"二十、颠倒数组的顺序，也称数组的反转\"></a>二十、颠倒数组的顺序，也称数组的反转</h2><pre><code>var arr=[1,2,3,45,5,2];\n\n    arr.reverse()\n\nconsole.log(arr)   // [2, 5, 45, 3, 2, 1]</code></pre><h2 id=\"二十一、join-将数组以括号中的值分割成字符串-不会改变原数组\"><a href=\"#二十一、join-将数组以括号中的值分割成字符串-不会改变原数组\" class=\"headerlink\" title=\"二十一、join()将数组以括号中的值分割成字符串(不会改变原数组)\"></a>二十一、<code>join()</code>将数组以括号中的值分割成字符串(不会改变原数组)</h2><pre><code>var arr=[1,2,3,45,5,2];\n\nconsole.log(arr.join(&quot;_”));  //  &quot;1_2_3_45_5_2&quot;\n\nconsole.log(arr);   //  [1, 2, 3, 45, 5, 2]</code></pre><h2 id=\"二十二、sort-排序，将数组中的值进行排序，从大到小或从小到大-会改变原本的数组\"><a href=\"#二十二、sort-排序，将数组中的值进行排序，从大到小或从小到大-会改变原本的数组\" class=\"headerlink\" title=\"二十二、sort()排序，将数组中的值进行排序，从大到小或从小到大(会改变原本的数组)\"></a>二十二、<code>sort()</code>排序，将数组中的值进行排序，从大到小或从小到大(会改变原本的数组)</h2><blockquote>\n<p><code>sort</code>原本的排序功能只能识别到个位数做比较，所以扩展使用以下方法：（排序方法有很多，这是最传统，也是使用频率较多的，其他的方法不再赘述）</p>\n</blockquote>\n<pre><code>var arr=[1,2,3,45,5,2];\n\n    arr.sort(function(a,b){\n        return a-b\n    })\n   //  [1, 2, 2, 3, 5, 45]\n\n查看此时的arr数组：\n    console.log(arr)  //   [1, 2, 2, 3, 5, 45]\n\n    arr.sort(function(a,b){\n        return b-a\n    })\n  //  [45, 5, 3, 2, 2, 1]\n\n查看此时的arr数组：\n    console.log(arr)  //   [45, 5, 3, 2, 2, 1]</code></pre><blockquote>\n<p>当然我们有时是不可以改变原数组的，那么可以试试下面的方法将需要的内容拷贝出来即可：</p>\n</blockquote>\n<pre><code>var arr=[1,3,6,8,45,34,90,122,9,0];\n\nvar array=arr.slice();\n\n    array.push(34)\n\nconsole.log(arr，array)\n\n// [1,3,6,8,45,34,90,122,9,0],[1,3,6,8,45,34,90,122,9,0,34]</code></pre><hr>\n<h2 id=\"数组中的迭代方法filter-every-forEach-map-some\"><a href=\"#数组中的迭代方法filter-every-forEach-map-some\" class=\"headerlink\" title=\"数组中的迭代方法filter(), every(),forEach(),map(),some()\"></a>数组中的迭代方法<code>filter()</code>, <code>every()</code>,<code>forEach()</code>,<code>map()</code>,<code>some()</code></h2><p><code>filter()</code>：对数组中的每一项运行给定函数，返回该函数会返回<code>true</code> 的项组成的数组。</p>\n<p><code>every()</code>：对数组中的每一项运行给定函数，如果该函数对每一项都返回<code>true</code>，则返回<code>true</code>。</p>\n<p><code>forEach()</code>：对数组中的每一项运行给定函数。这个方法没有返回值。</p>\n<p><code>map()</code>：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</p>\n<p><code>some()</code>：对数组中的每一项运行给定函数，如果该函数对任一项返回<code>true</code>，则返回 true.</p>\n<h2 id=\"一、数组迭代方法之filter\"><a href=\"#一、数组迭代方法之filter\" class=\"headerlink\" title=\"一、数组迭代方法之filter()\"></a>一、数组迭代方法之<code>filter()</code></h2><p>（<code>filter</code>返回的是一个符合某种条件的数组，并返回，不会更改原数组）</p>\n<pre><code>var arr=[1,3,6,8,45,34,90,122,9,0];\n\nvar array = arr.filter(function(element){\n\n        return element&gt;10\n    })\nconsole.log(array)\n\n//筛选数组中大于10的值， [45, 34, 90, 122]\n\n//查看原数组，并没有改变\n\nconsole.log(arr)    //  [1,3,6,8,45,34,90,122,9,0]</code></pre><h2 id=\"二、数组迭代方法之every\"><a href=\"#二、数组迭代方法之every\" class=\"headerlink\" title=\"二、数组迭代方法之every()\"></a>二、数组迭代方法之<code>every()</code></h2><p>（主要是用于判断一个素组中的值是否符合某个标准。必须是每个值都符合才会返回<code>true</code>。否则返回<code>false</code>）</p>\n<pre><code>var arr = [1,2,3,4,5,4,3,2,1];\n\nvar everyResult = arr.every(function(item, index, array){\n    return (item &gt; 2);\n});\n\n//判断数组中所有的值是否都大于2，如果都大于2，返回true，反之返回false.\n\nconsole.log(everyResult)     //false</code></pre><h2 id=\"三、数组迭代方法之forEach\"><a href=\"#三、数组迭代方法之forEach\" class=\"headerlink\" title=\"三、数组迭代方法之forEach()\"></a>三、数组迭代方法之<code>forEach()</code></h2><p>（数组的循环遍历,对数组中的每一项运行给定函数。这个方法没有返回值。)</p>\n<pre><code>var arr=[1,3,6,8,45,34,90,122,9,0];\n\n    arr.forEach(function(item,index,array){\n        console.log(item,index,array)\n    })\n/*\n 0 1 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 1 3 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 2 6 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 3 8 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 4 45 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 5 34 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 6 90 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 7 122 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 8 9 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 9 0 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n*/</code></pre><h2 id=\"四、数组迭代方法之map\"><a href=\"#四、数组迭代方法之map\" class=\"headerlink\" title=\"四、数组迭代方法之map()\"></a>四、数组迭代方法之<code>map()</code></h2><p>（数组的循环遍历,对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。)</p>\n<pre><code>var arr=[1,3,6,8,45,34,90,122,9,0];\n\n    arr.map(function(item,index,array){\n        console.log(index,item,array)\n    })\n /*\n 0 1 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 1 3 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 2 6 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 3 8 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 4 45 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 5 34 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 6 90 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 7 122 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 8 9 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 9 0 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n */</code></pre><h2 id=\"五、数组迭代方法之some\"><a href=\"#五、数组迭代方法之some\" class=\"headerlink\" title=\"五、数组迭代方法之some()\"></a>五、数组迭代方法之<code>some()</code></h2><p>(对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true)</p>\n<pre><code>var numbers = [1,2,3,4,5,4,3,2,1];\n\nvar someResult = numbers.some(function(item, index, array){\n    return (item &gt; 2);\n});\n\n//只要有一个返回true，则返回true\n\nconsole.log(someResult); // true</code></pre><h2 id=\"归并：迭代数组中的所有值，返回一个按条件计算的最终值。\"><a href=\"#归并：迭代数组中的所有值，返回一个按条件计算的最终值。\" class=\"headerlink\" title=\"归并：迭代数组中的所有值，返回一个按条件计算的最终值。\"></a><strong>归并：迭代数组中的所有值，返回一个按条件计算的最终值。</strong></h2><p><strong>reduce:</strong></p>\n<pre><code>var values = [1,2,3,4,5];\n\nvar sum = reduce(function(prev, cur, index, array){\n    return prev + cur;\n});\n\n//第一次执行回调函数，prev 是1，cur 是2。第二次，prev 是3（1 加2 的结果），cur 是3（数组的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。\n//通过循环遍历，返回数组中所有值的总和  15</code></pre><p><strong>reduceRight:</strong></p>\n<pre><code>var values = [1,2,3,4,5];\n\nvar sum = reduceRight(function(prev, cur, index, array){\n    return prev + cur;\n});\n\n//第一次执行回调函数，prev 是5，cur 是4。第二次，prev 是9（5加4 的结果），cur 是3（数组的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。\n//通过循环遍历，返回数组中所有值的总和  15</code></pre>","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h2 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h2><blockquote>\n<p>定义：数组是值的有序集合。 <code>JS</code>的数组是无类型的，数组元素可以是任意类型，并且同一个数组的不同元素也可能有不同的类型，每一个值叫做元素（数组元素），每个元素在数组中有一个位置。数组在平常的<code>coding</code>中是比较常用的数据格式，尤其式在解析后台数据时。之所以叫“教科书式的数组方法”，是因为每个方法我都配有示例，希望能通过示例的解析，让大家对方法能有更清晰对理解。除此之外，字符串和对象的方法也会在过两天分享，希望能对您有些许帮助，这将是我莫大的荣幸！</p>\n</blockquote>\n<h2 id=\"一、创建数组-x\"><a href=\"#一、创建数组-x\" class=\"headerlink\" title=\"一、创建数组 x=[ ]\"></a>一、创建数组 <code>x=[ ]</code></h2><pre><code>var a=[&quot;333&quot;,&quot;999&quot;];        // 直接写在[ ]中\n\nvar aa=new Array(4,8,9);    // 通过实例传入Array中\n\nvar aaa=new Array(5);       // 传入的5为array的个数\n\n    aaa[0]=6;               // 给aaa的第0个赋值为6\n\nconsole.log(aaa);           //  [6,,,,,]\n\nconsole.log(aa);            //  [4,8,9]</code></pre><h2 id=\"二、-访问数组元素-x-index\"><a href=\"#二、-访问数组元素-x-index\" class=\"headerlink\" title=\"二、 访问数组元素 x.[index]\"></a>二、 访问数组元素 <code>x.[index]</code></h2><pre><code>var a=[&quot;333&quot;,&quot;999&quot;];\n\nvar b=a[0];              // 访问数组的第一个元素\n\nvar c=a[a.length-1];     // 访问数组的最后一个元素\n\nvar f=a[&quot;1&quot;]===a[1];     // a[&quot;1&quot;]会自动转为数字1\n\nconsole.log(f);          //  true</code></pre><p><strong>当然，如果我们通过以下方式去访问时，会被解析成连续运算返回最后一个值</strong></p>\n<p><code>console.log([2,3,4,5][1,2]) // 4</code></p>\n<p><strong>数组也是一种特殊的对象，因此我们也可以通过键值对的形式去访问</strong></p>\n<pre><code>var arr9 = [];\n\n    arr9.say = &#39;Hello&#39;;\n\nconsole.log(arr9.say)    // Hello</code></pre><h2 id=\"三、遍历数组-x-forEach-function-item-index-array\"><a href=\"#三、遍历数组-x-forEach-function-item-index-array\" class=\"headerlink\" title=\"三、遍历数组 x.forEach(function(item,index,array){})\"></a>三、遍历数组 <code>x.forEach(function(item,index,array){})</code></h2><p><code>es6写法 forEach((item,index)=&gt;{dosomething.....})</code></p>\n<pre><code>var a=[&quot;333&quot;,&quot;999&quot;];\n\n   a.forEach(function (item,index,array) {\n\n           console.log(item,index)\n\n });\n       //333 0  999 1</code></pre><h2 id=\"四、添加元素到数组的末尾-x-push\"><a href=\"#四、添加元素到数组的末尾-x-push\" class=\"headerlink\" title=\"四、添加元素到数组的末尾 x.push(...)\"></a>四、添加元素到数组的末尾 <code>x.push(...)</code></h2><pre><code>var a=[&quot;333&quot;,&quot;999&quot;];\n\n    a.push(&quot;我是新元素&quot;,&quot;666&quot;);\n\nconsole.log(a);    //[&quot;333&quot;,&quot;999&quot;,&quot;我是新元素&quot;,&quot;666&quot;]\n\nconsole.log(a.push(&quot;我&quot;,&quot;690&quot;),a.length,a);  //6,[&quot;333&quot;,&quot;666&quot;,&quot;我是新元素&quot;,&quot;666&quot;,&quot;我&quot;,&quot;690&quot;]\n\n//返回新数组长度6，会执行一次a.push</code></pre><h2 id=\"五、在末尾删除数组-只能删除-1-个-x-pop\"><a href=\"#五、在末尾删除数组-只能删除-1-个-x-pop\" class=\"headerlink\" title=\"五、在末尾删除数组(只能删除 1 个) x.pop()\"></a>五、在末尾删除数组(只能删除 1 个) <code>x.pop()</code></h2><pre><code>var a=[&quot;333&quot;,&quot;999&quot;];\n\n    a.pop();\n\nconsole.log(a);            // [&quot;333&quot;];  返回新数组\n\nconsole.log( a.pop(),a);   //333 []\n\n//会执行一次a.pop()，返回本次被删除元素</code></pre><h2 id=\"六、删除数组最前面元素-x-shift\"><a href=\"#六、删除数组最前面元素-x-shift\" class=\"headerlink\" title=\"六、删除数组最前面元素 x.shift()\"></a>六、删除数组最前面元素 <code>x.shift()</code></h2><pre><code>var a=[&quot;333&quot;,&quot;999&quot;];\n\n    a.shift();\n\nconsole.log(a);            //  [&quot;999&quot;]\n\nconsole.log( a.shift());   //  &quot;999&quot;\n\n  //返回被删除元素，不会执行a.shift()</code></pre><h2 id=\"七、添加到数组的前面（头部）x-unshift-quot-quot\"><a href=\"#七、添加到数组的前面（头部）x-unshift-quot-quot\" class=\"headerlink\" title=\"七、添加到数组的前面（头部）x.unshift(&quot;...&quot;)\"></a>七、添加到数组的前面（头部）<code>x.unshift(&quot;...&quot;)</code></h2><pre><code>var a=[&quot;333&quot;,&quot;999&quot;];\n\n    a.unshift(&quot;000&quot;,&quot;888&quot;,&quot;777&quot;);\n\nconsole.log(a);\n\n// [&quot;000&quot;,&quot;888&quot;,&quot;777&quot;,&quot;333&quot;,&quot;999&quot;]\n\nconsole.log(a.unshift(&quot;111&quot;),a.length,a);\n\n//[&quot;111&quot;,&quot;000&quot;,&quot;888&quot;,&quot;777&quot;,&quot;333&quot;,&quot;999&quot;]\n\n   //会执行一次a.unshift，返回数组长度,</code></pre><h2 id=\"八、找到某个元素在数组中的索引-indexOf\"><a href=\"#八、找到某个元素在数组中的索引-indexOf\" class=\"headerlink\" title=\"八、找到某个元素在数组中的索引 indexOf\"></a>八、找到某个元素在数组中的索引 <code>indexOf</code></h2><pre><code>var a=[&quot;333&quot;,&quot;999&quot;];\n\nvar d=a.indexOf(&quot;333&quot;);   // 通过元素查找在当前数组的索引值\n\nconsole.log(d);           // 0\n\nvar e=a.indexOf(&quot;654&quot;);   // 如果查不到返回-1\n\nconsole.log(e);           // -1</code></pre><h2 id=\"九、复制数组-slice-Array-from-…\"><a href=\"#九、复制数组-slice-Array-from-…\" class=\"headerlink\" title=\"九、复制数组 slice() , Array.from() […]\"></a>九、复制数组 <code>slice()</code> , <code>Array.from()</code> […]</h2><pre><code>var a=[1,2,8];\n\nvar newArray=a.slice();\n\nconsole.log(newArray);   //第一种方法  [1,2,8]\n\n-----------------------------------\n\nvar newArray2=Array.from(a);\n\nconsole.log(newArray2);  //第二种方法 [1,2,8]\n\n------------------------------------\n\nvar newArray3=[...a];\n\nconsole.log(newArray3);  //第三种方法 [1,2,8]</code></pre><h2 id=\"十、清空数组\"><a href=\"#十、清空数组\" class=\"headerlink\" title=\"十、清空数组\"></a>十、清空数组</h2><pre><code>// 两种方法都可以实现，但第二种比较优雅\n\nvar arr=[1,2,3,3,4,5];\n\n    arr=[];\n\nconsole.log(arr)     //  []\n\n------------------------------------\n\nvar arr=[888,99];\n\n    arr.length=0;\n\nconsole.log(arr)     //  []</code></pre><h2 id=\"十一、合并数组\"><a href=\"#十一、合并数组\" class=\"headerlink\" title=\"十一、合并数组\"></a>十一、合并数组</h2><pre><code>var arr=[1];\n\nvar arr2=[2];\n\nvar arr3=[3];\n\nvar arr4=arr.concat(arr2,arr3)\n\nconsole.log(arr4)     // [1,2,3]\n\n---------------------------------------\n// 下面这个方法也可以实现，但只能合并两个数组\n\nvar arr1=[1,2,3];\n\nvar arr2=[4,5,6];\n\n    arr1.push.apply(arr1,arr2);\n\nconsole.log(arr1);   // [1, 2, 3, 4, 5, 6]</code></pre><h2 id=\"十二、在数组中找到最大值和最小值\"><a href=\"#十二、在数组中找到最大值和最小值\" class=\"headerlink\" title=\"十二、在数组中找到最大值和最小值\"></a>十二、在数组中找到最大值和最小值</h2><pre><code>//方法1\nvar array1 = [1,2,3,4];\n\nvar array2 = Math.max.apply(null,array1);  // 最大值\n\nvar array3 = Math.min.apply(null,array1);  // 最小值\n\nconsole.log(array2,array3);                // 4 ,1\n\n--------------------------------------------------\n\n//方法2\nvar array4 =Math.max(...array1);         // 最大值\n\nvar array5 =Math.min(...array1);         // 最小值\n\nconsole.log(array4,array5);              // 4 ,1</code></pre><h2 id=\"十三、判断是不是数组\"><a href=\"#十三、判断是不是数组\" class=\"headerlink\" title=\"十三、判断是不是数组\"></a>十三、判断是不是数组</h2><pre><code>// 在javascript中，如何判断一个变量是否是数组\n\n(1)Array.isArray()方法\n\n    var a = [0, 1, 2];\n\n    console.log(Array.isArray(a));   // true\n\n(2)typeof  toString 方法</code></pre><p><strong>由于低版本的<code>IE</code>不支持<code>ES5</code>，如需要兼容，用<code>typeof</code>，我们都知道，数组是特殊的对象，所以数组的<code>typeof</code>结果也是<code>object</code>，而因为<code>null</code>的结果也是<code>object</code>，所以需要加判断是 <code>object</code>同时排除<code>null</code>、排除纯对象,先判断<code>a</code>是不是<code>object</code>,并且<code>a!==null</code>, 并且<code>toString.call</code>判断<code>a</code>等于 <code>[object Array]</code></strong></p>\n<pre><code>var a = [0, 1, 2];\n\nconsole.log( typeof a ===&#39;object&#39; &amp;&amp;  a !==null  &amp;&amp;  Object.prototype.toString.call(a) ===&#39;[object Array]&#39;);   //  true</code></pre><h2 id=\"十四、数组与其他值的运算-使用”-”会自动转为string-”-“会自动转为number\"><a href=\"#十四、数组与其他值的运算-使用”-”会自动转为string-”-“会自动转为number\" class=\"headerlink\" title=\"十四、数组与其他值的运算(使用”+”会自动转为string,”-“会自动转为number)\"></a>十四、数组与其他值的运算(使用”+”会自动转为<code>string</code>,”-“会自动转为<code>number</code>)</h2><pre><code>// 数组和任何值相加都会将数组转换成字符串再进行拼接\n\nconsole.log([1,2,3] + 6) ;       // &quot;1,2,36&quot;\n\nconsole.log([1,2,3] + {}) ;      // &quot;1,2,3[object Object]&quot;\n\nconsole.log([1,2,3] + [1,2,3])； // &quot;1,2,31,2,3&quot;\n\n如果数组只有一个值，那么当这个数组和其他值相减相乘等时会被转换为数字，如果为空会被转换为0\n\nconsole.log([5] - 2)          // 3</code></pre><h2 id=\"十五、数组去重\"><a href=\"#十五、数组去重\" class=\"headerlink\" title=\"十五、数组去重\"></a>十五、数组去重</h2><pre><code>// ES6新增的Set数据结构，类似于数组，但是里面的元素都是唯一的，其构造函数可以接受一个数组作为参数\n\nlet arr1=[1,2,1,2,6,3,5,69,66,7,2,1,4,3,6,8,9663,8]\n\nlet set = new Set(arr1);\n\nconsole.log(set)       //  {1,2,6,3,5,69,66,7,4,8,9663,8]\n\n// ES6中Array新增了一个静态方法from，可以把类似数组的对象转换为数组\n\nvar arr=[1,2,1,2,6,3,5,69,66,7,2,1,4,3,6,8,9663,8]\n\nconsole.log(Array.from( new Set(arr)))  // {1,2,6,3,5,69,66,7,4,8,9663,8]\n\n//函数去重：\n\nfunction removeRepeatArray(arr){\n        return Array.from(new Set(arr))\n}\nconsole.log(removeRepeatArray([1,5,9,8,6,2,5,1,2,5,8,65,3,5,5,2,2,5]))\n    //  [1, 5, 9, 8, 6, 2, 65, 3]</code></pre><h2 id=\"十六、将数组顺序打乱\"><a href=\"#十六、将数组顺序打乱\" class=\"headerlink\" title=\"十六、将数组顺序打乱\"></a>十六、将数组顺序打乱</h2><pre><code>function upsetArr(arr){\n    return arr.sort(function(){ return Math.random() - 0.5});\n}</code></pre><blockquote>\n<p>解析：沿用原<code>sort</code>的 a-b 的方法，先生成一个随机数，然后将其与随机数进行 比较，如果 Math.random() - 0.5 是 true，则返回前者，否则比较下一个</p>\n</blockquote>\n<h2 id=\"十七-实现将数组中数字求和，字母忽略。\"><a href=\"#十七-实现将数组中数字求和，字母忽略。\" class=\"headerlink\" title=\"十七 实现将数组中数字求和，字母忽略。\"></a>十七 实现将数组中数字求和，字母忽略。</h2><pre><code>var arr=[&quot;a&quot;,3,4,5,9,&quot;d&quot;];\nfunction sum(arr){\n    var a=0;\n    for(var i=0;iif(typeof arr[i]===&quot;number&quot;){\n            a+=arr[i]\n        }\n    }\n    return a;\n}\n\nsum(arr)  //21</code></pre><blockquote>\n<p>通过循环遍历判断数组中的每个值是否是数字，如果是的赋值到变量上进行加法计算</p>\n</blockquote>\n<h2 id=\"十八、delete，splice删除数组内指定的某个值。\"><a href=\"#十八、delete，splice删除数组内指定的某个值。\" class=\"headerlink\" title=\"十八、delete，splice删除数组内指定的某个值。\"></a>十八、<code>delete</code>，<code>splice</code>删除数组内指定的某个值。</h2><blockquote>\n<p>使用<code>delete</code>删除数组内的制定索引的值后，直接改的是原数组，而且删除值的位置仍然保留，为<code>undefined</code>。</p>\n</blockquote>\n<pre><code>var arr=[1,2,3,45,5,2];\n\n    delete arr[0]\n\nconsole.log(arr,arr[0]).   // [empty,2,3,45,5],undefined</code></pre><blockquote>\n<p>如果要彻底删除，可以使用<code>splice()</code>方法 <code>splice(开始位置，删除个数，添加的值)</code>，如果没有第三个值，可以只传前两个值</p>\n</blockquote>\n<p><strong>两个值的示例：</strong></p>\n<pre><code>var arr=[1,2,3,45,5,2];\n\n    arr.splice(0,1)\n\nconsole.log(arr)    //  [2, 3, 45, 5, 2]</code></pre><p><strong>三个值的示例：</strong></p>\n<pre><code>var arr=[1,2,3,45,5,2];\n\n    arr.splice(0,1,100)\n\nconsole.log(arr)     //  [100 ,2, 3, 45, 5, 2]</code></pre><h2 id=\"十九、slice-截取数组，可选择开始位置和结束位置\"><a href=\"#十九、slice-截取数组，可选择开始位置和结束位置\" class=\"headerlink\" title=\"十九、slice()截取数组，可选择开始位置和结束位置\"></a>十九、<code>slice()</code>截取数组，可选择开始位置和结束位置</h2><p><code>slice()</code>接收两个参数，第一个是开始位置，第二个是结束位置</p>\n<pre><code>var arr=[1,2,3,45,5,2];\n\n    arr.slice(0,4)\n\nconsole.log(arr). //  [1, 2, 3, 45]</code></pre><p>如果<code>slice()</code>括号中不传参数，将会全部截取</p>\n<pre><code>var arr=[1,2,3,45,5,2];\n\n    arr.slice()\n\nconsole.log(arr).  //  [1, 2, 3, 45, 5, 2]</code></pre><h2 id=\"二十、颠倒数组的顺序，也称数组的反转\"><a href=\"#二十、颠倒数组的顺序，也称数组的反转\" class=\"headerlink\" title=\"二十、颠倒数组的顺序，也称数组的反转\"></a>二十、颠倒数组的顺序，也称数组的反转</h2><pre><code>var arr=[1,2,3,45,5,2];\n\n    arr.reverse()\n\nconsole.log(arr)   // [2, 5, 45, 3, 2, 1]</code></pre><h2 id=\"二十一、join-将数组以括号中的值分割成字符串-不会改变原数组\"><a href=\"#二十一、join-将数组以括号中的值分割成字符串-不会改变原数组\" class=\"headerlink\" title=\"二十一、join()将数组以括号中的值分割成字符串(不会改变原数组)\"></a>二十一、<code>join()</code>将数组以括号中的值分割成字符串(不会改变原数组)</h2><pre><code>var arr=[1,2,3,45,5,2];\n\nconsole.log(arr.join(&quot;_”));  //  &quot;1_2_3_45_5_2&quot;\n\nconsole.log(arr);   //  [1, 2, 3, 45, 5, 2]</code></pre><h2 id=\"二十二、sort-排序，将数组中的值进行排序，从大到小或从小到大-会改变原本的数组\"><a href=\"#二十二、sort-排序，将数组中的值进行排序，从大到小或从小到大-会改变原本的数组\" class=\"headerlink\" title=\"二十二、sort()排序，将数组中的值进行排序，从大到小或从小到大(会改变原本的数组)\"></a>二十二、<code>sort()</code>排序，将数组中的值进行排序，从大到小或从小到大(会改变原本的数组)</h2><blockquote>\n<p><code>sort</code>原本的排序功能只能识别到个位数做比较，所以扩展使用以下方法：（排序方法有很多，这是最传统，也是使用频率较多的，其他的方法不再赘述）</p>\n</blockquote>\n<pre><code>var arr=[1,2,3,45,5,2];\n\n    arr.sort(function(a,b){\n        return a-b\n    })\n   //  [1, 2, 2, 3, 5, 45]\n\n查看此时的arr数组：\n    console.log(arr)  //   [1, 2, 2, 3, 5, 45]\n\n    arr.sort(function(a,b){\n        return b-a\n    })\n  //  [45, 5, 3, 2, 2, 1]\n\n查看此时的arr数组：\n    console.log(arr)  //   [45, 5, 3, 2, 2, 1]</code></pre><blockquote>\n<p>当然我们有时是不可以改变原数组的，那么可以试试下面的方法将需要的内容拷贝出来即可：</p>\n</blockquote>\n<pre><code>var arr=[1,3,6,8,45,34,90,122,9,0];\n\nvar array=arr.slice();\n\n    array.push(34)\n\nconsole.log(arr，array)\n\n// [1,3,6,8,45,34,90,122,9,0],[1,3,6,8,45,34,90,122,9,0,34]</code></pre><hr>\n<h2 id=\"数组中的迭代方法filter-every-forEach-map-some\"><a href=\"#数组中的迭代方法filter-every-forEach-map-some\" class=\"headerlink\" title=\"数组中的迭代方法filter(), every(),forEach(),map(),some()\"></a>数组中的迭代方法<code>filter()</code>, <code>every()</code>,<code>forEach()</code>,<code>map()</code>,<code>some()</code></h2><p><code>filter()</code>：对数组中的每一项运行给定函数，返回该函数会返回<code>true</code> 的项组成的数组。</p>\n<p><code>every()</code>：对数组中的每一项运行给定函数，如果该函数对每一项都返回<code>true</code>，则返回<code>true</code>。</p>\n<p><code>forEach()</code>：对数组中的每一项运行给定函数。这个方法没有返回值。</p>\n<p><code>map()</code>：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</p>\n<p><code>some()</code>：对数组中的每一项运行给定函数，如果该函数对任一项返回<code>true</code>，则返回 true.</p>\n<h2 id=\"一、数组迭代方法之filter\"><a href=\"#一、数组迭代方法之filter\" class=\"headerlink\" title=\"一、数组迭代方法之filter()\"></a>一、数组迭代方法之<code>filter()</code></h2><p>（<code>filter</code>返回的是一个符合某种条件的数组，并返回，不会更改原数组）</p>\n<pre><code>var arr=[1,3,6,8,45,34,90,122,9,0];\n\nvar array = arr.filter(function(element){\n\n        return element&gt;10\n    })\nconsole.log(array)\n\n//筛选数组中大于10的值， [45, 34, 90, 122]\n\n//查看原数组，并没有改变\n\nconsole.log(arr)    //  [1,3,6,8,45,34,90,122,9,0]</code></pre><h2 id=\"二、数组迭代方法之every\"><a href=\"#二、数组迭代方法之every\" class=\"headerlink\" title=\"二、数组迭代方法之every()\"></a>二、数组迭代方法之<code>every()</code></h2><p>（主要是用于判断一个素组中的值是否符合某个标准。必须是每个值都符合才会返回<code>true</code>。否则返回<code>false</code>）</p>\n<pre><code>var arr = [1,2,3,4,5,4,3,2,1];\n\nvar everyResult = arr.every(function(item, index, array){\n    return (item &gt; 2);\n});\n\n//判断数组中所有的值是否都大于2，如果都大于2，返回true，反之返回false.\n\nconsole.log(everyResult)     //false</code></pre><h2 id=\"三、数组迭代方法之forEach\"><a href=\"#三、数组迭代方法之forEach\" class=\"headerlink\" title=\"三、数组迭代方法之forEach()\"></a>三、数组迭代方法之<code>forEach()</code></h2><p>（数组的循环遍历,对数组中的每一项运行给定函数。这个方法没有返回值。)</p>\n<pre><code>var arr=[1,3,6,8,45,34,90,122,9,0];\n\n    arr.forEach(function(item,index,array){\n        console.log(item,index,array)\n    })\n/*\n 0 1 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 1 3 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 2 6 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 3 8 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 4 45 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 5 34 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 6 90 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 7 122 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 8 9 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 9 0 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n*/</code></pre><h2 id=\"四、数组迭代方法之map\"><a href=\"#四、数组迭代方法之map\" class=\"headerlink\" title=\"四、数组迭代方法之map()\"></a>四、数组迭代方法之<code>map()</code></h2><p>（数组的循环遍历,对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。)</p>\n<pre><code>var arr=[1,3,6,8,45,34,90,122,9,0];\n\n    arr.map(function(item,index,array){\n        console.log(index,item,array)\n    })\n /*\n 0 1 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 1 3 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 2 6 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 3 8 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 4 45 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 5 34 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 6 90 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 7 122 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 8 9 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n 9 0 (10) [1, 3, 6, 8, 45, 34, 90, 122, 9, 0]\n */</code></pre><h2 id=\"五、数组迭代方法之some\"><a href=\"#五、数组迭代方法之some\" class=\"headerlink\" title=\"五、数组迭代方法之some()\"></a>五、数组迭代方法之<code>some()</code></h2><p>(对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true)</p>\n<pre><code>var numbers = [1,2,3,4,5,4,3,2,1];\n\nvar someResult = numbers.some(function(item, index, array){\n    return (item &gt; 2);\n});\n\n//只要有一个返回true，则返回true\n\nconsole.log(someResult); // true</code></pre><h2 id=\"归并：迭代数组中的所有值，返回一个按条件计算的最终值。\"><a href=\"#归并：迭代数组中的所有值，返回一个按条件计算的最终值。\" class=\"headerlink\" title=\"归并：迭代数组中的所有值，返回一个按条件计算的最终值。\"></a><strong>归并：迭代数组中的所有值，返回一个按条件计算的最终值。</strong></h2><p><strong>reduce:</strong></p>\n<pre><code>var values = [1,2,3,4,5];\n\nvar sum = reduce(function(prev, cur, index, array){\n    return prev + cur;\n});\n\n//第一次执行回调函数，prev 是1，cur 是2。第二次，prev 是3（1 加2 的结果），cur 是3（数组的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。\n//通过循环遍历，返回数组中所有值的总和  15</code></pre><p><strong>reduceRight:</strong></p>\n<pre><code>var values = [1,2,3,4,5];\n\nvar sum = reduceRight(function(prev, cur, index, array){\n    return prev + cur;\n});\n\n//第一次执行回调函数，prev 是5，cur 是4。第二次，prev 是9（5加4 的结果），cur 是3（数组的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。\n//通过循环遍历，返回数组中所有值的总和  15</code></pre>"},{"title":"超简单！Mac打造漂亮又好用的 zsh shell 环境","date":"2018-05-17T00:16:48.000Z","_content":"\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/QQ20180517-1@2x.png)身为开发者，很大一部分的时间是在用 command line 做事，如果能把 command line 调整成好用又酷炫的模样，不只是效率提升非常多，用起来爽度也比较高,上面放了一张我自己的 item，是不是觉得高大上了许多\n\n- 本片文章适用于 MAC 开发的 developer，学习时间大概十分钟\n- shell 默认选中 ZSH，已经安装过**iTerm2，oh-my-zsh**\n- 避免搞乱你的开发环境：仅可能使用 homebrew 来安装需要的套件\n- 安装 zsh theme: **powerlevel9k**\n\n#### **安装 iTerm2：**\n\n虽然不是必要，内建的 Terminal app 也可以，不过 iTerm2 还是比较好用，下面的示范也全都是用 iTerm2,个人用的自带其实还好\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/QQ20180517-3@2x.png)\n\n#如果你从来没有用过 brew cask 的话需要先跑这行\nbrew tap caskroom/cask\n\n#安装 iTerm2\nbrew cask instal iterm2\n\n安装好以后，打开 iTerm2 检查 Report Terminal Type 的设置，路径： `Preferences > Profiles > Terminal > Report Terminal Type`\n\n设为`xterm-256color`，等等在 terminal 才能看得到漂亮的颜色\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/QQ20180517-5@2x.png)\n\n#### **修改 iTerm2 的 color scheme**\n\n这步骤很重要，预设的很丑，想要自己的 command line 看起来赏心悦目就绝对要换掉预设的\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/QQ20180517-4@2x.png)\n\n#### **安装 powerline font**\n\n因为我们要用的 theme 会用到很多的特殊 icon，所以 iTerm2 选用的字型必需要支援这种特殊 icon font。这类型的字体统称为 powerline font（另外还有加强版支援更多特殊 icon 的叫的 nerd font）\n\n没有安装的话画面会长这样，遇到 icon 会变框框问号\n\n![](https://cdn-images-1.medium.com/max/1600/1*sB3u7_aAXl6BkRy9UEygPw.png)\n\n非 powerline font\n\n装完并设定新字型后的效果：\n\n![](https://cdn-images-1.medium.com/max/1600/1*0lPAd28LbancmQuHgnDyNg.png)\n\npowerline font\n\n支援 powerline 的字型很多，我推荐**Sauce Code Pro Nerd Font Complete** 安装方式推荐直接用 brew 安装比较快又好管理\n\n安装指令：\n\n#先执行这行，才能用 homebrew 安装字型。曾经执行过的人可以跳过这个指令\nbrew tap caskroom/fonts\n\n    # 安裝指令\n    brew cask install\n\n如果想要装别的，brew 上面也有很多字型可以挑。\n\n关键字是`nerd`：\n\nbrew cask search nerd\n\n装完后，记得修改 iTerm2 字型设定否则不会生效。请改成 SauceCodePro Nerd Font 或你自己下载的字型\n\n设定路径：`Preferences > Profiles > Text > Change Font`\n\n#### **安装 oh-my-zsh**\n\n上一步装完 zsh 后，就可以开始调整我们想要的 command line 外观设定了，但是原始的 zsh 因为设定太难搞，所以多年前刚出现的时候没有受到太多关注，直到有人写了一套叫**oh-my-zsh**的 framework 来帮助大家使用 zsh，zsh 才火了起来。现在几乎所有 zsh 好用的工具都有支援 oh-my-zsh，所以当然是要装这东西\n\n安装指令：\n\n    sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n\n> 注：这会直接执行 oh-my-zsh 的有疑虑的人可以先稍微研究一下[oh-my-zsh github](https://github.com/robbyrussell/oh-my-zsh)上的，觉得放心再执行`install.sh` `install.sh`\n\n执行完以后如果没有出现什么错误讯息就代表成功了，同时会发现多了 oh-my-zsh 的资料夹  `~/.oh-my-zsh`\n\n#### **重头戏！！安装 zsh theme **[**powerlevel9k**](https://github.com/bhilburn/powerlevel9k)\n\n刚装完 oh-my-zsh 以后，预设是使用内建的 theme *robbyrussell*，多了 git 资讯，颜色也看起来比原生 bash 好一些：\n\n![](https://cdn-images-1.medium.com/max/1600/1*1TqBIUz998aoEAoepG4mbw.png)\n\n不过 oh-my-zsh 内建很多 theme，在它的[github wiki](https://github.com/robbyrussell/oh-my-zsh/wiki/themes)上有很多截图可以参考\n\n切换内建的 theme 很简单，直接修改你的`~/.zshrc`，把原本改成你想要的：`ZSH_THEME=”_robbyrussell_”`\n\n    # 編輯 ~/.zshrc\n    ZSH_THEME=”\n\n任何的 zsh 设定修改过后，还要执行以下指令才会生效\n\nexec \\$SHELL\n\n![](https://cdn-images-1.medium.com/max/1600/1*Dj2trYBv3hgFg4LOIlMtWg.png)\n\nagnoster 看起来是不是比 robbyrussell 漂亮多了？\n\n这边推荐一个超强的 theme，powerlevel9k！\n\n文章开头的图片就是撷取自[powerlevel9k 的 github](https://github.com/bhilburn/powerlevel9k)\n\n![](https://cdn-images-1.medium.com/max/1600/1*OwwhfTqbc8IUaZnCAYXt7g.gif)\n\n图片来源：[https://github.com/bhilburn/powerlevel9k](https://github.com/bhilburn/powerlevel9k)\n\npowerlevel9k 不只是像上面的示范图显示一些基本的资讯，还可以做到很屌的事情，比如像下图那样，显示 WiFi 讯号强度、笔电电池电力、CPU loading、system free memory 等等资讯在 command line\n\n![](https://cdn-images-1.medium.com/max/1600/1*Ixhmm4KVixyzZolr-OTV3w.png)\n\n图片撷取自[powerlevel9k github](https://github.com/bhilburn/powerlevel9k)\n\n#### powerlevel9k 安装方式：\n\n1.  [powerlevel9k](https://github.com/bhilburn/powerlevel9k)不是 oh-my-zsh 内建的 theme ，必须另外下载\n\n指令：\n\n    git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k\n\n2.编辑你的`~/.zshrc`，把 ZSH_THEME 设为 powerlevel9k，并设定要显示哪些东西在 command line 上：\n\n    ZSH_THEME=\"powerlevel9k/powerlevel9k\"\n\n\\# command line 左边想显示的内容\nPOWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir) # <= left prompt 设了\"dir\"\n\n\\# command line 右边想显示的内容\nPOWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(time) # <= right prompt 设了\"time\"\n\n上面的例子我们把左边设了一个`dir`，右边设了`time`，代表左边想显示当前资料夹路径，右边显示时间\n\n设定完后 command line 看起来会像这样(记得执行`exec $SHELL`，设定才会生效)：\n\n![](https://cdn-images-1.medium.com/max/1600/1*MY6xGaUv0ksJni-EbeOZQg.png)\n\n左边显示当前资料夹路径，右边显示时间\n\n---\n\n如果想要有版本控制的资讯，可以在`POWERLEVEL9K_LEFT_PROMPT_ELEMENTS`加上`vcs`(vcs 为 version control system 的缩写)\n\n    # 編輯 ~/.zshrc\n    POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir vcs) # 加上 \"vcs\"\n\ncommand line 会变这样：\n\n![](https://cdn-images-1.medium.com/max/1600/1*BrzqzPH-XOjywfbIekAzEQ.png)\n\n多了 git branch 以及 git status 资讯\n\n---\n\n当你进入了一个没有写入权限的资料夹时还可以给你提醒：\n\n#加上\"dir_writable\"\nPOWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir **dir_writable** vcs)\n\n![](https://cdn-images-1.medium.com/max/1600/1*BYW3MIbGBv9DXzNU72JFKQ.png)\n\n/etc 没有写入权限，多出一个锁头提醒你\n\n---\n\n如果你的 command line 是设成 vi mode ，相信你一定碰过这个困扰，就是不晓得自己是处在 normal mode 还是 insert mode。没关系，powerlevel9k 可以帮你解决这个问题：\n\n#加上\"vi_mode\"\nPOWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir dir_writable vcs **vi_mode** )\n\n结果如下：\n\n![](https://cdn-images-1.medium.com/max/1600/1*bj90M9RvPCFZ6GNVqJUP4g.png)\n\n上图告诉我们现在在 insert mode\n\n按下`ESC`后：\n\n![](https://cdn-images-1.medium.com/max/1600/1*PCsqH7xDf3z4lXCr81QV0A.png)\n\n告诉你变 normal mode 啦~赞吧！\n\n---\n\n我自己习惯左侧的设定放一些常用基本资讯 右边放一些好用但不是每次下指令都要看的东西\n\ncommand line 右边的设定放在  `POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS`\n\n例如显示上一个指令的 return code：\n\n#加上\"status\"显示上一个指令的 return code：\nPOWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=( **status** time)\n\n如果指令没出错，linux return code 为 0 时会有个绿色小勾勾：\n\n![](https://cdn-images-1.medium.com/max/1600/1*nSS8Df1YlCwI87ICv_jM_Q.png)\n\n指令正确执行，return code 为 0\n\n如果打了错误指令会出现相对应的 return code，并且用红色底色提醒你\n\n![](https://cdn-images-1.medium.com/max/1600/1*DSV5vY-pzNOVcv4jaI-4Wg.png)\n\n指令执行错误，return code 为 127\n\n---\n\n还可以显示目前电脑的 free memory：\n\n#加上 ram，显示目前的 free memory\nPOWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status **ram** time)\n\n![](https://cdn-images-1.medium.com/max/1600/1*tgWdaWPdLSn8LMharCTOYQ.png)\n\n还有 4.61G 的记忆体可用\n\n**2017/12/30 更新： 上图的最左方有个资料夹 icon，且 git 资讯多显示了几个 icon，这用原本的设定是看不到的，需要加上这行：**\n\n    POWERLEVEL9K_MODE='nerdfont-complete'\n\n[powerlevel9k 的 wiki](https://github.com/bhilburn/powerlevel9k/wiki/Install-Instructions#option-4-install-nerd-fonts)有解释这个设定的作用，请大家使用时注意一下别忘记加上去\n\n---\n\n加上 CPU load average：\n\n#加上 load 显示 CPU 忙碌程度\nPOWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status ram **load** time)\n\n![](https://cdn-images-1.medium.com/max/1600/1*-j1gAm788RbWzRiY0MidCg.png)\n\nCPU 忙碌程度 2.45，还行\n\n显示电量：\n\nPOWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=( **battery** )\n\n![](https://cdn-images-1.medium.com/max/1600/1*48h7cUsjuzXBV8dhOjHehw.png)\n\n还可以用 6 小时又 11 分\n\n---\n\n示范了不少，但还有非常非常多东西可以用，请参考这个列表自己玩玩看[https://github.com/bhilburn/powerlevel9k#available-prompt-segments](https://github.com/bhilburn/powerlevel9k#available-prompt-segments)\n\n不过有些东西中看不中用，放太多东西也会让 command line 反应变慢，试了各种设定一阵子后，只留下了一些我觉得比较有用的，给大家参考：\n\n#左侧\nPOWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(context dir dir_writable vcs vi_mode)\n\n#右侧\nPOWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status background_jobs history ram load time)\n\n#若当前登入的帐号为你的帐号 xxx，就不用特别显示出来\nDEFAULT_USER=\"xxx\"\n\n    # 使用 nerd font 時可以顯示更多 icon。詳情請參考\n\n---\n\n#### 最后…\n\n这篇文章介绍了怎么样把自己的 command line 替换成 zsh，并且使用很厉害的 powerlevel9k theme，不过 zsh 不只是可以换酷炫的 theme 而已，更重要的是还有很多比 bash 好用的功能可以大幅提升工作效率，又可以装各种方便的 plugin，就留待有机会时再介绍啰\n\n---\n","source":"_posts/2018-05-17-超简单！Mac打造漂亮又好用的 zsh shell 环境.md","raw":"---\ntitle: 超简单！Mac打造漂亮又好用的 zsh shell 环境\ntags:\n  - 技术\n  - 工具\ndate: 2018-05-17 08:16:48\ncategories: 教程\n---\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/QQ20180517-1@2x.png)身为开发者，很大一部分的时间是在用 command line 做事，如果能把 command line 调整成好用又酷炫的模样，不只是效率提升非常多，用起来爽度也比较高,上面放了一张我自己的 item，是不是觉得高大上了许多\n\n- 本片文章适用于 MAC 开发的 developer，学习时间大概十分钟\n- shell 默认选中 ZSH，已经安装过**iTerm2，oh-my-zsh**\n- 避免搞乱你的开发环境：仅可能使用 homebrew 来安装需要的套件\n- 安装 zsh theme: **powerlevel9k**\n\n#### **安装 iTerm2：**\n\n虽然不是必要，内建的 Terminal app 也可以，不过 iTerm2 还是比较好用，下面的示范也全都是用 iTerm2,个人用的自带其实还好\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/QQ20180517-3@2x.png)\n\n#如果你从来没有用过 brew cask 的话需要先跑这行\nbrew tap caskroom/cask\n\n#安装 iTerm2\nbrew cask instal iterm2\n\n安装好以后，打开 iTerm2 检查 Report Terminal Type 的设置，路径： `Preferences > Profiles > Terminal > Report Terminal Type`\n\n设为`xterm-256color`，等等在 terminal 才能看得到漂亮的颜色\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/QQ20180517-5@2x.png)\n\n#### **修改 iTerm2 的 color scheme**\n\n这步骤很重要，预设的很丑，想要自己的 command line 看起来赏心悦目就绝对要换掉预设的\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/QQ20180517-4@2x.png)\n\n#### **安装 powerline font**\n\n因为我们要用的 theme 会用到很多的特殊 icon，所以 iTerm2 选用的字型必需要支援这种特殊 icon font。这类型的字体统称为 powerline font（另外还有加强版支援更多特殊 icon 的叫的 nerd font）\n\n没有安装的话画面会长这样，遇到 icon 会变框框问号\n\n![](https://cdn-images-1.medium.com/max/1600/1*sB3u7_aAXl6BkRy9UEygPw.png)\n\n非 powerline font\n\n装完并设定新字型后的效果：\n\n![](https://cdn-images-1.medium.com/max/1600/1*0lPAd28LbancmQuHgnDyNg.png)\n\npowerline font\n\n支援 powerline 的字型很多，我推荐**Sauce Code Pro Nerd Font Complete** 安装方式推荐直接用 brew 安装比较快又好管理\n\n安装指令：\n\n#先执行这行，才能用 homebrew 安装字型。曾经执行过的人可以跳过这个指令\nbrew tap caskroom/fonts\n\n    # 安裝指令\n    brew cask install\n\n如果想要装别的，brew 上面也有很多字型可以挑。\n\n关键字是`nerd`：\n\nbrew cask search nerd\n\n装完后，记得修改 iTerm2 字型设定否则不会生效。请改成 SauceCodePro Nerd Font 或你自己下载的字型\n\n设定路径：`Preferences > Profiles > Text > Change Font`\n\n#### **安装 oh-my-zsh**\n\n上一步装完 zsh 后，就可以开始调整我们想要的 command line 外观设定了，但是原始的 zsh 因为设定太难搞，所以多年前刚出现的时候没有受到太多关注，直到有人写了一套叫**oh-my-zsh**的 framework 来帮助大家使用 zsh，zsh 才火了起来。现在几乎所有 zsh 好用的工具都有支援 oh-my-zsh，所以当然是要装这东西\n\n安装指令：\n\n    sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n\n> 注：这会直接执行 oh-my-zsh 的有疑虑的人可以先稍微研究一下[oh-my-zsh github](https://github.com/robbyrussell/oh-my-zsh)上的，觉得放心再执行`install.sh` `install.sh`\n\n执行完以后如果没有出现什么错误讯息就代表成功了，同时会发现多了 oh-my-zsh 的资料夹  `~/.oh-my-zsh`\n\n#### **重头戏！！安装 zsh theme **[**powerlevel9k**](https://github.com/bhilburn/powerlevel9k)\n\n刚装完 oh-my-zsh 以后，预设是使用内建的 theme *robbyrussell*，多了 git 资讯，颜色也看起来比原生 bash 好一些：\n\n![](https://cdn-images-1.medium.com/max/1600/1*1TqBIUz998aoEAoepG4mbw.png)\n\n不过 oh-my-zsh 内建很多 theme，在它的[github wiki](https://github.com/robbyrussell/oh-my-zsh/wiki/themes)上有很多截图可以参考\n\n切换内建的 theme 很简单，直接修改你的`~/.zshrc`，把原本改成你想要的：`ZSH_THEME=”_robbyrussell_”`\n\n    # 編輯 ~/.zshrc\n    ZSH_THEME=”\n\n任何的 zsh 设定修改过后，还要执行以下指令才会生效\n\nexec \\$SHELL\n\n![](https://cdn-images-1.medium.com/max/1600/1*Dj2trYBv3hgFg4LOIlMtWg.png)\n\nagnoster 看起来是不是比 robbyrussell 漂亮多了？\n\n这边推荐一个超强的 theme，powerlevel9k！\n\n文章开头的图片就是撷取自[powerlevel9k 的 github](https://github.com/bhilburn/powerlevel9k)\n\n![](https://cdn-images-1.medium.com/max/1600/1*OwwhfTqbc8IUaZnCAYXt7g.gif)\n\n图片来源：[https://github.com/bhilburn/powerlevel9k](https://github.com/bhilburn/powerlevel9k)\n\npowerlevel9k 不只是像上面的示范图显示一些基本的资讯，还可以做到很屌的事情，比如像下图那样，显示 WiFi 讯号强度、笔电电池电力、CPU loading、system free memory 等等资讯在 command line\n\n![](https://cdn-images-1.medium.com/max/1600/1*Ixhmm4KVixyzZolr-OTV3w.png)\n\n图片撷取自[powerlevel9k github](https://github.com/bhilburn/powerlevel9k)\n\n#### powerlevel9k 安装方式：\n\n1.  [powerlevel9k](https://github.com/bhilburn/powerlevel9k)不是 oh-my-zsh 内建的 theme ，必须另外下载\n\n指令：\n\n    git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k\n\n2.编辑你的`~/.zshrc`，把 ZSH_THEME 设为 powerlevel9k，并设定要显示哪些东西在 command line 上：\n\n    ZSH_THEME=\"powerlevel9k/powerlevel9k\"\n\n\\# command line 左边想显示的内容\nPOWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir) # <= left prompt 设了\"dir\"\n\n\\# command line 右边想显示的内容\nPOWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(time) # <= right prompt 设了\"time\"\n\n上面的例子我们把左边设了一个`dir`，右边设了`time`，代表左边想显示当前资料夹路径，右边显示时间\n\n设定完后 command line 看起来会像这样(记得执行`exec $SHELL`，设定才会生效)：\n\n![](https://cdn-images-1.medium.com/max/1600/1*MY6xGaUv0ksJni-EbeOZQg.png)\n\n左边显示当前资料夹路径，右边显示时间\n\n---\n\n如果想要有版本控制的资讯，可以在`POWERLEVEL9K_LEFT_PROMPT_ELEMENTS`加上`vcs`(vcs 为 version control system 的缩写)\n\n    # 編輯 ~/.zshrc\n    POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir vcs) # 加上 \"vcs\"\n\ncommand line 会变这样：\n\n![](https://cdn-images-1.medium.com/max/1600/1*BrzqzPH-XOjywfbIekAzEQ.png)\n\n多了 git branch 以及 git status 资讯\n\n---\n\n当你进入了一个没有写入权限的资料夹时还可以给你提醒：\n\n#加上\"dir_writable\"\nPOWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir **dir_writable** vcs)\n\n![](https://cdn-images-1.medium.com/max/1600/1*BYW3MIbGBv9DXzNU72JFKQ.png)\n\n/etc 没有写入权限，多出一个锁头提醒你\n\n---\n\n如果你的 command line 是设成 vi mode ，相信你一定碰过这个困扰，就是不晓得自己是处在 normal mode 还是 insert mode。没关系，powerlevel9k 可以帮你解决这个问题：\n\n#加上\"vi_mode\"\nPOWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir dir_writable vcs **vi_mode** )\n\n结果如下：\n\n![](https://cdn-images-1.medium.com/max/1600/1*bj90M9RvPCFZ6GNVqJUP4g.png)\n\n上图告诉我们现在在 insert mode\n\n按下`ESC`后：\n\n![](https://cdn-images-1.medium.com/max/1600/1*PCsqH7xDf3z4lXCr81QV0A.png)\n\n告诉你变 normal mode 啦~赞吧！\n\n---\n\n我自己习惯左侧的设定放一些常用基本资讯 右边放一些好用但不是每次下指令都要看的东西\n\ncommand line 右边的设定放在  `POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS`\n\n例如显示上一个指令的 return code：\n\n#加上\"status\"显示上一个指令的 return code：\nPOWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=( **status** time)\n\n如果指令没出错，linux return code 为 0 时会有个绿色小勾勾：\n\n![](https://cdn-images-1.medium.com/max/1600/1*nSS8Df1YlCwI87ICv_jM_Q.png)\n\n指令正确执行，return code 为 0\n\n如果打了错误指令会出现相对应的 return code，并且用红色底色提醒你\n\n![](https://cdn-images-1.medium.com/max/1600/1*DSV5vY-pzNOVcv4jaI-4Wg.png)\n\n指令执行错误，return code 为 127\n\n---\n\n还可以显示目前电脑的 free memory：\n\n#加上 ram，显示目前的 free memory\nPOWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status **ram** time)\n\n![](https://cdn-images-1.medium.com/max/1600/1*tgWdaWPdLSn8LMharCTOYQ.png)\n\n还有 4.61G 的记忆体可用\n\n**2017/12/30 更新： 上图的最左方有个资料夹 icon，且 git 资讯多显示了几个 icon，这用原本的设定是看不到的，需要加上这行：**\n\n    POWERLEVEL9K_MODE='nerdfont-complete'\n\n[powerlevel9k 的 wiki](https://github.com/bhilburn/powerlevel9k/wiki/Install-Instructions#option-4-install-nerd-fonts)有解释这个设定的作用，请大家使用时注意一下别忘记加上去\n\n---\n\n加上 CPU load average：\n\n#加上 load 显示 CPU 忙碌程度\nPOWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status ram **load** time)\n\n![](https://cdn-images-1.medium.com/max/1600/1*-j1gAm788RbWzRiY0MidCg.png)\n\nCPU 忙碌程度 2.45，还行\n\n显示电量：\n\nPOWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=( **battery** )\n\n![](https://cdn-images-1.medium.com/max/1600/1*48h7cUsjuzXBV8dhOjHehw.png)\n\n还可以用 6 小时又 11 分\n\n---\n\n示范了不少，但还有非常非常多东西可以用，请参考这个列表自己玩玩看[https://github.com/bhilburn/powerlevel9k#available-prompt-segments](https://github.com/bhilburn/powerlevel9k#available-prompt-segments)\n\n不过有些东西中看不中用，放太多东西也会让 command line 反应变慢，试了各种设定一阵子后，只留下了一些我觉得比较有用的，给大家参考：\n\n#左侧\nPOWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(context dir dir_writable vcs vi_mode)\n\n#右侧\nPOWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status background_jobs history ram load time)\n\n#若当前登入的帐号为你的帐号 xxx，就不用特别显示出来\nDEFAULT_USER=\"xxx\"\n\n    # 使用 nerd font 時可以顯示更多 icon。詳情請參考\n\n---\n\n#### 最后…\n\n这篇文章介绍了怎么样把自己的 command line 替换成 zsh，并且使用很厉害的 powerlevel9k theme，不过 zsh 不只是可以换酷炫的 theme 而已，更重要的是还有很多比 bash 好用的功能可以大幅提升工作效率，又可以装各种方便的 plugin，就留待有机会时再介绍啰\n\n---\n","slug":"2018-05-17-超简单！Mac打造漂亮又好用的 zsh shell 环境","published":1,"updated":"2020-03-14T06:51:47.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvn200574k8y80zkdg7i","content":"<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/QQ20180517-1@2x.png\" alt=\"\">身为开发者，很大一部分的时间是在用 command line 做事，如果能把 command line 调整成好用又酷炫的模样，不只是效率提升非常多，用起来爽度也比较高,上面放了一张我自己的 item，是不是觉得高大上了许多</p>\n<ul>\n<li>本片文章适用于 MAC 开发的 developer，学习时间大概十分钟</li>\n<li>shell 默认选中 ZSH，已经安装过<strong>iTerm2，oh-my-zsh</strong></li>\n<li>避免搞乱你的开发环境：仅可能使用 homebrew 来安装需要的套件</li>\n<li>安装 zsh theme: <strong>powerlevel9k</strong></li>\n</ul>\n<h4 id=\"安装-iTerm2：\"><a href=\"#安装-iTerm2：\" class=\"headerlink\" title=\"安装 iTerm2：\"></a><strong>安装 iTerm2：</strong></h4><p>虽然不是必要，内建的 Terminal app 也可以，不过 iTerm2 还是比较好用，下面的示范也全都是用 iTerm2,个人用的自带其实还好</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/QQ20180517-3@2x.png\" alt=\"\"></p>\n<p>#如果你从来没有用过 brew cask 的话需要先跑这行<br>brew tap caskroom/cask</p>\n<p>#安装 iTerm2<br>brew cask instal iterm2</p>\n<p>安装好以后，打开 iTerm2 检查 Report Terminal Type 的设置，路径： <code>Preferences &gt; Profiles &gt; Terminal &gt; Report Terminal Type</code></p>\n<p>设为<code>xterm-256color</code>，等等在 terminal 才能看得到漂亮的颜色</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/QQ20180517-5@2x.png\" alt=\"\"></p>\n<h4 id=\"修改-iTerm2-的-color-scheme\"><a href=\"#修改-iTerm2-的-color-scheme\" class=\"headerlink\" title=\"修改 iTerm2 的 color scheme\"></a><strong>修改 iTerm2 的 color scheme</strong></h4><p>这步骤很重要，预设的很丑，想要自己的 command line 看起来赏心悦目就绝对要换掉预设的</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/QQ20180517-4@2x.png\" alt=\"\"></p>\n<h4 id=\"安装-powerline-font\"><a href=\"#安装-powerline-font\" class=\"headerlink\" title=\"安装 powerline font\"></a><strong>安装 powerline font</strong></h4><p>因为我们要用的 theme 会用到很多的特殊 icon，所以 iTerm2 选用的字型必需要支援这种特殊 icon font。这类型的字体统称为 powerline font（另外还有加强版支援更多特殊 icon 的叫的 nerd font）</p>\n<p>没有安装的话画面会长这样，遇到 icon 会变框框问号</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*sB3u7_aAXl6BkRy9UEygPw.png\" alt=\"\"></p>\n<p>非 powerline font</p>\n<p>装完并设定新字型后的效果：</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*0lPAd28LbancmQuHgnDyNg.png\" alt=\"\"></p>\n<p>powerline font</p>\n<p>支援 powerline 的字型很多，我推荐<strong>Sauce Code Pro Nerd Font Complete</strong> 安装方式推荐直接用 brew 安装比较快又好管理</p>\n<p>安装指令：</p>\n<p>#先执行这行，才能用 homebrew 安装字型。曾经执行过的人可以跳过这个指令<br>brew tap caskroom/fonts</p>\n<pre><code># 安裝指令\nbrew cask install</code></pre><p>如果想要装别的，brew 上面也有很多字型可以挑。</p>\n<p>关键字是<code>nerd</code>：</p>\n<p>brew cask search nerd</p>\n<p>装完后，记得修改 iTerm2 字型设定否则不会生效。请改成 SauceCodePro Nerd Font 或你自己下载的字型</p>\n<p>设定路径：<code>Preferences &gt; Profiles &gt; Text &gt; Change Font</code></p>\n<h4 id=\"安装-oh-my-zsh\"><a href=\"#安装-oh-my-zsh\" class=\"headerlink\" title=\"安装 oh-my-zsh\"></a><strong>安装 oh-my-zsh</strong></h4><p>上一步装完 zsh 后，就可以开始调整我们想要的 command line 外观设定了，但是原始的 zsh 因为设定太难搞，所以多年前刚出现的时候没有受到太多关注，直到有人写了一套叫<strong>oh-my-zsh</strong>的 framework 来帮助大家使用 zsh，zsh 才火了起来。现在几乎所有 zsh 好用的工具都有支援 oh-my-zsh，所以当然是要装这东西</p>\n<p>安装指令：</p>\n<pre><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></pre><blockquote>\n<p>注：这会直接执行 oh-my-zsh 的有疑虑的人可以先稍微研究一下<a href=\"https://github.com/robbyrussell/oh-my-zsh\" target=\"_blank\" rel=\"noopener\">oh-my-zsh github</a>上的，觉得放心再执行<code>install.sh</code> <code>install.sh</code></p>\n</blockquote>\n<p>执行完以后如果没有出现什么错误讯息就代表成功了，同时会发现多了 oh-my-zsh 的资料夹  <code>~/.oh-my-zsh</code></p>\n<h4 id=\"重头戏！！安装-zsh-theme-powerlevel9k-https-github-com-bhilburn-powerlevel9k\"><a href=\"#重头戏！！安装-zsh-theme-powerlevel9k-https-github-com-bhilburn-powerlevel9k\" class=\"headerlink\" title=\"重头戏！！安装 zsh theme **[powerlevel9k**](https://github.com/bhilburn/powerlevel9k)\"></a><strong>重头戏！！安装 zsh theme **[</strong>powerlevel9k**](<a href=\"https://github.com/bhilburn/powerlevel9k\" target=\"_blank\" rel=\"noopener\">https://github.com/bhilburn/powerlevel9k</a>)</h4><p>刚装完 oh-my-zsh 以后，预设是使用内建的 theme <em>robbyrussell</em>，多了 git 资讯，颜色也看起来比原生 bash 好一些：</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*1TqBIUz998aoEAoepG4mbw.png\" alt=\"\"></p>\n<p>不过 oh-my-zsh 内建很多 theme，在它的<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/themes\" target=\"_blank\" rel=\"noopener\">github wiki</a>上有很多截图可以参考</p>\n<p>切换内建的 theme 很简单，直接修改你的<code>~/.zshrc</code>，把原本改成你想要的：<code>ZSH_THEME=”_robbyrussell_”</code></p>\n<pre><code># 編輯 ~/.zshrc\nZSH_THEME=”</code></pre><p>任何的 zsh 设定修改过后，还要执行以下指令才会生效</p>\n<p>exec $SHELL</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*Dj2trYBv3hgFg4LOIlMtWg.png\" alt=\"\"></p>\n<p>agnoster 看起来是不是比 robbyrussell 漂亮多了？</p>\n<p>这边推荐一个超强的 theme，powerlevel9k！</p>\n<p>文章开头的图片就是撷取自<a href=\"https://github.com/bhilburn/powerlevel9k\" target=\"_blank\" rel=\"noopener\">powerlevel9k 的 github</a></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*OwwhfTqbc8IUaZnCAYXt7g.gif\" alt=\"\"></p>\n<p>图片来源：<a href=\"https://github.com/bhilburn/powerlevel9k\" target=\"_blank\" rel=\"noopener\">https://github.com/bhilburn/powerlevel9k</a></p>\n<p>powerlevel9k 不只是像上面的示范图显示一些基本的资讯，还可以做到很屌的事情，比如像下图那样，显示 WiFi 讯号强度、笔电电池电力、CPU loading、system free memory 等等资讯在 command line</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*Ixhmm4KVixyzZolr-OTV3w.png\" alt=\"\"></p>\n<p>图片撷取自<a href=\"https://github.com/bhilburn/powerlevel9k\" target=\"_blank\" rel=\"noopener\">powerlevel9k github</a></p>\n<h4 id=\"powerlevel9k-安装方式：\"><a href=\"#powerlevel9k-安装方式：\" class=\"headerlink\" title=\"powerlevel9k 安装方式：\"></a>powerlevel9k 安装方式：</h4><ol>\n<li><a href=\"https://github.com/bhilburn/powerlevel9k\" target=\"_blank\" rel=\"noopener\">powerlevel9k</a>不是 oh-my-zsh 内建的 theme ，必须另外下载</li>\n</ol>\n<p>指令：</p>\n<pre><code>git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k</code></pre><p>2.编辑你的<code>~/.zshrc</code>，把 ZSH_THEME 设为 powerlevel9k，并设定要显示哪些东西在 command line 上：</p>\n<pre><code>ZSH_THEME=&quot;powerlevel9k/powerlevel9k&quot;</code></pre><p># command line 左边想显示的内容<br>POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir) # &lt;= left prompt 设了”dir”</p>\n<p># command line 右边想显示的内容<br>POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(time) # &lt;= right prompt 设了”time”</p>\n<p>上面的例子我们把左边设了一个<code>dir</code>，右边设了<code>time</code>，代表左边想显示当前资料夹路径，右边显示时间</p>\n<p>设定完后 command line 看起来会像这样(记得执行<code>exec $SHELL</code>，设定才会生效)：</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*MY6xGaUv0ksJni-EbeOZQg.png\" alt=\"\"></p>\n<p>左边显示当前资料夹路径，右边显示时间</p>\n<hr>\n<p>如果想要有版本控制的资讯，可以在<code>POWERLEVEL9K_LEFT_PROMPT_ELEMENTS</code>加上<code>vcs</code>(vcs 为 version control system 的缩写)</p>\n<pre><code># 編輯 ~/.zshrc\nPOWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir vcs) # 加上 &quot;vcs&quot;</code></pre><p>command line 会变这样：</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*BrzqzPH-XOjywfbIekAzEQ.png\" alt=\"\"></p>\n<p>多了 git branch 以及 git status 资讯</p>\n<hr>\n<p>当你进入了一个没有写入权限的资料夹时还可以给你提醒：</p>\n<p>#加上”dir_writable”<br>POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir <strong>dir_writable</strong> vcs)</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*BYW3MIbGBv9DXzNU72JFKQ.png\" alt=\"\"></p>\n<p>/etc 没有写入权限，多出一个锁头提醒你</p>\n<hr>\n<p>如果你的 command line 是设成 vi mode ，相信你一定碰过这个困扰，就是不晓得自己是处在 normal mode 还是 insert mode。没关系，powerlevel9k 可以帮你解决这个问题：</p>\n<p>#加上”vi_mode”<br>POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir dir_writable vcs <strong>vi_mode</strong> )</p>\n<p>结果如下：</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*bj90M9RvPCFZ6GNVqJUP4g.png\" alt=\"\"></p>\n<p>上图告诉我们现在在 insert mode</p>\n<p>按下<code>ESC</code>后：</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*PCsqH7xDf3z4lXCr81QV0A.png\" alt=\"\"></p>\n<p>告诉你变 normal mode 啦~赞吧！</p>\n<hr>\n<p>我自己习惯左侧的设定放一些常用基本资讯 右边放一些好用但不是每次下指令都要看的东西</p>\n<p>command line 右边的设定放在  <code>POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS</code></p>\n<p>例如显示上一个指令的 return code：</p>\n<p>#加上”status”显示上一个指令的 return code：<br>POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=( <strong>status</strong> time)</p>\n<p>如果指令没出错，linux return code 为 0 时会有个绿色小勾勾：</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*nSS8Df1YlCwI87ICv_jM_Q.png\" alt=\"\"></p>\n<p>指令正确执行，return code 为 0</p>\n<p>如果打了错误指令会出现相对应的 return code，并且用红色底色提醒你</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*DSV5vY-pzNOVcv4jaI-4Wg.png\" alt=\"\"></p>\n<p>指令执行错误，return code 为 127</p>\n<hr>\n<p>还可以显示目前电脑的 free memory：</p>\n<p>#加上 ram，显示目前的 free memory<br>POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status <strong>ram</strong> time)</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*tgWdaWPdLSn8LMharCTOYQ.png\" alt=\"\"></p>\n<p>还有 4.61G 的记忆体可用</p>\n<p><strong>2017/12/30 更新： 上图的最左方有个资料夹 icon，且 git 资讯多显示了几个 icon，这用原本的设定是看不到的，需要加上这行：</strong></p>\n<pre><code>POWERLEVEL9K_MODE=&#39;nerdfont-complete&#39;</code></pre><p><a href=\"https://github.com/bhilburn/powerlevel9k/wiki/Install-Instructions#option-4-install-nerd-fonts\" target=\"_blank\" rel=\"noopener\">powerlevel9k 的 wiki</a>有解释这个设定的作用，请大家使用时注意一下别忘记加上去</p>\n<hr>\n<p>加上 CPU load average：</p>\n<p>#加上 load 显示 CPU 忙碌程度<br>POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status ram <strong>load</strong> time)</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*-j1gAm788RbWzRiY0MidCg.png\" alt=\"\"></p>\n<p>CPU 忙碌程度 2.45，还行</p>\n<p>显示电量：</p>\n<p>POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=( <strong>battery</strong> )</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*48h7cUsjuzXBV8dhOjHehw.png\" alt=\"\"></p>\n<p>还可以用 6 小时又 11 分</p>\n<hr>\n<p>示范了不少，但还有非常非常多东西可以用，请参考这个列表自己玩玩看<a href=\"https://github.com/bhilburn/powerlevel9k#available-prompt-segments\" target=\"_blank\" rel=\"noopener\">https://github.com/bhilburn/powerlevel9k#available-prompt-segments</a></p>\n<p>不过有些东西中看不中用，放太多东西也会让 command line 反应变慢，试了各种设定一阵子后，只留下了一些我觉得比较有用的，给大家参考：</p>\n<p>#左侧<br>POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(context dir dir_writable vcs vi_mode)</p>\n<p>#右侧<br>POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status background_jobs history ram load time)</p>\n<p>#若当前登入的帐号为你的帐号 xxx，就不用特别显示出来<br>DEFAULT_USER=”xxx”</p>\n<pre><code># 使用 nerd font 時可以顯示更多 icon。詳情請參考</code></pre><hr>\n<h4 id=\"最后…\"><a href=\"#最后…\" class=\"headerlink\" title=\"最后…\"></a>最后…</h4><p>这篇文章介绍了怎么样把自己的 command line 替换成 zsh，并且使用很厉害的 powerlevel9k theme，不过 zsh 不只是可以换酷炫的 theme 而已，更重要的是还有很多比 bash 好用的功能可以大幅提升工作效率，又可以装各种方便的 plugin，就留待有机会时再介绍啰</p>\n<hr>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/QQ20180517-1@2x.png\" alt=\"\">身为开发者，很大一部分的时间是在用 command line 做事，如果能把 command line 调整成好用又酷炫的模样，不只是效率提升非常多，用起来爽度也比较高,上面放了一张我自己的 item，是不是觉得高大上了许多</p>\n<ul>\n<li>本片文章适用于 MAC 开发的 developer，学习时间大概十分钟</li>\n<li>shell 默认选中 ZSH，已经安装过<strong>iTerm2，oh-my-zsh</strong></li>\n<li>避免搞乱你的开发环境：仅可能使用 homebrew 来安装需要的套件</li>\n<li>安装 zsh theme: <strong>powerlevel9k</strong></li>\n</ul>\n<h4 id=\"安装-iTerm2：\"><a href=\"#安装-iTerm2：\" class=\"headerlink\" title=\"安装 iTerm2：\"></a><strong>安装 iTerm2：</strong></h4><p>虽然不是必要，内建的 Terminal app 也可以，不过 iTerm2 还是比较好用，下面的示范也全都是用 iTerm2,个人用的自带其实还好</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/QQ20180517-3@2x.png\" alt=\"\"></p>\n<p>#如果你从来没有用过 brew cask 的话需要先跑这行<br>brew tap caskroom/cask</p>\n<p>#安装 iTerm2<br>brew cask instal iterm2</p>\n<p>安装好以后，打开 iTerm2 检查 Report Terminal Type 的设置，路径： <code>Preferences &gt; Profiles &gt; Terminal &gt; Report Terminal Type</code></p>\n<p>设为<code>xterm-256color</code>，等等在 terminal 才能看得到漂亮的颜色</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/QQ20180517-5@2x.png\" alt=\"\"></p>\n<h4 id=\"修改-iTerm2-的-color-scheme\"><a href=\"#修改-iTerm2-的-color-scheme\" class=\"headerlink\" title=\"修改 iTerm2 的 color scheme\"></a><strong>修改 iTerm2 的 color scheme</strong></h4><p>这步骤很重要，预设的很丑，想要自己的 command line 看起来赏心悦目就绝对要换掉预设的</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/QQ20180517-4@2x.png\" alt=\"\"></p>\n<h4 id=\"安装-powerline-font\"><a href=\"#安装-powerline-font\" class=\"headerlink\" title=\"安装 powerline font\"></a><strong>安装 powerline font</strong></h4><p>因为我们要用的 theme 会用到很多的特殊 icon，所以 iTerm2 选用的字型必需要支援这种特殊 icon font。这类型的字体统称为 powerline font（另外还有加强版支援更多特殊 icon 的叫的 nerd font）</p>\n<p>没有安装的话画面会长这样，遇到 icon 会变框框问号</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*sB3u7_aAXl6BkRy9UEygPw.png\" alt=\"\"></p>\n<p>非 powerline font</p>\n<p>装完并设定新字型后的效果：</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*0lPAd28LbancmQuHgnDyNg.png\" alt=\"\"></p>\n<p>powerline font</p>\n<p>支援 powerline 的字型很多，我推荐<strong>Sauce Code Pro Nerd Font Complete</strong> 安装方式推荐直接用 brew 安装比较快又好管理</p>\n<p>安装指令：</p>\n<p>#先执行这行，才能用 homebrew 安装字型。曾经执行过的人可以跳过这个指令<br>brew tap caskroom/fonts</p>\n<pre><code># 安裝指令\nbrew cask install</code></pre><p>如果想要装别的，brew 上面也有很多字型可以挑。</p>\n<p>关键字是<code>nerd</code>：</p>\n<p>brew cask search nerd</p>\n<p>装完后，记得修改 iTerm2 字型设定否则不会生效。请改成 SauceCodePro Nerd Font 或你自己下载的字型</p>\n<p>设定路径：<code>Preferences &gt; Profiles &gt; Text &gt; Change Font</code></p>\n<h4 id=\"安装-oh-my-zsh\"><a href=\"#安装-oh-my-zsh\" class=\"headerlink\" title=\"安装 oh-my-zsh\"></a><strong>安装 oh-my-zsh</strong></h4><p>上一步装完 zsh 后，就可以开始调整我们想要的 command line 外观设定了，但是原始的 zsh 因为设定太难搞，所以多年前刚出现的时候没有受到太多关注，直到有人写了一套叫<strong>oh-my-zsh</strong>的 framework 来帮助大家使用 zsh，zsh 才火了起来。现在几乎所有 zsh 好用的工具都有支援 oh-my-zsh，所以当然是要装这东西</p>\n<p>安装指令：</p>\n<pre><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></pre><blockquote>\n<p>注：这会直接执行 oh-my-zsh 的有疑虑的人可以先稍微研究一下<a href=\"https://github.com/robbyrussell/oh-my-zsh\" target=\"_blank\" rel=\"noopener\">oh-my-zsh github</a>上的，觉得放心再执行<code>install.sh</code> <code>install.sh</code></p>\n</blockquote>\n<p>执行完以后如果没有出现什么错误讯息就代表成功了，同时会发现多了 oh-my-zsh 的资料夹  <code>~/.oh-my-zsh</code></p>\n<h4 id=\"重头戏！！安装-zsh-theme-powerlevel9k-https-github-com-bhilburn-powerlevel9k\"><a href=\"#重头戏！！安装-zsh-theme-powerlevel9k-https-github-com-bhilburn-powerlevel9k\" class=\"headerlink\" title=\"重头戏！！安装 zsh theme **[powerlevel9k**](https://github.com/bhilburn/powerlevel9k)\"></a><strong>重头戏！！安装 zsh theme **[</strong>powerlevel9k**](<a href=\"https://github.com/bhilburn/powerlevel9k\" target=\"_blank\" rel=\"noopener\">https://github.com/bhilburn/powerlevel9k</a>)</h4><p>刚装完 oh-my-zsh 以后，预设是使用内建的 theme <em>robbyrussell</em>，多了 git 资讯，颜色也看起来比原生 bash 好一些：</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*1TqBIUz998aoEAoepG4mbw.png\" alt=\"\"></p>\n<p>不过 oh-my-zsh 内建很多 theme，在它的<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/themes\" target=\"_blank\" rel=\"noopener\">github wiki</a>上有很多截图可以参考</p>\n<p>切换内建的 theme 很简单，直接修改你的<code>~/.zshrc</code>，把原本改成你想要的：<code>ZSH_THEME=”_robbyrussell_”</code></p>\n<pre><code># 編輯 ~/.zshrc\nZSH_THEME=”</code></pre><p>任何的 zsh 设定修改过后，还要执行以下指令才会生效</p>\n<p>exec $SHELL</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*Dj2trYBv3hgFg4LOIlMtWg.png\" alt=\"\"></p>\n<p>agnoster 看起来是不是比 robbyrussell 漂亮多了？</p>\n<p>这边推荐一个超强的 theme，powerlevel9k！</p>\n<p>文章开头的图片就是撷取自<a href=\"https://github.com/bhilburn/powerlevel9k\" target=\"_blank\" rel=\"noopener\">powerlevel9k 的 github</a></p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*OwwhfTqbc8IUaZnCAYXt7g.gif\" alt=\"\"></p>\n<p>图片来源：<a href=\"https://github.com/bhilburn/powerlevel9k\" target=\"_blank\" rel=\"noopener\">https://github.com/bhilburn/powerlevel9k</a></p>\n<p>powerlevel9k 不只是像上面的示范图显示一些基本的资讯，还可以做到很屌的事情，比如像下图那样，显示 WiFi 讯号强度、笔电电池电力、CPU loading、system free memory 等等资讯在 command line</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*Ixhmm4KVixyzZolr-OTV3w.png\" alt=\"\"></p>\n<p>图片撷取自<a href=\"https://github.com/bhilburn/powerlevel9k\" target=\"_blank\" rel=\"noopener\">powerlevel9k github</a></p>\n<h4 id=\"powerlevel9k-安装方式：\"><a href=\"#powerlevel9k-安装方式：\" class=\"headerlink\" title=\"powerlevel9k 安装方式：\"></a>powerlevel9k 安装方式：</h4><ol>\n<li><a href=\"https://github.com/bhilburn/powerlevel9k\" target=\"_blank\" rel=\"noopener\">powerlevel9k</a>不是 oh-my-zsh 内建的 theme ，必须另外下载</li>\n</ol>\n<p>指令：</p>\n<pre><code>git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k</code></pre><p>2.编辑你的<code>~/.zshrc</code>，把 ZSH_THEME 设为 powerlevel9k，并设定要显示哪些东西在 command line 上：</p>\n<pre><code>ZSH_THEME=&quot;powerlevel9k/powerlevel9k&quot;</code></pre><p># command line 左边想显示的内容<br>POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir) # &lt;= left prompt 设了”dir”</p>\n<p># command line 右边想显示的内容<br>POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(time) # &lt;= right prompt 设了”time”</p>\n<p>上面的例子我们把左边设了一个<code>dir</code>，右边设了<code>time</code>，代表左边想显示当前资料夹路径，右边显示时间</p>\n<p>设定完后 command line 看起来会像这样(记得执行<code>exec $SHELL</code>，设定才会生效)：</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*MY6xGaUv0ksJni-EbeOZQg.png\" alt=\"\"></p>\n<p>左边显示当前资料夹路径，右边显示时间</p>\n<hr>\n<p>如果想要有版本控制的资讯，可以在<code>POWERLEVEL9K_LEFT_PROMPT_ELEMENTS</code>加上<code>vcs</code>(vcs 为 version control system 的缩写)</p>\n<pre><code># 編輯 ~/.zshrc\nPOWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir vcs) # 加上 &quot;vcs&quot;</code></pre><p>command line 会变这样：</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*BrzqzPH-XOjywfbIekAzEQ.png\" alt=\"\"></p>\n<p>多了 git branch 以及 git status 资讯</p>\n<hr>\n<p>当你进入了一个没有写入权限的资料夹时还可以给你提醒：</p>\n<p>#加上”dir_writable”<br>POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir <strong>dir_writable</strong> vcs)</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*BYW3MIbGBv9DXzNU72JFKQ.png\" alt=\"\"></p>\n<p>/etc 没有写入权限，多出一个锁头提醒你</p>\n<hr>\n<p>如果你的 command line 是设成 vi mode ，相信你一定碰过这个困扰，就是不晓得自己是处在 normal mode 还是 insert mode。没关系，powerlevel9k 可以帮你解决这个问题：</p>\n<p>#加上”vi_mode”<br>POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(dir dir_writable vcs <strong>vi_mode</strong> )</p>\n<p>结果如下：</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*bj90M9RvPCFZ6GNVqJUP4g.png\" alt=\"\"></p>\n<p>上图告诉我们现在在 insert mode</p>\n<p>按下<code>ESC</code>后：</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*PCsqH7xDf3z4lXCr81QV0A.png\" alt=\"\"></p>\n<p>告诉你变 normal mode 啦~赞吧！</p>\n<hr>\n<p>我自己习惯左侧的设定放一些常用基本资讯 右边放一些好用但不是每次下指令都要看的东西</p>\n<p>command line 右边的设定放在  <code>POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS</code></p>\n<p>例如显示上一个指令的 return code：</p>\n<p>#加上”status”显示上一个指令的 return code：<br>POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=( <strong>status</strong> time)</p>\n<p>如果指令没出错，linux return code 为 0 时会有个绿色小勾勾：</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*nSS8Df1YlCwI87ICv_jM_Q.png\" alt=\"\"></p>\n<p>指令正确执行，return code 为 0</p>\n<p>如果打了错误指令会出现相对应的 return code，并且用红色底色提醒你</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*DSV5vY-pzNOVcv4jaI-4Wg.png\" alt=\"\"></p>\n<p>指令执行错误，return code 为 127</p>\n<hr>\n<p>还可以显示目前电脑的 free memory：</p>\n<p>#加上 ram，显示目前的 free memory<br>POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status <strong>ram</strong> time)</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*tgWdaWPdLSn8LMharCTOYQ.png\" alt=\"\"></p>\n<p>还有 4.61G 的记忆体可用</p>\n<p><strong>2017/12/30 更新： 上图的最左方有个资料夹 icon，且 git 资讯多显示了几个 icon，这用原本的设定是看不到的，需要加上这行：</strong></p>\n<pre><code>POWERLEVEL9K_MODE=&#39;nerdfont-complete&#39;</code></pre><p><a href=\"https://github.com/bhilburn/powerlevel9k/wiki/Install-Instructions#option-4-install-nerd-fonts\" target=\"_blank\" rel=\"noopener\">powerlevel9k 的 wiki</a>有解释这个设定的作用，请大家使用时注意一下别忘记加上去</p>\n<hr>\n<p>加上 CPU load average：</p>\n<p>#加上 load 显示 CPU 忙碌程度<br>POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status ram <strong>load</strong> time)</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*-j1gAm788RbWzRiY0MidCg.png\" alt=\"\"></p>\n<p>CPU 忙碌程度 2.45，还行</p>\n<p>显示电量：</p>\n<p>POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=( <strong>battery</strong> )</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*48h7cUsjuzXBV8dhOjHehw.png\" alt=\"\"></p>\n<p>还可以用 6 小时又 11 分</p>\n<hr>\n<p>示范了不少，但还有非常非常多东西可以用，请参考这个列表自己玩玩看<a href=\"https://github.com/bhilburn/powerlevel9k#available-prompt-segments\" target=\"_blank\" rel=\"noopener\">https://github.com/bhilburn/powerlevel9k#available-prompt-segments</a></p>\n<p>不过有些东西中看不中用，放太多东西也会让 command line 反应变慢，试了各种设定一阵子后，只留下了一些我觉得比较有用的，给大家参考：</p>\n<p>#左侧<br>POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(context dir dir_writable vcs vi_mode)</p>\n<p>#右侧<br>POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status background_jobs history ram load time)</p>\n<p>#若当前登入的帐号为你的帐号 xxx，就不用特别显示出来<br>DEFAULT_USER=”xxx”</p>\n<pre><code># 使用 nerd font 時可以顯示更多 icon。詳情請參考</code></pre><hr>\n<h4 id=\"最后…\"><a href=\"#最后…\" class=\"headerlink\" title=\"最后…\"></a>最后…</h4><p>这篇文章介绍了怎么样把自己的 command line 替换成 zsh，并且使用很厉害的 powerlevel9k theme，不过 zsh 不只是可以换酷炫的 theme 而已，更重要的是还有很多比 bash 好用的功能可以大幅提升工作效率，又可以装各种方便的 plugin，就留待有机会时再介绍啰</p>\n<hr>\n"},{"title":"Vue前端框架面试问题","date":"2018-03-13T17:24:00.000Z","_content":"\n#### 1、active-class 是哪个组件的属性？嵌套路由怎么定义？\n\n> 答：vue-router 模块的 router-link 组件。\n\n#### 2、怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？\n\n答：在 router 目录下的 index.js 文件中，对 path 属性加上/:id。 [使用 router 对象的 params.id](http://xn--routerparams-ov8ss11l264ektes46i.id/)\n\n#### 3、vue-router 有哪几种导航钩子？\n\n答：三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件\n\n#### 4、v-model 是什么？怎么使用？ vue 中标签怎么绑定事件？\n\n答：可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。vue 的 model 层的 data 属性。绑定事件：\n\n#### 5、vuex 是什么？怎么使用？哪种功能场景使用它？\n\n答：vue 框架中状态管理。在 main.js 引入 store，注入。新建了一个目录 store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车\n\n#### 6、mvvm 框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？\n\n答：一个 model+view+viewModel 框架，数据模型 model，viewModel 连接两个\n\n区别：vue 数据驱动，通过数据来显示视图层而不是节点操作。\n\n场景：数据操作比较多的场景，更加便捷\n\n#### 7、说出至少 4 种 vue 当中的指令和它的用法？\n\n答：v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定\n\n#### 8、vue-router 是什么？它有哪些组件？\n\n答：vue 用来写路由一个插件。router-link、router-view\n\n#### 9、导航钩子有哪些？它们有哪些参数？\n\n答：导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave\n\n参数：有 to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种\n\n#### 10、Vue 的双向数据绑定原理是什么？\n\n答：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。\n\n具体步骤：\n\n- 第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化\n\n- 第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图\n\n- 第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:\n\n  - 1、在自身实例化时往属性订阅器(dep)里面添加自己\n  - 2、自身必须有一个 update()方法\n  - 3、待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。\n\n- 第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据 model 变更的双向绑定效果。\n\nps：10 题答案同样适合”vue data 是怎么实现的？”此面试题。\n\n#### 11、请详细说下你对 vue 生命周期的理解？\n\n答：总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。\n\n创建前/后： 在 beforeCreated 阶段，vue 实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el 还没有。\n\n载入前/后：在 beforeMount 阶段，vue 实例的\\$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。\n\n更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。\n\n销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在\n\n#### 12、请说下封装 vue 组件的过程？\n\n答：首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。\n\n然后，使用 Vue.extend 方法创建一个组件，然后使用 Vue.component 方法注册组件。子组件需要数据，可以在 props 中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用 emit 方法。\n\n#### 13、你是怎么认识 vuex 的？\n\n答：vuex 可以理解为一种开发模式或框架。比如 PHP 有 thinkphp，java 有 spring 等。 通过状态（数据源）集中管理驱动组件的变化（好比 spring 的 IOC 容器对 bean 进行集中管理）。\n\n应用级的状态集中放在 store 中； 改变状态的方式是提交 mutations，这是个同步的事物； 异步逻辑应该封装在 action 中。\n\n#### 14、vue-loader 是什么？使用它的用途有哪些？\n\n答：解析.vue 文件的一个加载器，跟 template/js/style 转换成 js 模块。\n\n用途：js 可以写 es6、style 样式可以 scss 或 less、template 可以加 jade 等\n\n#### 15、请说出 vue.cli 项目中 src 目录每个文件夹和文件的用法？\n\n答：assets 文件夹是放静态资源；components 是放组件；router 是定义路由相关的配置;view 视图；app.vue 是一个应用主组件；main.js 是入口文件\n\n#### 16、vue.cli 中怎样使用自定义的组件？有遇到过哪些问题吗？\n\n答：第一步：在 components 目录新建你的组件文件（smithButton.vue），script 一定要 export default {\n\n第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’\n\n第三步：注入到 vue 的子组件的 components 属性上面,components:{smithButton}\n\n第四步：在 template 视图 view 中使用， 问题有：smithButton 命名，使用的时候则 smith-button。\n\n#### 17、请说下具体使用 vue 的理解？\n\n答：1、使用 vue 不必担心布局更改和类名重复导致的 js 重写，因为它是靠数据驱动双向绑定，底层是通过 Object.defineProperty() 定义的数据 set、get 函数原理实现。\n\n2、组件化开发，让项目的可拓展性、移植性更好，代码重用性更高，就好像农民工建房子，拿起自己的工具包就可以开工。项目经理坐等收楼就好。\n\n3、单页应用的体验零距离接触安卓原生应用，局部组件更新界面，让用户体验更快速省时。\n\n4、js 的代码无形的规范，团队合作开发代码可阅读性更高。\n\n#### 18、你觉得哪些项目适合 vue 框架？\n\n答：1、数据信息量比较多的，反之类似企业网站就无需此框架了。\n\n2、手机 web 和 app 应用多端共用一套界面的项目，因为使用 vue.cli+webpack 后的前端目录，非常有利于项目的跨平台部署。\n\n#### 19、怎么理解 MVVM 模式的这些框架？\n\n答：1、M 就是 Model 模型层，存的一个数据对象。\n\n2、V 就是 View 视图层，所有的 html 节点在这一层。\n\n3、VM 就是 ViewModel，它通过 data 属性连接 Model 模型层，通过 el 属性连接 View 视图层。\n\n#### 20、PC 端项目你会在哪些场景使用 Vue 框架？\n\n答：上万级数据需要瀑布流更新和搜索的时候，因为数据庞大的时候，用原生的 dom 操作 js 和 html 都会有列表的 html 布局，迭代很困难。再一个 dom 节点的大面积添加会影响性能。\n\n那么 vue 为什么解决这些问题呢？\n\n第一：只需用 v-for 在 view 层一个地方遍历数据即可，无需复制一段 html 代码在 js 和 html 两个地方。\n\n第二：vue 通过 Virtual Dom 就是在 js 中模拟 DOM 对象树来优化 DOM 操作。\n\n#### 21、Less 常用特性\n\n变量(@color = #fff) 混合(Mixin) 内置函数(颜色，字符串，类型判断，数学) 循环 嵌套 运算 导入(@import)\n\n#### 22、ES6 常用特性\n\n变量定义(let 和 const,可变与不可变，const 定义对象的特殊情况) 解构赋值 模板字符串 数组新 API(例：Array.from(),entries(),values(),keys()) 箭头函数(rest 参数，扩展运算符，::绑定 this) Set 和 Map 数据结构(set 实例成员值唯一存储 key 值，map 实例存储键值对(key-value)) Promise 对象(前端异步解决方案进化史，generator 函数，async 函数) Class 语法糖(super 关键字)\n","source":"_posts/2018-03-14-Vue前端框架面试问题.md","raw":"---\ntitle: Vue前端框架面试问题\ntags:\n  - 技术\n  - 面试\ndate: 2018-03-14 01:24:00\ncategories: 面试\n---\n\n#### 1、active-class 是哪个组件的属性？嵌套路由怎么定义？\n\n> 答：vue-router 模块的 router-link 组件。\n\n#### 2、怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？\n\n答：在 router 目录下的 index.js 文件中，对 path 属性加上/:id。 [使用 router 对象的 params.id](http://xn--routerparams-ov8ss11l264ektes46i.id/)\n\n#### 3、vue-router 有哪几种导航钩子？\n\n答：三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件\n\n#### 4、v-model 是什么？怎么使用？ vue 中标签怎么绑定事件？\n\n答：可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。vue 的 model 层的 data 属性。绑定事件：\n\n#### 5、vuex 是什么？怎么使用？哪种功能场景使用它？\n\n答：vue 框架中状态管理。在 main.js 引入 store，注入。新建了一个目录 store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车\n\n#### 6、mvvm 框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？\n\n答：一个 model+view+viewModel 框架，数据模型 model，viewModel 连接两个\n\n区别：vue 数据驱动，通过数据来显示视图层而不是节点操作。\n\n场景：数据操作比较多的场景，更加便捷\n\n#### 7、说出至少 4 种 vue 当中的指令和它的用法？\n\n答：v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定\n\n#### 8、vue-router 是什么？它有哪些组件？\n\n答：vue 用来写路由一个插件。router-link、router-view\n\n#### 9、导航钩子有哪些？它们有哪些参数？\n\n答：导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave\n\n参数：有 to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种\n\n#### 10、Vue 的双向数据绑定原理是什么？\n\n答：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。\n\n具体步骤：\n\n- 第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化\n\n- 第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图\n\n- 第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:\n\n  - 1、在自身实例化时往属性订阅器(dep)里面添加自己\n  - 2、自身必须有一个 update()方法\n  - 3、待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。\n\n- 第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据 model 变更的双向绑定效果。\n\nps：10 题答案同样适合”vue data 是怎么实现的？”此面试题。\n\n#### 11、请详细说下你对 vue 生命周期的理解？\n\n答：总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。\n\n创建前/后： 在 beforeCreated 阶段，vue 实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el 还没有。\n\n载入前/后：在 beforeMount 阶段，vue 实例的\\$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。\n\n更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。\n\n销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在\n\n#### 12、请说下封装 vue 组件的过程？\n\n答：首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。\n\n然后，使用 Vue.extend 方法创建一个组件，然后使用 Vue.component 方法注册组件。子组件需要数据，可以在 props 中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用 emit 方法。\n\n#### 13、你是怎么认识 vuex 的？\n\n答：vuex 可以理解为一种开发模式或框架。比如 PHP 有 thinkphp，java 有 spring 等。 通过状态（数据源）集中管理驱动组件的变化（好比 spring 的 IOC 容器对 bean 进行集中管理）。\n\n应用级的状态集中放在 store 中； 改变状态的方式是提交 mutations，这是个同步的事物； 异步逻辑应该封装在 action 中。\n\n#### 14、vue-loader 是什么？使用它的用途有哪些？\n\n答：解析.vue 文件的一个加载器，跟 template/js/style 转换成 js 模块。\n\n用途：js 可以写 es6、style 样式可以 scss 或 less、template 可以加 jade 等\n\n#### 15、请说出 vue.cli 项目中 src 目录每个文件夹和文件的用法？\n\n答：assets 文件夹是放静态资源；components 是放组件；router 是定义路由相关的配置;view 视图；app.vue 是一个应用主组件；main.js 是入口文件\n\n#### 16、vue.cli 中怎样使用自定义的组件？有遇到过哪些问题吗？\n\n答：第一步：在 components 目录新建你的组件文件（smithButton.vue），script 一定要 export default {\n\n第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’\n\n第三步：注入到 vue 的子组件的 components 属性上面,components:{smithButton}\n\n第四步：在 template 视图 view 中使用， 问题有：smithButton 命名，使用的时候则 smith-button。\n\n#### 17、请说下具体使用 vue 的理解？\n\n答：1、使用 vue 不必担心布局更改和类名重复导致的 js 重写，因为它是靠数据驱动双向绑定，底层是通过 Object.defineProperty() 定义的数据 set、get 函数原理实现。\n\n2、组件化开发，让项目的可拓展性、移植性更好，代码重用性更高，就好像农民工建房子，拿起自己的工具包就可以开工。项目经理坐等收楼就好。\n\n3、单页应用的体验零距离接触安卓原生应用，局部组件更新界面，让用户体验更快速省时。\n\n4、js 的代码无形的规范，团队合作开发代码可阅读性更高。\n\n#### 18、你觉得哪些项目适合 vue 框架？\n\n答：1、数据信息量比较多的，反之类似企业网站就无需此框架了。\n\n2、手机 web 和 app 应用多端共用一套界面的项目，因为使用 vue.cli+webpack 后的前端目录，非常有利于项目的跨平台部署。\n\n#### 19、怎么理解 MVVM 模式的这些框架？\n\n答：1、M 就是 Model 模型层，存的一个数据对象。\n\n2、V 就是 View 视图层，所有的 html 节点在这一层。\n\n3、VM 就是 ViewModel，它通过 data 属性连接 Model 模型层，通过 el 属性连接 View 视图层。\n\n#### 20、PC 端项目你会在哪些场景使用 Vue 框架？\n\n答：上万级数据需要瀑布流更新和搜索的时候，因为数据庞大的时候，用原生的 dom 操作 js 和 html 都会有列表的 html 布局，迭代很困难。再一个 dom 节点的大面积添加会影响性能。\n\n那么 vue 为什么解决这些问题呢？\n\n第一：只需用 v-for 在 view 层一个地方遍历数据即可，无需复制一段 html 代码在 js 和 html 两个地方。\n\n第二：vue 通过 Virtual Dom 就是在 js 中模拟 DOM 对象树来优化 DOM 操作。\n\n#### 21、Less 常用特性\n\n变量(@color = #fff) 混合(Mixin) 内置函数(颜色，字符串，类型判断，数学) 循环 嵌套 运算 导入(@import)\n\n#### 22、ES6 常用特性\n\n变量定义(let 和 const,可变与不可变，const 定义对象的特殊情况) 解构赋值 模板字符串 数组新 API(例：Array.from(),entries(),values(),keys()) 箭头函数(rest 参数，扩展运算符，::绑定 this) Set 和 Map 数据结构(set 实例成员值唯一存储 key 值，map 实例存储键值对(key-value)) Promise 对象(前端异步解决方案进化史，generator 函数，async 函数) Class 语法糖(super 关键字)\n","slug":"2018-03-14-Vue前端框架面试问题","published":1,"updated":"2020-03-14T06:50:42.262Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvn3005a4k8yetv952y0","content":"<h4 id=\"1、active-class-是哪个组件的属性？嵌套路由怎么定义？\"><a href=\"#1、active-class-是哪个组件的属性？嵌套路由怎么定义？\" class=\"headerlink\" title=\"1、active-class 是哪个组件的属性？嵌套路由怎么定义？\"></a>1、active-class 是哪个组件的属性？嵌套路由怎么定义？</h4><blockquote>\n<p>答：vue-router 模块的 router-link 组件。</p>\n</blockquote>\n<h4 id=\"2、怎么定义-vue-router-的动态路由？怎么获取传过来的动态参数？\"><a href=\"#2、怎么定义-vue-router-的动态路由？怎么获取传过来的动态参数？\" class=\"headerlink\" title=\"2、怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？\"></a>2、怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？</h4><p>答：在 router 目录下的 index.js 文件中，对 path 属性加上/:id。 <a href=\"http://xn--routerparams-ov8ss11l264ektes46i.id/\" target=\"_blank\" rel=\"noopener\">使用 router 对象的 params.id</a></p>\n<h4 id=\"3、vue-router-有哪几种导航钩子？\"><a href=\"#3、vue-router-有哪几种导航钩子？\" class=\"headerlink\" title=\"3、vue-router 有哪几种导航钩子？\"></a>3、vue-router 有哪几种导航钩子？</h4><p>答：三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件</p>\n<h4 id=\"4、v-model-是什么？怎么使用？-vue-中标签怎么绑定事件？\"><a href=\"#4、v-model-是什么？怎么使用？-vue-中标签怎么绑定事件？\" class=\"headerlink\" title=\"4、v-model 是什么？怎么使用？ vue 中标签怎么绑定事件？\"></a>4、v-model 是什么？怎么使用？ vue 中标签怎么绑定事件？</h4><p>答：可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。vue 的 model 层的 data 属性。绑定事件：</p>\n<h4 id=\"5、vuex-是什么？怎么使用？哪种功能场景使用它？\"><a href=\"#5、vuex-是什么？怎么使用？哪种功能场景使用它？\" class=\"headerlink\" title=\"5、vuex 是什么？怎么使用？哪种功能场景使用它？\"></a>5、vuex 是什么？怎么使用？哪种功能场景使用它？</h4><p>答：vue 框架中状态管理。在 main.js 引入 store，注入。新建了一个目录 store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p>\n<h4 id=\"6、mvvm-框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？\"><a href=\"#6、mvvm-框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？\" class=\"headerlink\" title=\"6、mvvm 框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？\"></a>6、mvvm 框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？</h4><p>答：一个 model+view+viewModel 框架，数据模型 model，viewModel 连接两个</p>\n<p>区别：vue 数据驱动，通过数据来显示视图层而不是节点操作。</p>\n<p>场景：数据操作比较多的场景，更加便捷</p>\n<h4 id=\"7、说出至少-4-种-vue-当中的指令和它的用法？\"><a href=\"#7、说出至少-4-种-vue-当中的指令和它的用法？\" class=\"headerlink\" title=\"7、说出至少 4 种 vue 当中的指令和它的用法？\"></a>7、说出至少 4 种 vue 当中的指令和它的用法？</h4><p>答：v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定</p>\n<h4 id=\"8、vue-router-是什么？它有哪些组件？\"><a href=\"#8、vue-router-是什么？它有哪些组件？\" class=\"headerlink\" title=\"8、vue-router 是什么？它有哪些组件？\"></a>8、vue-router 是什么？它有哪些组件？</h4><p>答：vue 用来写路由一个插件。router-link、router-view</p>\n<h4 id=\"9、导航钩子有哪些？它们有哪些参数？\"><a href=\"#9、导航钩子有哪些？它们有哪些参数？\" class=\"headerlink\" title=\"9、导航钩子有哪些？它们有哪些参数？\"></a>9、导航钩子有哪些？它们有哪些参数？</h4><p>答：导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave</p>\n<p>参数：有 to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种</p>\n<h4 id=\"10、Vue-的双向数据绑定原理是什么？\"><a href=\"#10、Vue-的双向数据绑定原理是什么？\" class=\"headerlink\" title=\"10、Vue 的双向数据绑定原理是什么？\"></a>10、Vue 的双向数据绑定原理是什么？</h4><p>答：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>\n<p>具体步骤：</p>\n<ul>\n<li><p>第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</p>\n</li>\n<li><p>第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p>\n</li>\n<li><p>第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:</p>\n<ul>\n<li>1、在自身实例化时往属性订阅器(dep)里面添加自己</li>\n<li>2、自身必须有一个 update()方法</li>\n<li>3、待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。</li>\n</ul>\n</li>\n<li><p>第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。</p>\n</li>\n</ul>\n<p>ps：10 题答案同样适合”vue data 是怎么实现的？”此面试题。</p>\n<h4 id=\"11、请详细说下你对-vue-生命周期的理解？\"><a href=\"#11、请详细说下你对-vue-生命周期的理解？\" class=\"headerlink\" title=\"11、请详细说下你对 vue 生命周期的理解？\"></a>11、请详细说下你对 vue 生命周期的理解？</h4><p>答：总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p>\n<p>创建前/后： 在 beforeCreated 阶段，vue 实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el 还没有。</p>\n<p>载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。</p>\n<p>更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。</p>\n<p>销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在</p>\n<h4 id=\"12、请说下封装-vue-组件的过程？\"><a href=\"#12、请说下封装-vue-组件的过程？\" class=\"headerlink\" title=\"12、请说下封装 vue 组件的过程？\"></a>12、请说下封装 vue 组件的过程？</h4><p>答：首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。</p>\n<p>然后，使用 Vue.extend 方法创建一个组件，然后使用 Vue.component 方法注册组件。子组件需要数据，可以在 props 中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用 emit 方法。</p>\n<h4 id=\"13、你是怎么认识-vuex-的？\"><a href=\"#13、你是怎么认识-vuex-的？\" class=\"headerlink\" title=\"13、你是怎么认识 vuex 的？\"></a>13、你是怎么认识 vuex 的？</h4><p>答：vuex 可以理解为一种开发模式或框架。比如 PHP 有 thinkphp，java 有 spring 等。 通过状态（数据源）集中管理驱动组件的变化（好比 spring 的 IOC 容器对 bean 进行集中管理）。</p>\n<p>应用级的状态集中放在 store 中； 改变状态的方式是提交 mutations，这是个同步的事物； 异步逻辑应该封装在 action 中。</p>\n<h4 id=\"14、vue-loader-是什么？使用它的用途有哪些？\"><a href=\"#14、vue-loader-是什么？使用它的用途有哪些？\" class=\"headerlink\" title=\"14、vue-loader 是什么？使用它的用途有哪些？\"></a>14、vue-loader 是什么？使用它的用途有哪些？</h4><p>答：解析.vue 文件的一个加载器，跟 template/js/style 转换成 js 模块。</p>\n<p>用途：js 可以写 es6、style 样式可以 scss 或 less、template 可以加 jade 等</p>\n<h4 id=\"15、请说出-vue-cli-项目中-src-目录每个文件夹和文件的用法？\"><a href=\"#15、请说出-vue-cli-项目中-src-目录每个文件夹和文件的用法？\" class=\"headerlink\" title=\"15、请说出 vue.cli 项目中 src 目录每个文件夹和文件的用法？\"></a>15、请说出 vue.cli 项目中 src 目录每个文件夹和文件的用法？</h4><p>答：assets 文件夹是放静态资源；components 是放组件；router 是定义路由相关的配置;view 视图；app.vue 是一个应用主组件；main.js 是入口文件</p>\n<h4 id=\"16、vue-cli-中怎样使用自定义的组件？有遇到过哪些问题吗？\"><a href=\"#16、vue-cli-中怎样使用自定义的组件？有遇到过哪些问题吗？\" class=\"headerlink\" title=\"16、vue.cli 中怎样使用自定义的组件？有遇到过哪些问题吗？\"></a>16、vue.cli 中怎样使用自定义的组件？有遇到过哪些问题吗？</h4><p>答：第一步：在 components 目录新建你的组件文件（smithButton.vue），script 一定要 export default {</p>\n<p>第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’</p>\n<p>第三步：注入到 vue 的子组件的 components 属性上面,components:{smithButton}</p>\n<p>第四步：在 template 视图 view 中使用， 问题有：smithButton 命名，使用的时候则 smith-button。</p>\n<h4 id=\"17、请说下具体使用-vue-的理解？\"><a href=\"#17、请说下具体使用-vue-的理解？\" class=\"headerlink\" title=\"17、请说下具体使用 vue 的理解？\"></a>17、请说下具体使用 vue 的理解？</h4><p>答：1、使用 vue 不必担心布局更改和类名重复导致的 js 重写，因为它是靠数据驱动双向绑定，底层是通过 Object.defineProperty() 定义的数据 set、get 函数原理实现。</p>\n<p>2、组件化开发，让项目的可拓展性、移植性更好，代码重用性更高，就好像农民工建房子，拿起自己的工具包就可以开工。项目经理坐等收楼就好。</p>\n<p>3、单页应用的体验零距离接触安卓原生应用，局部组件更新界面，让用户体验更快速省时。</p>\n<p>4、js 的代码无形的规范，团队合作开发代码可阅读性更高。</p>\n<h4 id=\"18、你觉得哪些项目适合-vue-框架？\"><a href=\"#18、你觉得哪些项目适合-vue-框架？\" class=\"headerlink\" title=\"18、你觉得哪些项目适合 vue 框架？\"></a>18、你觉得哪些项目适合 vue 框架？</h4><p>答：1、数据信息量比较多的，反之类似企业网站就无需此框架了。</p>\n<p>2、手机 web 和 app 应用多端共用一套界面的项目，因为使用 vue.cli+webpack 后的前端目录，非常有利于项目的跨平台部署。</p>\n<h4 id=\"19、怎么理解-MVVM-模式的这些框架？\"><a href=\"#19、怎么理解-MVVM-模式的这些框架？\" class=\"headerlink\" title=\"19、怎么理解 MVVM 模式的这些框架？\"></a>19、怎么理解 MVVM 模式的这些框架？</h4><p>答：1、M 就是 Model 模型层，存的一个数据对象。</p>\n<p>2、V 就是 View 视图层，所有的 html 节点在这一层。</p>\n<p>3、VM 就是 ViewModel，它通过 data 属性连接 Model 模型层，通过 el 属性连接 View 视图层。</p>\n<h4 id=\"20、PC-端项目你会在哪些场景使用-Vue-框架？\"><a href=\"#20、PC-端项目你会在哪些场景使用-Vue-框架？\" class=\"headerlink\" title=\"20、PC 端项目你会在哪些场景使用 Vue 框架？\"></a>20、PC 端项目你会在哪些场景使用 Vue 框架？</h4><p>答：上万级数据需要瀑布流更新和搜索的时候，因为数据庞大的时候，用原生的 dom 操作 js 和 html 都会有列表的 html 布局，迭代很困难。再一个 dom 节点的大面积添加会影响性能。</p>\n<p>那么 vue 为什么解决这些问题呢？</p>\n<p>第一：只需用 v-for 在 view 层一个地方遍历数据即可，无需复制一段 html 代码在 js 和 html 两个地方。</p>\n<p>第二：vue 通过 Virtual Dom 就是在 js 中模拟 DOM 对象树来优化 DOM 操作。</p>\n<h4 id=\"21、Less-常用特性\"><a href=\"#21、Less-常用特性\" class=\"headerlink\" title=\"21、Less 常用特性\"></a>21、Less 常用特性</h4><p>变量(@color = #fff) 混合(Mixin) 内置函数(颜色，字符串，类型判断，数学) 循环 嵌套 运算 导入(@import)</p>\n<h4 id=\"22、ES6-常用特性\"><a href=\"#22、ES6-常用特性\" class=\"headerlink\" title=\"22、ES6 常用特性\"></a>22、ES6 常用特性</h4><p>变量定义(let 和 const,可变与不可变，const 定义对象的特殊情况) 解构赋值 模板字符串 数组新 API(例：Array.from(),entries(),values(),keys()) 箭头函数(rest 参数，扩展运算符，::绑定 this) Set 和 Map 数据结构(set 实例成员值唯一存储 key 值，map 实例存储键值对(key-value)) Promise 对象(前端异步解决方案进化史，generator 函数，async 函数) Class 语法糖(super 关键字)</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h4 id=\"1、active-class-是哪个组件的属性？嵌套路由怎么定义？\"><a href=\"#1、active-class-是哪个组件的属性？嵌套路由怎么定义？\" class=\"headerlink\" title=\"1、active-class 是哪个组件的属性？嵌套路由怎么定义？\"></a>1、active-class 是哪个组件的属性？嵌套路由怎么定义？</h4><blockquote>\n<p>答：vue-router 模块的 router-link 组件。</p>\n</blockquote>\n<h4 id=\"2、怎么定义-vue-router-的动态路由？怎么获取传过来的动态参数？\"><a href=\"#2、怎么定义-vue-router-的动态路由？怎么获取传过来的动态参数？\" class=\"headerlink\" title=\"2、怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？\"></a>2、怎么定义 vue-router 的动态路由？怎么获取传过来的动态参数？</h4><p>答：在 router 目录下的 index.js 文件中，对 path 属性加上/:id。 <a href=\"http://xn--routerparams-ov8ss11l264ektes46i.id/\" target=\"_blank\" rel=\"noopener\">使用 router 对象的 params.id</a></p>\n<h4 id=\"3、vue-router-有哪几种导航钩子？\"><a href=\"#3、vue-router-有哪几种导航钩子？\" class=\"headerlink\" title=\"3、vue-router 有哪几种导航钩子？\"></a>3、vue-router 有哪几种导航钩子？</h4><p>答：三种，一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。第二种：组件内的钩子；第三种：单独路由独享组件</p>\n<h4 id=\"4、v-model-是什么？怎么使用？-vue-中标签怎么绑定事件？\"><a href=\"#4、v-model-是什么？怎么使用？-vue-中标签怎么绑定事件？\" class=\"headerlink\" title=\"4、v-model 是什么？怎么使用？ vue 中标签怎么绑定事件？\"></a>4、v-model 是什么？怎么使用？ vue 中标签怎么绑定事件？</h4><p>答：可以实现双向绑定，指令（v-class、v-for、v-if、v-show、v-on）。vue 的 model 层的 data 属性。绑定事件：</p>\n<h4 id=\"5、vuex-是什么？怎么使用？哪种功能场景使用它？\"><a href=\"#5、vuex-是什么？怎么使用？哪种功能场景使用它？\" class=\"headerlink\" title=\"5、vuex 是什么？怎么使用？哪种功能场景使用它？\"></a>5、vuex 是什么？怎么使用？哪种功能场景使用它？</h4><p>答：vue 框架中状态管理。在 main.js 引入 store，注入。新建了一个目录 store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p>\n<h4 id=\"6、mvvm-框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？\"><a href=\"#6、mvvm-框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？\" class=\"headerlink\" title=\"6、mvvm 框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？\"></a>6、mvvm 框架是什么？它和其它框架（jquery）的区别是什么？哪些场景适合？</h4><p>答：一个 model+view+viewModel 框架，数据模型 model，viewModel 连接两个</p>\n<p>区别：vue 数据驱动，通过数据来显示视图层而不是节点操作。</p>\n<p>场景：数据操作比较多的场景，更加便捷</p>\n<h4 id=\"7、说出至少-4-种-vue-当中的指令和它的用法？\"><a href=\"#7、说出至少-4-种-vue-当中的指令和它的用法？\" class=\"headerlink\" title=\"7、说出至少 4 种 vue 当中的指令和它的用法？\"></a>7、说出至少 4 种 vue 当中的指令和它的用法？</h4><p>答：v-if：判断是否隐藏；v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定</p>\n<h4 id=\"8、vue-router-是什么？它有哪些组件？\"><a href=\"#8、vue-router-是什么？它有哪些组件？\" class=\"headerlink\" title=\"8、vue-router 是什么？它有哪些组件？\"></a>8、vue-router 是什么？它有哪些组件？</h4><p>答：vue 用来写路由一个插件。router-link、router-view</p>\n<h4 id=\"9、导航钩子有哪些？它们有哪些参数？\"><a href=\"#9、导航钩子有哪些？它们有哪些参数？\" class=\"headerlink\" title=\"9、导航钩子有哪些？它们有哪些参数？\"></a>9、导航钩子有哪些？它们有哪些参数？</h4><p>答：导航钩子有：a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave</p>\n<p>参数：有 to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种</p>\n<h4 id=\"10、Vue-的双向数据绑定原理是什么？\"><a href=\"#10、Vue-的双向数据绑定原理是什么？\" class=\"headerlink\" title=\"10、Vue 的双向数据绑定原理是什么？\"></a>10、Vue 的双向数据绑定原理是什么？</h4><p>答：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>\n<p>具体步骤：</p>\n<ul>\n<li><p>第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</p>\n</li>\n<li><p>第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p>\n</li>\n<li><p>第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:</p>\n<ul>\n<li>1、在自身实例化时往属性订阅器(dep)里面添加自己</li>\n<li>2、自身必须有一个 update()方法</li>\n<li>3、待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。</li>\n</ul>\n</li>\n<li><p>第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。</p>\n</li>\n</ul>\n<p>ps：10 题答案同样适合”vue data 是怎么实现的？”此面试题。</p>\n<h4 id=\"11、请详细说下你对-vue-生命周期的理解？\"><a href=\"#11、请详细说下你对-vue-生命周期的理解？\" class=\"headerlink\" title=\"11、请详细说下你对 vue 生命周期的理解？\"></a>11、请详细说下你对 vue 生命周期的理解？</h4><p>答：总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p>\n<p>创建前/后： 在 beforeCreated 阶段，vue 实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el 还没有。</p>\n<p>载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。</p>\n<p>更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。</p>\n<p>销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在</p>\n<h4 id=\"12、请说下封装-vue-组件的过程？\"><a href=\"#12、请说下封装-vue-组件的过程？\" class=\"headerlink\" title=\"12、请说下封装 vue 组件的过程？\"></a>12、请说下封装 vue 组件的过程？</h4><p>答：首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。</p>\n<p>然后，使用 Vue.extend 方法创建一个组件，然后使用 Vue.component 方法注册组件。子组件需要数据，可以在 props 中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用 emit 方法。</p>\n<h4 id=\"13、你是怎么认识-vuex-的？\"><a href=\"#13、你是怎么认识-vuex-的？\" class=\"headerlink\" title=\"13、你是怎么认识 vuex 的？\"></a>13、你是怎么认识 vuex 的？</h4><p>答：vuex 可以理解为一种开发模式或框架。比如 PHP 有 thinkphp，java 有 spring 等。 通过状态（数据源）集中管理驱动组件的变化（好比 spring 的 IOC 容器对 bean 进行集中管理）。</p>\n<p>应用级的状态集中放在 store 中； 改变状态的方式是提交 mutations，这是个同步的事物； 异步逻辑应该封装在 action 中。</p>\n<h4 id=\"14、vue-loader-是什么？使用它的用途有哪些？\"><a href=\"#14、vue-loader-是什么？使用它的用途有哪些？\" class=\"headerlink\" title=\"14、vue-loader 是什么？使用它的用途有哪些？\"></a>14、vue-loader 是什么？使用它的用途有哪些？</h4><p>答：解析.vue 文件的一个加载器，跟 template/js/style 转换成 js 模块。</p>\n<p>用途：js 可以写 es6、style 样式可以 scss 或 less、template 可以加 jade 等</p>\n<h4 id=\"15、请说出-vue-cli-项目中-src-目录每个文件夹和文件的用法？\"><a href=\"#15、请说出-vue-cli-项目中-src-目录每个文件夹和文件的用法？\" class=\"headerlink\" title=\"15、请说出 vue.cli 项目中 src 目录每个文件夹和文件的用法？\"></a>15、请说出 vue.cli 项目中 src 目录每个文件夹和文件的用法？</h4><p>答：assets 文件夹是放静态资源；components 是放组件；router 是定义路由相关的配置;view 视图；app.vue 是一个应用主组件；main.js 是入口文件</p>\n<h4 id=\"16、vue-cli-中怎样使用自定义的组件？有遇到过哪些问题吗？\"><a href=\"#16、vue-cli-中怎样使用自定义的组件？有遇到过哪些问题吗？\" class=\"headerlink\" title=\"16、vue.cli 中怎样使用自定义的组件？有遇到过哪些问题吗？\"></a>16、vue.cli 中怎样使用自定义的组件？有遇到过哪些问题吗？</h4><p>答：第一步：在 components 目录新建你的组件文件（smithButton.vue），script 一定要 export default {</p>\n<p>第二步：在需要用的页面（组件）中导入：import smithButton from ‘../components/smithButton.vue’</p>\n<p>第三步：注入到 vue 的子组件的 components 属性上面,components:{smithButton}</p>\n<p>第四步：在 template 视图 view 中使用， 问题有：smithButton 命名，使用的时候则 smith-button。</p>\n<h4 id=\"17、请说下具体使用-vue-的理解？\"><a href=\"#17、请说下具体使用-vue-的理解？\" class=\"headerlink\" title=\"17、请说下具体使用 vue 的理解？\"></a>17、请说下具体使用 vue 的理解？</h4><p>答：1、使用 vue 不必担心布局更改和类名重复导致的 js 重写，因为它是靠数据驱动双向绑定，底层是通过 Object.defineProperty() 定义的数据 set、get 函数原理实现。</p>\n<p>2、组件化开发，让项目的可拓展性、移植性更好，代码重用性更高，就好像农民工建房子，拿起自己的工具包就可以开工。项目经理坐等收楼就好。</p>\n<p>3、单页应用的体验零距离接触安卓原生应用，局部组件更新界面，让用户体验更快速省时。</p>\n<p>4、js 的代码无形的规范，团队合作开发代码可阅读性更高。</p>\n<h4 id=\"18、你觉得哪些项目适合-vue-框架？\"><a href=\"#18、你觉得哪些项目适合-vue-框架？\" class=\"headerlink\" title=\"18、你觉得哪些项目适合 vue 框架？\"></a>18、你觉得哪些项目适合 vue 框架？</h4><p>答：1、数据信息量比较多的，反之类似企业网站就无需此框架了。</p>\n<p>2、手机 web 和 app 应用多端共用一套界面的项目，因为使用 vue.cli+webpack 后的前端目录，非常有利于项目的跨平台部署。</p>\n<h4 id=\"19、怎么理解-MVVM-模式的这些框架？\"><a href=\"#19、怎么理解-MVVM-模式的这些框架？\" class=\"headerlink\" title=\"19、怎么理解 MVVM 模式的这些框架？\"></a>19、怎么理解 MVVM 模式的这些框架？</h4><p>答：1、M 就是 Model 模型层，存的一个数据对象。</p>\n<p>2、V 就是 View 视图层，所有的 html 节点在这一层。</p>\n<p>3、VM 就是 ViewModel，它通过 data 属性连接 Model 模型层，通过 el 属性连接 View 视图层。</p>\n<h4 id=\"20、PC-端项目你会在哪些场景使用-Vue-框架？\"><a href=\"#20、PC-端项目你会在哪些场景使用-Vue-框架？\" class=\"headerlink\" title=\"20、PC 端项目你会在哪些场景使用 Vue 框架？\"></a>20、PC 端项目你会在哪些场景使用 Vue 框架？</h4><p>答：上万级数据需要瀑布流更新和搜索的时候，因为数据庞大的时候，用原生的 dom 操作 js 和 html 都会有列表的 html 布局，迭代很困难。再一个 dom 节点的大面积添加会影响性能。</p>\n<p>那么 vue 为什么解决这些问题呢？</p>\n<p>第一：只需用 v-for 在 view 层一个地方遍历数据即可，无需复制一段 html 代码在 js 和 html 两个地方。</p>\n<p>第二：vue 通过 Virtual Dom 就是在 js 中模拟 DOM 对象树来优化 DOM 操作。</p>\n<h4 id=\"21、Less-常用特性\"><a href=\"#21、Less-常用特性\" class=\"headerlink\" title=\"21、Less 常用特性\"></a>21、Less 常用特性</h4><p>变量(@color = #fff) 混合(Mixin) 内置函数(颜色，字符串，类型判断，数学) 循环 嵌套 运算 导入(@import)</p>\n<h4 id=\"22、ES6-常用特性\"><a href=\"#22、ES6-常用特性\" class=\"headerlink\" title=\"22、ES6 常用特性\"></a>22、ES6 常用特性</h4><p>变量定义(let 和 const,可变与不可变，const 定义对象的特殊情况) 解构赋值 模板字符串 数组新 API(例：Array.from(),entries(),values(),keys()) 箭头函数(rest 参数，扩展运算符，::绑定 this) Set 和 Map 数据结构(set 实例成员值唯一存储 key 值，map 实例存储键值对(key-value)) Promise 对象(前端异步解决方案进化史，generator 函数，async 函数) Class 语法糖(super 关键字)</p>\n"},{"layout":"post","title":"如何上传自己的UI组件包","date":"2019-10-11T16:00:00.000Z","top":true,"_content":"\n# 开篇\n\n> 西风吹老洞庭波，一夜湘君白发多。\n> 醉后不知天在水，满船清梦压星河。\n\n## 前言\n\n**身为程序员,还没有自己的包,总感觉缺点什么,女朋友和包至少占一样吧.正如上战场没有扛枪的士兵,吃饭少了筷子一样,令人心情不愉悦.同时经常会有面试官会问一个犀利的问题,你有自己开源项目么?你写过公司自己的 UI 组件么?如同雷劈,总觉得比别人矮一截,那么今天就以[hekr-ui](https://hy.hekr.me/hk-ui/web/index.html)为例,介绍一下如何打造自己的 UI 库吧**\n\n- [文档地址](https://hy.hekr.me/hk-ui/web/index.html)\n- [项目源码](https://github.com/xkloveme/hk-ui)\n\n## 选型\n\n> 我们的目标是构建一个以`Vue`为基础基于`element-ui`的 UI 框架\n\n- 文档选用 `Vuepress` 构建,简单便捷\n- 打包选择 `gitlab CI` ,本文以 `travis` 为例\n- 初始化采用`vue-cli 3.0`、`pug`和`sass`等相关依赖和插件(自行探索)\n\n## 目的\n\n1. 快速构建属于 ❤️ 自己`npm`库\n2. 熟悉打包 📦 命令及其语法\n3. 熟练掌握自动化 👷 构建\n4. 为社区贡献自己一份脚印 👣\n\n# 初步构思\n\n## 启动一个项目\n\n### 1.初始化一个项目\n\n> 这里推荐使用[`Vue CLI`](https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create) 来进行快速构建\n\n![初始化.jpg](https://s2.ax1x.com/2019/10/10/uThubn.jpg)\n\n```bash\nvue create hekr-ui\n```\n\n我们选择默认配置就可以了\n\n### 2.关联代码到你的库\n\n> `git`可以很好对代码版本进行管理\n\n- 当你初始化库时\n\n```bash\necho \"# hekr-ui\" >> README.md\ngit init\ngit add README.md\ngit commit -m \"first commit\"\ngit remote add origin https://github.com/xkloveme/hekr-ui.git\ngit push -u origin master\n```\n\n- 关联本地库时\n\n```bash\ngit remote add origin https://github.com/xkloveme/hekr-ui.git\ngit push -u origin master\n```\n\n当然我们选择第二种.记得把`node_modules`忽略\n\n## 配置你的项目\n\n### 1.添加相关依赖\n\n> 本文以`yarn`为主,当然`npm`也是 👌OK 的\n\n我们以`vuepress`为主编写文档,当然这是非必须的,如果您只想发一个包,可以省略此步,必要的`demo`和测试会有极大的方便\n\n```bash\n# 将 VuePress 作为一个本地依赖安装\nyarn add -D vuepress # 或者：npm install -D vuepress\n\n# 新建一个 docs 文件夹\nmkdir docs\n\n# 新建一个 markdown 文件\necho '# Hello VuePress!' > docs/README.md\n\n# 开始写作\nnpx vuepress dev docs\n```\n\n接着，在 `package.json` 里加一些脚本:\n\n```json\n{\n  \"scripts\": {\n    \"docs:dev\": \"vuepress dev docs\",\n    \"docs:build\": \"vuepress build docs\"\n  }\n}\n```\n\n然后就可以开始写作了:\n\n```bash\nyarn docs:dev # 或者：npm run docs:dev\n```\n\n要生成静态的 HTML 文件，运行：\n\n```bash\nyarn docs:build # 或者：npm run docs:build\n```\n\n添加其他依赖,常用语法\n\n```bash\n// 安装指定包\nyarn add ***\n// 安装所有包,注意和npm的区别\nyarn\n```\n\n注意 ⚠️ 这两者的区别`dependencies`和`devDependencies`\n\n1. `--save` 将依赖的名称、版本要求添加到 `dependencies`\n2. `--save-dev` 将依赖的名称、版本要求添加到 `devDependencies`\n\n### 2.一些约定俗成的目录结构\n\n- 在使用`vuepress`开发时,约定了一些目录结构\n\n```docs\n.\n├── docs\n│   ├── .vuepress (可选的)\n│   │   ├── components (可选的)\n│   │   ├── theme (可选的)\n│   │   │   └── Layout.vue\n│   │   ├── public (可选的)\n│   │   ├── styles (可选的)\n│   │   │   ├── index.styl\n│   │   │   └── palette.styl\n│   │   ├── templates (可选的, 谨慎配置)\n│   │   │   ├── dev.html\n│   │   │   └── ssr.html\n│   │   ├── config.js (可选的)\n│   │   └── enhanceApp.js (可选的)\n│   │\n│   ├── README.md\n│   ├── guide\n│   │   └── README.md\n│   └── config.md\n│\n└── package.json\n```\n\n- 在本项目中目录结构为\n\n![结构.jpg](https://s2.ax1x.com/2019/10/10/uThQU0.jpg)\n\n```tree\ntemplate\n├─ docs\n│    └─ .vuepress            # 配置、演示组件、静态资源\n│    │    ├─ compnents        # 演示组件\n│    │    |    └─ demo          # demo组件\n│    │    ├─ public           # 静态资源\n│    │    |    └─ images        # 图片文件\n│    │    |    └─ scss          # 样式文件\n│    │    ├─ config.js        # 配置文件\n│    │    └─ enhanceApp       # 引入文件\n|    ├─ compnent             # 组件md文件\n|    └─ README              # 首页md\n├─ packages\n│    ├─ index.js             # 组件index.js\n│    └─ hk-countup           # countup组件\n├─ public\n└─ package.json\n```\n\n### 3.修改你的`package.json`文件\n\n> 这个文件是项目的灵魂 👻,是最重要的文件之一.具体字段参考[packagejson](http://javascript.ruanyifeng.com/nodejs/packagejson.html)\n\n![目录.jpg](https://s2.ax1x.com/2019/10/10/uThl5V.jpg)\n\n- 修改主入口`main`\n\n> `main`字段指定了加载的入口文件，`require('moduleName')`就会加载这个文件。这个字段的默认值是模块根目录下面的`index.js`。\n\n```bash\n\"main\": \"dist/hekr-ui.umd.min.js\"\n```\n\n> 你可以通过下面的命令将一个单独的入口构建为一个库\n\n```bash\nvue-cli-service build --target lib --name myLib [entry]\n```\n\n运行结果为:\n\n```bash\n  File                     Size                     Gzipped\n\n  dist/hk-ui.umd.min.js    13.64 KiB                5.31 KiB\n  dist/hk-ui.umd.js        43.87 KiB                11.37 KiB\n  dist/hk-ui.common.js     43.49 KiB                11.25 KiB\n  dist/hk-ui.css           0.54 KiB                 0.29 KiB\n```\n\n- 添加`lib`命令\n\n```bash\n    \"lib\": \"vue-cli-service build --target lib --name hk-ui --dest dist ./src/packages/index.js\"\n```\n\n这个入口可以是一个 `.js` 或一个 `.vue` 文件。如果没有指定入口，则会使用 `src/App.vue`。\n\n构建一个库会输出：\n\n- `dist/myLib.common.js`：一个给打包器用的 CommonJS 包 (不幸的是，webpack 目前还并没有支持 ES modules 输出格式的包)\n\n- `dist/myLib.umd.js`：一个直接给浏览器或 AMD loader 使用的 UMD 包\n\n- `dist/myLib.umd.min.js`：压缩后的 UMD 构建版本\n\n- `dist/myLib.css`：提取出来的 CSS 文件 (可以通过在 `vue.config.js` 中设置 `css: { extract: false }` 强制内联)\n\n### 4. 文档配置\n\n![文档.jpg](https://s2.ax1x.com/2019/10/10/uTIdVs.jpg)\n\n> 项目启动之后需要我们配置我们的`vuepress`\n\n```js\n/*\n * @describe: 配置文件 config.js\n * @Author: superDragon\n * @Date: 2019-10-09 23:25:49\n * @LastEditors: superDragon\n * @LastEditTime: 2019-10-10 18:49:25\n */\nlet component = [\"hk-button\", \"hk-card\"];\nmodule.exports = {\n  base: \"/hekr-ui/\",\n  title: \"hekr-ui\",\n  description: \"hekr-ui\",\n  themeConfig: {\n    nav: [\n      { text: \"首页\", link: \"/\" },\n      {\n        text: \"组件\",\n        link: \"/component/hk-button\"\n      }\n    ],\n    sidebar: {\n      \"/component/\": component\n    },\n    lastUpdated: \"最后更新\",\n    repo: \"\",\n    repoLabel: \"GitLab\"\n  },\n  plugins: [],\n  serviceWorker: true\n};\n```\n\n当我们能够成功运行下面时\n\n```js\n    \"docs:dev\": \"vuepress dev docs\",\n    \"docs:build\": \"vuepress build docs\",\n```\n\n- 本地运行\n\n\n    yarn docs:dev # 或者：npm run docs:dev\n\n- 打包\n\n\n    yarn docs:build # 或者：npm run docs:build\n\n### 5.持续集成\n\n> 以`GitHub Pages` 和`Travis CI` 为例\n\n- 打包后放置在项目的 `docs` 目录中的`dist`中,注意 ⚠️ 区分；\n- 使用的是默认的构建输出位置；\n- VuePress 以本地依赖的形式被安装到你的项目中，并且配置了如下的 npm scripts:\n\n```json\n{\n  \"scripts\": {\n    \"docs:build\": \"vuepress build docs\"\n  }\n}\n```\n\n1. 在 `docs/.vuepress/config.js` 中设置正确的 `base`这里我们设置`/hekr-ui/` 🌿。\n\n   如果你打算发布到 `https://<USERNAME>.github.io/`，则可以省略这一步，因为 `base` 默认即是 `\"/\"`。\n\n   如果你打算发布到 `https://<USERNAME>.github.io/<REPO>/`（也就是说你的仓库在 `https://github.com/<USERNAME>/<REPO>`），则将 `base` 设置为 `\"/<REPO>/\"`。\n\n2. 在你的项目中，创建一个如下的 `.travis.yml` 文件 📃:\n\n```yml\nlanguage: node_js\nnode_js:\n  - \"8\"\n\ninstall:\n  - npm install\n\nscript:\n  - npm run build\n\nafter_success:\n  - cd ./docs/.vuepress/dist\n  - git init\n  - git config --global user.name \"${U_NAME}\"\n  - git config --global user.email \"${U_EMAIL}\"\n  - git add .\n  - git commit -m \"👷‍Automatically update from travis-ci 👷‍\"\n  - git push --quiet --force  \"https://${GH_TOKEN}@${GH_REF}\" master:${P_BRANCH}\n\nbranches:\n  only:\n    - master\n\nnotifications:\n  email:\n    - xkloveme@163.com\n  on_failure: always\n\n# Note: you should set Environment Variables here or 'Settings' on travis-ci.org\nenv:\n  global:\n    # 我将其添加到了travis-ci的环境变量中\n    - U_NAME: xkloveme\n    - U_EMAIL: xkloveme@qq.com\n    - P_BRANCH: gh-pages\n    - GH_REF: github.com/xkloveme/vue-v-xxx.git\n```\n\n3. 注册`github`、`travis`和配置`travis`相关,启用构建,自行`Google`[传送门](https://docs.travis-ci.com/user/deployment/pages/)\n4. 更多配置参考[vuepress 部署](https://vuepress.vuejs.org/zh/guide/deploy.html)\n\n# 实践\n\n## 完善组件并打包\n\n> 以编写`hk-button`组件为例,并导出\n\n1. 添加组件及导出\n\n```vue\n<template lang=\"pug\">\nel-tooltip(effect=\"dark\" v-if=\"tips\" :content=\"tips\" placement=\"top-start\")\n  el-button.hk-button(:size=\"size\" :type=\"type\" v-bind=\"$attrs\" @click=\"handleClick\")\n    slot\nel-button.hk-button(:size=\"size\" v-else :type=\"type\" v-bind=\"$attrs\" @click=\"handleClick\")\n  slot\n</template>\n\n<script>\nimport { Debounce } from \"./../util/debounce\";\nexport default {\n  name: \"hk-button\",\n  props: {\n    type: {\n      type: String,\n      default: \"primary\"\n    },\n    size: {\n      type: String,\n      default: \"medium\"\n    },\n    tips: {\n      type: String,\n      default: null\n    }\n  },\n  methods: {\n    handleClick: Debounce(function(e) {\n      this.$emit(\"click\", e);\n    }, 200)\n  }\n};\n</script>\n\n<style lang=\"scss\">\n.hk-button {\n  i + span {\n    padding-left: 10px;\n  }\n}\n</style>\n```\n\n2. 导出组件\n\n```js\nimport HkButton from \"./hk-button\";\n\nexport default HkButton;\n```\n\n3. 导出为`install`\n\n```js\n/*\n * @describe: 主入口,导出install\n * @Author: superDragon\n * @Date: 2019-10-09 23:21:11\n * @LastEditors: superDragon\n * @LastEditTime: 2019-10-10 19:09:57\n */\nimport HkButton from \"./hk-button\";\nimport HKcard from \"./hk-card\";\n\nconst install = Vue => {\n  Vue.component(HkButton.name, HkButton);\n  Vue.component(HKcard.name, HKcard);\n};\n\nif (typeof window !== \"undefined\" && window.Vue) {\n  install(window.Vue);\n}\n\nexport { HkButton, HKcard };\n\nexport default { install };\n```\n\n## 上传自己的`npm`\n\n### 注册 ®️ 并切换到官方`npm`源\n\n![换源.jpg](https://s2.ax1x.com/2019/10/10/uTjYY4.jpg)\n\n### 注册登陆`npm`\n\n```bash\nnpm adduser        //回车后,弹出Username:\nUsername:          //输入你在官网注册时的用户名,回车\nPassword:          //输入官网注册的密码,密码看不见,请确保你输的密码正确, 回车\nEmail:(this is Public)    //输入官网注册时绑定的邮箱,回车\n```\n\n### 上传\n\n```bash\nnpm publish        //此处上传命令,回车\n```\n\n![发布.jpg](https://s2.ax1x.com/2019/10/10/uTvZB6.jpg)\n\n这样一个`hekr-ui`就发布完成了\n\n### 撤销\n\n> 24 小时内撤销也是很简单的.\n\n```bash\nnpm unpublish --force\n```\n\n# 大功告成\n\n> Let's enjoy the taste of life, if we feel, the more we will live longer.\n\n觉得不错的话给个`star`\n\n- 本文演示库地址[hekr-ui](https://github.com/xkloveme/hekr-ui)\n- [文档地址](https://hy.hekr.me/hk-ui/web/index.html)\n- [项目源码](https://github.com/xkloveme/hk-ui)\n","source":"_posts/2019-10-12-如何上传自己的UI组件包.md","raw":"---\nlayout: post\ntitle: 如何上传自己的UI组件包\ndate: 2019-10-12\ntags: [vue, GitHub, 教程]\ntop: true\ncategories: 前端\n---\n\n# 开篇\n\n> 西风吹老洞庭波，一夜湘君白发多。\n> 醉后不知天在水，满船清梦压星河。\n\n## 前言\n\n**身为程序员,还没有自己的包,总感觉缺点什么,女朋友和包至少占一样吧.正如上战场没有扛枪的士兵,吃饭少了筷子一样,令人心情不愉悦.同时经常会有面试官会问一个犀利的问题,你有自己开源项目么?你写过公司自己的 UI 组件么?如同雷劈,总觉得比别人矮一截,那么今天就以[hekr-ui](https://hy.hekr.me/hk-ui/web/index.html)为例,介绍一下如何打造自己的 UI 库吧**\n\n- [文档地址](https://hy.hekr.me/hk-ui/web/index.html)\n- [项目源码](https://github.com/xkloveme/hk-ui)\n\n## 选型\n\n> 我们的目标是构建一个以`Vue`为基础基于`element-ui`的 UI 框架\n\n- 文档选用 `Vuepress` 构建,简单便捷\n- 打包选择 `gitlab CI` ,本文以 `travis` 为例\n- 初始化采用`vue-cli 3.0`、`pug`和`sass`等相关依赖和插件(自行探索)\n\n## 目的\n\n1. 快速构建属于 ❤️ 自己`npm`库\n2. 熟悉打包 📦 命令及其语法\n3. 熟练掌握自动化 👷 构建\n4. 为社区贡献自己一份脚印 👣\n\n# 初步构思\n\n## 启动一个项目\n\n### 1.初始化一个项目\n\n> 这里推荐使用[`Vue CLI`](https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create) 来进行快速构建\n\n![初始化.jpg](https://s2.ax1x.com/2019/10/10/uThubn.jpg)\n\n```bash\nvue create hekr-ui\n```\n\n我们选择默认配置就可以了\n\n### 2.关联代码到你的库\n\n> `git`可以很好对代码版本进行管理\n\n- 当你初始化库时\n\n```bash\necho \"# hekr-ui\" >> README.md\ngit init\ngit add README.md\ngit commit -m \"first commit\"\ngit remote add origin https://github.com/xkloveme/hekr-ui.git\ngit push -u origin master\n```\n\n- 关联本地库时\n\n```bash\ngit remote add origin https://github.com/xkloveme/hekr-ui.git\ngit push -u origin master\n```\n\n当然我们选择第二种.记得把`node_modules`忽略\n\n## 配置你的项目\n\n### 1.添加相关依赖\n\n> 本文以`yarn`为主,当然`npm`也是 👌OK 的\n\n我们以`vuepress`为主编写文档,当然这是非必须的,如果您只想发一个包,可以省略此步,必要的`demo`和测试会有极大的方便\n\n```bash\n# 将 VuePress 作为一个本地依赖安装\nyarn add -D vuepress # 或者：npm install -D vuepress\n\n# 新建一个 docs 文件夹\nmkdir docs\n\n# 新建一个 markdown 文件\necho '# Hello VuePress!' > docs/README.md\n\n# 开始写作\nnpx vuepress dev docs\n```\n\n接着，在 `package.json` 里加一些脚本:\n\n```json\n{\n  \"scripts\": {\n    \"docs:dev\": \"vuepress dev docs\",\n    \"docs:build\": \"vuepress build docs\"\n  }\n}\n```\n\n然后就可以开始写作了:\n\n```bash\nyarn docs:dev # 或者：npm run docs:dev\n```\n\n要生成静态的 HTML 文件，运行：\n\n```bash\nyarn docs:build # 或者：npm run docs:build\n```\n\n添加其他依赖,常用语法\n\n```bash\n// 安装指定包\nyarn add ***\n// 安装所有包,注意和npm的区别\nyarn\n```\n\n注意 ⚠️ 这两者的区别`dependencies`和`devDependencies`\n\n1. `--save` 将依赖的名称、版本要求添加到 `dependencies`\n2. `--save-dev` 将依赖的名称、版本要求添加到 `devDependencies`\n\n### 2.一些约定俗成的目录结构\n\n- 在使用`vuepress`开发时,约定了一些目录结构\n\n```docs\n.\n├── docs\n│   ├── .vuepress (可选的)\n│   │   ├── components (可选的)\n│   │   ├── theme (可选的)\n│   │   │   └── Layout.vue\n│   │   ├── public (可选的)\n│   │   ├── styles (可选的)\n│   │   │   ├── index.styl\n│   │   │   └── palette.styl\n│   │   ├── templates (可选的, 谨慎配置)\n│   │   │   ├── dev.html\n│   │   │   └── ssr.html\n│   │   ├── config.js (可选的)\n│   │   └── enhanceApp.js (可选的)\n│   │\n│   ├── README.md\n│   ├── guide\n│   │   └── README.md\n│   └── config.md\n│\n└── package.json\n```\n\n- 在本项目中目录结构为\n\n![结构.jpg](https://s2.ax1x.com/2019/10/10/uThQU0.jpg)\n\n```tree\ntemplate\n├─ docs\n│    └─ .vuepress            # 配置、演示组件、静态资源\n│    │    ├─ compnents        # 演示组件\n│    │    |    └─ demo          # demo组件\n│    │    ├─ public           # 静态资源\n│    │    |    └─ images        # 图片文件\n│    │    |    └─ scss          # 样式文件\n│    │    ├─ config.js        # 配置文件\n│    │    └─ enhanceApp       # 引入文件\n|    ├─ compnent             # 组件md文件\n|    └─ README              # 首页md\n├─ packages\n│    ├─ index.js             # 组件index.js\n│    └─ hk-countup           # countup组件\n├─ public\n└─ package.json\n```\n\n### 3.修改你的`package.json`文件\n\n> 这个文件是项目的灵魂 👻,是最重要的文件之一.具体字段参考[packagejson](http://javascript.ruanyifeng.com/nodejs/packagejson.html)\n\n![目录.jpg](https://s2.ax1x.com/2019/10/10/uThl5V.jpg)\n\n- 修改主入口`main`\n\n> `main`字段指定了加载的入口文件，`require('moduleName')`就会加载这个文件。这个字段的默认值是模块根目录下面的`index.js`。\n\n```bash\n\"main\": \"dist/hekr-ui.umd.min.js\"\n```\n\n> 你可以通过下面的命令将一个单独的入口构建为一个库\n\n```bash\nvue-cli-service build --target lib --name myLib [entry]\n```\n\n运行结果为:\n\n```bash\n  File                     Size                     Gzipped\n\n  dist/hk-ui.umd.min.js    13.64 KiB                5.31 KiB\n  dist/hk-ui.umd.js        43.87 KiB                11.37 KiB\n  dist/hk-ui.common.js     43.49 KiB                11.25 KiB\n  dist/hk-ui.css           0.54 KiB                 0.29 KiB\n```\n\n- 添加`lib`命令\n\n```bash\n    \"lib\": \"vue-cli-service build --target lib --name hk-ui --dest dist ./src/packages/index.js\"\n```\n\n这个入口可以是一个 `.js` 或一个 `.vue` 文件。如果没有指定入口，则会使用 `src/App.vue`。\n\n构建一个库会输出：\n\n- `dist/myLib.common.js`：一个给打包器用的 CommonJS 包 (不幸的是，webpack 目前还并没有支持 ES modules 输出格式的包)\n\n- `dist/myLib.umd.js`：一个直接给浏览器或 AMD loader 使用的 UMD 包\n\n- `dist/myLib.umd.min.js`：压缩后的 UMD 构建版本\n\n- `dist/myLib.css`：提取出来的 CSS 文件 (可以通过在 `vue.config.js` 中设置 `css: { extract: false }` 强制内联)\n\n### 4. 文档配置\n\n![文档.jpg](https://s2.ax1x.com/2019/10/10/uTIdVs.jpg)\n\n> 项目启动之后需要我们配置我们的`vuepress`\n\n```js\n/*\n * @describe: 配置文件 config.js\n * @Author: superDragon\n * @Date: 2019-10-09 23:25:49\n * @LastEditors: superDragon\n * @LastEditTime: 2019-10-10 18:49:25\n */\nlet component = [\"hk-button\", \"hk-card\"];\nmodule.exports = {\n  base: \"/hekr-ui/\",\n  title: \"hekr-ui\",\n  description: \"hekr-ui\",\n  themeConfig: {\n    nav: [\n      { text: \"首页\", link: \"/\" },\n      {\n        text: \"组件\",\n        link: \"/component/hk-button\"\n      }\n    ],\n    sidebar: {\n      \"/component/\": component\n    },\n    lastUpdated: \"最后更新\",\n    repo: \"\",\n    repoLabel: \"GitLab\"\n  },\n  plugins: [],\n  serviceWorker: true\n};\n```\n\n当我们能够成功运行下面时\n\n```js\n    \"docs:dev\": \"vuepress dev docs\",\n    \"docs:build\": \"vuepress build docs\",\n```\n\n- 本地运行\n\n\n    yarn docs:dev # 或者：npm run docs:dev\n\n- 打包\n\n\n    yarn docs:build # 或者：npm run docs:build\n\n### 5.持续集成\n\n> 以`GitHub Pages` 和`Travis CI` 为例\n\n- 打包后放置在项目的 `docs` 目录中的`dist`中,注意 ⚠️ 区分；\n- 使用的是默认的构建输出位置；\n- VuePress 以本地依赖的形式被安装到你的项目中，并且配置了如下的 npm scripts:\n\n```json\n{\n  \"scripts\": {\n    \"docs:build\": \"vuepress build docs\"\n  }\n}\n```\n\n1. 在 `docs/.vuepress/config.js` 中设置正确的 `base`这里我们设置`/hekr-ui/` 🌿。\n\n   如果你打算发布到 `https://<USERNAME>.github.io/`，则可以省略这一步，因为 `base` 默认即是 `\"/\"`。\n\n   如果你打算发布到 `https://<USERNAME>.github.io/<REPO>/`（也就是说你的仓库在 `https://github.com/<USERNAME>/<REPO>`），则将 `base` 设置为 `\"/<REPO>/\"`。\n\n2. 在你的项目中，创建一个如下的 `.travis.yml` 文件 📃:\n\n```yml\nlanguage: node_js\nnode_js:\n  - \"8\"\n\ninstall:\n  - npm install\n\nscript:\n  - npm run build\n\nafter_success:\n  - cd ./docs/.vuepress/dist\n  - git init\n  - git config --global user.name \"${U_NAME}\"\n  - git config --global user.email \"${U_EMAIL}\"\n  - git add .\n  - git commit -m \"👷‍Automatically update from travis-ci 👷‍\"\n  - git push --quiet --force  \"https://${GH_TOKEN}@${GH_REF}\" master:${P_BRANCH}\n\nbranches:\n  only:\n    - master\n\nnotifications:\n  email:\n    - xkloveme@163.com\n  on_failure: always\n\n# Note: you should set Environment Variables here or 'Settings' on travis-ci.org\nenv:\n  global:\n    # 我将其添加到了travis-ci的环境变量中\n    - U_NAME: xkloveme\n    - U_EMAIL: xkloveme@qq.com\n    - P_BRANCH: gh-pages\n    - GH_REF: github.com/xkloveme/vue-v-xxx.git\n```\n\n3. 注册`github`、`travis`和配置`travis`相关,启用构建,自行`Google`[传送门](https://docs.travis-ci.com/user/deployment/pages/)\n4. 更多配置参考[vuepress 部署](https://vuepress.vuejs.org/zh/guide/deploy.html)\n\n# 实践\n\n## 完善组件并打包\n\n> 以编写`hk-button`组件为例,并导出\n\n1. 添加组件及导出\n\n```vue\n<template lang=\"pug\">\nel-tooltip(effect=\"dark\" v-if=\"tips\" :content=\"tips\" placement=\"top-start\")\n  el-button.hk-button(:size=\"size\" :type=\"type\" v-bind=\"$attrs\" @click=\"handleClick\")\n    slot\nel-button.hk-button(:size=\"size\" v-else :type=\"type\" v-bind=\"$attrs\" @click=\"handleClick\")\n  slot\n</template>\n\n<script>\nimport { Debounce } from \"./../util/debounce\";\nexport default {\n  name: \"hk-button\",\n  props: {\n    type: {\n      type: String,\n      default: \"primary\"\n    },\n    size: {\n      type: String,\n      default: \"medium\"\n    },\n    tips: {\n      type: String,\n      default: null\n    }\n  },\n  methods: {\n    handleClick: Debounce(function(e) {\n      this.$emit(\"click\", e);\n    }, 200)\n  }\n};\n</script>\n\n<style lang=\"scss\">\n.hk-button {\n  i + span {\n    padding-left: 10px;\n  }\n}\n</style>\n```\n\n2. 导出组件\n\n```js\nimport HkButton from \"./hk-button\";\n\nexport default HkButton;\n```\n\n3. 导出为`install`\n\n```js\n/*\n * @describe: 主入口,导出install\n * @Author: superDragon\n * @Date: 2019-10-09 23:21:11\n * @LastEditors: superDragon\n * @LastEditTime: 2019-10-10 19:09:57\n */\nimport HkButton from \"./hk-button\";\nimport HKcard from \"./hk-card\";\n\nconst install = Vue => {\n  Vue.component(HkButton.name, HkButton);\n  Vue.component(HKcard.name, HKcard);\n};\n\nif (typeof window !== \"undefined\" && window.Vue) {\n  install(window.Vue);\n}\n\nexport { HkButton, HKcard };\n\nexport default { install };\n```\n\n## 上传自己的`npm`\n\n### 注册 ®️ 并切换到官方`npm`源\n\n![换源.jpg](https://s2.ax1x.com/2019/10/10/uTjYY4.jpg)\n\n### 注册登陆`npm`\n\n```bash\nnpm adduser        //回车后,弹出Username:\nUsername:          //输入你在官网注册时的用户名,回车\nPassword:          //输入官网注册的密码,密码看不见,请确保你输的密码正确, 回车\nEmail:(this is Public)    //输入官网注册时绑定的邮箱,回车\n```\n\n### 上传\n\n```bash\nnpm publish        //此处上传命令,回车\n```\n\n![发布.jpg](https://s2.ax1x.com/2019/10/10/uTvZB6.jpg)\n\n这样一个`hekr-ui`就发布完成了\n\n### 撤销\n\n> 24 小时内撤销也是很简单的.\n\n```bash\nnpm unpublish --force\n```\n\n# 大功告成\n\n> Let's enjoy the taste of life, if we feel, the more we will live longer.\n\n觉得不错的话给个`star`\n\n- 本文演示库地址[hekr-ui](https://github.com/xkloveme/hekr-ui)\n- [文档地址](https://hy.hekr.me/hk-ui/web/index.html)\n- [项目源码](https://github.com/xkloveme/hk-ui)\n","slug":"2019-10-12-如何上传自己的UI组件包","published":1,"updated":"2020-03-14T11:54:01.546Z","comments":1,"photos":[],"link":"","_id":"ck7u2pvn4005d4k8yfbnl6reo","content":"<h1 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h1><blockquote>\n<p>西风吹老洞庭波，一夜湘君白发多。<br>醉后不知天在水，满船清梦压星河。</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><strong>身为程序员,还没有自己的包,总感觉缺点什么,女朋友和包至少占一样吧.正如上战场没有扛枪的士兵,吃饭少了筷子一样,令人心情不愉悦.同时经常会有面试官会问一个犀利的问题,你有自己开源项目么?你写过公司自己的 UI 组件么?如同雷劈,总觉得比别人矮一截,那么今天就以<a href=\"https://hy.hekr.me/hk-ui/web/index.html\" target=\"_blank\" rel=\"noopener\">hekr-ui</a>为例,介绍一下如何打造自己的 UI 库吧</strong></p>\n<ul>\n<li><a href=\"https://hy.hekr.me/hk-ui/web/index.html\" target=\"_blank\" rel=\"noopener\">文档地址</a></li>\n<li><a href=\"https://github.com/xkloveme/hk-ui\" target=\"_blank\" rel=\"noopener\">项目源码</a></li>\n</ul>\n<h2 id=\"选型\"><a href=\"#选型\" class=\"headerlink\" title=\"选型\"></a>选型</h2><blockquote>\n<p>我们的目标是构建一个以<code>Vue</code>为基础基于<code>element-ui</code>的 UI 框架</p>\n</blockquote>\n<ul>\n<li>文档选用 <code>Vuepress</code> 构建,简单便捷</li>\n<li>打包选择 <code>gitlab CI</code> ,本文以 <code>travis</code> 为例</li>\n<li>初始化采用<code>vue-cli 3.0</code>、<code>pug</code>和<code>sass</code>等相关依赖和插件(自行探索)</li>\n</ul>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><ol>\n<li>快速构建属于 ❤️ 自己<code>npm</code>库</li>\n<li>熟悉打包 📦 命令及其语法</li>\n<li>熟练掌握自动化 👷 构建</li>\n<li>为社区贡献自己一份脚印 👣</li>\n</ol>\n<h1 id=\"初步构思\"><a href=\"#初步构思\" class=\"headerlink\" title=\"初步构思\"></a>初步构思</h1><h2 id=\"启动一个项目\"><a href=\"#启动一个项目\" class=\"headerlink\" title=\"启动一个项目\"></a>启动一个项目</h2><h3 id=\"1-初始化一个项目\"><a href=\"#1-初始化一个项目\" class=\"headerlink\" title=\"1.初始化一个项目\"></a>1.初始化一个项目</h3><blockquote>\n<p>这里推荐使用<a href=\"https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create\" target=\"_blank\" rel=\"noopener\"><code>Vue CLI</code></a> 来进行快速构建</p>\n</blockquote>\n<p><img src=\"https://s2.ax1x.com/2019/10/10/uThubn.jpg\" alt=\"初始化.jpg\"></p>\n<pre class=\" language-bash\"><code class=\"language-bash\">vue create hekr-ui</code></pre>\n<p>我们选择默认配置就可以了</p>\n<h3 id=\"2-关联代码到你的库\"><a href=\"#2-关联代码到你的库\" class=\"headerlink\" title=\"2.关联代码到你的库\"></a>2.关联代码到你的库</h3><blockquote>\n<p><code>git</code>可以很好对代码版本进行管理</p>\n</blockquote>\n<ul>\n<li>当你初始化库时</li>\n</ul>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">echo</span> <span class=\"token string\">\"# hekr-ui\"</span> <span class=\"token operator\">>></span> README.md\n<span class=\"token function\">git</span> init\n<span class=\"token function\">git</span> add README.md\n<span class=\"token function\">git</span> commit -m <span class=\"token string\">\"first commit\"</span>\n<span class=\"token function\">git</span> remote add origin https://github.com/xkloveme/hekr-ui.git\n<span class=\"token function\">git</span> push -u origin master</code></pre>\n<ul>\n<li>关联本地库时</li>\n</ul>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> remote add origin https://github.com/xkloveme/hekr-ui.git\n<span class=\"token function\">git</span> push -u origin master</code></pre>\n<p>当然我们选择第二种.记得把<code>node_modules</code>忽略</p>\n<h2 id=\"配置你的项目\"><a href=\"#配置你的项目\" class=\"headerlink\" title=\"配置你的项目\"></a>配置你的项目</h2><h3 id=\"1-添加相关依赖\"><a href=\"#1-添加相关依赖\" class=\"headerlink\" title=\"1.添加相关依赖\"></a>1.添加相关依赖</h3><blockquote>\n<p>本文以<code>yarn</code>为主,当然<code>npm</code>也是 👌OK 的</p>\n</blockquote>\n<p>我们以<code>vuepress</code>为主编写文档,当然这是非必须的,如果您只想发一个包,可以省略此步,必要的<code>demo</code>和测试会有极大的方便</p>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># 将 VuePress 作为一个本地依赖安装</span>\nyarn add -D vuepress <span class=\"token comment\" spellcheck=\"true\"># 或者：npm install -D vuepress</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 新建一个 docs 文件夹</span>\n<span class=\"token function\">mkdir</span> docs\n\n<span class=\"token comment\" spellcheck=\"true\"># 新建一个 markdown 文件</span>\n<span class=\"token keyword\">echo</span> <span class=\"token string\">'# Hello VuePress!'</span> <span class=\"token operator\">></span> docs/README.md\n\n<span class=\"token comment\" spellcheck=\"true\"># 开始写作</span>\nnpx vuepress dev docs</code></pre>\n<p>接着，在 <code>package.json</code> 里加一些脚本:</p>\n<pre class=\" language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"scripts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"docs:dev\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"vuepress dev docs\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"docs:build\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"vuepress build docs\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>然后就可以开始写作了:</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">yarn docs:dev <span class=\"token comment\" spellcheck=\"true\"># 或者：npm run docs:dev</span></code></pre>\n<p>要生成静态的 HTML 文件，运行：</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">yarn docs:build <span class=\"token comment\" spellcheck=\"true\"># 或者：npm run docs:build</span></code></pre>\n<p>添加其他依赖,常用语法</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">// 安装指定包\nyarn add ***\n// 安装所有包,注意和npm的区别\nyarn</code></pre>\n<p>注意 ⚠️ 这两者的区别<code>dependencies</code>和<code>devDependencies</code></p>\n<ol>\n<li><code>--save</code> 将依赖的名称、版本要求添加到 <code>dependencies</code></li>\n<li><code>--save-dev</code> 将依赖的名称、版本要求添加到 <code>devDependencies</code></li>\n</ol>\n<h3 id=\"2-一些约定俗成的目录结构\"><a href=\"#2-一些约定俗成的目录结构\" class=\"headerlink\" title=\"2.一些约定俗成的目录结构\"></a>2.一些约定俗成的目录结构</h3><ul>\n<li>在使用<code>vuepress</code>开发时,约定了一些目录结构</li>\n</ul>\n<pre class=\" language-docs\"><code class=\"language-docs\">.\n├── docs\n│   ├── .vuepress (可选的)\n│   │   ├── components (可选的)\n│   │   ├── theme (可选的)\n│   │   │   └── Layout.vue\n│   │   ├── public (可选的)\n│   │   ├── styles (可选的)\n│   │   │   ├── index.styl\n│   │   │   └── palette.styl\n│   │   ├── templates (可选的, 谨慎配置)\n│   │   │   ├── dev.html\n│   │   │   └── ssr.html\n│   │   ├── config.js (可选的)\n│   │   └── enhanceApp.js (可选的)\n│   │\n│   ├── README.md\n│   ├── guide\n│   │   └── README.md\n│   └── config.md\n│\n└── package.json</code></pre>\n<ul>\n<li>在本项目中目录结构为</li>\n</ul>\n<p><img src=\"https://s2.ax1x.com/2019/10/10/uThQU0.jpg\" alt=\"结构.jpg\"></p>\n<pre class=\" language-tree\"><code class=\"language-tree\">template\n├─ docs\n│    └─ .vuepress            # 配置、演示组件、静态资源\n│    │    ├─ compnents        # 演示组件\n│    │    |    └─ demo          # demo组件\n│    │    ├─ public           # 静态资源\n│    │    |    └─ images        # 图片文件\n│    │    |    └─ scss          # 样式文件\n│    │    ├─ config.js        # 配置文件\n│    │    └─ enhanceApp       # 引入文件\n|    ├─ compnent             # 组件md文件\n|    └─ README              # 首页md\n├─ packages\n│    ├─ index.js             # 组件index.js\n│    └─ hk-countup           # countup组件\n├─ public\n└─ package.json</code></pre>\n<h3 id=\"3-修改你的package-json文件\"><a href=\"#3-修改你的package-json文件\" class=\"headerlink\" title=\"3.修改你的package.json文件\"></a>3.修改你的<code>package.json</code>文件</h3><blockquote>\n<p>这个文件是项目的灵魂 👻,是最重要的文件之一.具体字段参考<a href=\"http://javascript.ruanyifeng.com/nodejs/packagejson.html\" target=\"_blank\" rel=\"noopener\">packagejson</a></p>\n</blockquote>\n<p><img src=\"https://s2.ax1x.com/2019/10/10/uThl5V.jpg\" alt=\"目录.jpg\"></p>\n<ul>\n<li>修改主入口<code>main</code></li>\n</ul>\n<blockquote>\n<p><code>main</code>字段指定了加载的入口文件，<code>require(&#39;moduleName&#39;)</code>就会加载这个文件。这个字段的默认值是模块根目录下面的<code>index.js</code>。</p>\n</blockquote>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token string\">\"main\"</span><span class=\"token keyword\">:</span> <span class=\"token string\">\"dist/hekr-ui.umd.min.js\"</span></code></pre>\n<blockquote>\n<p>你可以通过下面的命令将一个单独的入口构建为一个库</p>\n</blockquote>\n<pre class=\" language-bash\"><code class=\"language-bash\">vue-cli-service build --target lib --name myLib <span class=\"token punctuation\">[</span>entry<span class=\"token punctuation\">]</span></code></pre>\n<p>运行结果为:</p>\n<pre class=\" language-bash\"><code class=\"language-bash\">  File                     Size                     Gzipped\n\n  dist/hk-ui.umd.min.js    13.64 KiB                5.31 KiB\n  dist/hk-ui.umd.js        43.87 KiB                11.37 KiB\n  dist/hk-ui.common.js     43.49 KiB                11.25 KiB\n  dist/hk-ui.css           0.54 KiB                 0.29 KiB</code></pre>\n<ul>\n<li>添加<code>lib</code>命令</li>\n</ul>\n<pre class=\" language-bash\"><code class=\"language-bash\">    <span class=\"token string\">\"lib\"</span><span class=\"token keyword\">:</span> <span class=\"token string\">\"vue-cli-service build --target lib --name hk-ui --dest dist ./src/packages/index.js\"</span></code></pre>\n<p>这个入口可以是一个 <code>.js</code> 或一个 <code>.vue</code> 文件。如果没有指定入口，则会使用 <code>src/App.vue</code>。</p>\n<p>构建一个库会输出：</p>\n<ul>\n<li><p><code>dist/myLib.common.js</code>：一个给打包器用的 CommonJS 包 (不幸的是，webpack 目前还并没有支持 ES modules 输出格式的包)</p>\n</li>\n<li><p><code>dist/myLib.umd.js</code>：一个直接给浏览器或 AMD loader 使用的 UMD 包</p>\n</li>\n<li><p><code>dist/myLib.umd.min.js</code>：压缩后的 UMD 构建版本</p>\n</li>\n<li><p><code>dist/myLib.css</code>：提取出来的 CSS 文件 (可以通过在 <code>vue.config.js</code> 中设置 <code>css: { extract: false }</code> 强制内联)</p>\n</li>\n</ul>\n<h3 id=\"4-文档配置\"><a href=\"#4-文档配置\" class=\"headerlink\" title=\"4. 文档配置\"></a>4. 文档配置</h3><p><img src=\"https://s2.ax1x.com/2019/10/10/uTIdVs.jpg\" alt=\"文档.jpg\"></p>\n<blockquote>\n<p>项目启动之后需要我们配置我们的<code>vuepress</code></p>\n</blockquote>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">/*\n * @describe: 配置文件 config.js\n * @Author: superDragon\n * @Date: 2019-10-09 23:25:49\n * @LastEditors: superDragon\n * @LastEditTime: 2019-10-10 18:49:25\n */</span>\n<span class=\"token keyword\">let</span> component <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"hk-button\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"hk-card\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  base<span class=\"token punctuation\">:</span> <span class=\"token string\">\"/hekr-ui/\"</span><span class=\"token punctuation\">,</span>\n  title<span class=\"token punctuation\">:</span> <span class=\"token string\">\"hekr-ui\"</span><span class=\"token punctuation\">,</span>\n  description<span class=\"token punctuation\">:</span> <span class=\"token string\">\"hekr-ui\"</span><span class=\"token punctuation\">,</span>\n  themeConfig<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    nav<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token punctuation\">{</span> text<span class=\"token punctuation\">:</span> <span class=\"token string\">\"首页\"</span><span class=\"token punctuation\">,</span> link<span class=\"token punctuation\">:</span> <span class=\"token string\">\"/\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">{</span>\n        text<span class=\"token punctuation\">:</span> <span class=\"token string\">\"组件\"</span><span class=\"token punctuation\">,</span>\n        link<span class=\"token punctuation\">:</span> <span class=\"token string\">\"/component/hk-button\"</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    sidebar<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token string\">\"/component/\"</span><span class=\"token punctuation\">:</span> component\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    lastUpdated<span class=\"token punctuation\">:</span> <span class=\"token string\">\"最后更新\"</span><span class=\"token punctuation\">,</span>\n    repo<span class=\"token punctuation\">:</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span>\n    repoLabel<span class=\"token punctuation\">:</span> <span class=\"token string\">\"GitLab\"</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  plugins<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  serviceWorker<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre>\n<p>当我们能够成功运行下面时</p>\n<pre class=\" language-js\"><code class=\"language-js\">    <span class=\"token string\">\"docs:dev\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"vuepress dev docs\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"docs:build\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"vuepress build docs\"</span><span class=\"token punctuation\">,</span></code></pre>\n<ul>\n<li>本地运行</li>\n</ul>\n<pre><code>yarn docs:dev # 或者：npm run docs:dev</code></pre><ul>\n<li>打包</li>\n</ul>\n<pre><code>yarn docs:build # 或者：npm run docs:build</code></pre><h3 id=\"5-持续集成\"><a href=\"#5-持续集成\" class=\"headerlink\" title=\"5.持续集成\"></a>5.持续集成</h3><blockquote>\n<p>以<code>GitHub Pages</code> 和<code>Travis CI</code> 为例</p>\n</blockquote>\n<ul>\n<li>打包后放置在项目的 <code>docs</code> 目录中的<code>dist</code>中,注意 ⚠️ 区分；</li>\n<li>使用的是默认的构建输出位置；</li>\n<li>VuePress 以本地依赖的形式被安装到你的项目中，并且配置了如下的 npm scripts:</li>\n</ul>\n<pre class=\" language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"scripts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"docs:build\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"vuepress build docs\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ol>\n<li><p>在 <code>docs/.vuepress/config.js</code> 中设置正确的 <code>base</code>这里我们设置<code>/hekr-ui/</code> 🌿。</p>\n<p>如果你打算发布到 <code>https://&lt;USERNAME&gt;.github.io/</code>，则可以省略这一步，因为 <code>base</code> 默认即是 <code>&quot;/&quot;</code>。</p>\n<p>如果你打算发布到 <code>https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;/</code>（也就是说你的仓库在 <code>https://github.com/&lt;USERNAME&gt;/&lt;REPO&gt;</code>），则将 <code>base</code> 设置为 <code>&quot;/&lt;REPO&gt;/&quot;</code>。</p>\n</li>\n<li><p>在你的项目中，创建一个如下的 <code>.travis.yml</code> 文件 📃:</p>\n</li>\n</ol>\n<pre class=\" language-yml\"><code class=\"language-yml\">language: node_js\nnode_js:\n  - \"8\"\n\ninstall:\n  - npm install\n\nscript:\n  - npm run build\n\nafter_success:\n  - cd ./docs/.vuepress/dist\n  - git init\n  - git config --global user.name \"${U_NAME}\"\n  - git config --global user.email \"${U_EMAIL}\"\n  - git add .\n  - git commit -m \"👷‍Automatically update from travis-ci 👷‍\"\n  - git push --quiet --force  \"https://${GH_TOKEN}@${GH_REF}\" master:${P_BRANCH}\n\nbranches:\n  only:\n    - master\n\nnotifications:\n  email:\n    - xkloveme@163.com\n  on_failure: always\n\n# Note: you should set Environment Variables here or 'Settings' on travis-ci.org\nenv:\n  global:\n    # 我将其添加到了travis-ci的环境变量中\n    - U_NAME: xkloveme\n    - U_EMAIL: xkloveme@qq.com\n    - P_BRANCH: gh-pages\n    - GH_REF: github.com/xkloveme/vue-v-xxx.git</code></pre>\n<ol start=\"3\">\n<li>注册<code>github</code>、<code>travis</code>和配置<code>travis</code>相关,启用构建,自行<code>Google</code><a href=\"https://docs.travis-ci.com/user/deployment/pages/\" target=\"_blank\" rel=\"noopener\">传送门</a></li>\n<li>更多配置参考<a href=\"https://vuepress.vuejs.org/zh/guide/deploy.html\" target=\"_blank\" rel=\"noopener\">vuepress 部署</a></li>\n</ol>\n<h1 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h1><h2 id=\"完善组件并打包\"><a href=\"#完善组件并打包\" class=\"headerlink\" title=\"完善组件并打包\"></a>完善组件并打包</h2><blockquote>\n<p>以编写<code>hk-button</code>组件为例,并导出</p>\n</blockquote>\n<ol>\n<li>添加组件及导出</li>\n</ol>\n<pre class=\" language-vue\"><code class=\"language-vue\"><template lang=\"pug\">\nel-tooltip(effect=\"dark\" v-if=\"tips\" :content=\"tips\" placement=\"top-start\")\n  el-button.hk-button(:size=\"size\" :type=\"type\" v-bind=\"$attrs\" @click=\"handleClick\")\n    slot\nel-button.hk-button(:size=\"size\" v-else :type=\"type\" v-bind=\"$attrs\" @click=\"handleClick\")\n  slot\n</template>\n\n<script>\nimport { Debounce } from \"./../util/debounce\";\nexport default {\n  name: \"hk-button\",\n  props: {\n    type: {\n      type: String,\n      default: \"primary\"\n    },\n    size: {\n      type: String,\n      default: \"medium\"\n    },\n    tips: {\n      type: String,\n      default: null\n    }\n  },\n  methods: {\n    handleClick: Debounce(function(e) {\n      this.$emit(\"click\", e);\n    }, 200)\n  }\n};\n</script>\n\n<style lang=\"scss\">\n.hk-button {\n  i + span {\n    padding-left: 10px;\n  }\n}\n</style></code></pre>\n<ol start=\"2\">\n<li>导出组件</li>\n</ol>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> HkButton <span class=\"token keyword\">from</span> <span class=\"token string\">\"./hk-button\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> HkButton<span class=\"token punctuation\">;</span></code></pre>\n<ol start=\"3\">\n<li>导出为<code>install</code></li>\n</ol>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">/*\n * @describe: 主入口,导出install\n * @Author: superDragon\n * @Date: 2019-10-09 23:21:11\n * @LastEditors: superDragon\n * @LastEditTime: 2019-10-10 19:09:57\n */</span>\n<span class=\"token keyword\">import</span> HkButton <span class=\"token keyword\">from</span> <span class=\"token string\">\"./hk-button\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> HKcard <span class=\"token keyword\">from</span> <span class=\"token string\">\"./hk-card\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> install <span class=\"token operator\">=</span> Vue <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  Vue<span class=\"token punctuation\">.</span><span class=\"token function\">component</span><span class=\"token punctuation\">(</span>HkButton<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span> HkButton<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  Vue<span class=\"token punctuation\">.</span><span class=\"token function\">component</span><span class=\"token punctuation\">(</span>HKcard<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span> HKcard<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> window <span class=\"token operator\">!==</span> <span class=\"token string\">\"undefined\"</span> <span class=\"token operator\">&amp;&amp;</span> window<span class=\"token punctuation\">.</span>Vue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">install</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>Vue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token punctuation\">{</span> HkButton<span class=\"token punctuation\">,</span> HKcard <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span> install <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"上传自己的npm\"><a href=\"#上传自己的npm\" class=\"headerlink\" title=\"上传自己的npm\"></a>上传自己的<code>npm</code></h2><h3 id=\"注册-®️-并切换到官方npm源\"><a href=\"#注册-®️-并切换到官方npm源\" class=\"headerlink\" title=\"注册 ®️ 并切换到官方npm源\"></a>注册 ®️ 并切换到官方<code>npm</code>源</h3><p><img src=\"https://s2.ax1x.com/2019/10/10/uTjYY4.jpg\" alt=\"换源.jpg\"></p>\n<h3 id=\"注册登陆npm\"><a href=\"#注册登陆npm\" class=\"headerlink\" title=\"注册登陆npm\"></a>注册登陆<code>npm</code></h3><pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> adduser        //回车后,弹出Username:\nUsername:          //输入你在官网注册时的用户名,回车\nPassword:          //输入官网注册的密码,密码看不见,请确保你输的密码正确, 回车\nEmail:<span class=\"token punctuation\">(</span>this is Public<span class=\"token punctuation\">)</span>    //输入官网注册时绑定的邮箱,回车</code></pre>\n<h3 id=\"上传\"><a href=\"#上传\" class=\"headerlink\" title=\"上传\"></a>上传</h3><pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> publish        //此处上传命令,回车</code></pre>\n<p><img src=\"https://s2.ax1x.com/2019/10/10/uTvZB6.jpg\" alt=\"发布.jpg\"></p>\n<p>这样一个<code>hekr-ui</code>就发布完成了</p>\n<h3 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h3><blockquote>\n<p>24 小时内撤销也是很简单的.</p>\n</blockquote>\n<pre class=\" language-bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> unpublish --force</code></pre>\n<h1 id=\"大功告成\"><a href=\"#大功告成\" class=\"headerlink\" title=\"大功告成\"></a>大功告成</h1><blockquote>\n<p>Let’s enjoy the taste of life, if we feel, the more we will live longer.</p>\n</blockquote>\n<p>觉得不错的话给个<code>star</code></p>\n<ul>\n<li>本文演示库地址<a href=\"https://github.com/xkloveme/hekr-ui\" target=\"_blank\" rel=\"noopener\">hekr-ui</a></li>\n<li><a href=\"https://hy.hekr.me/hk-ui/web/index.html\" target=\"_blank\" rel=\"noopener\">文档地址</a></li>\n<li><a href=\"https://github.com/xkloveme/hk-ui\" target=\"_blank\" rel=\"noopener\">项目源码</a></li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h1 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h1><blockquote>\n<p>西风吹老洞庭波，一夜湘君白发多。<br>醉后不知天在水，满船清梦压星河。</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><strong>身为程序员,还没有自己的包,总感觉缺点什么,女朋友和包至少占一样吧.正如上战场没有扛枪的士兵,吃饭少了筷子一样,令人心情不愉悦.同时经常会有面试官会问一个犀利的问题,你有自己开源项目么?你写过公司自己的 UI 组件么?如同雷劈,总觉得比别人矮一截,那么今天就以<a href=\"https://hy.hekr.me/hk-ui/web/index.html\" target=\"_blank\" rel=\"noopener\">hekr-ui</a>为例,介绍一下如何打造自己的 UI 库吧</strong></p>\n<ul>\n<li><a href=\"https://hy.hekr.me/hk-ui/web/index.html\" target=\"_blank\" rel=\"noopener\">文档地址</a></li>\n<li><a href=\"https://github.com/xkloveme/hk-ui\" target=\"_blank\" rel=\"noopener\">项目源码</a></li>\n</ul>\n<h2 id=\"选型\"><a href=\"#选型\" class=\"headerlink\" title=\"选型\"></a>选型</h2><blockquote>\n<p>我们的目标是构建一个以<code>Vue</code>为基础基于<code>element-ui</code>的 UI 框架</p>\n</blockquote>\n<ul>\n<li>文档选用 <code>Vuepress</code> 构建,简单便捷</li>\n<li>打包选择 <code>gitlab CI</code> ,本文以 <code>travis</code> 为例</li>\n<li>初始化采用<code>vue-cli 3.0</code>、<code>pug</code>和<code>sass</code>等相关依赖和插件(自行探索)</li>\n</ul>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><ol>\n<li>快速构建属于 ❤️ 自己<code>npm</code>库</li>\n<li>熟悉打包 📦 命令及其语法</li>\n<li>熟练掌握自动化 👷 构建</li>\n<li>为社区贡献自己一份脚印 👣</li>\n</ol>\n<h1 id=\"初步构思\"><a href=\"#初步构思\" class=\"headerlink\" title=\"初步构思\"></a>初步构思</h1><h2 id=\"启动一个项目\"><a href=\"#启动一个项目\" class=\"headerlink\" title=\"启动一个项目\"></a>启动一个项目</h2><h3 id=\"1-初始化一个项目\"><a href=\"#1-初始化一个项目\" class=\"headerlink\" title=\"1.初始化一个项目\"></a>1.初始化一个项目</h3><blockquote>\n<p>这里推荐使用<a href=\"https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create\" target=\"_blank\" rel=\"noopener\"><code>Vue CLI</code></a> 来进行快速构建</p>\n</blockquote>\n<p><img src=\"https://s2.ax1x.com/2019/10/10/uThubn.jpg\" alt=\"初始化.jpg\"></p>\n<pre><code class=\"bash\">vue create hekr-ui</code></pre>\n<p>我们选择默认配置就可以了</p>\n<h3 id=\"2-关联代码到你的库\"><a href=\"#2-关联代码到你的库\" class=\"headerlink\" title=\"2.关联代码到你的库\"></a>2.关联代码到你的库</h3><blockquote>\n<p><code>git</code>可以很好对代码版本进行管理</p>\n</blockquote>\n<ul>\n<li>当你初始化库时</li>\n</ul>\n<pre><code class=\"bash\">echo &quot;# hekr-ui&quot; &gt;&gt; README.md\ngit init\ngit add README.md\ngit commit -m &quot;first commit&quot;\ngit remote add origin https://github.com/xkloveme/hekr-ui.git\ngit push -u origin master</code></pre>\n<ul>\n<li>关联本地库时</li>\n</ul>\n<pre><code class=\"bash\">git remote add origin https://github.com/xkloveme/hekr-ui.git\ngit push -u origin master</code></pre>\n<p>当然我们选择第二种.记得把<code>node_modules</code>忽略</p>\n<h2 id=\"配置你的项目\"><a href=\"#配置你的项目\" class=\"headerlink\" title=\"配置你的项目\"></a>配置你的项目</h2><h3 id=\"1-添加相关依赖\"><a href=\"#1-添加相关依赖\" class=\"headerlink\" title=\"1.添加相关依赖\"></a>1.添加相关依赖</h3><blockquote>\n<p>本文以<code>yarn</code>为主,当然<code>npm</code>也是 👌OK 的</p>\n</blockquote>\n<p>我们以<code>vuepress</code>为主编写文档,当然这是非必须的,如果您只想发一个包,可以省略此步,必要的<code>demo</code>和测试会有极大的方便</p>\n<pre><code class=\"bash\"># 将 VuePress 作为一个本地依赖安装\nyarn add -D vuepress # 或者：npm install -D vuepress\n\n# 新建一个 docs 文件夹\nmkdir docs\n\n# 新建一个 markdown 文件\necho &#39;# Hello VuePress!&#39; &gt; docs/README.md\n\n# 开始写作\nnpx vuepress dev docs</code></pre>\n<p>接着，在 <code>package.json</code> 里加一些脚本:</p>\n<pre><code class=\"json\">{\n  &quot;scripts&quot;: {\n    &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;,\n    &quot;docs:build&quot;: &quot;vuepress build docs&quot;\n  }\n}</code></pre>\n<p>然后就可以开始写作了:</p>\n<pre><code class=\"bash\">yarn docs:dev # 或者：npm run docs:dev</code></pre>\n<p>要生成静态的 HTML 文件，运行：</p>\n<pre><code class=\"bash\">yarn docs:build # 或者：npm run docs:build</code></pre>\n<p>添加其他依赖,常用语法</p>\n<pre><code class=\"bash\">// 安装指定包\nyarn add ***\n// 安装所有包,注意和npm的区别\nyarn</code></pre>\n<p>注意 ⚠️ 这两者的区别<code>dependencies</code>和<code>devDependencies</code></p>\n<ol>\n<li><code>--save</code> 将依赖的名称、版本要求添加到 <code>dependencies</code></li>\n<li><code>--save-dev</code> 将依赖的名称、版本要求添加到 <code>devDependencies</code></li>\n</ol>\n<h3 id=\"2-一些约定俗成的目录结构\"><a href=\"#2-一些约定俗成的目录结构\" class=\"headerlink\" title=\"2.一些约定俗成的目录结构\"></a>2.一些约定俗成的目录结构</h3><ul>\n<li>在使用<code>vuepress</code>开发时,约定了一些目录结构</li>\n</ul>\n<pre><code class=\"docs\">.\n├── docs\n│   ├── .vuepress (可选的)\n│   │   ├── components (可选的)\n│   │   ├── theme (可选的)\n│   │   │   └── Layout.vue\n│   │   ├── public (可选的)\n│   │   ├── styles (可选的)\n│   │   │   ├── index.styl\n│   │   │   └── palette.styl\n│   │   ├── templates (可选的, 谨慎配置)\n│   │   │   ├── dev.html\n│   │   │   └── ssr.html\n│   │   ├── config.js (可选的)\n│   │   └── enhanceApp.js (可选的)\n│   │\n│   ├── README.md\n│   ├── guide\n│   │   └── README.md\n│   └── config.md\n│\n└── package.json</code></pre>\n<ul>\n<li>在本项目中目录结构为</li>\n</ul>\n<p><img src=\"https://s2.ax1x.com/2019/10/10/uThQU0.jpg\" alt=\"结构.jpg\"></p>\n<pre><code class=\"tree\">template\n├─ docs\n│    └─ .vuepress            # 配置、演示组件、静态资源\n│    │    ├─ compnents        # 演示组件\n│    │    |    └─ demo          # demo组件\n│    │    ├─ public           # 静态资源\n│    │    |    └─ images        # 图片文件\n│    │    |    └─ scss          # 样式文件\n│    │    ├─ config.js        # 配置文件\n│    │    └─ enhanceApp       # 引入文件\n|    ├─ compnent             # 组件md文件\n|    └─ README              # 首页md\n├─ packages\n│    ├─ index.js             # 组件index.js\n│    └─ hk-countup           # countup组件\n├─ public\n└─ package.json</code></pre>\n<h3 id=\"3-修改你的package-json文件\"><a href=\"#3-修改你的package-json文件\" class=\"headerlink\" title=\"3.修改你的package.json文件\"></a>3.修改你的<code>package.json</code>文件</h3><blockquote>\n<p>这个文件是项目的灵魂 👻,是最重要的文件之一.具体字段参考<a href=\"http://javascript.ruanyifeng.com/nodejs/packagejson.html\" target=\"_blank\" rel=\"noopener\">packagejson</a></p>\n</blockquote>\n<p><img src=\"https://s2.ax1x.com/2019/10/10/uThl5V.jpg\" alt=\"目录.jpg\"></p>\n<ul>\n<li>修改主入口<code>main</code></li>\n</ul>\n<blockquote>\n<p><code>main</code>字段指定了加载的入口文件，<code>require(&#39;moduleName&#39;)</code>就会加载这个文件。这个字段的默认值是模块根目录下面的<code>index.js</code>。</p>\n</blockquote>\n<pre><code class=\"bash\">&quot;main&quot;: &quot;dist/hekr-ui.umd.min.js&quot;</code></pre>\n<blockquote>\n<p>你可以通过下面的命令将一个单独的入口构建为一个库</p>\n</blockquote>\n<pre><code class=\"bash\">vue-cli-service build --target lib --name myLib [entry]</code></pre>\n<p>运行结果为:</p>\n<pre><code class=\"bash\">  File                     Size                     Gzipped\n\n  dist/hk-ui.umd.min.js    13.64 KiB                5.31 KiB\n  dist/hk-ui.umd.js        43.87 KiB                11.37 KiB\n  dist/hk-ui.common.js     43.49 KiB                11.25 KiB\n  dist/hk-ui.css           0.54 KiB                 0.29 KiB</code></pre>\n<ul>\n<li>添加<code>lib</code>命令</li>\n</ul>\n<pre><code class=\"bash\">    &quot;lib&quot;: &quot;vue-cli-service build --target lib --name hk-ui --dest dist ./src/packages/index.js&quot;</code></pre>\n<p>这个入口可以是一个 <code>.js</code> 或一个 <code>.vue</code> 文件。如果没有指定入口，则会使用 <code>src/App.vue</code>。</p>\n<p>构建一个库会输出：</p>\n<ul>\n<li><p><code>dist/myLib.common.js</code>：一个给打包器用的 CommonJS 包 (不幸的是，webpack 目前还并没有支持 ES modules 输出格式的包)</p>\n</li>\n<li><p><code>dist/myLib.umd.js</code>：一个直接给浏览器或 AMD loader 使用的 UMD 包</p>\n</li>\n<li><p><code>dist/myLib.umd.min.js</code>：压缩后的 UMD 构建版本</p>\n</li>\n<li><p><code>dist/myLib.css</code>：提取出来的 CSS 文件 (可以通过在 <code>vue.config.js</code> 中设置 <code>css: { extract: false }</code> 强制内联)</p>\n</li>\n</ul>\n<h3 id=\"4-文档配置\"><a href=\"#4-文档配置\" class=\"headerlink\" title=\"4. 文档配置\"></a>4. 文档配置</h3><p><img src=\"https://s2.ax1x.com/2019/10/10/uTIdVs.jpg\" alt=\"文档.jpg\"></p>\n<blockquote>\n<p>项目启动之后需要我们配置我们的<code>vuepress</code></p>\n</blockquote>\n<pre><code class=\"js\">/*\n * @describe: 配置文件 config.js\n * @Author: superDragon\n * @Date: 2019-10-09 23:25:49\n * @LastEditors: superDragon\n * @LastEditTime: 2019-10-10 18:49:25\n */\nlet component = [&quot;hk-button&quot;, &quot;hk-card&quot;];\nmodule.exports = {\n  base: &quot;/hekr-ui/&quot;,\n  title: &quot;hekr-ui&quot;,\n  description: &quot;hekr-ui&quot;,\n  themeConfig: {\n    nav: [\n      { text: &quot;首页&quot;, link: &quot;/&quot; },\n      {\n        text: &quot;组件&quot;,\n        link: &quot;/component/hk-button&quot;\n      }\n    ],\n    sidebar: {\n      &quot;/component/&quot;: component\n    },\n    lastUpdated: &quot;最后更新&quot;,\n    repo: &quot;&quot;,\n    repoLabel: &quot;GitLab&quot;\n  },\n  plugins: [],\n  serviceWorker: true\n};</code></pre>\n<p>当我们能够成功运行下面时</p>\n<pre><code class=\"js\">    &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;,\n    &quot;docs:build&quot;: &quot;vuepress build docs&quot;,</code></pre>\n<ul>\n<li>本地运行</li>\n</ul>\n<pre><code>yarn docs:dev # 或者：npm run docs:dev</code></pre><ul>\n<li>打包</li>\n</ul>\n<pre><code>yarn docs:build # 或者：npm run docs:build</code></pre><h3 id=\"5-持续集成\"><a href=\"#5-持续集成\" class=\"headerlink\" title=\"5.持续集成\"></a>5.持续集成</h3><blockquote>\n<p>以<code>GitHub Pages</code> 和<code>Travis CI</code> 为例</p>\n</blockquote>\n<ul>\n<li>打包后放置在项目的 <code>docs</code> 目录中的<code>dist</code>中,注意 ⚠️ 区分；</li>\n<li>使用的是默认的构建输出位置；</li>\n<li>VuePress 以本地依赖的形式被安装到你的项目中，并且配置了如下的 npm scripts:</li>\n</ul>\n<pre><code class=\"json\">{\n  &quot;scripts&quot;: {\n    &quot;docs:build&quot;: &quot;vuepress build docs&quot;\n  }\n}</code></pre>\n<ol>\n<li><p>在 <code>docs/.vuepress/config.js</code> 中设置正确的 <code>base</code>这里我们设置<code>/hekr-ui/</code> 🌿。</p>\n<p>如果你打算发布到 <code>https://&lt;USERNAME&gt;.github.io/</code>，则可以省略这一步，因为 <code>base</code> 默认即是 <code>&quot;/&quot;</code>。</p>\n<p>如果你打算发布到 <code>https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;/</code>（也就是说你的仓库在 <code>https://github.com/&lt;USERNAME&gt;/&lt;REPO&gt;</code>），则将 <code>base</code> 设置为 <code>&quot;/&lt;REPO&gt;/&quot;</code>。</p>\n</li>\n<li><p>在你的项目中，创建一个如下的 <code>.travis.yml</code> 文件 📃:</p>\n</li>\n</ol>\n<pre><code class=\"yml\">language: node_js\nnode_js:\n  - &quot;8&quot;\n\ninstall:\n  - npm install\n\nscript:\n  - npm run build\n\nafter_success:\n  - cd ./docs/.vuepress/dist\n  - git init\n  - git config --global user.name &quot;${U_NAME}&quot;\n  - git config --global user.email &quot;${U_EMAIL}&quot;\n  - git add .\n  - git commit -m &quot;👷‍Automatically update from travis-ci 👷‍&quot;\n  - git push --quiet --force  &quot;https://${GH_TOKEN}@${GH_REF}&quot; master:${P_BRANCH}\n\nbranches:\n  only:\n    - master\n\nnotifications:\n  email:\n    - xkloveme@163.com\n  on_failure: always\n\n# Note: you should set Environment Variables here or &#39;Settings&#39; on travis-ci.org\nenv:\n  global:\n    # 我将其添加到了travis-ci的环境变量中\n    - U_NAME: xkloveme\n    - U_EMAIL: xkloveme@qq.com\n    - P_BRANCH: gh-pages\n    - GH_REF: github.com/xkloveme/vue-v-xxx.git</code></pre>\n<ol start=\"3\">\n<li>注册<code>github</code>、<code>travis</code>和配置<code>travis</code>相关,启用构建,自行<code>Google</code><a href=\"https://docs.travis-ci.com/user/deployment/pages/\" target=\"_blank\" rel=\"noopener\">传送门</a></li>\n<li>更多配置参考<a href=\"https://vuepress.vuejs.org/zh/guide/deploy.html\" target=\"_blank\" rel=\"noopener\">vuepress 部署</a></li>\n</ol>\n<h1 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h1><h2 id=\"完善组件并打包\"><a href=\"#完善组件并打包\" class=\"headerlink\" title=\"完善组件并打包\"></a>完善组件并打包</h2><blockquote>\n<p>以编写<code>hk-button</code>组件为例,并导出</p>\n</blockquote>\n<ol>\n<li>添加组件及导出</li>\n</ol>\n<pre><code class=\"vue\">&lt;template lang=&quot;pug&quot;&gt;\nel-tooltip(effect=&quot;dark&quot; v-if=&quot;tips&quot; :content=&quot;tips&quot; placement=&quot;top-start&quot;)\n  el-button.hk-button(:size=&quot;size&quot; :type=&quot;type&quot; v-bind=&quot;$attrs&quot; @click=&quot;handleClick&quot;)\n    slot\nel-button.hk-button(:size=&quot;size&quot; v-else :type=&quot;type&quot; v-bind=&quot;$attrs&quot; @click=&quot;handleClick&quot;)\n  slot\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { Debounce } from &quot;./../util/debounce&quot;;\nexport default {\n  name: &quot;hk-button&quot;,\n  props: {\n    type: {\n      type: String,\n      default: &quot;primary&quot;\n    },\n    size: {\n      type: String,\n      default: &quot;medium&quot;\n    },\n    tips: {\n      type: String,\n      default: null\n    }\n  },\n  methods: {\n    handleClick: Debounce(function(e) {\n      this.$emit(&quot;click&quot;, e);\n    }, 200)\n  }\n};\n&lt;/script&gt;\n\n&lt;style lang=&quot;scss&quot;&gt;\n.hk-button {\n  i + span {\n    padding-left: 10px;\n  }\n}\n&lt;/style&gt;</code></pre>\n<ol start=\"2\">\n<li>导出组件</li>\n</ol>\n<pre><code class=\"js\">import HkButton from &quot;./hk-button&quot;;\n\nexport default HkButton;</code></pre>\n<ol start=\"3\">\n<li>导出为<code>install</code></li>\n</ol>\n<pre><code class=\"js\">/*\n * @describe: 主入口,导出install\n * @Author: superDragon\n * @Date: 2019-10-09 23:21:11\n * @LastEditors: superDragon\n * @LastEditTime: 2019-10-10 19:09:57\n */\nimport HkButton from &quot;./hk-button&quot;;\nimport HKcard from &quot;./hk-card&quot;;\n\nconst install = Vue =&gt; {\n  Vue.component(HkButton.name, HkButton);\n  Vue.component(HKcard.name, HKcard);\n};\n\nif (typeof window !== &quot;undefined&quot; &amp;&amp; window.Vue) {\n  install(window.Vue);\n}\n\nexport { HkButton, HKcard };\n\nexport default { install };</code></pre>\n<h2 id=\"上传自己的npm\"><a href=\"#上传自己的npm\" class=\"headerlink\" title=\"上传自己的npm\"></a>上传自己的<code>npm</code></h2><h3 id=\"注册-®️-并切换到官方npm源\"><a href=\"#注册-®️-并切换到官方npm源\" class=\"headerlink\" title=\"注册 ®️ 并切换到官方npm源\"></a>注册 ®️ 并切换到官方<code>npm</code>源</h3><p><img src=\"https://s2.ax1x.com/2019/10/10/uTjYY4.jpg\" alt=\"换源.jpg\"></p>\n<h3 id=\"注册登陆npm\"><a href=\"#注册登陆npm\" class=\"headerlink\" title=\"注册登陆npm\"></a>注册登陆<code>npm</code></h3><pre><code class=\"bash\">npm adduser        //回车后,弹出Username:\nUsername:          //输入你在官网注册时的用户名,回车\nPassword:          //输入官网注册的密码,密码看不见,请确保你输的密码正确, 回车\nEmail:(this is Public)    //输入官网注册时绑定的邮箱,回车</code></pre>\n<h3 id=\"上传\"><a href=\"#上传\" class=\"headerlink\" title=\"上传\"></a>上传</h3><pre><code class=\"bash\">npm publish        //此处上传命令,回车</code></pre>\n<p><img src=\"https://s2.ax1x.com/2019/10/10/uTvZB6.jpg\" alt=\"发布.jpg\"></p>\n<p>这样一个<code>hekr-ui</code>就发布完成了</p>\n<h3 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h3><blockquote>\n<p>24 小时内撤销也是很简单的.</p>\n</blockquote>\n<pre><code class=\"bash\">npm unpublish --force</code></pre>\n<h1 id=\"大功告成\"><a href=\"#大功告成\" class=\"headerlink\" title=\"大功告成\"></a>大功告成</h1><blockquote>\n<p>Let’s enjoy the taste of life, if we feel, the more we will live longer.</p>\n</blockquote>\n<p>觉得不错的话给个<code>star</code></p>\n<ul>\n<li>本文演示库地址<a href=\"https://github.com/xkloveme/hekr-ui\" target=\"_blank\" rel=\"noopener\">hekr-ui</a></li>\n<li><a href=\"https://hy.hekr.me/hk-ui/web/index.html\" target=\"_blank\" rel=\"noopener\">文档地址</a></li>\n<li><a href=\"https://github.com/xkloveme/hk-ui\" target=\"_blank\" rel=\"noopener\">项目源码</a></li>\n</ul>\n"},{"layout":"post","title":"Vue中的代理Proxy和$refs","date":"2018-08-09T16:00:00.000Z","_content":"\n## 前言\n\n> 最近国内 VPN 限制的严厉的多，一不小心就会被抓去签保证书，为了能和小伙伴联系，也为了能查到相关资讯，了解国内动态，关注权利的猎物老郭\n> 特此写博，然而这一切都是免费的！免费的！免费的！（重要的事情讲三遍）\n\n## 正文开始\n\n一、 代理 Proxy\n\n1.  介绍\n\n1.  Proxy 又称为代理。在现实生活中，大家对代理二字并不会太陌生，比如某产品的代理。打个比方来说，我们要买一台手机，我们不会直接到一家手机厂去买，会在手机的代理商中买。\n\n1.  在 JavaScript 中，Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种元编程，即对编程语言进行编程。\n\n    3.  Proxy 可以理解成，在目标对象之前架设一层拦截，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来代理某些操作，可以译为代理器。\n\n1.  基本语法\n\n```js\n// @param {Object} target 用来被代理的对象\n// @param {Object} handler 用来设置代理的对象\nlet proxy = new Proxy(target, handler);\n```\n\n- Proxy，见名知意，其功能非常类似于设计模式中的代理模式，该模式常用于三个方面：\n\n- 拦截和监视外部对对象的访问\n\n- 降低函数或类的复杂度\n\n- 在复杂操作前对操作进行校验或对所需资源进行管理\n\n- 在支持 Proxy 的浏览器环境中，Proxy 是一个全局对象，可以直接使用。Proxy(target, handler) 是一个构造函数，target 是被代理的对象，handlder 是声明了各类代理操作的对象，最终返回一个代理对象。外界每次通过代理对象访问 target 对象的属性时，就会经过 handler 对象，从这个流程来看，代理对象很类似 middleware（中间件）。那么 Proxy 可以拦截什么操作呢？最常见的就是 get（读取）、set（修改）对象属性等操作，完整的可拦截操作列表请点击这里。此外，Proxy 对象还提供了一个 revoke 方法，可以随时注销所有的代理操作。\n\n一个代理的例子：\n\n```js\nconst target = { name: \"Billy Bob\", age: 15 };\nconst handler = {\n  get(target, key, proxy) {\n    const today = new Date();\n    console.log(`GET request made for ${key} at ${today}`);\n    return Reflect.get(target, key, proxy);\n  }\n};\nconst proxy = new Proxy(target, handler);\nproxy.name; // => \"GET request made for name at Thu Jul 21 2016 15:26:20 GMT+0800 (CST)\" // => \"Billy Bob\"\n```\n\n1.Reflect 称为反射。它也是 ES6 中为了操作对象而提供的新的 API，用来替代直接调用 Object 的方法。Reflect 是一个内置的对象，它提供可拦截 JavaScript 操作的方法。方法与代理处理程序的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。\n\nReflect 与大多数全局对象不同，Reflect 没有构造函数。你不能将其与一个 new 运算符一起使用，或者将 Reflect 对象作为一个函数来调用。\n\n1.  处理器对象 handler\n\n处理器对象 handler 一共提供了 14 种可代理操作，每种操作的代号（属性名/方法名）和触发这种操作的方式如下：\n\n- handler.getPrototypeOf()：在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy)时\n\n- handler.setPrototypeOf()：在设置代理对象的原型时触发该操作，比如在执行 Object.setprototypeOf(proxy, null)时\n\n- handler.isExtensible()：在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy)时\n\n- handler.preventExtensions()：在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy)时\n\n- handler.getOwnPropertyDescriptor()：在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, 'foo')时\n\n- handler.defineProperty()：在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy,'foo',{})时\n\n- handler.has()：在判断代理对象是否拥有某个属性时触发该操作，比如在执行'foo' in proxy 时\n\n- handler.get()：在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时\n\n- handler.set()：在给代理对象的某个赋值时触发该操作，比如在执行 proxy.foo = 1 时\n\n- handler.deleteProperty()：在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时\n\n- handler.ownKeys()：在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy)时\n\n- handler.apply()：在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy()时\n\n- handler.construct()：在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行 new proxy()时\n\nReflect 对象拥有对应的可以控制各种元编程任务的静态方法。这些功能和 Proxy 一一对应。\n\n下面的这些名称你可能看起来很眼熟（因为他们也是 Object 上的方法）：\n\n```js\nReflect.getOwnPropertyDescriptor(..)\n\nReflect.defineProperty(..)\n\nReflect.getPrototypeOf(..)\n\nReflect.setPrototypeOf(..)\n\nReflect.preventExtensions(..)\n\nReflect.isExtensible(..)\n```\n\n这些方法和在 Object 上的同名方法一样。然后，一个区别在于，Object 上这么方法的第一个参数是一个对象，Reflect 遇到这种情况会扔出一个错误。\n\n3.  陷阱代理\n\n使用 set 陷阱验证属性\n\n假设创建一个属性值是数字的对象，对象中每新增一个属性都要加以验证，如果不是数字必须抛出错误。为了实现这个任务，可以定义一个 set 陷阱来覆写设置值的默认特性。\n\nset 陷阱接受 4 个参数：\n\n- trapTaqget 用于接收属性(代理的目标)的对象\n\n- key 要写入的属性键(字符串或 Symbol 类型)\n\n- value 被写入属性的值\n\n- receiver 操作发生的对象(通常是代理)\n\n**Reflect.set()是 set 陷阱对应的反射方法和默认特性，它和 set 代理陷阱一样也接受相同的 4 个参数，以方便在陷阱中使用。如果属性已设置陷阱应该返回 true，如果未设置则返回 false。(Reflect.set()方法基于操作是否成功来返回恰当的值)。**\n\n可以使用 set 陷阱并检查传入的值来验证属性值：\n\n```js\n1 //set 陷阱并检查传入的值来验证属性值\n2 let target = { name: \"target\" };\n3 let proxy = new Proxy(target, {\n4 set(trapTarget, key, value, receiver) {\n5 // 忽略已有属性，避免影响它们\n6 if (!trapTarget.hasOwnProperty(key)) {\n7 if (isNaN(value)) { throw new TypeError(\"Property must be a number.\"); }\n8 } // 添加属性\n9 return Reflect.set(trapTarget, key, value, receiver);\n10 }\n11 });\n12 // 添加一个新属性\n13 proxy.count = 1;\n14 console.log(proxy.count); // => 1\n15 console.log(target.count); // => 1 // 你可以为 name 赋一个非数值类型的值，因为该属性已经存在\n16 proxy.name = \"proxy\";\n17 console.log(proxy.name); // => \"proxy\"\n18 console.log(target.name); // => \"proxy\"\n// 抛出错误 proxy.anotherName = \"proxy\";\n```\n\n这段代码定义了一个代理来验证添加到 target 的新属性，当执行 proxy.count=1 时，set 陷阱被调用，此时 trapTarget 的值等于 target，key 等于\"count\"，value 等于 1，receiver 等于 proxy。\n\n由于 target 上没有 count 属性，因此代理继续将 value 值传入 isNaN()，如果结果是 NaN，则证明传入的属性值不是数字，同时也抛出一个错误。在这段代码中，count 被设置为 1，所以代理调用 Reflect.set()方法并传入陷阱接受的 4 个参数来添加新属性。\n\nproxy.name 可以成功被赋值为一个字符串，这是因为 target 已经拥有一个 name 属性，但通过调用 trapTarget.hasownproperty()方法验证检查后被排除了，所以目标已有的非数字属性仍然可以被操作。\n\n然而，将 proxy.anotherName 赋值为一个字符串时会抛出错误。目标上没有 anotherName 属性，所以它的值需要被验证，而由于\"Proxy\"不是一个数字值，因此抛出错误。\n\nset 代理陷阱可以拦截写入属性的操作，get 代理陷阱可以拦截读取属性的操作\n\n用 get 陷阱验证对象结构(Object Shape)\n\nJS 有一个时常令人感到困惑的特殊行为，即读取不存在的属性时不会抛出错误，而是用 undefined 代替被读取属性的值。\n\n```js\n1 //用 get 陷阱验证对象结构(Object Shape)\n\n2 let target = {};\n\n3 console.log(target.name); // => undefined\n```\n\n对象结构是指对象中所有可用属性和方法的集合，JS 引擎通过对象结构来优化代码，通常会创建类来表示对象，如果可以安全地假定一个对象将始终具有相同的属性和方法，那么当程序试图访问不存在的属性时会抛出错误。代理让对象结构检验变得简单。\n\n因为只有当读取属性时才会检验属性，所以无论对象中是否存在某个属性，都可以通过 get 陷阱来检测，它接受 3 个参数：\n\n- trapTarget 被读取属性的源对象(代理的目标)\n\n- key 要读取的属性键(字符串或 Symbol)\n\n- receiver 操作发生的对象(通常是代理)\n\n由于 get 陷阱不写入值，所以它复刻了 set 陷阱中除 value 外的其他 3 个参数，Reflect.get()也接受同样 3 个参数并返回属性的默认值。\n\n如果属性在目标上不存在，则使用 get 陷阱和 Reflect.get()时会抛出错误：\n\n```js\nlet proxy = new Proxy(\n  {},\n  {\n    get(trapTarget, key, receiver) {\n      if (!(key in receiver)) {\n        throw new TypeError(\"Property \" + key + \" doesn't exist.\");\n      }\n\n      return Reflect.get(trapTarget, key, receiver);\n    }\n  }\n);\n\n// 添加属性的功能正常\n\nproxy.name = \"proxy\";\n\nconsole.log(proxy.name); // => \"proxy\"\n\n// 读取不存在属性会抛出错误\n\nconsole.log(proxy.nme); // => 抛出错误\n```\n\n原型代理陷阱\nObject.setPrototypeOf()方法被用于作为 ES5 中的 Object.getPrototypeOf()方法的补充。通过代理中的 setPrototypeOf 陷阱和 getPrototypeOf 陷阱可以拦截这两个方法的执行过程，在这两种情况下，Object 上的方法会调用代理中的同名陷阱来改变方法的行为。\n\n两个陷阱均与代理有关，但具体到方法只与每个陷阱的类型有关，setPrototypeOf 陷阱接受以下这些参数:\n\n- trapTarget 接受原型设置的对象(代理的目标)\n\n- proto 作为原型使用的对象\n\n传入 Object.setPrototypeOf()方法和 Reflect.setPrototypeOf()方法的均是以上两个参数，另一方面，getPrototypeOf 陷阱中的 Object.getPrototypeOf()方法和 Reflect.getPrototypeOf()方法只接受参数 trapTarget。\n\n原型代理陷阱的运行机制\n原型代理陷阱有一些限制。首先，getPrototypeOf 陷阱必须返回对象或 null，否则将导致运行时错误，返回值检查可以确保 Object.getPrototypeOf()返回的总是预期的值；其次，在 setPrototypeOf 陷阱中，如果操作失败则返回的一定是 false，此时 Object.setPrototypeOf()会抛出错误，如果 setPrototypeOf 返回了任何不是 false 的值，那么 Object.setPrototypeOf()便假设操作成功。\n\n以下示例通过总是返回 null，且不允许改变原型的方式隐藏了代理的原型:\n\n```js\n1 let target = {};\n\n2 let proxy = new Proxy(target, {\n\n3 getPrototypeOf(trapTarget) {\n\n4 returnnull;\n\n5 },\n\n6 setPrototypeOf(trapTarget, proto) {\n\n7 returnfalse;\n\n8 }\n\n9 });\n\n10 let targetProto = Object.getPrototypeOf(target);\n\n11 let proxyProto = Object.getPrototypeOf(proxy);\n\n12 console.log(targetProto ===Object.prototype); // => true\n\n13 console.log(proxyProto ===Object.prototype); // => false\n\n14 console.log(proxyProto); // => null\n\n// 成功\n\n15 Object.setPrototypeOf(target, {});\n\n// 抛出错误\n\n16 Object.setPrototypeOf(proxy, {});\n```\n\n代码强调了 target 和 proxy 的行为差异。Object.getPrototypeOf()给 target 返回的是值，而给 proxy 返回值时，由于 getPrototypeOf 陷阱被调用，返回的是 null；同样，Object.setPrototypeOf()成功为 target 设置原型，而给 proxy 设置原型时，由于 setPrototypeOf 陷阱被调用，最终抛出一个错误。\n\n一、 vue 的\\$ref\n\n一个对象，持有注册过 ref 特性 的所有 DOM 元素和组件实例。\n\nref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 \\$refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：\n\n```js\n<!-- `vm.$refs.p` will be the DOM node -->\n<p ref=\"p\">hello</p>\n\n<!-- `vm.$refs.child` will be the child component instance -->\n\n<child-component ref=\"child\"></child-component>\n\nref 属性不是一个标准的 HTML 属性，只是 Vue 中的一个属性。实际上，它甚至不会是 DOM 的一部分，所以在浏览器中你查看渲染的 HTML，你是看不到有关于 ref 的任何东西。因为在它前面没有添加:，而且它也不是一个指令\n\n<div ref=\"demo\"></div>\n\ndocument.querySelector('[ref=demo]');\n```\n","source":"_posts/2018-07-10-vue-refs.md","raw":"---\nlayout: post\ntitle: Vue中的代理Proxy和$refs\ndate: 2018-08-10\ntags: [vue]\ncategories: 前端\n---\n\n## 前言\n\n> 最近国内 VPN 限制的严厉的多，一不小心就会被抓去签保证书，为了能和小伙伴联系，也为了能查到相关资讯，了解国内动态，关注权利的猎物老郭\n> 特此写博，然而这一切都是免费的！免费的！免费的！（重要的事情讲三遍）\n\n## 正文开始\n\n一、 代理 Proxy\n\n1.  介绍\n\n1.  Proxy 又称为代理。在现实生活中，大家对代理二字并不会太陌生，比如某产品的代理。打个比方来说，我们要买一台手机，我们不会直接到一家手机厂去买，会在手机的代理商中买。\n\n1.  在 JavaScript 中，Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种元编程，即对编程语言进行编程。\n\n    3.  Proxy 可以理解成，在目标对象之前架设一层拦截，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来代理某些操作，可以译为代理器。\n\n1.  基本语法\n\n```js\n// @param {Object} target 用来被代理的对象\n// @param {Object} handler 用来设置代理的对象\nlet proxy = new Proxy(target, handler);\n```\n\n- Proxy，见名知意，其功能非常类似于设计模式中的代理模式，该模式常用于三个方面：\n\n- 拦截和监视外部对对象的访问\n\n- 降低函数或类的复杂度\n\n- 在复杂操作前对操作进行校验或对所需资源进行管理\n\n- 在支持 Proxy 的浏览器环境中，Proxy 是一个全局对象，可以直接使用。Proxy(target, handler) 是一个构造函数，target 是被代理的对象，handlder 是声明了各类代理操作的对象，最终返回一个代理对象。外界每次通过代理对象访问 target 对象的属性时，就会经过 handler 对象，从这个流程来看，代理对象很类似 middleware（中间件）。那么 Proxy 可以拦截什么操作呢？最常见的就是 get（读取）、set（修改）对象属性等操作，完整的可拦截操作列表请点击这里。此外，Proxy 对象还提供了一个 revoke 方法，可以随时注销所有的代理操作。\n\n一个代理的例子：\n\n```js\nconst target = { name: \"Billy Bob\", age: 15 };\nconst handler = {\n  get(target, key, proxy) {\n    const today = new Date();\n    console.log(`GET request made for ${key} at ${today}`);\n    return Reflect.get(target, key, proxy);\n  }\n};\nconst proxy = new Proxy(target, handler);\nproxy.name; // => \"GET request made for name at Thu Jul 21 2016 15:26:20 GMT+0800 (CST)\" // => \"Billy Bob\"\n```\n\n1.Reflect 称为反射。它也是 ES6 中为了操作对象而提供的新的 API，用来替代直接调用 Object 的方法。Reflect 是一个内置的对象，它提供可拦截 JavaScript 操作的方法。方法与代理处理程序的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。\n\nReflect 与大多数全局对象不同，Reflect 没有构造函数。你不能将其与一个 new 运算符一起使用，或者将 Reflect 对象作为一个函数来调用。\n\n1.  处理器对象 handler\n\n处理器对象 handler 一共提供了 14 种可代理操作，每种操作的代号（属性名/方法名）和触发这种操作的方式如下：\n\n- handler.getPrototypeOf()：在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy)时\n\n- handler.setPrototypeOf()：在设置代理对象的原型时触发该操作，比如在执行 Object.setprototypeOf(proxy, null)时\n\n- handler.isExtensible()：在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy)时\n\n- handler.preventExtensions()：在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy)时\n\n- handler.getOwnPropertyDescriptor()：在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, 'foo')时\n\n- handler.defineProperty()：在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy,'foo',{})时\n\n- handler.has()：在判断代理对象是否拥有某个属性时触发该操作，比如在执行'foo' in proxy 时\n\n- handler.get()：在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时\n\n- handler.set()：在给代理对象的某个赋值时触发该操作，比如在执行 proxy.foo = 1 时\n\n- handler.deleteProperty()：在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时\n\n- handler.ownKeys()：在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy)时\n\n- handler.apply()：在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy()时\n\n- handler.construct()：在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行 new proxy()时\n\nReflect 对象拥有对应的可以控制各种元编程任务的静态方法。这些功能和 Proxy 一一对应。\n\n下面的这些名称你可能看起来很眼熟（因为他们也是 Object 上的方法）：\n\n```js\nReflect.getOwnPropertyDescriptor(..)\n\nReflect.defineProperty(..)\n\nReflect.getPrototypeOf(..)\n\nReflect.setPrototypeOf(..)\n\nReflect.preventExtensions(..)\n\nReflect.isExtensible(..)\n```\n\n这些方法和在 Object 上的同名方法一样。然后，一个区别在于，Object 上这么方法的第一个参数是一个对象，Reflect 遇到这种情况会扔出一个错误。\n\n3.  陷阱代理\n\n使用 set 陷阱验证属性\n\n假设创建一个属性值是数字的对象，对象中每新增一个属性都要加以验证，如果不是数字必须抛出错误。为了实现这个任务，可以定义一个 set 陷阱来覆写设置值的默认特性。\n\nset 陷阱接受 4 个参数：\n\n- trapTaqget 用于接收属性(代理的目标)的对象\n\n- key 要写入的属性键(字符串或 Symbol 类型)\n\n- value 被写入属性的值\n\n- receiver 操作发生的对象(通常是代理)\n\n**Reflect.set()是 set 陷阱对应的反射方法和默认特性，它和 set 代理陷阱一样也接受相同的 4 个参数，以方便在陷阱中使用。如果属性已设置陷阱应该返回 true，如果未设置则返回 false。(Reflect.set()方法基于操作是否成功来返回恰当的值)。**\n\n可以使用 set 陷阱并检查传入的值来验证属性值：\n\n```js\n1 //set 陷阱并检查传入的值来验证属性值\n2 let target = { name: \"target\" };\n3 let proxy = new Proxy(target, {\n4 set(trapTarget, key, value, receiver) {\n5 // 忽略已有属性，避免影响它们\n6 if (!trapTarget.hasOwnProperty(key)) {\n7 if (isNaN(value)) { throw new TypeError(\"Property must be a number.\"); }\n8 } // 添加属性\n9 return Reflect.set(trapTarget, key, value, receiver);\n10 }\n11 });\n12 // 添加一个新属性\n13 proxy.count = 1;\n14 console.log(proxy.count); // => 1\n15 console.log(target.count); // => 1 // 你可以为 name 赋一个非数值类型的值，因为该属性已经存在\n16 proxy.name = \"proxy\";\n17 console.log(proxy.name); // => \"proxy\"\n18 console.log(target.name); // => \"proxy\"\n// 抛出错误 proxy.anotherName = \"proxy\";\n```\n\n这段代码定义了一个代理来验证添加到 target 的新属性，当执行 proxy.count=1 时，set 陷阱被调用，此时 trapTarget 的值等于 target，key 等于\"count\"，value 等于 1，receiver 等于 proxy。\n\n由于 target 上没有 count 属性，因此代理继续将 value 值传入 isNaN()，如果结果是 NaN，则证明传入的属性值不是数字，同时也抛出一个错误。在这段代码中，count 被设置为 1，所以代理调用 Reflect.set()方法并传入陷阱接受的 4 个参数来添加新属性。\n\nproxy.name 可以成功被赋值为一个字符串，这是因为 target 已经拥有一个 name 属性，但通过调用 trapTarget.hasownproperty()方法验证检查后被排除了，所以目标已有的非数字属性仍然可以被操作。\n\n然而，将 proxy.anotherName 赋值为一个字符串时会抛出错误。目标上没有 anotherName 属性，所以它的值需要被验证，而由于\"Proxy\"不是一个数字值，因此抛出错误。\n\nset 代理陷阱可以拦截写入属性的操作，get 代理陷阱可以拦截读取属性的操作\n\n用 get 陷阱验证对象结构(Object Shape)\n\nJS 有一个时常令人感到困惑的特殊行为，即读取不存在的属性时不会抛出错误，而是用 undefined 代替被读取属性的值。\n\n```js\n1 //用 get 陷阱验证对象结构(Object Shape)\n\n2 let target = {};\n\n3 console.log(target.name); // => undefined\n```\n\n对象结构是指对象中所有可用属性和方法的集合，JS 引擎通过对象结构来优化代码，通常会创建类来表示对象，如果可以安全地假定一个对象将始终具有相同的属性和方法，那么当程序试图访问不存在的属性时会抛出错误。代理让对象结构检验变得简单。\n\n因为只有当读取属性时才会检验属性，所以无论对象中是否存在某个属性，都可以通过 get 陷阱来检测，它接受 3 个参数：\n\n- trapTarget 被读取属性的源对象(代理的目标)\n\n- key 要读取的属性键(字符串或 Symbol)\n\n- receiver 操作发生的对象(通常是代理)\n\n由于 get 陷阱不写入值，所以它复刻了 set 陷阱中除 value 外的其他 3 个参数，Reflect.get()也接受同样 3 个参数并返回属性的默认值。\n\n如果属性在目标上不存在，则使用 get 陷阱和 Reflect.get()时会抛出错误：\n\n```js\nlet proxy = new Proxy(\n  {},\n  {\n    get(trapTarget, key, receiver) {\n      if (!(key in receiver)) {\n        throw new TypeError(\"Property \" + key + \" doesn't exist.\");\n      }\n\n      return Reflect.get(trapTarget, key, receiver);\n    }\n  }\n);\n\n// 添加属性的功能正常\n\nproxy.name = \"proxy\";\n\nconsole.log(proxy.name); // => \"proxy\"\n\n// 读取不存在属性会抛出错误\n\nconsole.log(proxy.nme); // => 抛出错误\n```\n\n原型代理陷阱\nObject.setPrototypeOf()方法被用于作为 ES5 中的 Object.getPrototypeOf()方法的补充。通过代理中的 setPrototypeOf 陷阱和 getPrototypeOf 陷阱可以拦截这两个方法的执行过程，在这两种情况下，Object 上的方法会调用代理中的同名陷阱来改变方法的行为。\n\n两个陷阱均与代理有关，但具体到方法只与每个陷阱的类型有关，setPrototypeOf 陷阱接受以下这些参数:\n\n- trapTarget 接受原型设置的对象(代理的目标)\n\n- proto 作为原型使用的对象\n\n传入 Object.setPrototypeOf()方法和 Reflect.setPrototypeOf()方法的均是以上两个参数，另一方面，getPrototypeOf 陷阱中的 Object.getPrototypeOf()方法和 Reflect.getPrototypeOf()方法只接受参数 trapTarget。\n\n原型代理陷阱的运行机制\n原型代理陷阱有一些限制。首先，getPrototypeOf 陷阱必须返回对象或 null，否则将导致运行时错误，返回值检查可以确保 Object.getPrototypeOf()返回的总是预期的值；其次，在 setPrototypeOf 陷阱中，如果操作失败则返回的一定是 false，此时 Object.setPrototypeOf()会抛出错误，如果 setPrototypeOf 返回了任何不是 false 的值，那么 Object.setPrototypeOf()便假设操作成功。\n\n以下示例通过总是返回 null，且不允许改变原型的方式隐藏了代理的原型:\n\n```js\n1 let target = {};\n\n2 let proxy = new Proxy(target, {\n\n3 getPrototypeOf(trapTarget) {\n\n4 returnnull;\n\n5 },\n\n6 setPrototypeOf(trapTarget, proto) {\n\n7 returnfalse;\n\n8 }\n\n9 });\n\n10 let targetProto = Object.getPrototypeOf(target);\n\n11 let proxyProto = Object.getPrototypeOf(proxy);\n\n12 console.log(targetProto ===Object.prototype); // => true\n\n13 console.log(proxyProto ===Object.prototype); // => false\n\n14 console.log(proxyProto); // => null\n\n// 成功\n\n15 Object.setPrototypeOf(target, {});\n\n// 抛出错误\n\n16 Object.setPrototypeOf(proxy, {});\n```\n\n代码强调了 target 和 proxy 的行为差异。Object.getPrototypeOf()给 target 返回的是值，而给 proxy 返回值时，由于 getPrototypeOf 陷阱被调用，返回的是 null；同样，Object.setPrototypeOf()成功为 target 设置原型，而给 proxy 设置原型时，由于 setPrototypeOf 陷阱被调用，最终抛出一个错误。\n\n一、 vue 的\\$ref\n\n一个对象，持有注册过 ref 特性 的所有 DOM 元素和组件实例。\n\nref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 \\$refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：\n\n```js\n<!-- `vm.$refs.p` will be the DOM node -->\n<p ref=\"p\">hello</p>\n\n<!-- `vm.$refs.child` will be the child component instance -->\n\n<child-component ref=\"child\"></child-component>\n\nref 属性不是一个标准的 HTML 属性，只是 Vue 中的一个属性。实际上，它甚至不会是 DOM 的一部分，所以在浏览器中你查看渲染的 HTML，你是看不到有关于 ref 的任何东西。因为在它前面没有添加:，而且它也不是一个指令\n\n<div ref=\"demo\"></div>\n\ndocument.querySelector('[ref=demo]');\n```\n","slug":"2018-07-10-vue-refs","published":1,"updated":"2020-03-14T06:52:03.314Z","comments":1,"photos":[],"link":"","_id":"ck7u2pvn5005i4k8y6momf7iy","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>最近国内 VPN 限制的严厉的多，一不小心就会被抓去签保证书，为了能和小伙伴联系，也为了能查到相关资讯，了解国内动态，关注权利的猎物老郭<br>特此写博，然而这一切都是免费的！免费的！免费的！（重要的事情讲三遍）</p>\n</blockquote>\n<h2 id=\"正文开始\"><a href=\"#正文开始\" class=\"headerlink\" title=\"正文开始\"></a>正文开始</h2><p>一、 代理 Proxy</p>\n<ol>\n<li><p>介绍</p>\n</li>\n<li><p>Proxy 又称为代理。在现实生活中，大家对代理二字并不会太陌生，比如某产品的代理。打个比方来说，我们要买一台手机，我们不会直接到一家手机厂去买，会在手机的代理商中买。</p>\n</li>\n<li><p>在 JavaScript 中，Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种元编程，即对编程语言进行编程。</p>\n<ol start=\"3\">\n<li>Proxy 可以理解成，在目标对象之前架设一层拦截，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来代理某些操作，可以译为代理器。</li>\n</ol>\n</li>\n<li><p>基本语法</p>\n</li>\n</ol>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// @param {Object} target 用来被代理的对象</span>\n<span class=\"token comment\" spellcheck=\"true\">// @param {Object} handler 用来设置代理的对象</span>\n<span class=\"token keyword\">let</span> proxy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<ul>\n<li><p>Proxy，见名知意，其功能非常类似于设计模式中的代理模式，该模式常用于三个方面：</p>\n</li>\n<li><p>拦截和监视外部对对象的访问</p>\n</li>\n<li><p>降低函数或类的复杂度</p>\n</li>\n<li><p>在复杂操作前对操作进行校验或对所需资源进行管理</p>\n</li>\n<li><p>在支持 Proxy 的浏览器环境中，Proxy 是一个全局对象，可以直接使用。Proxy(target, handler) 是一个构造函数，target 是被代理的对象，handlder 是声明了各类代理操作的对象，最终返回一个代理对象。外界每次通过代理对象访问 target 对象的属性时，就会经过 handler 对象，从这个流程来看，代理对象很类似 middleware（中间件）。那么 Proxy 可以拦截什么操作呢？最常见的就是 get（读取）、set（修改）对象属性等操作，完整的可拦截操作列表请点击这里。此外，Proxy 对象还提供了一个 revoke 方法，可以随时注销所有的代理操作。</p>\n</li>\n</ul>\n<p>一个代理的例子：</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> target <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Billy Bob\"</span><span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">:</span> <span class=\"token number\">15</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> handler <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> proxy<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> today <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`GET request made for </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>key<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> at </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>today<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> Reflect<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> proxy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> proxy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nproxy<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// => \"GET request made for name at Thu Jul 21 2016 15:26:20 GMT+0800 (CST)\" // => \"Billy Bob\"</span></code></pre>\n<p>1.Reflect 称为反射。它也是 ES6 中为了操作对象而提供的新的 API，用来替代直接调用 Object 的方法。Reflect 是一个内置的对象，它提供可拦截 JavaScript 操作的方法。方法与代理处理程序的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。</p>\n<p>Reflect 与大多数全局对象不同，Reflect 没有构造函数。你不能将其与一个 new 运算符一起使用，或者将 Reflect 对象作为一个函数来调用。</p>\n<ol>\n<li>处理器对象 handler</li>\n</ol>\n<p>处理器对象 handler 一共提供了 14 种可代理操作，每种操作的代号（属性名/方法名）和触发这种操作的方式如下：</p>\n<ul>\n<li><p>handler.getPrototypeOf()：在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy)时</p>\n</li>\n<li><p>handler.setPrototypeOf()：在设置代理对象的原型时触发该操作，比如在执行 Object.setprototypeOf(proxy, null)时</p>\n</li>\n<li><p>handler.isExtensible()：在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy)时</p>\n</li>\n<li><p>handler.preventExtensions()：在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy)时</p>\n</li>\n<li><p>handler.getOwnPropertyDescriptor()：在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, ‘foo’)时</p>\n</li>\n<li><p>handler.defineProperty()：在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy,’foo’,{})时</p>\n</li>\n<li><p>handler.has()：在判断代理对象是否拥有某个属性时触发该操作，比如在执行’foo’ in proxy 时</p>\n</li>\n<li><p>handler.get()：在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时</p>\n</li>\n<li><p>handler.set()：在给代理对象的某个赋值时触发该操作，比如在执行 proxy.foo = 1 时</p>\n</li>\n<li><p>handler.deleteProperty()：在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时</p>\n</li>\n<li><p>handler.ownKeys()：在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy)时</p>\n</li>\n<li><p>handler.apply()：在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy()时</p>\n</li>\n<li><p>handler.construct()：在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行 new proxy()时</p>\n</li>\n</ul>\n<p>Reflect 对象拥有对应的可以控制各种元编程任务的静态方法。这些功能和 Proxy 一一对应。</p>\n<p>下面的这些名称你可能看起来很眼熟（因为他们也是 Object 上的方法）：</p>\n<pre class=\" language-js\"><code class=\"language-js\">Reflect<span class=\"token punctuation\">.</span><span class=\"token function\">getOwnPropertyDescriptor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\n\nReflect<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\n\nReflect<span class=\"token punctuation\">.</span><span class=\"token function\">getPrototypeOf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\n\nReflect<span class=\"token punctuation\">.</span><span class=\"token function\">setPrototypeOf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\n\nReflect<span class=\"token punctuation\">.</span><span class=\"token function\">preventExtensions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\n\nReflect<span class=\"token punctuation\">.</span><span class=\"token function\">isExtensible</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span></code></pre>\n<p>这些方法和在 Object 上的同名方法一样。然后，一个区别在于，Object 上这么方法的第一个参数是一个对象，Reflect 遇到这种情况会扔出一个错误。</p>\n<ol start=\"3\">\n<li>陷阱代理</li>\n</ol>\n<p>使用 set 陷阱验证属性</p>\n<p>假设创建一个属性值是数字的对象，对象中每新增一个属性都要加以验证，如果不是数字必须抛出错误。为了实现这个任务，可以定义一个 set 陷阱来覆写设置值的默认特性。</p>\n<p>set 陷阱接受 4 个参数：</p>\n<ul>\n<li><p>trapTaqget 用于接收属性(代理的目标)的对象</p>\n</li>\n<li><p>key 要写入的属性键(字符串或 Symbol 类型)</p>\n</li>\n<li><p>value 被写入属性的值</p>\n</li>\n<li><p>receiver 操作发生的对象(通常是代理)</p>\n</li>\n</ul>\n<p><strong>Reflect.set()是 set 陷阱对应的反射方法和默认特性，它和 set 代理陷阱一样也接受相同的 4 个参数，以方便在陷阱中使用。如果属性已设置陷阱应该返回 true，如果未设置则返回 false。(Reflect.set()方法基于操作是否成功来返回恰当的值)。</strong></p>\n<p>可以使用 set 陷阱并检查传入的值来验证属性值：</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token number\">1</span> <span class=\"token comment\" spellcheck=\"true\">//set 陷阱并检查传入的值来验证属性值</span>\n<span class=\"token number\">2</span> <span class=\"token keyword\">let</span> target <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"target\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">3</span> <span class=\"token keyword\">let</span> proxy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n<span class=\"token number\">4</span> <span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>trapTarget<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token number\">5</span> <span class=\"token comment\" spellcheck=\"true\">// 忽略已有属性，避免影响它们</span>\n<span class=\"token number\">6</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>trapTarget<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token number\">7</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isNaN</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Property must be a number.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token number\">8</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">// 添加属性</span>\n<span class=\"token number\">9</span> <span class=\"token keyword\">return</span> Reflect<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>trapTarget<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">10</span> <span class=\"token punctuation\">}</span>\n<span class=\"token number\">11</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">12</span> <span class=\"token comment\" spellcheck=\"true\">// 添加一个新属性</span>\n<span class=\"token number\">13</span> proxy<span class=\"token punctuation\">.</span>count <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">14</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>proxy<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// => 1</span>\n<span class=\"token number\">15</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// => 1 // 你可以为 name 赋一个非数值类型的值，因为该属性已经存在</span>\n<span class=\"token number\">16</span> proxy<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"proxy\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">17</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>proxy<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// => \"proxy\"</span>\n<span class=\"token number\">18</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// => \"proxy\"</span>\n<span class=\"token comment\" spellcheck=\"true\">// 抛出错误 proxy.anotherName = \"proxy\";</span></code></pre>\n<p>这段代码定义了一个代理来验证添加到 target 的新属性，当执行 proxy.count=1 时，set 陷阱被调用，此时 trapTarget 的值等于 target，key 等于”count”，value 等于 1，receiver 等于 proxy。</p>\n<p>由于 target 上没有 count 属性，因此代理继续将 value 值传入 isNaN()，如果结果是 NaN，则证明传入的属性值不是数字，同时也抛出一个错误。在这段代码中，count 被设置为 1，所以代理调用 Reflect.set()方法并传入陷阱接受的 4 个参数来添加新属性。</p>\n<p>proxy.name 可以成功被赋值为一个字符串，这是因为 target 已经拥有一个 name 属性，但通过调用 trapTarget.hasownproperty()方法验证检查后被排除了，所以目标已有的非数字属性仍然可以被操作。</p>\n<p>然而，将 proxy.anotherName 赋值为一个字符串时会抛出错误。目标上没有 anotherName 属性，所以它的值需要被验证，而由于”Proxy”不是一个数字值，因此抛出错误。</p>\n<p>set 代理陷阱可以拦截写入属性的操作，get 代理陷阱可以拦截读取属性的操作</p>\n<p>用 get 陷阱验证对象结构(Object Shape)</p>\n<p>JS 有一个时常令人感到困惑的特殊行为，即读取不存在的属性时不会抛出错误，而是用 undefined 代替被读取属性的值。</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token number\">1</span> <span class=\"token comment\" spellcheck=\"true\">//用 get 陷阱验证对象结构(Object Shape)</span>\n\n<span class=\"token number\">2</span> <span class=\"token keyword\">let</span> target <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token number\">3</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// => undefined</span></code></pre>\n<p>对象结构是指对象中所有可用属性和方法的集合，JS 引擎通过对象结构来优化代码，通常会创建类来表示对象，如果可以安全地假定一个对象将始终具有相同的属性和方法，那么当程序试图访问不存在的属性时会抛出错误。代理让对象结构检验变得简单。</p>\n<p>因为只有当读取属性时才会检验属性，所以无论对象中是否存在某个属性，都可以通过 get 陷阱来检测，它接受 3 个参数：</p>\n<ul>\n<li><p>trapTarget 被读取属性的源对象(代理的目标)</p>\n</li>\n<li><p>key 要读取的属性键(字符串或 Symbol)</p>\n</li>\n<li><p>receiver 操作发生的对象(通常是代理)</p>\n</li>\n</ul>\n<p>由于 get 陷阱不写入值，所以它复刻了 set 陷阱中除 value 外的其他 3 个参数，Reflect.get()也接受同样 3 个参数并返回属性的默认值。</p>\n<p>如果属性在目标上不存在，则使用 get 陷阱和 Reflect.get()时会抛出错误：</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> proxy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span>\n  <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>trapTarget<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>key <span class=\"token keyword\">in</span> receiver<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Property \"</span> <span class=\"token operator\">+</span> key <span class=\"token operator\">+</span> <span class=\"token string\">\" doesn't exist.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">return</span> Reflect<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>trapTarget<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 添加属性的功能正常</span>\n\nproxy<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"proxy\"</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>proxy<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// => \"proxy\"</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 读取不存在属性会抛出错误</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>proxy<span class=\"token punctuation\">.</span>nme<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// => 抛出错误</span></code></pre>\n<p>原型代理陷阱<br>Object.setPrototypeOf()方法被用于作为 ES5 中的 Object.getPrototypeOf()方法的补充。通过代理中的 setPrototypeOf 陷阱和 getPrototypeOf 陷阱可以拦截这两个方法的执行过程，在这两种情况下，Object 上的方法会调用代理中的同名陷阱来改变方法的行为。</p>\n<p>两个陷阱均与代理有关，但具体到方法只与每个陷阱的类型有关，setPrototypeOf 陷阱接受以下这些参数:</p>\n<ul>\n<li><p>trapTarget 接受原型设置的对象(代理的目标)</p>\n</li>\n<li><p>proto 作为原型使用的对象</p>\n</li>\n</ul>\n<p>传入 Object.setPrototypeOf()方法和 Reflect.setPrototypeOf()方法的均是以上两个参数，另一方面，getPrototypeOf 陷阱中的 Object.getPrototypeOf()方法和 Reflect.getPrototypeOf()方法只接受参数 trapTarget。</p>\n<p>原型代理陷阱的运行机制<br>原型代理陷阱有一些限制。首先，getPrototypeOf 陷阱必须返回对象或 null，否则将导致运行时错误，返回值检查可以确保 Object.getPrototypeOf()返回的总是预期的值；其次，在 setPrototypeOf 陷阱中，如果操作失败则返回的一定是 false，此时 Object.setPrototypeOf()会抛出错误，如果 setPrototypeOf 返回了任何不是 false 的值，那么 Object.setPrototypeOf()便假设操作成功。</p>\n<p>以下示例通过总是返回 null，且不允许改变原型的方式隐藏了代理的原型:</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token number\">1</span> <span class=\"token keyword\">let</span> target <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token number\">2</span> <span class=\"token keyword\">let</span> proxy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token number\">3</span> <span class=\"token function\">getPrototypeOf</span><span class=\"token punctuation\">(</span>trapTarget<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token number\">4</span> returnnull<span class=\"token punctuation\">;</span>\n\n<span class=\"token number\">5</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n<span class=\"token number\">6</span> <span class=\"token function\">setPrototypeOf</span><span class=\"token punctuation\">(</span>trapTarget<span class=\"token punctuation\">,</span> proto<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token number\">7</span> returnfalse<span class=\"token punctuation\">;</span>\n\n<span class=\"token number\">8</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token number\">9</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token number\">10</span> <span class=\"token keyword\">let</span> targetProto <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">getPrototypeOf</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token number\">11</span> <span class=\"token keyword\">let</span> proxyProto <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">getPrototypeOf</span><span class=\"token punctuation\">(</span>proxy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token number\">12</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>targetProto <span class=\"token operator\">===</span>Object<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// => true</span>\n\n<span class=\"token number\">13</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>proxyProto <span class=\"token operator\">===</span>Object<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// => false</span>\n\n<span class=\"token number\">14</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>proxyProto<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// => null</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 成功</span>\n\n<span class=\"token number\">15</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">setPrototypeOf</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 抛出错误</span>\n\n<span class=\"token number\">16</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">setPrototypeOf</span><span class=\"token punctuation\">(</span>proxy<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>代码强调了 target 和 proxy 的行为差异。Object.getPrototypeOf()给 target 返回的是值，而给 proxy 返回值时，由于 getPrototypeOf 陷阱被调用，返回的是 null；同样，Object.setPrototypeOf()成功为 target 设置原型，而给 proxy 设置原型时，由于 setPrototypeOf 陷阱被调用，最终抛出一个错误。</p>\n<p>一、 vue 的$ref</p>\n<p>一个对象，持有注册过 ref 特性 的所有 DOM 元素和组件实例。</p>\n<p>ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> <span class=\"token template-string\"><span class=\"token string\">`vm.$refs.p`</span></span> will be the DOM node <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>p ref<span class=\"token operator\">=</span><span class=\"token string\">\"p\"</span><span class=\"token operator\">></span>hello<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> <span class=\"token template-string\"><span class=\"token string\">`vm.$refs.child`</span></span> will be the child component instance <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n\n<span class=\"token operator\">&lt;</span>child<span class=\"token operator\">-</span>component ref<span class=\"token operator\">=</span><span class=\"token string\">\"child\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>child<span class=\"token operator\">-</span>component<span class=\"token operator\">></span>\n\nref 属性不是一个标准的 HTML 属性，只是 Vue 中的一个属性。实际上，它甚至不会是 DOM 的一部分，所以在浏览器中你查看渲染的 HTML，你是看不到有关于 ref 的任何东西。因为在它前面没有添加<span class=\"token punctuation\">:</span>，而且它也不是一个指令\n\n<span class=\"token operator\">&lt;</span>div ref<span class=\"token operator\">=</span><span class=\"token string\">\"demo\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n\ndocument<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'[ref=demo]'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>最近国内 VPN 限制的严厉的多，一不小心就会被抓去签保证书，为了能和小伙伴联系，也为了能查到相关资讯，了解国内动态，关注权利的猎物老郭<br>特此写博，然而这一切都是免费的！免费的！免费的！（重要的事情讲三遍）</p>\n</blockquote>\n<h2 id=\"正文开始\"><a href=\"#正文开始\" class=\"headerlink\" title=\"正文开始\"></a>正文开始</h2><p>一、 代理 Proxy</p>\n<ol>\n<li><p>介绍</p>\n</li>\n<li><p>Proxy 又称为代理。在现实生活中，大家对代理二字并不会太陌生，比如某产品的代理。打个比方来说，我们要买一台手机，我们不会直接到一家手机厂去买，会在手机的代理商中买。</p>\n</li>\n<li><p>在 JavaScript 中，Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种元编程，即对编程语言进行编程。</p>\n<ol start=\"3\">\n<li>Proxy 可以理解成，在目标对象之前架设一层拦截，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来代理某些操作，可以译为代理器。</li>\n</ol>\n</li>\n<li><p>基本语法</p>\n</li>\n</ol>\n<pre><code class=\"js\">// @param {Object} target 用来被代理的对象\n// @param {Object} handler 用来设置代理的对象\nlet proxy = new Proxy(target, handler);</code></pre>\n<ul>\n<li><p>Proxy，见名知意，其功能非常类似于设计模式中的代理模式，该模式常用于三个方面：</p>\n</li>\n<li><p>拦截和监视外部对对象的访问</p>\n</li>\n<li><p>降低函数或类的复杂度</p>\n</li>\n<li><p>在复杂操作前对操作进行校验或对所需资源进行管理</p>\n</li>\n<li><p>在支持 Proxy 的浏览器环境中，Proxy 是一个全局对象，可以直接使用。Proxy(target, handler) 是一个构造函数，target 是被代理的对象，handlder 是声明了各类代理操作的对象，最终返回一个代理对象。外界每次通过代理对象访问 target 对象的属性时，就会经过 handler 对象，从这个流程来看，代理对象很类似 middleware（中间件）。那么 Proxy 可以拦截什么操作呢？最常见的就是 get（读取）、set（修改）对象属性等操作，完整的可拦截操作列表请点击这里。此外，Proxy 对象还提供了一个 revoke 方法，可以随时注销所有的代理操作。</p>\n</li>\n</ul>\n<p>一个代理的例子：</p>\n<pre><code class=\"js\">const target = { name: &quot;Billy Bob&quot;, age: 15 };\nconst handler = {\n  get(target, key, proxy) {\n    const today = new Date();\n    console.log(`GET request made for ${key} at ${today}`);\n    return Reflect.get(target, key, proxy);\n  }\n};\nconst proxy = new Proxy(target, handler);\nproxy.name; // =&gt; &quot;GET request made for name at Thu Jul 21 2016 15:26:20 GMT+0800 (CST)&quot; // =&gt; &quot;Billy Bob&quot;</code></pre>\n<p>1.Reflect 称为反射。它也是 ES6 中为了操作对象而提供的新的 API，用来替代直接调用 Object 的方法。Reflect 是一个内置的对象，它提供可拦截 JavaScript 操作的方法。方法与代理处理程序的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。</p>\n<p>Reflect 与大多数全局对象不同，Reflect 没有构造函数。你不能将其与一个 new 运算符一起使用，或者将 Reflect 对象作为一个函数来调用。</p>\n<ol>\n<li>处理器对象 handler</li>\n</ol>\n<p>处理器对象 handler 一共提供了 14 种可代理操作，每种操作的代号（属性名/方法名）和触发这种操作的方式如下：</p>\n<ul>\n<li><p>handler.getPrototypeOf()：在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy)时</p>\n</li>\n<li><p>handler.setPrototypeOf()：在设置代理对象的原型时触发该操作，比如在执行 Object.setprototypeOf(proxy, null)时</p>\n</li>\n<li><p>handler.isExtensible()：在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy)时</p>\n</li>\n<li><p>handler.preventExtensions()：在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy)时</p>\n</li>\n<li><p>handler.getOwnPropertyDescriptor()：在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, ‘foo’)时</p>\n</li>\n<li><p>handler.defineProperty()：在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy,’foo’,{})时</p>\n</li>\n<li><p>handler.has()：在判断代理对象是否拥有某个属性时触发该操作，比如在执行’foo’ in proxy 时</p>\n</li>\n<li><p>handler.get()：在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时</p>\n</li>\n<li><p>handler.set()：在给代理对象的某个赋值时触发该操作，比如在执行 proxy.foo = 1 时</p>\n</li>\n<li><p>handler.deleteProperty()：在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时</p>\n</li>\n<li><p>handler.ownKeys()：在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy)时</p>\n</li>\n<li><p>handler.apply()：在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy()时</p>\n</li>\n<li><p>handler.construct()：在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行 new proxy()时</p>\n</li>\n</ul>\n<p>Reflect 对象拥有对应的可以控制各种元编程任务的静态方法。这些功能和 Proxy 一一对应。</p>\n<p>下面的这些名称你可能看起来很眼熟（因为他们也是 Object 上的方法）：</p>\n<pre><code class=\"js\">Reflect.getOwnPropertyDescriptor(..)\n\nReflect.defineProperty(..)\n\nReflect.getPrototypeOf(..)\n\nReflect.setPrototypeOf(..)\n\nReflect.preventExtensions(..)\n\nReflect.isExtensible(..)</code></pre>\n<p>这些方法和在 Object 上的同名方法一样。然后，一个区别在于，Object 上这么方法的第一个参数是一个对象，Reflect 遇到这种情况会扔出一个错误。</p>\n<ol start=\"3\">\n<li>陷阱代理</li>\n</ol>\n<p>使用 set 陷阱验证属性</p>\n<p>假设创建一个属性值是数字的对象，对象中每新增一个属性都要加以验证，如果不是数字必须抛出错误。为了实现这个任务，可以定义一个 set 陷阱来覆写设置值的默认特性。</p>\n<p>set 陷阱接受 4 个参数：</p>\n<ul>\n<li><p>trapTaqget 用于接收属性(代理的目标)的对象</p>\n</li>\n<li><p>key 要写入的属性键(字符串或 Symbol 类型)</p>\n</li>\n<li><p>value 被写入属性的值</p>\n</li>\n<li><p>receiver 操作发生的对象(通常是代理)</p>\n</li>\n</ul>\n<p><strong>Reflect.set()是 set 陷阱对应的反射方法和默认特性，它和 set 代理陷阱一样也接受相同的 4 个参数，以方便在陷阱中使用。如果属性已设置陷阱应该返回 true，如果未设置则返回 false。(Reflect.set()方法基于操作是否成功来返回恰当的值)。</strong></p>\n<p>可以使用 set 陷阱并检查传入的值来验证属性值：</p>\n<pre><code class=\"js\">1 //set 陷阱并检查传入的值来验证属性值\n2 let target = { name: &quot;target&quot; };\n3 let proxy = new Proxy(target, {\n4 set(trapTarget, key, value, receiver) {\n5 // 忽略已有属性，避免影响它们\n6 if (!trapTarget.hasOwnProperty(key)) {\n7 if (isNaN(value)) { throw new TypeError(&quot;Property must be a number.&quot;); }\n8 } // 添加属性\n9 return Reflect.set(trapTarget, key, value, receiver);\n10 }\n11 });\n12 // 添加一个新属性\n13 proxy.count = 1;\n14 console.log(proxy.count); // =&gt; 1\n15 console.log(target.count); // =&gt; 1 // 你可以为 name 赋一个非数值类型的值，因为该属性已经存在\n16 proxy.name = &quot;proxy&quot;;\n17 console.log(proxy.name); // =&gt; &quot;proxy&quot;\n18 console.log(target.name); // =&gt; &quot;proxy&quot;\n// 抛出错误 proxy.anotherName = &quot;proxy&quot;;</code></pre>\n<p>这段代码定义了一个代理来验证添加到 target 的新属性，当执行 proxy.count=1 时，set 陷阱被调用，此时 trapTarget 的值等于 target，key 等于”count”，value 等于 1，receiver 等于 proxy。</p>\n<p>由于 target 上没有 count 属性，因此代理继续将 value 值传入 isNaN()，如果结果是 NaN，则证明传入的属性值不是数字，同时也抛出一个错误。在这段代码中，count 被设置为 1，所以代理调用 Reflect.set()方法并传入陷阱接受的 4 个参数来添加新属性。</p>\n<p>proxy.name 可以成功被赋值为一个字符串，这是因为 target 已经拥有一个 name 属性，但通过调用 trapTarget.hasownproperty()方法验证检查后被排除了，所以目标已有的非数字属性仍然可以被操作。</p>\n<p>然而，将 proxy.anotherName 赋值为一个字符串时会抛出错误。目标上没有 anotherName 属性，所以它的值需要被验证，而由于”Proxy”不是一个数字值，因此抛出错误。</p>\n<p>set 代理陷阱可以拦截写入属性的操作，get 代理陷阱可以拦截读取属性的操作</p>\n<p>用 get 陷阱验证对象结构(Object Shape)</p>\n<p>JS 有一个时常令人感到困惑的特殊行为，即读取不存在的属性时不会抛出错误，而是用 undefined 代替被读取属性的值。</p>\n<pre><code class=\"js\">1 //用 get 陷阱验证对象结构(Object Shape)\n\n2 let target = {};\n\n3 console.log(target.name); // =&gt; undefined</code></pre>\n<p>对象结构是指对象中所有可用属性和方法的集合，JS 引擎通过对象结构来优化代码，通常会创建类来表示对象，如果可以安全地假定一个对象将始终具有相同的属性和方法，那么当程序试图访问不存在的属性时会抛出错误。代理让对象结构检验变得简单。</p>\n<p>因为只有当读取属性时才会检验属性，所以无论对象中是否存在某个属性，都可以通过 get 陷阱来检测，它接受 3 个参数：</p>\n<ul>\n<li><p>trapTarget 被读取属性的源对象(代理的目标)</p>\n</li>\n<li><p>key 要读取的属性键(字符串或 Symbol)</p>\n</li>\n<li><p>receiver 操作发生的对象(通常是代理)</p>\n</li>\n</ul>\n<p>由于 get 陷阱不写入值，所以它复刻了 set 陷阱中除 value 外的其他 3 个参数，Reflect.get()也接受同样 3 个参数并返回属性的默认值。</p>\n<p>如果属性在目标上不存在，则使用 get 陷阱和 Reflect.get()时会抛出错误：</p>\n<pre><code class=\"js\">let proxy = new Proxy(\n  {},\n  {\n    get(trapTarget, key, receiver) {\n      if (!(key in receiver)) {\n        throw new TypeError(&quot;Property &quot; + key + &quot; doesn&#39;t exist.&quot;);\n      }\n\n      return Reflect.get(trapTarget, key, receiver);\n    }\n  }\n);\n\n// 添加属性的功能正常\n\nproxy.name = &quot;proxy&quot;;\n\nconsole.log(proxy.name); // =&gt; &quot;proxy&quot;\n\n// 读取不存在属性会抛出错误\n\nconsole.log(proxy.nme); // =&gt; 抛出错误</code></pre>\n<p>原型代理陷阱<br>Object.setPrototypeOf()方法被用于作为 ES5 中的 Object.getPrototypeOf()方法的补充。通过代理中的 setPrototypeOf 陷阱和 getPrototypeOf 陷阱可以拦截这两个方法的执行过程，在这两种情况下，Object 上的方法会调用代理中的同名陷阱来改变方法的行为。</p>\n<p>两个陷阱均与代理有关，但具体到方法只与每个陷阱的类型有关，setPrototypeOf 陷阱接受以下这些参数:</p>\n<ul>\n<li><p>trapTarget 接受原型设置的对象(代理的目标)</p>\n</li>\n<li><p>proto 作为原型使用的对象</p>\n</li>\n</ul>\n<p>传入 Object.setPrototypeOf()方法和 Reflect.setPrototypeOf()方法的均是以上两个参数，另一方面，getPrototypeOf 陷阱中的 Object.getPrototypeOf()方法和 Reflect.getPrototypeOf()方法只接受参数 trapTarget。</p>\n<p>原型代理陷阱的运行机制<br>原型代理陷阱有一些限制。首先，getPrototypeOf 陷阱必须返回对象或 null，否则将导致运行时错误，返回值检查可以确保 Object.getPrototypeOf()返回的总是预期的值；其次，在 setPrototypeOf 陷阱中，如果操作失败则返回的一定是 false，此时 Object.setPrototypeOf()会抛出错误，如果 setPrototypeOf 返回了任何不是 false 的值，那么 Object.setPrototypeOf()便假设操作成功。</p>\n<p>以下示例通过总是返回 null，且不允许改变原型的方式隐藏了代理的原型:</p>\n<pre><code class=\"js\">1 let target = {};\n\n2 let proxy = new Proxy(target, {\n\n3 getPrototypeOf(trapTarget) {\n\n4 returnnull;\n\n5 },\n\n6 setPrototypeOf(trapTarget, proto) {\n\n7 returnfalse;\n\n8 }\n\n9 });\n\n10 let targetProto = Object.getPrototypeOf(target);\n\n11 let proxyProto = Object.getPrototypeOf(proxy);\n\n12 console.log(targetProto ===Object.prototype); // =&gt; true\n\n13 console.log(proxyProto ===Object.prototype); // =&gt; false\n\n14 console.log(proxyProto); // =&gt; null\n\n// 成功\n\n15 Object.setPrototypeOf(target, {});\n\n// 抛出错误\n\n16 Object.setPrototypeOf(proxy, {});</code></pre>\n<p>代码强调了 target 和 proxy 的行为差异。Object.getPrototypeOf()给 target 返回的是值，而给 proxy 返回值时，由于 getPrototypeOf 陷阱被调用，返回的是 null；同样，Object.setPrototypeOf()成功为 target 设置原型，而给 proxy 设置原型时，由于 setPrototypeOf 陷阱被调用，最终抛出一个错误。</p>\n<p>一、 vue 的$ref</p>\n<p>一个对象，持有注册过 ref 特性 的所有 DOM 元素和组件实例。</p>\n<p>ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：</p>\n<pre><code class=\"js\">&lt;!-- `vm.$refs.p` will be the DOM node --&gt;\n&lt;p ref=&quot;p&quot;&gt;hello&lt;/p&gt;\n\n&lt;!-- `vm.$refs.child` will be the child component instance --&gt;\n\n&lt;child-component ref=&quot;child&quot;&gt;&lt;/child-component&gt;\n\nref 属性不是一个标准的 HTML 属性，只是 Vue 中的一个属性。实际上，它甚至不会是 DOM 的一部分，所以在浏览器中你查看渲染的 HTML，你是看不到有关于 ref 的任何东西。因为在它前面没有添加:，而且它也不是一个指令\n\n&lt;div ref=&quot;demo&quot;&gt;&lt;/div&gt;\n\ndocument.querySelector(&#39;[ref=demo]&#39;);</code></pre>\n"},{"layout":"post","title":"基于 Vue拓展的 v-xxx 库","date":"2019-10-11T16:00:00.000Z","top":true,"_content":"\n> **君问归期未有期，巴山夜雨涨秋池。** > **何当共剪西窗烛，却话巴山夜雨时。**\n\n作为`vue`轻车熟路的老司机，经常会用到一些指令，`vue`官方提供的指令又太少，无法满足旺盛的欲望，而每次要写一遍，终日郁郁寡欢，从小就教育我们乐于助人，为了将奉献精神贯彻始终，用了这个库，空下来大把时间陪陪家人朋友岂不乐哉。\n\n闲话少叙，直逼主题，毕竟我们是正经的官方软文。\n\n- **[查看官网](https://www.jixiaokang.com/vue-v-xxx/)**\n- **[查看源码](https://github.com/xkloveme/vue-v-xxx/)**\n\n## 什么是 vue 指令?\n\n---\n\n- 在我们了解库之前,我们先回顾一下`Vue`指令\n\n### 1. 我们经常用的有一下几种指令\n\n```js\nv-text 、 v-html 、 v-show 、 v-if 、 v-else 、v-for 、 v-bind 、 v-on 、\nv-model 、 v-once\n```\n\n> 具体用法[前去官网](https://cn.vuejs.org/v2/guide/conditional.html),不再赘述\n\n### 什么是自定义指令?\n\n> 有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令.\n\n```js\n<input  v-focus>// 为例\n\n// 在组件内部\ndirectives: {\n  focus: {\n  // 指令的定义\n  inserted: function (el) {\n    el.focus()\n    }\n  }\n}\n```\n\n### 钩子函数\n\n一个指令定义对象可以提供如下几个钩子函数 (均为可选)：\n\n- `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n\n- `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\n\n- `update`：所在组件的 VNode 更新时调用，**但是可能发生在其子 VNode 更新之前**。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。\n\n- `componentUpdated`：指令所在组件的 VNode **及其子 VNode** 全部更新后调用。\n\n- `unbind`：只调用一次，指令与元素解绑时调用。\n\n### 钩子函数的参数\n\n- `el`：指令所绑定的元素，可以用来直接操作 DOM 。\n- `binding`：一个对象，包含以下属性：\n  - `name`：指令名，不包括 `v-` 前缀。\n  - `value`：指令的绑定值，例如：`v-my-directive=\"1 + 1\"` 中，绑定值为 `2`。\n  - `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。\n  - `expression`：字符串形式的指令表达式。例如 `v-my-directive=\"1 + 1\"` 中，表达式为 `\"1 + 1\"`。\n  - `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `\"foo\"`。\n  - `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`。\n- `vnode`：Vue 编译生成的虚拟节点。\n- `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。\n\n## 怎么安装 vue-v-xxx?\n\n---\n\n> 基于 vue 指令,又新增丰富一些常用的指令,看看是怎么使用的吧\n\n### 安装\n\n- 您可以通过 npm 安装,推荐使用 `npm` 的方式安装，它能更好地和 `webpack` 打包工具配合使用。\n\n```bash\n\n# install vue-v-xxx\n\n npm install vue-v-xxx --save\n\n# or\n\n yarn add vue-v-xxx --save\n\n```\n\n- 您也可以通过 unpkg.com/vue-v-xxx 获取到最新版本的资源，在页面上引入 js 和 css 文件即可开始使用。\n\n```html\n<!-- 引入样式 -->\n\n<link rel=\"stylesheet\" href=\"https://unpkg.com/vue-v-xxx/lib/vue-v-xxx.css\" />\n\n<!-- 引入组件库 -->\n\n<script src=\"https://unpkg.com/vue-v-xxx\"></script>\n```\n\n### 使用\n\n- 您可以在`main.js`里面全局注册,在组件内就可以应用了[推荐工程](https://github.com/xkloveme/vue-v-xxx-project)\n\n```js\nimport Vue from \"vue\";\n\nimport App from \"./App\";\n\nimport Vxxx from \"vue-v-xxx\";\n\nimport \"vue-v-xxx/lib/vue-v-xxx.css\";\n\nVue.config.productionTip = false;\n\nVue.use(Vxxx);\n\n/* eslint-disable no-new */\n\nnew Vue({\n  el: \"#app\",\n\n  components: { App },\n\n  template: \"<App/>\"\n});\n```\n\n- 您可以通过 CDN 可以快速使用 vue-v-xxx 写出一个示例，您可以复制下面代码或[在线预览](https://codesandbox.io/s/vue-v-xxx-bndj4)\n\n```html\n<!DOCTYPE html>\n\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n\n    <title>vue-v-xxx</title>\n\n    <link\n      rel=\"stylesheet\"\n      href=\"https://unpkg.com/vue-v-xxx/lib/vue-v-xxx.css\"\n    />\n  </head>\n\n  <body>\n    <div id=\"app\">\n      <h1 title=\"Welcome\">欢迎使用 {{ value }}</h1>\n\n      <button v-copy=\"value\">Click me!</button>\n    </div>\n  </body>\n\n  <!-- import Vue before vue-v-xxx -->\n\n  <script src=\"https://unpkg.com/vue/dist/vue.js\"></script>\n\n  <!-- import JavaScript -->\n\n  <script src=\"https://unpkg.com/vue-v-xxx/lib/vue-v-xxx.umd.js\"></script>\n\n  <script>\n    new Vue({\n      el: \"#app\",\n\n      data: {\n        value: \"vue-v-xxx\"\n      }\n    });\n  </script>\n</html>\n```\n\n## 我们提供了那些额外的指令?\n\n---\n\n### v-call 拨打指令\n\n> 该指令快速唤起拨打电话或者发送短信\n\n- [在线预览](https://www.jixiaokang.com/vue-v-xxx/configurations/v-call.html)\n\n- 使用案例\n\n```\n<template lang=\"pug\">\n.v-xxx\n  div(v-call=\"tel\") 点击拨打☎️\n  div(v-call:sms=\"10086\") 点击发短信💬\n</template>\n<script>\n  export default {\n    name: 'v-call',\n    data() {\n      return {\n        tel: '10086'\n      }\n    }\n  }\n</script>\n```\n\n### v-copy 复制指令\n\n> 在很多情况下，我们需要复制操作\n\n- [在线预览](https://www.jixiaokang.com/vue-v-xxx/configurations/v-copy.html)\n\n- 使用案例\n\n```\n<template lang=\"pug\">\n.v-xxx\n  Button(@click=\"handleClick\" v-copy=\"value\") 点击复制\n  div\n    textarea(placeholder=\"Paste here\" style=\"margin-top:40px;width:100%;height:100%;\")\n</template>\n<script>\n  export default {\n    name: 'v-copy',\n    data() {\n      return {\n        value: ''\n      }\n    },\n    methods: {\n      handleClick(html = '你复制了我,去粘贴吧') {\n        this.value = html\n      }\n    }\n  }\n</script>\n```\n\n### v-debounce 防抖指令\n\n> `v-debounce` 支持传入防抖时间`v-debounce:500` 默认 500ms\n\n- [在线预览](https://www.jixiaokang.com/vue-v-xxx/configurations/v-debounce.html)\n\n```\n<template lang=\"pug\">\n.v-xxx\n  h1 未加防抖\n  h2 点击次数:{{num}}\n  Button(@click=\"addNum\") (点我)\n  h1 加入防抖\n  h2 点击次数:{{num2}}\n  Button(v-debounce=\"addNum2\") (点我)\n</template>\n<script>\nexport default {\n  name: 'v-debounce',\n  data () {\n    return {\n      num: 0,\n      num2: 0,\n    }\n  },\n  methods: {\n    addNum () {\n      this.num++\n    },\n    addNum2 () {\n      this.num2++\n    }\n  }\n}\n</script>\n```\n\n### v-throttle 节流指令\n\n> `v-throttle` 支持传入防抖时间`v-throttle:2000` 默认 2s\n\n- [在线预览](https://www.jixiaokang.com/vue-v-xxx/configurations/v-throttle.html)\n\n```\n<template lang=\"pug\">\n.v-xxx\n  h3 立即触发:{{num}}\n  input(v-model=\"num\")\n  h3 节流后:{{num2}}\n  input(v-throttle:2000=\"num2\")\n</template>\n<script>\n  export default {\n    name: 'v-throttle',\n    data() {\n      return {\n        num: '立即改变',\n        num2: '节流值'\n      }\n    }\n  }\n</script>\n```\n\n### v-ellipsis 省略指令\n\n> `v-ellipsis` 在表格中经常使用,`v-ellipsis`默认单行省略\n\n- [在线预览](https://www.jixiaokang.com/vue-v-xxx/configurations/v-ellipsis.html)\n\n```\n<template lang=\"pug\">\n.v-xxx\n  div(v-ellipsis) {{des}}\n  div(v-ellipsis:3)\n    p {{des2}}\n</template>\n<script>\nexport default {\n  name: 'v-ellipsis',\n  data() {\n    return {\n      des:\n        '单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略',\n      des2:\n        '多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略'\n    }\n  }\n}\n</script>\n```\n\n### v-pin 固定指令\n\n> `v-pin` 支持传入定位位置和定位值`v-pin:left || top` 默认 left\n\n- [在线预览](https://www.jixiaokang.com/vue-v-xxx/configurations/v-pin.html)\n\n```\n<template lang=\"pug\">\n.v-xxx\n  div(v-pin=\"200\") 顶部200px\n  div(v-pin:left=\"300\") 左边300px\n</template>\n<script>\n  export default {\n    name: 'v-pin'\n  }\n</script>\n```\n\n### v-focus 聚焦指令\n\n> `v-focus` 在移动端登录时异常好用\n\n- [在线预览](https://www.jixiaokang.com/vue-v-xxx/configurations/v-focus.html)\n\n```\n<template lang=\"pug\">\n.v-xxx\n  input(v-focus)\n</template>\n<script>\nexport default {\n  name: 'v-focus'\n}\n</script>\n```\n\n### v-click-out 外部点击指令\n\n> `v-click-out` 点击外部 dom 触发\n\n- [在线预览](https://www.jixiaokang.com/vue-v-xxx/configurations/v-click-out.html)\n\n```\n<template lang=\"pug\">\n.v-xxx\n  div(style=\"border:1px solid red;width:200px;height:200px;\" @click=\"handleClick\" v-click-out=\"handleClickOut\") {{name}}\n</template>\n<script>\n  export default {\n    name: 'v-click-out',\n    data() {\n      return {\n        name: '内部'\n      }\n    },\n    methods: {\n      handleClick() {\n        this.name = '您点击了内部'\n      },\n      handleClickOut() {\n        this.name = '您点击了外部'\n      }\n    }\n  }\n</script>\n\n```\n\n## 结束语\n\n> **如果您有好的指令欢迎 👏 来提 issue,尽可能多的覆盖,一旦选用将获取神秘礼品,期待您的加入**\n\n## 神交\n\n觉得不错的话给个`star`\n\n- [GitHub](https://github.com/xkloveme/vue-v-xxx/)\n- [blog](https://www.cnblogs.com/xkloveme/)\n","source":"_posts/2019-10-12-vue-v-xxx基于 Vue拓展的 v-xxx 库.md","raw":"---\nlayout: post\ntitle: 基于 Vue拓展的 v-xxx 库\ndate: 2019-10-12\ntags: [vue, GitHub, 指令]\ntop: true\ncategories: 前端\n---\n\n> **君问归期未有期，巴山夜雨涨秋池。** > **何当共剪西窗烛，却话巴山夜雨时。**\n\n作为`vue`轻车熟路的老司机，经常会用到一些指令，`vue`官方提供的指令又太少，无法满足旺盛的欲望，而每次要写一遍，终日郁郁寡欢，从小就教育我们乐于助人，为了将奉献精神贯彻始终，用了这个库，空下来大把时间陪陪家人朋友岂不乐哉。\n\n闲话少叙，直逼主题，毕竟我们是正经的官方软文。\n\n- **[查看官网](https://www.jixiaokang.com/vue-v-xxx/)**\n- **[查看源码](https://github.com/xkloveme/vue-v-xxx/)**\n\n## 什么是 vue 指令?\n\n---\n\n- 在我们了解库之前,我们先回顾一下`Vue`指令\n\n### 1. 我们经常用的有一下几种指令\n\n```js\nv-text 、 v-html 、 v-show 、 v-if 、 v-else 、v-for 、 v-bind 、 v-on 、\nv-model 、 v-once\n```\n\n> 具体用法[前去官网](https://cn.vuejs.org/v2/guide/conditional.html),不再赘述\n\n### 什么是自定义指令?\n\n> 有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令.\n\n```js\n<input  v-focus>// 为例\n\n// 在组件内部\ndirectives: {\n  focus: {\n  // 指令的定义\n  inserted: function (el) {\n    el.focus()\n    }\n  }\n}\n```\n\n### 钩子函数\n\n一个指令定义对象可以提供如下几个钩子函数 (均为可选)：\n\n- `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n\n- `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\n\n- `update`：所在组件的 VNode 更新时调用，**但是可能发生在其子 VNode 更新之前**。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。\n\n- `componentUpdated`：指令所在组件的 VNode **及其子 VNode** 全部更新后调用。\n\n- `unbind`：只调用一次，指令与元素解绑时调用。\n\n### 钩子函数的参数\n\n- `el`：指令所绑定的元素，可以用来直接操作 DOM 。\n- `binding`：一个对象，包含以下属性：\n  - `name`：指令名，不包括 `v-` 前缀。\n  - `value`：指令的绑定值，例如：`v-my-directive=\"1 + 1\"` 中，绑定值为 `2`。\n  - `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。\n  - `expression`：字符串形式的指令表达式。例如 `v-my-directive=\"1 + 1\"` 中，表达式为 `\"1 + 1\"`。\n  - `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `\"foo\"`。\n  - `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`。\n- `vnode`：Vue 编译生成的虚拟节点。\n- `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。\n\n## 怎么安装 vue-v-xxx?\n\n---\n\n> 基于 vue 指令,又新增丰富一些常用的指令,看看是怎么使用的吧\n\n### 安装\n\n- 您可以通过 npm 安装,推荐使用 `npm` 的方式安装，它能更好地和 `webpack` 打包工具配合使用。\n\n```bash\n\n# install vue-v-xxx\n\n npm install vue-v-xxx --save\n\n# or\n\n yarn add vue-v-xxx --save\n\n```\n\n- 您也可以通过 unpkg.com/vue-v-xxx 获取到最新版本的资源，在页面上引入 js 和 css 文件即可开始使用。\n\n```html\n<!-- 引入样式 -->\n\n<link rel=\"stylesheet\" href=\"https://unpkg.com/vue-v-xxx/lib/vue-v-xxx.css\" />\n\n<!-- 引入组件库 -->\n\n<script src=\"https://unpkg.com/vue-v-xxx\"></script>\n```\n\n### 使用\n\n- 您可以在`main.js`里面全局注册,在组件内就可以应用了[推荐工程](https://github.com/xkloveme/vue-v-xxx-project)\n\n```js\nimport Vue from \"vue\";\n\nimport App from \"./App\";\n\nimport Vxxx from \"vue-v-xxx\";\n\nimport \"vue-v-xxx/lib/vue-v-xxx.css\";\n\nVue.config.productionTip = false;\n\nVue.use(Vxxx);\n\n/* eslint-disable no-new */\n\nnew Vue({\n  el: \"#app\",\n\n  components: { App },\n\n  template: \"<App/>\"\n});\n```\n\n- 您可以通过 CDN 可以快速使用 vue-v-xxx 写出一个示例，您可以复制下面代码或[在线预览](https://codesandbox.io/s/vue-v-xxx-bndj4)\n\n```html\n<!DOCTYPE html>\n\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n\n    <title>vue-v-xxx</title>\n\n    <link\n      rel=\"stylesheet\"\n      href=\"https://unpkg.com/vue-v-xxx/lib/vue-v-xxx.css\"\n    />\n  </head>\n\n  <body>\n    <div id=\"app\">\n      <h1 title=\"Welcome\">欢迎使用 {{ value }}</h1>\n\n      <button v-copy=\"value\">Click me!</button>\n    </div>\n  </body>\n\n  <!-- import Vue before vue-v-xxx -->\n\n  <script src=\"https://unpkg.com/vue/dist/vue.js\"></script>\n\n  <!-- import JavaScript -->\n\n  <script src=\"https://unpkg.com/vue-v-xxx/lib/vue-v-xxx.umd.js\"></script>\n\n  <script>\n    new Vue({\n      el: \"#app\",\n\n      data: {\n        value: \"vue-v-xxx\"\n      }\n    });\n  </script>\n</html>\n```\n\n## 我们提供了那些额外的指令?\n\n---\n\n### v-call 拨打指令\n\n> 该指令快速唤起拨打电话或者发送短信\n\n- [在线预览](https://www.jixiaokang.com/vue-v-xxx/configurations/v-call.html)\n\n- 使用案例\n\n```\n<template lang=\"pug\">\n.v-xxx\n  div(v-call=\"tel\") 点击拨打☎️\n  div(v-call:sms=\"10086\") 点击发短信💬\n</template>\n<script>\n  export default {\n    name: 'v-call',\n    data() {\n      return {\n        tel: '10086'\n      }\n    }\n  }\n</script>\n```\n\n### v-copy 复制指令\n\n> 在很多情况下，我们需要复制操作\n\n- [在线预览](https://www.jixiaokang.com/vue-v-xxx/configurations/v-copy.html)\n\n- 使用案例\n\n```\n<template lang=\"pug\">\n.v-xxx\n  Button(@click=\"handleClick\" v-copy=\"value\") 点击复制\n  div\n    textarea(placeholder=\"Paste here\" style=\"margin-top:40px;width:100%;height:100%;\")\n</template>\n<script>\n  export default {\n    name: 'v-copy',\n    data() {\n      return {\n        value: ''\n      }\n    },\n    methods: {\n      handleClick(html = '你复制了我,去粘贴吧') {\n        this.value = html\n      }\n    }\n  }\n</script>\n```\n\n### v-debounce 防抖指令\n\n> `v-debounce` 支持传入防抖时间`v-debounce:500` 默认 500ms\n\n- [在线预览](https://www.jixiaokang.com/vue-v-xxx/configurations/v-debounce.html)\n\n```\n<template lang=\"pug\">\n.v-xxx\n  h1 未加防抖\n  h2 点击次数:{{num}}\n  Button(@click=\"addNum\") (点我)\n  h1 加入防抖\n  h2 点击次数:{{num2}}\n  Button(v-debounce=\"addNum2\") (点我)\n</template>\n<script>\nexport default {\n  name: 'v-debounce',\n  data () {\n    return {\n      num: 0,\n      num2: 0,\n    }\n  },\n  methods: {\n    addNum () {\n      this.num++\n    },\n    addNum2 () {\n      this.num2++\n    }\n  }\n}\n</script>\n```\n\n### v-throttle 节流指令\n\n> `v-throttle` 支持传入防抖时间`v-throttle:2000` 默认 2s\n\n- [在线预览](https://www.jixiaokang.com/vue-v-xxx/configurations/v-throttle.html)\n\n```\n<template lang=\"pug\">\n.v-xxx\n  h3 立即触发:{{num}}\n  input(v-model=\"num\")\n  h3 节流后:{{num2}}\n  input(v-throttle:2000=\"num2\")\n</template>\n<script>\n  export default {\n    name: 'v-throttle',\n    data() {\n      return {\n        num: '立即改变',\n        num2: '节流值'\n      }\n    }\n  }\n</script>\n```\n\n### v-ellipsis 省略指令\n\n> `v-ellipsis` 在表格中经常使用,`v-ellipsis`默认单行省略\n\n- [在线预览](https://www.jixiaokang.com/vue-v-xxx/configurations/v-ellipsis.html)\n\n```\n<template lang=\"pug\">\n.v-xxx\n  div(v-ellipsis) {{des}}\n  div(v-ellipsis:3)\n    p {{des2}}\n</template>\n<script>\nexport default {\n  name: 'v-ellipsis',\n  data() {\n    return {\n      des:\n        '单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略',\n      des2:\n        '多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略'\n    }\n  }\n}\n</script>\n```\n\n### v-pin 固定指令\n\n> `v-pin` 支持传入定位位置和定位值`v-pin:left || top` 默认 left\n\n- [在线预览](https://www.jixiaokang.com/vue-v-xxx/configurations/v-pin.html)\n\n```\n<template lang=\"pug\">\n.v-xxx\n  div(v-pin=\"200\") 顶部200px\n  div(v-pin:left=\"300\") 左边300px\n</template>\n<script>\n  export default {\n    name: 'v-pin'\n  }\n</script>\n```\n\n### v-focus 聚焦指令\n\n> `v-focus` 在移动端登录时异常好用\n\n- [在线预览](https://www.jixiaokang.com/vue-v-xxx/configurations/v-focus.html)\n\n```\n<template lang=\"pug\">\n.v-xxx\n  input(v-focus)\n</template>\n<script>\nexport default {\n  name: 'v-focus'\n}\n</script>\n```\n\n### v-click-out 外部点击指令\n\n> `v-click-out` 点击外部 dom 触发\n\n- [在线预览](https://www.jixiaokang.com/vue-v-xxx/configurations/v-click-out.html)\n\n```\n<template lang=\"pug\">\n.v-xxx\n  div(style=\"border:1px solid red;width:200px;height:200px;\" @click=\"handleClick\" v-click-out=\"handleClickOut\") {{name}}\n</template>\n<script>\n  export default {\n    name: 'v-click-out',\n    data() {\n      return {\n        name: '内部'\n      }\n    },\n    methods: {\n      handleClick() {\n        this.name = '您点击了内部'\n      },\n      handleClickOut() {\n        this.name = '您点击了外部'\n      }\n    }\n  }\n</script>\n\n```\n\n## 结束语\n\n> **如果您有好的指令欢迎 👏 来提 issue,尽可能多的覆盖,一旦选用将获取神秘礼品,期待您的加入**\n\n## 神交\n\n觉得不错的话给个`star`\n\n- [GitHub](https://github.com/xkloveme/vue-v-xxx/)\n- [blog](https://www.cnblogs.com/xkloveme/)\n","slug":"2019-10-12-vue-v-xxx基于 Vue拓展的 v-xxx 库","published":1,"updated":"2020-03-14T11:53:59.439Z","comments":1,"photos":[],"link":"","_id":"ck7u2pvn7005l4k8y4m4t5j00","content":"<blockquote>\n<p><strong>君问归期未有期，巴山夜雨涨秋池。</strong> &gt; <strong>何当共剪西窗烛，却话巴山夜雨时。</strong></p>\n</blockquote>\n<p>作为<code>vue</code>轻车熟路的老司机，经常会用到一些指令，<code>vue</code>官方提供的指令又太少，无法满足旺盛的欲望，而每次要写一遍，终日郁郁寡欢，从小就教育我们乐于助人，为了将奉献精神贯彻始终，用了这个库，空下来大把时间陪陪家人朋友岂不乐哉。</p>\n<p>闲话少叙，直逼主题，毕竟我们是正经的官方软文。</p>\n<ul>\n<li><strong><a href=\"https://www.jixiaokang.com/vue-v-xxx/\" target=\"_blank\" rel=\"noopener\">查看官网</a></strong></li>\n<li><strong><a href=\"https://github.com/xkloveme/vue-v-xxx/\" target=\"_blank\" rel=\"noopener\">查看源码</a></strong></li>\n</ul>\n<h2 id=\"什么是-vue-指令\"><a href=\"#什么是-vue-指令\" class=\"headerlink\" title=\"什么是 vue 指令?\"></a>什么是 vue 指令?</h2><hr>\n<ul>\n<li>在我们了解库之前,我们先回顾一下<code>Vue</code>指令</li>\n</ul>\n<h3 id=\"1-我们经常用的有一下几种指令\"><a href=\"#1-我们经常用的有一下几种指令\" class=\"headerlink\" title=\"1. 我们经常用的有一下几种指令\"></a>1. 我们经常用的有一下几种指令</h3><pre class=\" language-js\"><code class=\"language-js\">v<span class=\"token operator\">-</span>text 、 v<span class=\"token operator\">-</span>html 、 v<span class=\"token operator\">-</span>show 、 v<span class=\"token operator\">-</span><span class=\"token keyword\">if</span> 、 v<span class=\"token operator\">-</span><span class=\"token keyword\">else</span> 、v<span class=\"token operator\">-</span><span class=\"token keyword\">for</span> 、 v<span class=\"token operator\">-</span>bind 、 v<span class=\"token operator\">-</span>on 、\nv<span class=\"token operator\">-</span>model 、 v<span class=\"token operator\">-</span>once</code></pre>\n<blockquote>\n<p>具体用法<a href=\"https://cn.vuejs.org/v2/guide/conditional.html\" target=\"_blank\" rel=\"noopener\">前去官网</a>,不再赘述</p>\n</blockquote>\n<h3 id=\"什么是自定义指令\"><a href=\"#什么是自定义指令\" class=\"headerlink\" title=\"什么是自定义指令?\"></a>什么是自定义指令?</h3><blockquote>\n<p>有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令.</p>\n</blockquote>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span>input  v<span class=\"token operator\">-</span>focus<span class=\"token operator\">></span><span class=\"token comment\" spellcheck=\"true\">// 为例</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 在组件内部</span>\ndirectives<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  focus<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 指令的定义</span>\n  inserted<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    el<span class=\"token punctuation\">.</span><span class=\"token function\">focus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"钩子函数\"><a href=\"#钩子函数\" class=\"headerlink\" title=\"钩子函数\"></a>钩子函数</h3><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p>\n<ul>\n<li><p><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>\n</li>\n<li><p><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p>\n</li>\n<li><p><code>update</code>：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。</p>\n</li>\n<li><p><code>componentUpdated</code>：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</p>\n</li>\n<li><p><code>unbind</code>：只调用一次，指令与元素解绑时调用。</p>\n</li>\n</ul>\n<h3 id=\"钩子函数的参数\"><a href=\"#钩子函数的参数\" class=\"headerlink\" title=\"钩子函数的参数\"></a>钩子函数的参数</h3><ul>\n<li><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM 。</li>\n<li><code>binding</code>：一个对象，包含以下属性：<ul>\n<li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li>\n<li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li>\n<li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li>\n<li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li>\n<li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li>\n<li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>{ foo: true, bar: true }</code>。</li>\n</ul>\n</li>\n<li><code>vnode</code>：Vue 编译生成的虚拟节点。</li>\n<li><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li>\n</ul>\n<h2 id=\"怎么安装-vue-v-xxx\"><a href=\"#怎么安装-vue-v-xxx\" class=\"headerlink\" title=\"怎么安装 vue-v-xxx?\"></a>怎么安装 vue-v-xxx?</h2><hr>\n<blockquote>\n<p>基于 vue 指令,又新增丰富一些常用的指令,看看是怎么使用的吧</p>\n</blockquote>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><ul>\n<li>您可以通过 npm 安装,推荐使用 <code>npm</code> 的方式安装，它能更好地和 <code>webpack</code> 打包工具配合使用。</li>\n</ul>\n<pre class=\" language-bash\"><code class=\"language-bash\">\n<span class=\"token comment\" spellcheck=\"true\"># install vue-v-xxx</span>\n\n <span class=\"token function\">npm</span> <span class=\"token function\">install</span> vue-v-xxx --save\n\n<span class=\"token comment\" spellcheck=\"true\"># or</span>\n\n yarn add vue-v-xxx --save\n</code></pre>\n<ul>\n<li>您也可以通过 unpkg.com/vue-v-xxx 获取到最新版本的资源，在页面上引入 js 和 css 文件即可开始使用。</li>\n</ul>\n<pre class=\" language-html\"><code class=\"language-html\"><span class=\"token comment\" spellcheck=\"true\">&lt;!-- 引入样式 --></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>link</span> <span class=\"token attr-name\">rel</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>stylesheet<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>https://unpkg.com/vue-v-xxx/lib/vue-v-xxx.css<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">&lt;!-- 引入组件库 --></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>https://unpkg.com/vue-v-xxx<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span></code></pre>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>您可以在<code>main.js</code>里面全局注册,在组件内就可以应用了<a href=\"https://github.com/xkloveme/vue-v-xxx-project\" target=\"_blank\" rel=\"noopener\">推荐工程</a></li>\n</ul>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> Vue <span class=\"token keyword\">from</span> <span class=\"token string\">\"vue\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> App <span class=\"token keyword\">from</span> <span class=\"token string\">\"./App\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> Vxxx <span class=\"token keyword\">from</span> <span class=\"token string\">\"vue-v-xxx\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> <span class=\"token string\">\"vue-v-xxx/lib/vue-v-xxx.css\"</span><span class=\"token punctuation\">;</span>\n\nVue<span class=\"token punctuation\">.</span>config<span class=\"token punctuation\">.</span>productionTip <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\nVue<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span>Vxxx<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/* eslint-disable no-new */</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Vue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  el<span class=\"token punctuation\">:</span> <span class=\"token string\">\"#app\"</span><span class=\"token punctuation\">,</span>\n\n  components<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> App <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n  template<span class=\"token punctuation\">:</span> <span class=\"token string\">\"&lt;App/>\"</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<ul>\n<li>您可以通过 CDN 可以快速使用 vue-v-xxx 写出一个示例，您可以复制下面代码或<a href=\"https://codesandbox.io/s/vue-v-xxx-bndj4\" target=\"_blank\" rel=\"noopener\">在线预览</a></li>\n</ul>\n<pre class=\" language-html\"><code class=\"language-html\"><span class=\"token doctype\">&lt;!DOCTYPE html></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">charset</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>utf-8<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span>vue-v-xxx<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>link</span>\n      <span class=\"token attr-name\">rel</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>stylesheet<span class=\"token punctuation\">\"</span></span>\n      <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>https://unpkg.com/vue-v-xxx/lib/vue-v-xxx.css<span class=\"token punctuation\">\"</span></span>\n    <span class=\"token punctuation\">/></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>app<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span> <span class=\"token attr-name\">title</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Welcome<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>欢迎使用 {{ value }}<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span>\n\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">v-copy</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>value<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Click me!<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n\n  <span class=\"token comment\" spellcheck=\"true\">&lt;!-- import Vue before vue-v-xxx --></span>\n\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>https://unpkg.com/vue/dist/vue.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n\n  <span class=\"token comment\" spellcheck=\"true\">&lt;!-- import JavaScript --></span>\n\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>https://unpkg.com/vue-v-xxx/lib/vue-v-xxx.umd.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      el<span class=\"token punctuation\">:</span> <span class=\"token string\">\"#app\"</span><span class=\"token punctuation\">,</span>\n\n      data<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        value<span class=\"token punctuation\">:</span> <span class=\"token string\">\"vue-v-xxx\"</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span></code></pre>\n<h2 id=\"我们提供了那些额外的指令\"><a href=\"#我们提供了那些额外的指令\" class=\"headerlink\" title=\"我们提供了那些额外的指令?\"></a>我们提供了那些额外的指令?</h2><hr>\n<h3 id=\"v-call-拨打指令\"><a href=\"#v-call-拨打指令\" class=\"headerlink\" title=\"v-call 拨打指令\"></a>v-call 拨打指令</h3><blockquote>\n<p>该指令快速唤起拨打电话或者发送短信</p>\n</blockquote>\n<ul>\n<li><p><a href=\"https://www.jixiaokang.com/vue-v-xxx/configurations/v-call.html\" target=\"_blank\" rel=\"noopener\">在线预览</a></p>\n</li>\n<li><p>使用案例</p>\n</li>\n</ul>\n<pre><code>&lt;template lang=&quot;pug&quot;&gt;\n.v-xxx\n  div(v-call=&quot;tel&quot;) 点击拨打☎️\n  div(v-call:sms=&quot;10086&quot;) 点击发短信💬\n&lt;/template&gt;\n&lt;script&gt;\n  export default {\n    name: &#39;v-call&#39;,\n    data() {\n      return {\n        tel: &#39;10086&#39;\n      }\n    }\n  }\n&lt;/script&gt;</code></pre><h3 id=\"v-copy-复制指令\"><a href=\"#v-copy-复制指令\" class=\"headerlink\" title=\"v-copy 复制指令\"></a>v-copy 复制指令</h3><blockquote>\n<p>在很多情况下，我们需要复制操作</p>\n</blockquote>\n<ul>\n<li><p><a href=\"https://www.jixiaokang.com/vue-v-xxx/configurations/v-copy.html\" target=\"_blank\" rel=\"noopener\">在线预览</a></p>\n</li>\n<li><p>使用案例</p>\n</li>\n</ul>\n<pre><code>&lt;template lang=&quot;pug&quot;&gt;\n.v-xxx\n  Button(@click=&quot;handleClick&quot; v-copy=&quot;value&quot;) 点击复制\n  div\n    textarea(placeholder=&quot;Paste here&quot; style=&quot;margin-top:40px;width:100%;height:100%;&quot;)\n&lt;/template&gt;\n&lt;script&gt;\n  export default {\n    name: &#39;v-copy&#39;,\n    data() {\n      return {\n        value: &#39;&#39;\n      }\n    },\n    methods: {\n      handleClick(html = &#39;你复制了我,去粘贴吧&#39;) {\n        this.value = html\n      }\n    }\n  }\n&lt;/script&gt;</code></pre><h3 id=\"v-debounce-防抖指令\"><a href=\"#v-debounce-防抖指令\" class=\"headerlink\" title=\"v-debounce 防抖指令\"></a>v-debounce 防抖指令</h3><blockquote>\n<p><code>v-debounce</code> 支持传入防抖时间<code>v-debounce:500</code> 默认 500ms</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.jixiaokang.com/vue-v-xxx/configurations/v-debounce.html\" target=\"_blank\" rel=\"noopener\">在线预览</a></li>\n</ul>\n<pre><code>&lt;template lang=&quot;pug&quot;&gt;\n.v-xxx\n  h1 未加防抖\n  h2 点击次数:{{num}}\n  Button(@click=&quot;addNum&quot;) (点我)\n  h1 加入防抖\n  h2 点击次数:{{num2}}\n  Button(v-debounce=&quot;addNum2&quot;) (点我)\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  name: &#39;v-debounce&#39;,\n  data () {\n    return {\n      num: 0,\n      num2: 0,\n    }\n  },\n  methods: {\n    addNum () {\n      this.num++\n    },\n    addNum2 () {\n      this.num2++\n    }\n  }\n}\n&lt;/script&gt;</code></pre><h3 id=\"v-throttle-节流指令\"><a href=\"#v-throttle-节流指令\" class=\"headerlink\" title=\"v-throttle 节流指令\"></a>v-throttle 节流指令</h3><blockquote>\n<p><code>v-throttle</code> 支持传入防抖时间<code>v-throttle:2000</code> 默认 2s</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.jixiaokang.com/vue-v-xxx/configurations/v-throttle.html\" target=\"_blank\" rel=\"noopener\">在线预览</a></li>\n</ul>\n<pre><code>&lt;template lang=&quot;pug&quot;&gt;\n.v-xxx\n  h3 立即触发:{{num}}\n  input(v-model=&quot;num&quot;)\n  h3 节流后:{{num2}}\n  input(v-throttle:2000=&quot;num2&quot;)\n&lt;/template&gt;\n&lt;script&gt;\n  export default {\n    name: &#39;v-throttle&#39;,\n    data() {\n      return {\n        num: &#39;立即改变&#39;,\n        num2: &#39;节流值&#39;\n      }\n    }\n  }\n&lt;/script&gt;</code></pre><h3 id=\"v-ellipsis-省略指令\"><a href=\"#v-ellipsis-省略指令\" class=\"headerlink\" title=\"v-ellipsis 省略指令\"></a>v-ellipsis 省略指令</h3><blockquote>\n<p><code>v-ellipsis</code> 在表格中经常使用,<code>v-ellipsis</code>默认单行省略</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.jixiaokang.com/vue-v-xxx/configurations/v-ellipsis.html\" target=\"_blank\" rel=\"noopener\">在线预览</a></li>\n</ul>\n<pre><code>&lt;template lang=&quot;pug&quot;&gt;\n.v-xxx\n  div(v-ellipsis) {{des}}\n  div(v-ellipsis:3)\n    p {{des2}}\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  name: &#39;v-ellipsis&#39;,\n  data() {\n    return {\n      des:\n        &#39;单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略&#39;,\n      des2:\n        &#39;多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略&#39;\n    }\n  }\n}\n&lt;/script&gt;</code></pre><h3 id=\"v-pin-固定指令\"><a href=\"#v-pin-固定指令\" class=\"headerlink\" title=\"v-pin 固定指令\"></a>v-pin 固定指令</h3><blockquote>\n<p><code>v-pin</code> 支持传入定位位置和定位值<code>v-pin:left || top</code> 默认 left</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.jixiaokang.com/vue-v-xxx/configurations/v-pin.html\" target=\"_blank\" rel=\"noopener\">在线预览</a></li>\n</ul>\n<pre><code>&lt;template lang=&quot;pug&quot;&gt;\n.v-xxx\n  div(v-pin=&quot;200&quot;) 顶部200px\n  div(v-pin:left=&quot;300&quot;) 左边300px\n&lt;/template&gt;\n&lt;script&gt;\n  export default {\n    name: &#39;v-pin&#39;\n  }\n&lt;/script&gt;</code></pre><h3 id=\"v-focus-聚焦指令\"><a href=\"#v-focus-聚焦指令\" class=\"headerlink\" title=\"v-focus 聚焦指令\"></a>v-focus 聚焦指令</h3><blockquote>\n<p><code>v-focus</code> 在移动端登录时异常好用</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.jixiaokang.com/vue-v-xxx/configurations/v-focus.html\" target=\"_blank\" rel=\"noopener\">在线预览</a></li>\n</ul>\n<pre><code>&lt;template lang=&quot;pug&quot;&gt;\n.v-xxx\n  input(v-focus)\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  name: &#39;v-focus&#39;\n}\n&lt;/script&gt;</code></pre><h3 id=\"v-click-out-外部点击指令\"><a href=\"#v-click-out-外部点击指令\" class=\"headerlink\" title=\"v-click-out 外部点击指令\"></a>v-click-out 外部点击指令</h3><blockquote>\n<p><code>v-click-out</code> 点击外部 dom 触发</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.jixiaokang.com/vue-v-xxx/configurations/v-click-out.html\" target=\"_blank\" rel=\"noopener\">在线预览</a></li>\n</ul>\n<pre><code>&lt;template lang=&quot;pug&quot;&gt;\n.v-xxx\n  div(style=&quot;border:1px solid red;width:200px;height:200px;&quot; @click=&quot;handleClick&quot; v-click-out=&quot;handleClickOut&quot;) {{name}}\n&lt;/template&gt;\n&lt;script&gt;\n  export default {\n    name: &#39;v-click-out&#39;,\n    data() {\n      return {\n        name: &#39;内部&#39;\n      }\n    },\n    methods: {\n      handleClick() {\n        this.name = &#39;您点击了内部&#39;\n      },\n      handleClickOut() {\n        this.name = &#39;您点击了外部&#39;\n      }\n    }\n  }\n&lt;/script&gt;\n</code></pre><h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><blockquote>\n<p><strong>如果您有好的指令欢迎 👏 来提 issue,尽可能多的覆盖,一旦选用将获取神秘礼品,期待您的加入</strong></p>\n</blockquote>\n<h2 id=\"神交\"><a href=\"#神交\" class=\"headerlink\" title=\"神交\"></a>神交</h2><p>觉得不错的话给个<code>star</code></p>\n<ul>\n<li><a href=\"https://github.com/xkloveme/vue-v-xxx/\" target=\"_blank\" rel=\"noopener\">GitHub</a></li>\n<li><a href=\"https://www.cnblogs.com/xkloveme/\" target=\"_blank\" rel=\"noopener\">blog</a></li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<blockquote>\n<p><strong>君问归期未有期，巴山夜雨涨秋池。</strong> &gt; <strong>何当共剪西窗烛，却话巴山夜雨时。</strong></p>\n</blockquote>\n<p>作为<code>vue</code>轻车熟路的老司机，经常会用到一些指令，<code>vue</code>官方提供的指令又太少，无法满足旺盛的欲望，而每次要写一遍，终日郁郁寡欢，从小就教育我们乐于助人，为了将奉献精神贯彻始终，用了这个库，空下来大把时间陪陪家人朋友岂不乐哉。</p>\n<p>闲话少叙，直逼主题，毕竟我们是正经的官方软文。</p>\n<ul>\n<li><strong><a href=\"https://www.jixiaokang.com/vue-v-xxx/\" target=\"_blank\" rel=\"noopener\">查看官网</a></strong></li>\n<li><strong><a href=\"https://github.com/xkloveme/vue-v-xxx/\" target=\"_blank\" rel=\"noopener\">查看源码</a></strong></li>\n</ul>\n<h2 id=\"什么是-vue-指令\"><a href=\"#什么是-vue-指令\" class=\"headerlink\" title=\"什么是 vue 指令?\"></a>什么是 vue 指令?</h2><hr>\n<ul>\n<li>在我们了解库之前,我们先回顾一下<code>Vue</code>指令</li>\n</ul>\n<h3 id=\"1-我们经常用的有一下几种指令\"><a href=\"#1-我们经常用的有一下几种指令\" class=\"headerlink\" title=\"1. 我们经常用的有一下几种指令\"></a>1. 我们经常用的有一下几种指令</h3><pre><code class=\"js\">v-text 、 v-html 、 v-show 、 v-if 、 v-else 、v-for 、 v-bind 、 v-on 、\nv-model 、 v-once</code></pre>\n<blockquote>\n<p>具体用法<a href=\"https://cn.vuejs.org/v2/guide/conditional.html\" target=\"_blank\" rel=\"noopener\">前去官网</a>,不再赘述</p>\n</blockquote>\n<h3 id=\"什么是自定义指令\"><a href=\"#什么是自定义指令\" class=\"headerlink\" title=\"什么是自定义指令?\"></a>什么是自定义指令?</h3><blockquote>\n<p>有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令.</p>\n</blockquote>\n<pre><code class=\"js\">&lt;input  v-focus&gt;// 为例\n\n// 在组件内部\ndirectives: {\n  focus: {\n  // 指令的定义\n  inserted: function (el) {\n    el.focus()\n    }\n  }\n}</code></pre>\n<h3 id=\"钩子函数\"><a href=\"#钩子函数\" class=\"headerlink\" title=\"钩子函数\"></a>钩子函数</h3><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p>\n<ul>\n<li><p><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>\n</li>\n<li><p><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p>\n</li>\n<li><p><code>update</code>：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。</p>\n</li>\n<li><p><code>componentUpdated</code>：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</p>\n</li>\n<li><p><code>unbind</code>：只调用一次，指令与元素解绑时调用。</p>\n</li>\n</ul>\n<h3 id=\"钩子函数的参数\"><a href=\"#钩子函数的参数\" class=\"headerlink\" title=\"钩子函数的参数\"></a>钩子函数的参数</h3><ul>\n<li><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM 。</li>\n<li><code>binding</code>：一个对象，包含以下属性：<ul>\n<li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li>\n<li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li>\n<li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li>\n<li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li>\n<li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li>\n<li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>{ foo: true, bar: true }</code>。</li>\n</ul>\n</li>\n<li><code>vnode</code>：Vue 编译生成的虚拟节点。</li>\n<li><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li>\n</ul>\n<h2 id=\"怎么安装-vue-v-xxx\"><a href=\"#怎么安装-vue-v-xxx\" class=\"headerlink\" title=\"怎么安装 vue-v-xxx?\"></a>怎么安装 vue-v-xxx?</h2><hr>\n<blockquote>\n<p>基于 vue 指令,又新增丰富一些常用的指令,看看是怎么使用的吧</p>\n</blockquote>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><ul>\n<li>您可以通过 npm 安装,推荐使用 <code>npm</code> 的方式安装，它能更好地和 <code>webpack</code> 打包工具配合使用。</li>\n</ul>\n<pre><code class=\"bash\">\n# install vue-v-xxx\n\n npm install vue-v-xxx --save\n\n# or\n\n yarn add vue-v-xxx --save\n</code></pre>\n<ul>\n<li>您也可以通过 unpkg.com/vue-v-xxx 获取到最新版本的资源，在页面上引入 js 和 css 文件即可开始使用。</li>\n</ul>\n<pre><code class=\"html\">&lt;!-- 引入样式 --&gt;\n\n&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/vue-v-xxx/lib/vue-v-xxx.css&quot; /&gt;\n\n&lt;!-- 引入组件库 --&gt;\n\n&lt;script src=&quot;https://unpkg.com/vue-v-xxx&quot;&gt;&lt;/script&gt;</code></pre>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>您可以在<code>main.js</code>里面全局注册,在组件内就可以应用了<a href=\"https://github.com/xkloveme/vue-v-xxx-project\" target=\"_blank\" rel=\"noopener\">推荐工程</a></li>\n</ul>\n<pre><code class=\"js\">import Vue from &quot;vue&quot;;\n\nimport App from &quot;./App&quot;;\n\nimport Vxxx from &quot;vue-v-xxx&quot;;\n\nimport &quot;vue-v-xxx/lib/vue-v-xxx.css&quot;;\n\nVue.config.productionTip = false;\n\nVue.use(Vxxx);\n\n/* eslint-disable no-new */\n\nnew Vue({\n  el: &quot;#app&quot;,\n\n  components: { App },\n\n  template: &quot;&lt;App/&gt;&quot;\n});</code></pre>\n<ul>\n<li>您可以通过 CDN 可以快速使用 vue-v-xxx 写出一个示例，您可以复制下面代码或<a href=\"https://codesandbox.io/s/vue-v-xxx-bndj4\" target=\"_blank\" rel=\"noopener\">在线预览</a></li>\n</ul>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n\n    &lt;title&gt;vue-v-xxx&lt;/title&gt;\n\n    &lt;link\n      rel=&quot;stylesheet&quot;\n      href=&quot;https://unpkg.com/vue-v-xxx/lib/vue-v-xxx.css&quot;\n    /&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;\n      &lt;h1 title=&quot;Welcome&quot;&gt;欢迎使用 {{ value }}&lt;/h1&gt;\n\n      &lt;button v-copy=&quot;value&quot;&gt;Click me!&lt;/button&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n\n  &lt;!-- import Vue before vue-v-xxx --&gt;\n\n  &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n\n  &lt;!-- import JavaScript --&gt;\n\n  &lt;script src=&quot;https://unpkg.com/vue-v-xxx/lib/vue-v-xxx.umd.js&quot;&gt;&lt;/script&gt;\n\n  &lt;script&gt;\n    new Vue({\n      el: &quot;#app&quot;,\n\n      data: {\n        value: &quot;vue-v-xxx&quot;\n      }\n    });\n  &lt;/script&gt;\n&lt;/html&gt;</code></pre>\n<h2 id=\"我们提供了那些额外的指令\"><a href=\"#我们提供了那些额外的指令\" class=\"headerlink\" title=\"我们提供了那些额外的指令?\"></a>我们提供了那些额外的指令?</h2><hr>\n<h3 id=\"v-call-拨打指令\"><a href=\"#v-call-拨打指令\" class=\"headerlink\" title=\"v-call 拨打指令\"></a>v-call 拨打指令</h3><blockquote>\n<p>该指令快速唤起拨打电话或者发送短信</p>\n</blockquote>\n<ul>\n<li><p><a href=\"https://www.jixiaokang.com/vue-v-xxx/configurations/v-call.html\" target=\"_blank\" rel=\"noopener\">在线预览</a></p>\n</li>\n<li><p>使用案例</p>\n</li>\n</ul>\n<pre><code>&lt;template lang=&quot;pug&quot;&gt;\n.v-xxx\n  div(v-call=&quot;tel&quot;) 点击拨打☎️\n  div(v-call:sms=&quot;10086&quot;) 点击发短信💬\n&lt;/template&gt;\n&lt;script&gt;\n  export default {\n    name: &#39;v-call&#39;,\n    data() {\n      return {\n        tel: &#39;10086&#39;\n      }\n    }\n  }\n&lt;/script&gt;</code></pre><h3 id=\"v-copy-复制指令\"><a href=\"#v-copy-复制指令\" class=\"headerlink\" title=\"v-copy 复制指令\"></a>v-copy 复制指令</h3><blockquote>\n<p>在很多情况下，我们需要复制操作</p>\n</blockquote>\n<ul>\n<li><p><a href=\"https://www.jixiaokang.com/vue-v-xxx/configurations/v-copy.html\" target=\"_blank\" rel=\"noopener\">在线预览</a></p>\n</li>\n<li><p>使用案例</p>\n</li>\n</ul>\n<pre><code>&lt;template lang=&quot;pug&quot;&gt;\n.v-xxx\n  Button(@click=&quot;handleClick&quot; v-copy=&quot;value&quot;) 点击复制\n  div\n    textarea(placeholder=&quot;Paste here&quot; style=&quot;margin-top:40px;width:100%;height:100%;&quot;)\n&lt;/template&gt;\n&lt;script&gt;\n  export default {\n    name: &#39;v-copy&#39;,\n    data() {\n      return {\n        value: &#39;&#39;\n      }\n    },\n    methods: {\n      handleClick(html = &#39;你复制了我,去粘贴吧&#39;) {\n        this.value = html\n      }\n    }\n  }\n&lt;/script&gt;</code></pre><h3 id=\"v-debounce-防抖指令\"><a href=\"#v-debounce-防抖指令\" class=\"headerlink\" title=\"v-debounce 防抖指令\"></a>v-debounce 防抖指令</h3><blockquote>\n<p><code>v-debounce</code> 支持传入防抖时间<code>v-debounce:500</code> 默认 500ms</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.jixiaokang.com/vue-v-xxx/configurations/v-debounce.html\" target=\"_blank\" rel=\"noopener\">在线预览</a></li>\n</ul>\n<pre><code>&lt;template lang=&quot;pug&quot;&gt;\n.v-xxx\n  h1 未加防抖\n  h2 点击次数:{{num}}\n  Button(@click=&quot;addNum&quot;) (点我)\n  h1 加入防抖\n  h2 点击次数:{{num2}}\n  Button(v-debounce=&quot;addNum2&quot;) (点我)\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  name: &#39;v-debounce&#39;,\n  data () {\n    return {\n      num: 0,\n      num2: 0,\n    }\n  },\n  methods: {\n    addNum () {\n      this.num++\n    },\n    addNum2 () {\n      this.num2++\n    }\n  }\n}\n&lt;/script&gt;</code></pre><h3 id=\"v-throttle-节流指令\"><a href=\"#v-throttle-节流指令\" class=\"headerlink\" title=\"v-throttle 节流指令\"></a>v-throttle 节流指令</h3><blockquote>\n<p><code>v-throttle</code> 支持传入防抖时间<code>v-throttle:2000</code> 默认 2s</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.jixiaokang.com/vue-v-xxx/configurations/v-throttle.html\" target=\"_blank\" rel=\"noopener\">在线预览</a></li>\n</ul>\n<pre><code>&lt;template lang=&quot;pug&quot;&gt;\n.v-xxx\n  h3 立即触发:{{num}}\n  input(v-model=&quot;num&quot;)\n  h3 节流后:{{num2}}\n  input(v-throttle:2000=&quot;num2&quot;)\n&lt;/template&gt;\n&lt;script&gt;\n  export default {\n    name: &#39;v-throttle&#39;,\n    data() {\n      return {\n        num: &#39;立即改变&#39;,\n        num2: &#39;节流值&#39;\n      }\n    }\n  }\n&lt;/script&gt;</code></pre><h3 id=\"v-ellipsis-省略指令\"><a href=\"#v-ellipsis-省略指令\" class=\"headerlink\" title=\"v-ellipsis 省略指令\"></a>v-ellipsis 省略指令</h3><blockquote>\n<p><code>v-ellipsis</code> 在表格中经常使用,<code>v-ellipsis</code>默认单行省略</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.jixiaokang.com/vue-v-xxx/configurations/v-ellipsis.html\" target=\"_blank\" rel=\"noopener\">在线预览</a></li>\n</ul>\n<pre><code>&lt;template lang=&quot;pug&quot;&gt;\n.v-xxx\n  div(v-ellipsis) {{des}}\n  div(v-ellipsis:3)\n    p {{des2}}\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  name: &#39;v-ellipsis&#39;,\n  data() {\n    return {\n      des:\n        &#39;单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略单行省略&#39;,\n      des2:\n        &#39;多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略多行省略&#39;\n    }\n  }\n}\n&lt;/script&gt;</code></pre><h3 id=\"v-pin-固定指令\"><a href=\"#v-pin-固定指令\" class=\"headerlink\" title=\"v-pin 固定指令\"></a>v-pin 固定指令</h3><blockquote>\n<p><code>v-pin</code> 支持传入定位位置和定位值<code>v-pin:left || top</code> 默认 left</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.jixiaokang.com/vue-v-xxx/configurations/v-pin.html\" target=\"_blank\" rel=\"noopener\">在线预览</a></li>\n</ul>\n<pre><code>&lt;template lang=&quot;pug&quot;&gt;\n.v-xxx\n  div(v-pin=&quot;200&quot;) 顶部200px\n  div(v-pin:left=&quot;300&quot;) 左边300px\n&lt;/template&gt;\n&lt;script&gt;\n  export default {\n    name: &#39;v-pin&#39;\n  }\n&lt;/script&gt;</code></pre><h3 id=\"v-focus-聚焦指令\"><a href=\"#v-focus-聚焦指令\" class=\"headerlink\" title=\"v-focus 聚焦指令\"></a>v-focus 聚焦指令</h3><blockquote>\n<p><code>v-focus</code> 在移动端登录时异常好用</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.jixiaokang.com/vue-v-xxx/configurations/v-focus.html\" target=\"_blank\" rel=\"noopener\">在线预览</a></li>\n</ul>\n<pre><code>&lt;template lang=&quot;pug&quot;&gt;\n.v-xxx\n  input(v-focus)\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  name: &#39;v-focus&#39;\n}\n&lt;/script&gt;</code></pre><h3 id=\"v-click-out-外部点击指令\"><a href=\"#v-click-out-外部点击指令\" class=\"headerlink\" title=\"v-click-out 外部点击指令\"></a>v-click-out 外部点击指令</h3><blockquote>\n<p><code>v-click-out</code> 点击外部 dom 触发</p>\n</blockquote>\n<ul>\n<li><a href=\"https://www.jixiaokang.com/vue-v-xxx/configurations/v-click-out.html\" target=\"_blank\" rel=\"noopener\">在线预览</a></li>\n</ul>\n<pre><code>&lt;template lang=&quot;pug&quot;&gt;\n.v-xxx\n  div(style=&quot;border:1px solid red;width:200px;height:200px;&quot; @click=&quot;handleClick&quot; v-click-out=&quot;handleClickOut&quot;) {{name}}\n&lt;/template&gt;\n&lt;script&gt;\n  export default {\n    name: &#39;v-click-out&#39;,\n    data() {\n      return {\n        name: &#39;内部&#39;\n      }\n    },\n    methods: {\n      handleClick() {\n        this.name = &#39;您点击了内部&#39;\n      },\n      handleClickOut() {\n        this.name = &#39;您点击了外部&#39;\n      }\n    }\n  }\n&lt;/script&gt;\n</code></pre><h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><blockquote>\n<p><strong>如果您有好的指令欢迎 👏 来提 issue,尽可能多的覆盖,一旦选用将获取神秘礼品,期待您的加入</strong></p>\n</blockquote>\n<h2 id=\"神交\"><a href=\"#神交\" class=\"headerlink\" title=\"神交\"></a>神交</h2><p>觉得不错的话给个<code>star</code></p>\n<ul>\n<li><a href=\"https://github.com/xkloveme/vue-v-xxx/\" target=\"_blank\" rel=\"noopener\">GitHub</a></li>\n<li><a href=\"https://www.cnblogs.com/xkloveme/\" target=\"_blank\" rel=\"noopener\">blog</a></li>\n</ul>\n"},{"title":"Web前端开发规范文档","date":"2017-08-27T07:15:00.000Z","_content":"\n### 规范目的：\n\n---\n\n> - 使开发流程更加规范化。\n\n### [](https://github.com/xkloveme/houtai/blob/master/README.md#通用规范)通用规范：\n\n---\n\n> - TAB 键用两个空格代替（`WINDOWS`下 TAB 键占四个空格，`LINUX`下 TAB 键占八个空格）。\n> - `CSS`样式属性或者`JAVASCRIPT`代码后加“;”方便压缩工具“断句”。\n> - 文件内容编码均统一为`UTF-8`。\n> - `CSS`、`JAVASCRIPT`中的非注释类中文字符须转换成 unicode 编码使用,以避免编码错误时乱码显示。\n\n### [](https://github.com/xkloveme/houtai/blob/master/README.md#文件规范)文件规范：\n\n---\n\n> - 文件名用英文单词，多个单词用驼峰命名法。\n> - 一些浏览器会将含有这些词的作为广告拦截，文件命名、ID、CLASS 等所有命名避免以上词汇。`ad`、`ads`、`adv`、`banner`、`sponsor`、`gg`、`guangg`、`guanggao`等。\n\n### [](https://github.com/xkloveme/houtai/blob/master/README.md#html书写规范)html 书写规范：\n\n---\n\n> - 为每个`HTML`页面的第一行添加标准模式（standard mode）的声明，确保在每个浏览器中拥有一致的展现。\n\n>     `文档类型声明`统一为HTML5声明类型，`编码`统一为UTF-8。\n\n>     ``中添加信息。\n\n    \t//作者\n    \t//网页描述\n    \t//关键字,“，”分隔\n    \t//设定网页的到期时间。一旦网页过期，必须到服务器上重新调阅\n    \t//禁止浏览器从本地机的缓存中调阅页面内容\n    \t//用来防止别人在框架里调用你的页面\n    \t//跳转页面，5指时间停留5秒 网页搜索机器人向导。用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引\n    \t//content的参数有all,none,index,noindex,follow,nofollow，默认是all\n    \t//收藏图标\n    \t//网页不会被缓存\n\n>     `IE`支持通过特定<meta>标签来确定绘制当前页面所应该采用的`IE`版本。除非有强烈的特殊需求，否则最好是设置为`edge mode` ，从而通知`IE`采用其所支持的最新的模式。\n\n> - 非特殊情况下`CSS`样式文件外链至 HEAD 之间，`JAVASCRIPT`文件外链至页面底部。\n\n>     引入`JAVASCRIPT`库文件，文件名须包含库名称及版本号及是否为压缩版。\n\n    \tjQuery-1.8.3.min.js\n\n>     引入`JAVASCRIPT`插件, 文件名格式为库名称+`.`+插件名称。\n\n    \tjQuery.cookie.js\n\n> - `HTML`属性应当按照以下给出的顺序依次排列，来确保代码的易读性。\n\n    \tclass\n    \tid 、 name\n    \tdata-*\n    \tsrc、for、 type、 href\n    \ttitle、alt\n    \taria-*、 role\n\n>     编码均遵循`XHTML`标准,\n>     标签、属性、属性命名由小写英文、数字和\\_组成，且所有标签必须闭合，属性值必须用双引号`\"\"`,\n>     避免使用中文拼音尽量简易并要求语义化。\n\n    \tCLASS --> nHeadTitle --> CLASS遵循小驼峰命名法（little camel-case）\n    \tID --> n_head_title --> ID遵循名称+_\n    \tNAME --> N_Head_Title --> NAME属性命名遵循首个字母大写+_\n\n>     当`JAVASCRIPT`获取单个元素时，通常使用document.getElementById来获取dom元素，document.getElementById兼容所有浏览器，但IE浏览器会混淆元素的ID和NAME属性，所以要区分ID和NAME命名。\n\n> - 特殊符号应使用转意符。\n\n    \t<    -->    <\n    \t>    -->    >\n    \t空格  -->     \n\n> - 含有描述性表单元素（`INPUT`，`TEXTAREA`）添加`LABEL`。\n\n    \t\t测试\n\n> - 多用无兼容性问题的`HTML`内置标签,比如 SPAN、EM、STRONG、OPTGROUP、LABEL 等,需要自定义`HTML`标签属性时，首先考虑是否存在已有的合适标签可替换，如果没有,可使用须以“`data-`”为前缀来添加自定义属性，避免使用其他命名方式。\n> - 语义化`HTML`。\n> - 尽可能减少\n>\n>   嵌套。\n>\n> - 书写链接地址时避免重定向。\n\n    \thref=\"http://www.kahn1990.com/\" //即在URL地址后面加“/”\n\n> - `HTML`中对于属性的定义，确保全部使用双引号，绝不要使用单引号\n\n### [](https://github.com/xkloveme/houtai/blob/master/README.md#css书写规范)css 书写规范：\n\n---\n\n> - 为了欺骗`W3C`的验证工具,可将代码分为两个文件，一个是针对所有浏览器,一个只针对 IE。即将所有符合`W3C`的代码写到一个文件中,而一些 IE 中必须而又不能通过`W3C`验证的代码（如:`cursor:hand;`）放到另一个文件中，再用下面的方法导入。\n\n> - `CSS`样式新建或修改尽量遵循以下原则。\n\n    \t根据新建样式的适用范围分为三级：全站级、产品级、页面级。\n    \t尽量通过继承和层叠重用已有样式。\n    \t不要轻易改动全站级CSS。改动后，要经过全面测试。\n\n> - `CSS`属性显示顺序。\n\n    \t显示属性\n    \t元素位置\n    \t元素属性\n    \t元素内容属性\n\n> - `CSS`书写顺序。\n\n    \t.header {\n    \t/* 显示属性 */\n    \t\tdisplay || visibility\n    \t\tlist-style\n    \t\tposition top || right || bottom || left\n    \t\tz-index\n    \t\tclear\n    \t\tfloat\n    \t/* 自身属性 */\n    \t\twidth max-width || min-width\n    \t\theight max-height || min-height\n    \t\toverflow || clip\n    \t\tmargin\n    \t\tpadding\n    \t\toutline\n    \t\tborder\n    \t\tbackground\n    \t/* 文本属性 */\n    \t\tcolor\n    \t\tfont\n    \t\ttext-overflow\n    \t\ttext-align\n    \t\ttext-indent\n    \t\tline-height\n    \t\twhite-space\n    \t\tvertical-align\n    \t\tcursor\n    \t\tcontent\n    \t};\n\n>     兼容多个浏览器时，将标准属性写在底部。\n\n    \t-moz-border-radius: 15px; /* Firefox */\n    \t-webkit-border-radius: 15px; /* Safari和Chrome */\n    \t-o-border-radius: 15px;\n    \tborder-radius: 15px; /* Opera 10.5+, 以及使用了IE-CSS3的IE浏览器 *//标准属性\n\n> - 使用选择器时，命名比较短的词汇或者缩写的不允许直接定义样式。\n\n    \t.hd,.bd,.td{};//如这些命名\n\n>     可用上级节点进行限定。\n\n    \t.recommend-mod .hd\n\n>     多选择器规则之间换行，即当样式针对多个选择器时每个选择器占一行。\n\n    \tbutton.btn,\n    \tinput.btn,\n    \tinput[type=\"button\"] {…};\n\n>     优化`CSS`选择器。\n\n    \t#header a { color: #444; };/*CSS选择器是从右边到左边进行匹配*/\n\n>     浏览器将检查整个文档中的所有链接和每个链接的父元素，并遍历文档树去查找ID为header的祖先元素，如果找不到header将追溯到文档的根节点，解决方法如下。\n\n    \t避免使用通配规则和相邻兄弟选择符、子选择符,、后代选择符、属性选择符等选择器\n    \t不要限定id选择符，如div#header（提权的除外）\n    \t不要限定类选择器，如ul.recommend（提权的除外）\n    \t不要使用 ul li a 这样长的选择符\n    \t避免使用标签子选择符，如#header > li > a\n\n> - 使用`z-index`属性尽量`z-index`的值不要超过 150（通用组的除外），页面中的元素内容的`z-index`不能超过 10（提示框等模块除外但维持在 150 以下），不允许直接使用（999~9999）之间大值。\n> - 尽量避免使用 CSS Hack。\n\n    \tproperty:value; /* 所有浏览器 */\n    \t+property:value; /* IE7 */\n    \t_property:value; /* IE6 */\n    \t*property:value; /* IE6/7 */\n    \tproperty:value\\9; /* IE6/7/8/9，即所有IE浏览器 */\n\n\n    \t* html selector { … }; /* IE6 */\n    \t*:first-child+html selector { … }; /* IE7 */\n    \thtml>body selector { … }; /* 非IE6 */\n    \t@-moz-document url-prefix() { … }; /* firefox */\n    \t@media all and (-webkit-min-device-pixel-ratio:0) { … }; /* saf3+/chrome1+ */\n    \t@media all and (-webkit-min-device-pixel-ratio:10000),not all and (-webkit-min-device-pixel-ratio:0) { … }; /* opera */\n    \t@media screen and (max-device-width: 480px) { … }; /* iPhone/mobile webkit */\n\n>     避免使用低效的选择器。\n\n    \tbody > * {…};\n    \tul > li > a {…};\n    \t#footer > h3 {…};\n    \tul#top_blue_nav {…};\n    \tsearbar span.submit a { … }; /* 反面示例 */\n\n> - 六个不要三个避免一个使用。\n\n    \t不要在标签上直接写样式\n    \t不要在CSS中使用expression\n    \t不要在CSS中使用@import\n    \t不要在CSS中使用!important\n    \t不要在CSS中使用“*”选择符\n    \t不要将CSS样式写为单行\n    \t避免使用filter\n    \t避免使用行内（inline）样式\n    \t避免使用“*”设置{margin: 0; padding: 0;}\n    \t使用after或overflow的方式清浮动\n\n> - 减少使用影响性能的属性。\n\n    \tposition:absolute;\n    \tfloat:left;//如这些定位或浮动属性\n\n\n    \t减少在`CSS`中使用滤镜表达式和图片repeat,\n    \t尤其在body当中,渲染性能极差, 如果需要用repeat的话,\n    \t图片的宽或高不能少于8px。\n\n### [](https://github.com/xkloveme/houtai/blob/master/README.md#javascript书写规范)javaScript 书写规范：\n\n---\n\n> - 命名规范。\n\n    \t常量名\n    \t\t全部大写并单词间用下划线分隔\n    \t\t如：CSS_BTN_CLOSE、TXT_LOADING\n\n\n    \t对象的属性或方法名\n    \t\t小驼峰式（little camel-case）\n    \t\t如：init、bindEvent、updatePosition\n    \t\t示例：Dialog.prototype = {\n    \t\t\t\tinit: function () {},\n    \t\t\t\tbindEvent: function () {},\n    \t\t\t\tupdatePosition: function () {}\n    \t\t\t\t …\n    \t\t\t};\n    \t类名（构造器）\n    \t\t-->小驼峰式但首字母大写\n    \t\t-->如：Current、DefaultConfig\n    \t函数名\n    \t\t-->小驼峰式\n    \t\t-->如：current()、defaultConfig()\n    \t变量名\n    \t\t-->小驼峰式\n    \t\t-->如：current、defaultConfig\n    \t私有变量名\n    \t\t-->小驼峰式但需要用_开头\n    \t\t-->如：_current、_defaultConfig\n    \t变量名的前缀\n    \t\t-->续\n\n> - 代码格式。\n\n    \t\"()\"前后需要跟空格\n    \t\"=\"前后需要跟空格\n    \t\",\"后面需要跟空格\n    \tJSON对象需格式化对象参数\n    \tif、while、for、do语句的执行体用\"{}\"括起来\n\n>     \"{}\"格式如下。\n\n    \tif (a==1) {\n    \t\t//代码\n    \t};\n\n>     避免额外的逗号。\n\n    \tvar arr = [1,2,3,];\n\n>     `for-in`循环体中必须用`hasOwnProperty`方法检查成员是否为自身成员，避免来自原型链上的污染。\n>\n> - 长语句可考虑断行。\n\n    \tTEMPL_SONGLIST.replace('{TABLE}', da['results'])\n    \t\t.replace('{PREV_NUM}', prev)\n    \t\t.replace('{NEXT_NUM}', next)\n    \t\t.replace('{CURRENT_NUM}', current)\n    \t\t.replace('{TOTAL_NUM}', da.page_total);\n\n>     为了避免和`JSLint`的检验机制冲突，“.”或“+”这类操作符放在行尾。\n\n    \tTEMPL_SONGLIST.replace('{TABLE}', da['results']).\n    \t\treplace('{PREV_NUM}', prev).\n    \t\treplace('{NEXT_NUM}', next).\n    \t\treplace('{CURRENT_NUM}', current).\n    \t\treplace('{TOTAL_NUM}', da.page_total);\n\n>     如果模块代码中，使用其它全局变量想跳过JSLint的检查，可以在该文件中加入`/*global*/`声明。\n\n    \t/*global alert: true, console: true, top: true, setTimeout: true */\n\n> - 使用严格的条件判断符。用===代替==，用!==代替!=，避免掉入==造成的陷阱 在条件判断时，这样的一些值表示 false。\n\n    \tnull\n    \tundefined与null相等\n    \t字符串''\n    \t数字0\n    \tNaN\n\n>     在==时，则会有一些让人难以理解的陷阱。\n\n    \t(function () {\n    \t\tvar undefined;\n    \t\tundefined == null; // true\n    \t\t1 == true; //true\n    \t\t2 == true; // false\n    \t\t0 == false; // true\n    \t\t0 == ''; // true\n    \t\tNaN == NaN;// false\n    \t\t[] == false; // true\n    \t\t[] == ![]; // true\n    \t})();\n\n>     对于不同类型的 == 判断，有这样一些规则，顺序自上而下：\n\n    \tundefined与null相等\n    \t一个是number一个是string时，会尝试将string转换为number\n    \t尝试将boolean转换为number\n    \t0或1\n    \t尝试将Object转换成number或string\n\n>     而这些取决于另外一个对比量，即值的类型，所以对于0、空字符串的判断，建议使用`===`\n>     。`===`会先判断两边的值类型，类型不匹配时为`false`。\n>\n> - 下面类型的对象不建议用 new 构造。\n\n    \tnew Number\n    \tnew String\n    \tnew Boolean\n    \tnew Object //用{}代替\n    \tnew Array //用[]代替\n\n>     引用对象成员用`obj.prop`代替`obj[\"prop\"]`，除非属性名是变量。\n>\n> - 从 number 到 string 的转换。\n\n    \t/** 推荐写法*/\n    \tvar a = 1;\n    \ttypeof(a); //\"number\"\n    \tconsole.log(a); //1\n    \tvar aa=a+'';\n    \ttypeof(aa); //\"string\"\n    \tconsole.log(aa); //'1'\n    \t/** 不推荐写法*/\n    \tnew String(a)或a.toString()\n\n>     从string到number的转换，使用parseInt，必须显式指定第二个参数的进制。\n\n    \t/** 推荐写法*/\n    \tvar a = '1';\n    \tvar aa = parseInt(a,10);\n    \ttypeof(a); //\"string\"\n    \tconsole.log(a); //'1'\n    \ttypeof(aa); //\"number\"\n    \tconsole.log(aa); //1\n\n>     从float到integer的转换。\n\n    \t/** 推荐写法*/\n    \tMath.floor/Math.round/Math.ceil\n    \t/** 不推荐写法*/\n    \tparseInt\n\n>     字符串拼接应使用数组保存字符串片段，使用时调用join方法。避免使用+或+=的方式拼接较长的字符串，每个字符串都会使用一个小的内存片段，过多的内存片段会影响性能。\n\n    \t/**推荐的拼接方式array的push、join*/\n    \tvar str=[],\n    \t\tlist=['测试A','测试B'];\n    \tfor (var i=0 , len=list.length; i < len; i++) {\n    \t\tstr.push( ''+ list[i] + '');\n    \t};\n    \tconsole.log(str.join('')); //测试A测试B\n    \t/** 不推荐的拼接方式+=*/\n    \tvar str = '',\n    \t\tlist=['测试A','测试B'];\n    \tfor (var i = 0, len = list.length; i< len; i++) {\n    \t\tstr+='' + list[i] + '';\n    \t};\n    \tconsole.log(str); //测试A测试B\n\n> - 尽量避免使用存在兼容性及消耗资源的方法或属性。\n\n    \t不要使用with，void，evil，eval_r，innerText\n\n> - 注重`HTML`分离, 减小`reflow`, 注重性能。\n\n### [](https://github.com/xkloveme/houtai/blob/master/README.md#图片规范)图片规范：\n\n---\n\n> - 命名应用`小写英文`、`数字`、`_`组合，便于团队其他成员理解。\n\n    \theader_btn.gif\n    \theader_btn2.gif\n\n> - 页面元素类图片均放入`img`文件夹,测试用图片放于`img/testimg`文件夹，psd 源图放入`img/psdimg`文件夹。\n> - 图片格式仅限于`gif`、`png`、`jpg`等。\n> - 用`png`图片做图片时, 要求图片格式为`png-8`格式,若`png-8`实在影响图片质量或其中有半透明效果,请为`ie-6`单独定义背景，并尽量避免使用半透明的 png 图片。\n> - 背景图片请尽可能使用`sprite`技术, 减小`http`请求。\n\n### [](https://github.com/xkloveme/houtai/blob/master/README.md#注释规范)注释规范：\n\n---\n\n> - `JAVASCRIPT`、`CSS`文件注释需要标明作者、文件版本、创建/修改时间、重大版本修改记录、函数描述、文件版本、创建或者修改时间、功能、作者等信息。\n\n    \t/* * 注释块 */\n\n>     中间可添加如下信息。\n\n    \t @file 文件名\n    \t@addon 把一个函数标记为另一个函数的扩张，另一个函数的定义不在源文件中\n    \t@argument 用大括号中的自变量类型描述一个自变量\n    \t@author 函数/类作者的姓名\n    \t@base 如果类是继承得来，定义提供的类名称\n    \t@class 用来给一个类提供描述，不能用于构造器的文档中\n    \t@constructor 描述一个类的构造器\n    \t@deprecated 表示函数/类已被忽略\n    \t@exception 描述函数/类产生的一个错误\n    \t@exec @extends 表示派生出当前类的另一个类\n    \t@fileoverview 表示文档块将用于描述当前文件，这个标签应该放在其它任何标签之前\n    \t@final 指出函数/类\n    \t@ignore 让jsdoc忽视随后的代码\n    \t@link 类似于@link标签，用于连接许多其它页面\n    \t@member 定义随后的函数为提供的类名称的一个成员\n    \t@param 用大括号中的参数类型描述一个参数\n    \t@private 表示函数/类为私有，不应包含在生成的文档中\n    \t@requires 表示需要另一个函数/类\n    \t@return 描述一个函数的返回值\n    \t@see 连接到另一个函数/类\n    \t@throws 描述函数/类可能产生的错误\n    \t@type 指定函数/成员的返回类型\n    \t@version 函数/类的版本号\n\n### [](https://github.com/xkloveme/houtai/blob/master/README.md#开发及测试工具约定)开发及测试工具约定：\n\n---\n\n> - 编码格式化，三码统一。\n> - 测试工具: 前期开发仅测试 FireFox & IE6 & IE7 & IE8 & IE9 & Opera & Chrome & Safari\n\n### [](https://github.com/xkloveme/houtai/blob/master/README.md#参考和借鉴了大家的经验收集整理了这一篇开发规范感谢所有的原作者众人拾柴火焰高技术无国界持续更新中)参考和借鉴了大家的经验，收集整理了这一篇开发规范，感谢所有的原作者，众人拾柴火焰高，技术无国界，持续更新中。\n","source":"_posts/2017-08-27-Web前端开发规范文档.md","raw":"---\ntitle: Web前端开发规范文档\ntags:\n  - 技术\n  - 规范\ndate: 2017-08-27 15:15:00\ncategories: 前端\n---\n\n### 规范目的：\n\n---\n\n> - 使开发流程更加规范化。\n\n### [](https://github.com/xkloveme/houtai/blob/master/README.md#通用规范)通用规范：\n\n---\n\n> - TAB 键用两个空格代替（`WINDOWS`下 TAB 键占四个空格，`LINUX`下 TAB 键占八个空格）。\n> - `CSS`样式属性或者`JAVASCRIPT`代码后加“;”方便压缩工具“断句”。\n> - 文件内容编码均统一为`UTF-8`。\n> - `CSS`、`JAVASCRIPT`中的非注释类中文字符须转换成 unicode 编码使用,以避免编码错误时乱码显示。\n\n### [](https://github.com/xkloveme/houtai/blob/master/README.md#文件规范)文件规范：\n\n---\n\n> - 文件名用英文单词，多个单词用驼峰命名法。\n> - 一些浏览器会将含有这些词的作为广告拦截，文件命名、ID、CLASS 等所有命名避免以上词汇。`ad`、`ads`、`adv`、`banner`、`sponsor`、`gg`、`guangg`、`guanggao`等。\n\n### [](https://github.com/xkloveme/houtai/blob/master/README.md#html书写规范)html 书写规范：\n\n---\n\n> - 为每个`HTML`页面的第一行添加标准模式（standard mode）的声明，确保在每个浏览器中拥有一致的展现。\n\n>     `文档类型声明`统一为HTML5声明类型，`编码`统一为UTF-8。\n\n>     ``中添加信息。\n\n    \t//作者\n    \t//网页描述\n    \t//关键字,“，”分隔\n    \t//设定网页的到期时间。一旦网页过期，必须到服务器上重新调阅\n    \t//禁止浏览器从本地机的缓存中调阅页面内容\n    \t//用来防止别人在框架里调用你的页面\n    \t//跳转页面，5指时间停留5秒 网页搜索机器人向导。用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引\n    \t//content的参数有all,none,index,noindex,follow,nofollow，默认是all\n    \t//收藏图标\n    \t//网页不会被缓存\n\n>     `IE`支持通过特定<meta>标签来确定绘制当前页面所应该采用的`IE`版本。除非有强烈的特殊需求，否则最好是设置为`edge mode` ，从而通知`IE`采用其所支持的最新的模式。\n\n> - 非特殊情况下`CSS`样式文件外链至 HEAD 之间，`JAVASCRIPT`文件外链至页面底部。\n\n>     引入`JAVASCRIPT`库文件，文件名须包含库名称及版本号及是否为压缩版。\n\n    \tjQuery-1.8.3.min.js\n\n>     引入`JAVASCRIPT`插件, 文件名格式为库名称+`.`+插件名称。\n\n    \tjQuery.cookie.js\n\n> - `HTML`属性应当按照以下给出的顺序依次排列，来确保代码的易读性。\n\n    \tclass\n    \tid 、 name\n    \tdata-*\n    \tsrc、for、 type、 href\n    \ttitle、alt\n    \taria-*、 role\n\n>     编码均遵循`XHTML`标准,\n>     标签、属性、属性命名由小写英文、数字和\\_组成，且所有标签必须闭合，属性值必须用双引号`\"\"`,\n>     避免使用中文拼音尽量简易并要求语义化。\n\n    \tCLASS --> nHeadTitle --> CLASS遵循小驼峰命名法（little camel-case）\n    \tID --> n_head_title --> ID遵循名称+_\n    \tNAME --> N_Head_Title --> NAME属性命名遵循首个字母大写+_\n\n>     当`JAVASCRIPT`获取单个元素时，通常使用document.getElementById来获取dom元素，document.getElementById兼容所有浏览器，但IE浏览器会混淆元素的ID和NAME属性，所以要区分ID和NAME命名。\n\n> - 特殊符号应使用转意符。\n\n    \t<    -->    <\n    \t>    -->    >\n    \t空格  -->     \n\n> - 含有描述性表单元素（`INPUT`，`TEXTAREA`）添加`LABEL`。\n\n    \t\t测试\n\n> - 多用无兼容性问题的`HTML`内置标签,比如 SPAN、EM、STRONG、OPTGROUP、LABEL 等,需要自定义`HTML`标签属性时，首先考虑是否存在已有的合适标签可替换，如果没有,可使用须以“`data-`”为前缀来添加自定义属性，避免使用其他命名方式。\n> - 语义化`HTML`。\n> - 尽可能减少\n>\n>   嵌套。\n>\n> - 书写链接地址时避免重定向。\n\n    \thref=\"http://www.kahn1990.com/\" //即在URL地址后面加“/”\n\n> - `HTML`中对于属性的定义，确保全部使用双引号，绝不要使用单引号\n\n### [](https://github.com/xkloveme/houtai/blob/master/README.md#css书写规范)css 书写规范：\n\n---\n\n> - 为了欺骗`W3C`的验证工具,可将代码分为两个文件，一个是针对所有浏览器,一个只针对 IE。即将所有符合`W3C`的代码写到一个文件中,而一些 IE 中必须而又不能通过`W3C`验证的代码（如:`cursor:hand;`）放到另一个文件中，再用下面的方法导入。\n\n> - `CSS`样式新建或修改尽量遵循以下原则。\n\n    \t根据新建样式的适用范围分为三级：全站级、产品级、页面级。\n    \t尽量通过继承和层叠重用已有样式。\n    \t不要轻易改动全站级CSS。改动后，要经过全面测试。\n\n> - `CSS`属性显示顺序。\n\n    \t显示属性\n    \t元素位置\n    \t元素属性\n    \t元素内容属性\n\n> - `CSS`书写顺序。\n\n    \t.header {\n    \t/* 显示属性 */\n    \t\tdisplay || visibility\n    \t\tlist-style\n    \t\tposition top || right || bottom || left\n    \t\tz-index\n    \t\tclear\n    \t\tfloat\n    \t/* 自身属性 */\n    \t\twidth max-width || min-width\n    \t\theight max-height || min-height\n    \t\toverflow || clip\n    \t\tmargin\n    \t\tpadding\n    \t\toutline\n    \t\tborder\n    \t\tbackground\n    \t/* 文本属性 */\n    \t\tcolor\n    \t\tfont\n    \t\ttext-overflow\n    \t\ttext-align\n    \t\ttext-indent\n    \t\tline-height\n    \t\twhite-space\n    \t\tvertical-align\n    \t\tcursor\n    \t\tcontent\n    \t};\n\n>     兼容多个浏览器时，将标准属性写在底部。\n\n    \t-moz-border-radius: 15px; /* Firefox */\n    \t-webkit-border-radius: 15px; /* Safari和Chrome */\n    \t-o-border-radius: 15px;\n    \tborder-radius: 15px; /* Opera 10.5+, 以及使用了IE-CSS3的IE浏览器 *//标准属性\n\n> - 使用选择器时，命名比较短的词汇或者缩写的不允许直接定义样式。\n\n    \t.hd,.bd,.td{};//如这些命名\n\n>     可用上级节点进行限定。\n\n    \t.recommend-mod .hd\n\n>     多选择器规则之间换行，即当样式针对多个选择器时每个选择器占一行。\n\n    \tbutton.btn,\n    \tinput.btn,\n    \tinput[type=\"button\"] {…};\n\n>     优化`CSS`选择器。\n\n    \t#header a { color: #444; };/*CSS选择器是从右边到左边进行匹配*/\n\n>     浏览器将检查整个文档中的所有链接和每个链接的父元素，并遍历文档树去查找ID为header的祖先元素，如果找不到header将追溯到文档的根节点，解决方法如下。\n\n    \t避免使用通配规则和相邻兄弟选择符、子选择符,、后代选择符、属性选择符等选择器\n    \t不要限定id选择符，如div#header（提权的除外）\n    \t不要限定类选择器，如ul.recommend（提权的除外）\n    \t不要使用 ul li a 这样长的选择符\n    \t避免使用标签子选择符，如#header > li > a\n\n> - 使用`z-index`属性尽量`z-index`的值不要超过 150（通用组的除外），页面中的元素内容的`z-index`不能超过 10（提示框等模块除外但维持在 150 以下），不允许直接使用（999~9999）之间大值。\n> - 尽量避免使用 CSS Hack。\n\n    \tproperty:value; /* 所有浏览器 */\n    \t+property:value; /* IE7 */\n    \t_property:value; /* IE6 */\n    \t*property:value; /* IE6/7 */\n    \tproperty:value\\9; /* IE6/7/8/9，即所有IE浏览器 */\n\n\n    \t* html selector { … }; /* IE6 */\n    \t*:first-child+html selector { … }; /* IE7 */\n    \thtml>body selector { … }; /* 非IE6 */\n    \t@-moz-document url-prefix() { … }; /* firefox */\n    \t@media all and (-webkit-min-device-pixel-ratio:0) { … }; /* saf3+/chrome1+ */\n    \t@media all and (-webkit-min-device-pixel-ratio:10000),not all and (-webkit-min-device-pixel-ratio:0) { … }; /* opera */\n    \t@media screen and (max-device-width: 480px) { … }; /* iPhone/mobile webkit */\n\n>     避免使用低效的选择器。\n\n    \tbody > * {…};\n    \tul > li > a {…};\n    \t#footer > h3 {…};\n    \tul#top_blue_nav {…};\n    \tsearbar span.submit a { … }; /* 反面示例 */\n\n> - 六个不要三个避免一个使用。\n\n    \t不要在标签上直接写样式\n    \t不要在CSS中使用expression\n    \t不要在CSS中使用@import\n    \t不要在CSS中使用!important\n    \t不要在CSS中使用“*”选择符\n    \t不要将CSS样式写为单行\n    \t避免使用filter\n    \t避免使用行内（inline）样式\n    \t避免使用“*”设置{margin: 0; padding: 0;}\n    \t使用after或overflow的方式清浮动\n\n> - 减少使用影响性能的属性。\n\n    \tposition:absolute;\n    \tfloat:left;//如这些定位或浮动属性\n\n\n    \t减少在`CSS`中使用滤镜表达式和图片repeat,\n    \t尤其在body当中,渲染性能极差, 如果需要用repeat的话,\n    \t图片的宽或高不能少于8px。\n\n### [](https://github.com/xkloveme/houtai/blob/master/README.md#javascript书写规范)javaScript 书写规范：\n\n---\n\n> - 命名规范。\n\n    \t常量名\n    \t\t全部大写并单词间用下划线分隔\n    \t\t如：CSS_BTN_CLOSE、TXT_LOADING\n\n\n    \t对象的属性或方法名\n    \t\t小驼峰式（little camel-case）\n    \t\t如：init、bindEvent、updatePosition\n    \t\t示例：Dialog.prototype = {\n    \t\t\t\tinit: function () {},\n    \t\t\t\tbindEvent: function () {},\n    \t\t\t\tupdatePosition: function () {}\n    \t\t\t\t …\n    \t\t\t};\n    \t类名（构造器）\n    \t\t-->小驼峰式但首字母大写\n    \t\t-->如：Current、DefaultConfig\n    \t函数名\n    \t\t-->小驼峰式\n    \t\t-->如：current()、defaultConfig()\n    \t变量名\n    \t\t-->小驼峰式\n    \t\t-->如：current、defaultConfig\n    \t私有变量名\n    \t\t-->小驼峰式但需要用_开头\n    \t\t-->如：_current、_defaultConfig\n    \t变量名的前缀\n    \t\t-->续\n\n> - 代码格式。\n\n    \t\"()\"前后需要跟空格\n    \t\"=\"前后需要跟空格\n    \t\",\"后面需要跟空格\n    \tJSON对象需格式化对象参数\n    \tif、while、for、do语句的执行体用\"{}\"括起来\n\n>     \"{}\"格式如下。\n\n    \tif (a==1) {\n    \t\t//代码\n    \t};\n\n>     避免额外的逗号。\n\n    \tvar arr = [1,2,3,];\n\n>     `for-in`循环体中必须用`hasOwnProperty`方法检查成员是否为自身成员，避免来自原型链上的污染。\n>\n> - 长语句可考虑断行。\n\n    \tTEMPL_SONGLIST.replace('{TABLE}', da['results'])\n    \t\t.replace('{PREV_NUM}', prev)\n    \t\t.replace('{NEXT_NUM}', next)\n    \t\t.replace('{CURRENT_NUM}', current)\n    \t\t.replace('{TOTAL_NUM}', da.page_total);\n\n>     为了避免和`JSLint`的检验机制冲突，“.”或“+”这类操作符放在行尾。\n\n    \tTEMPL_SONGLIST.replace('{TABLE}', da['results']).\n    \t\treplace('{PREV_NUM}', prev).\n    \t\treplace('{NEXT_NUM}', next).\n    \t\treplace('{CURRENT_NUM}', current).\n    \t\treplace('{TOTAL_NUM}', da.page_total);\n\n>     如果模块代码中，使用其它全局变量想跳过JSLint的检查，可以在该文件中加入`/*global*/`声明。\n\n    \t/*global alert: true, console: true, top: true, setTimeout: true */\n\n> - 使用严格的条件判断符。用===代替==，用!==代替!=，避免掉入==造成的陷阱 在条件判断时，这样的一些值表示 false。\n\n    \tnull\n    \tundefined与null相等\n    \t字符串''\n    \t数字0\n    \tNaN\n\n>     在==时，则会有一些让人难以理解的陷阱。\n\n    \t(function () {\n    \t\tvar undefined;\n    \t\tundefined == null; // true\n    \t\t1 == true; //true\n    \t\t2 == true; // false\n    \t\t0 == false; // true\n    \t\t0 == ''; // true\n    \t\tNaN == NaN;// false\n    \t\t[] == false; // true\n    \t\t[] == ![]; // true\n    \t})();\n\n>     对于不同类型的 == 判断，有这样一些规则，顺序自上而下：\n\n    \tundefined与null相等\n    \t一个是number一个是string时，会尝试将string转换为number\n    \t尝试将boolean转换为number\n    \t0或1\n    \t尝试将Object转换成number或string\n\n>     而这些取决于另外一个对比量，即值的类型，所以对于0、空字符串的判断，建议使用`===`\n>     。`===`会先判断两边的值类型，类型不匹配时为`false`。\n>\n> - 下面类型的对象不建议用 new 构造。\n\n    \tnew Number\n    \tnew String\n    \tnew Boolean\n    \tnew Object //用{}代替\n    \tnew Array //用[]代替\n\n>     引用对象成员用`obj.prop`代替`obj[\"prop\"]`，除非属性名是变量。\n>\n> - 从 number 到 string 的转换。\n\n    \t/** 推荐写法*/\n    \tvar a = 1;\n    \ttypeof(a); //\"number\"\n    \tconsole.log(a); //1\n    \tvar aa=a+'';\n    \ttypeof(aa); //\"string\"\n    \tconsole.log(aa); //'1'\n    \t/** 不推荐写法*/\n    \tnew String(a)或a.toString()\n\n>     从string到number的转换，使用parseInt，必须显式指定第二个参数的进制。\n\n    \t/** 推荐写法*/\n    \tvar a = '1';\n    \tvar aa = parseInt(a,10);\n    \ttypeof(a); //\"string\"\n    \tconsole.log(a); //'1'\n    \ttypeof(aa); //\"number\"\n    \tconsole.log(aa); //1\n\n>     从float到integer的转换。\n\n    \t/** 推荐写法*/\n    \tMath.floor/Math.round/Math.ceil\n    \t/** 不推荐写法*/\n    \tparseInt\n\n>     字符串拼接应使用数组保存字符串片段，使用时调用join方法。避免使用+或+=的方式拼接较长的字符串，每个字符串都会使用一个小的内存片段，过多的内存片段会影响性能。\n\n    \t/**推荐的拼接方式array的push、join*/\n    \tvar str=[],\n    \t\tlist=['测试A','测试B'];\n    \tfor (var i=0 , len=list.length; i < len; i++) {\n    \t\tstr.push( ''+ list[i] + '');\n    \t};\n    \tconsole.log(str.join('')); //测试A测试B\n    \t/** 不推荐的拼接方式+=*/\n    \tvar str = '',\n    \t\tlist=['测试A','测试B'];\n    \tfor (var i = 0, len = list.length; i< len; i++) {\n    \t\tstr+='' + list[i] + '';\n    \t};\n    \tconsole.log(str); //测试A测试B\n\n> - 尽量避免使用存在兼容性及消耗资源的方法或属性。\n\n    \t不要使用with，void，evil，eval_r，innerText\n\n> - 注重`HTML`分离, 减小`reflow`, 注重性能。\n\n### [](https://github.com/xkloveme/houtai/blob/master/README.md#图片规范)图片规范：\n\n---\n\n> - 命名应用`小写英文`、`数字`、`_`组合，便于团队其他成员理解。\n\n    \theader_btn.gif\n    \theader_btn2.gif\n\n> - 页面元素类图片均放入`img`文件夹,测试用图片放于`img/testimg`文件夹，psd 源图放入`img/psdimg`文件夹。\n> - 图片格式仅限于`gif`、`png`、`jpg`等。\n> - 用`png`图片做图片时, 要求图片格式为`png-8`格式,若`png-8`实在影响图片质量或其中有半透明效果,请为`ie-6`单独定义背景，并尽量避免使用半透明的 png 图片。\n> - 背景图片请尽可能使用`sprite`技术, 减小`http`请求。\n\n### [](https://github.com/xkloveme/houtai/blob/master/README.md#注释规范)注释规范：\n\n---\n\n> - `JAVASCRIPT`、`CSS`文件注释需要标明作者、文件版本、创建/修改时间、重大版本修改记录、函数描述、文件版本、创建或者修改时间、功能、作者等信息。\n\n    \t/* * 注释块 */\n\n>     中间可添加如下信息。\n\n    \t @file 文件名\n    \t@addon 把一个函数标记为另一个函数的扩张，另一个函数的定义不在源文件中\n    \t@argument 用大括号中的自变量类型描述一个自变量\n    \t@author 函数/类作者的姓名\n    \t@base 如果类是继承得来，定义提供的类名称\n    \t@class 用来给一个类提供描述，不能用于构造器的文档中\n    \t@constructor 描述一个类的构造器\n    \t@deprecated 表示函数/类已被忽略\n    \t@exception 描述函数/类产生的一个错误\n    \t@exec @extends 表示派生出当前类的另一个类\n    \t@fileoverview 表示文档块将用于描述当前文件，这个标签应该放在其它任何标签之前\n    \t@final 指出函数/类\n    \t@ignore 让jsdoc忽视随后的代码\n    \t@link 类似于@link标签，用于连接许多其它页面\n    \t@member 定义随后的函数为提供的类名称的一个成员\n    \t@param 用大括号中的参数类型描述一个参数\n    \t@private 表示函数/类为私有，不应包含在生成的文档中\n    \t@requires 表示需要另一个函数/类\n    \t@return 描述一个函数的返回值\n    \t@see 连接到另一个函数/类\n    \t@throws 描述函数/类可能产生的错误\n    \t@type 指定函数/成员的返回类型\n    \t@version 函数/类的版本号\n\n### [](https://github.com/xkloveme/houtai/blob/master/README.md#开发及测试工具约定)开发及测试工具约定：\n\n---\n\n> - 编码格式化，三码统一。\n> - 测试工具: 前期开发仅测试 FireFox & IE6 & IE7 & IE8 & IE9 & Opera & Chrome & Safari\n\n### [](https://github.com/xkloveme/houtai/blob/master/README.md#参考和借鉴了大家的经验收集整理了这一篇开发规范感谢所有的原作者众人拾柴火焰高技术无国界持续更新中)参考和借鉴了大家的经验，收集整理了这一篇开发规范，感谢所有的原作者，众人拾柴火焰高，技术无国界，持续更新中。\n","slug":"2017-08-27-Web前端开发规范文档","published":1,"updated":"2020-03-14T06:46:55.827Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvnn00654k8ychmy2xiv","content":"<h3 id=\"规范目的：\"><a href=\"#规范目的：\" class=\"headerlink\" title=\"规范目的：\"></a>规范目的：</h3><hr>\n<blockquote>\n<ul>\n<li>使开发流程更加规范化。</li>\n</ul>\n</blockquote>\n<h3 id=\"通用规范：\"><a href=\"#通用规范：\" class=\"headerlink\" title=\"通用规范：\"></a><a href=\"https://github.com/xkloveme/houtai/blob/master/README.md#通用规范\" target=\"_blank\" rel=\"noopener\"></a>通用规范：</h3><hr>\n<blockquote>\n<ul>\n<li>TAB 键用两个空格代替（<code>WINDOWS</code>下 TAB 键占四个空格，<code>LINUX</code>下 TAB 键占八个空格）。</li>\n<li><code>CSS</code>样式属性或者<code>JAVASCRIPT</code>代码后加“;”方便压缩工具“断句”。</li>\n<li>文件内容编码均统一为<code>UTF-8</code>。</li>\n<li><code>CSS</code>、<code>JAVASCRIPT</code>中的非注释类中文字符须转换成 unicode 编码使用,以避免编码错误时乱码显示。</li>\n</ul>\n</blockquote>\n<h3 id=\"文件规范：\"><a href=\"#文件规范：\" class=\"headerlink\" title=\"文件规范：\"></a><a href=\"https://github.com/xkloveme/houtai/blob/master/README.md#文件规范\" target=\"_blank\" rel=\"noopener\"></a>文件规范：</h3><hr>\n<blockquote>\n<ul>\n<li>文件名用英文单词，多个单词用驼峰命名法。</li>\n<li>一些浏览器会将含有这些词的作为广告拦截，文件命名、ID、CLASS 等所有命名避免以上词汇。<code>ad</code>、<code>ads</code>、<code>adv</code>、<code>banner</code>、<code>sponsor</code>、<code>gg</code>、<code>guangg</code>、<code>guanggao</code>等。</li>\n</ul>\n</blockquote>\n<h3 id=\"html-书写规范：\"><a href=\"#html-书写规范：\" class=\"headerlink\" title=\"html 书写规范：\"></a><a href=\"https://github.com/xkloveme/houtai/blob/master/README.md#html书写规范\" target=\"_blank\" rel=\"noopener\"></a>html 书写规范：</h3><hr>\n<blockquote>\n<ul>\n<li>为每个<code>HTML</code>页面的第一行添加标准模式（standard mode）的声明，确保在每个浏览器中拥有一致的展现。</li>\n</ul>\n</blockquote>\n<blockquote>\n<pre><code>`文档类型声明`统一为HTML5声明类型，`编码`统一为UTF-8。</code></pre></blockquote>\n<blockquote>\n<pre><code>``中添加信息。</code></pre></blockquote>\n<pre><code>    //作者\n    //网页描述\n    //关键字,“，”分隔\n    //设定网页的到期时间。一旦网页过期，必须到服务器上重新调阅\n    //禁止浏览器从本地机的缓存中调阅页面内容\n    //用来防止别人在框架里调用你的页面\n    //跳转页面，5指时间停留5秒 网页搜索机器人向导。用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引\n    //content的参数有all,none,index,noindex,follow,nofollow，默认是all\n    //收藏图标\n    //网页不会被缓存</code></pre><blockquote>\n<pre><code>`IE`支持通过特定&lt;meta&gt;标签来确定绘制当前页面所应该采用的`IE`版本。除非有强烈的特殊需求，否则最好是设置为`edge mode` ，从而通知`IE`采用其所支持的最新的模式。</code></pre></blockquote>\n<blockquote>\n<ul>\n<li>非特殊情况下<code>CSS</code>样式文件外链至 HEAD 之间，<code>JAVASCRIPT</code>文件外链至页面底部。</li>\n</ul>\n</blockquote>\n<blockquote>\n<pre><code>引入`JAVASCRIPT`库文件，文件名须包含库名称及版本号及是否为压缩版。</code></pre></blockquote>\n<pre><code>    jQuery-1.8.3.min.js</code></pre><blockquote>\n<pre><code>引入`JAVASCRIPT`插件, 文件名格式为库名称+`.`+插件名称。</code></pre></blockquote>\n<pre><code>    jQuery.cookie.js</code></pre><blockquote>\n<ul>\n<li><code>HTML</code>属性应当按照以下给出的顺序依次排列，来确保代码的易读性。</li>\n</ul>\n</blockquote>\n<pre><code>    class\n    id 、 name\n    data-*\n    src、for、 type、 href\n    title、alt\n    aria-*、 role</code></pre><blockquote>\n<pre><code>编码均遵循`XHTML`标准,\n标签、属性、属性命名由小写英文、数字和\\_组成，且所有标签必须闭合，属性值必须用双引号`&quot;&quot;`,\n避免使用中文拼音尽量简易并要求语义化。</code></pre></blockquote>\n<pre><code>    CLASS --&gt; nHeadTitle --&gt; CLASS遵循小驼峰命名法（little camel-case）\n    ID --&gt; n_head_title --&gt; ID遵循名称+_\n    NAME --&gt; N_Head_Title --&gt; NAME属性命名遵循首个字母大写+_</code></pre><blockquote>\n<pre><code>当`JAVASCRIPT`获取单个元素时，通常使用document.getElementById来获取dom元素，document.getElementById兼容所有浏览器，但IE浏览器会混淆元素的ID和NAME属性，所以要区分ID和NAME命名。</code></pre></blockquote>\n<blockquote>\n<ul>\n<li>特殊符号应使用转意符。</li>\n</ul>\n</blockquote>\n<pre><code>    &lt;    --&gt;    &lt;\n    &gt;    --&gt;    &gt;\n    空格  --&gt;     </code></pre><blockquote>\n<ul>\n<li>含有描述性表单元素（<code>INPUT</code>，<code>TEXTAREA</code>）添加<code>LABEL</code>。</li>\n</ul>\n</blockquote>\n<pre><code>        测试</code></pre><blockquote>\n<ul>\n<li><p>多用无兼容性问题的<code>HTML</code>内置标签,比如 SPAN、EM、STRONG、OPTGROUP、LABEL 等,需要自定义<code>HTML</code>标签属性时，首先考虑是否存在已有的合适标签可替换，如果没有,可使用须以“<code>data-</code>”为前缀来添加自定义属性，避免使用其他命名方式。</p>\n</li>\n<li><p>语义化<code>HTML</code>。</p>\n</li>\n<li><p>尽可能减少</p>\n<p>嵌套。</p>\n</li>\n<li><p>书写链接地址时避免重定向。</p>\n</li>\n</ul>\n</blockquote>\n<pre><code>    href=&quot;http://www.kahn1990.com/&quot; //即在URL地址后面加“/”</code></pre><blockquote>\n<ul>\n<li><code>HTML</code>中对于属性的定义，确保全部使用双引号，绝不要使用单引号</li>\n</ul>\n</blockquote>\n<h3 id=\"css-书写规范：\"><a href=\"#css-书写规范：\" class=\"headerlink\" title=\"css 书写规范：\"></a><a href=\"https://github.com/xkloveme/houtai/blob/master/README.md#css书写规范\" target=\"_blank\" rel=\"noopener\"></a>css 书写规范：</h3><hr>\n<blockquote>\n<ul>\n<li>为了欺骗<code>W3C</code>的验证工具,可将代码分为两个文件，一个是针对所有浏览器,一个只针对 IE。即将所有符合<code>W3C</code>的代码写到一个文件中,而一些 IE 中必须而又不能通过<code>W3C</code>验证的代码（如:<code>cursor:hand;</code>）放到另一个文件中，再用下面的方法导入。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li><code>CSS</code>样式新建或修改尽量遵循以下原则。</li>\n</ul>\n</blockquote>\n<pre><code>    根据新建样式的适用范围分为三级：全站级、产品级、页面级。\n    尽量通过继承和层叠重用已有样式。\n    不要轻易改动全站级CSS。改动后，要经过全面测试。</code></pre><blockquote>\n<ul>\n<li><code>CSS</code>属性显示顺序。</li>\n</ul>\n</blockquote>\n<pre><code>    显示属性\n    元素位置\n    元素属性\n    元素内容属性</code></pre><blockquote>\n<ul>\n<li><code>CSS</code>书写顺序。</li>\n</ul>\n</blockquote>\n<pre><code>    .header {\n    /* 显示属性 */\n        display || visibility\n        list-style\n        position top || right || bottom || left\n        z-index\n        clear\n        float\n    /* 自身属性 */\n        width max-width || min-width\n        height max-height || min-height\n        overflow || clip\n        margin\n        padding\n        outline\n        border\n        background\n    /* 文本属性 */\n        color\n        font\n        text-overflow\n        text-align\n        text-indent\n        line-height\n        white-space\n        vertical-align\n        cursor\n        content\n    };</code></pre><blockquote>\n<pre><code>兼容多个浏览器时，将标准属性写在底部。</code></pre></blockquote>\n<pre><code>    -moz-border-radius: 15px; /* Firefox */\n    -webkit-border-radius: 15px; /* Safari和Chrome */\n    -o-border-radius: 15px;\n    border-radius: 15px; /* Opera 10.5+, 以及使用了IE-CSS3的IE浏览器 *//标准属性</code></pre><blockquote>\n<ul>\n<li>使用选择器时，命名比较短的词汇或者缩写的不允许直接定义样式。</li>\n</ul>\n</blockquote>\n<pre><code>    .hd,.bd,.td{};//如这些命名</code></pre><blockquote>\n<pre><code>可用上级节点进行限定。</code></pre></blockquote>\n<pre><code>    .recommend-mod .hd</code></pre><blockquote>\n<pre><code>多选择器规则之间换行，即当样式针对多个选择器时每个选择器占一行。</code></pre></blockquote>\n<pre><code>    button.btn,\n    input.btn,\n    input[type=&quot;button&quot;] {…};</code></pre><blockquote>\n<pre><code>优化`CSS`选择器。</code></pre></blockquote>\n<pre><code>    #header a { color: #444; };/*CSS选择器是从右边到左边进行匹配*/</code></pre><blockquote>\n<pre><code>浏览器将检查整个文档中的所有链接和每个链接的父元素，并遍历文档树去查找ID为header的祖先元素，如果找不到header将追溯到文档的根节点，解决方法如下。</code></pre></blockquote>\n<pre><code>    避免使用通配规则和相邻兄弟选择符、子选择符,、后代选择符、属性选择符等选择器\n    不要限定id选择符，如div#header（提权的除外）\n    不要限定类选择器，如ul.recommend（提权的除外）\n    不要使用 ul li a 这样长的选择符\n    避免使用标签子选择符，如#header &gt; li &gt; a</code></pre><blockquote>\n<ul>\n<li>使用<code>z-index</code>属性尽量<code>z-index</code>的值不要超过 150（通用组的除外），页面中的元素内容的<code>z-index</code>不能超过 10（提示框等模块除外但维持在 150 以下），不允许直接使用（999~9999）之间大值。</li>\n<li>尽量避免使用 CSS Hack。</li>\n</ul>\n</blockquote>\n<pre><code>    property:value; /* 所有浏览器 */\n    +property:value; /* IE7 */\n    _property:value; /* IE6 */\n    *property:value; /* IE6/7 */\n    property:value\\9; /* IE6/7/8/9，即所有IE浏览器 */\n\n\n    * html selector { … }; /* IE6 */\n    *:first-child+html selector { … }; /* IE7 */\n    html&gt;body selector { … }; /* 非IE6 */\n    @-moz-document url-prefix() { … }; /* firefox */\n    @media all and (-webkit-min-device-pixel-ratio:0) { … }; /* saf3+/chrome1+ */\n    @media all and (-webkit-min-device-pixel-ratio:10000),not all and (-webkit-min-device-pixel-ratio:0) { … }; /* opera */\n    @media screen and (max-device-width: 480px) { … }; /* iPhone/mobile webkit */</code></pre><blockquote>\n<pre><code>避免使用低效的选择器。</code></pre></blockquote>\n<pre><code>    body &gt; * {…};\n    ul &gt; li &gt; a {…};\n    #footer &gt; h3 {…};\n    ul#top_blue_nav {…};\n    searbar span.submit a { … }; /* 反面示例 */</code></pre><blockquote>\n<ul>\n<li>六个不要三个避免一个使用。</li>\n</ul>\n</blockquote>\n<pre><code>    不要在标签上直接写样式\n    不要在CSS中使用expression\n    不要在CSS中使用@import\n    不要在CSS中使用!important\n    不要在CSS中使用“*”选择符\n    不要将CSS样式写为单行\n    避免使用filter\n    避免使用行内（inline）样式\n    避免使用“*”设置{margin: 0; padding: 0;}\n    使用after或overflow的方式清浮动</code></pre><blockquote>\n<ul>\n<li>减少使用影响性能的属性。</li>\n</ul>\n</blockquote>\n<pre><code>    position:absolute;\n    float:left;//如这些定位或浮动属性\n\n\n    减少在`CSS`中使用滤镜表达式和图片repeat,\n    尤其在body当中,渲染性能极差, 如果需要用repeat的话,\n    图片的宽或高不能少于8px。</code></pre><h3 id=\"javaScript-书写规范：\"><a href=\"#javaScript-书写规范：\" class=\"headerlink\" title=\"javaScript 书写规范：\"></a><a href=\"https://github.com/xkloveme/houtai/blob/master/README.md#javascript书写规范\" target=\"_blank\" rel=\"noopener\"></a>javaScript 书写规范：</h3><hr>\n<blockquote>\n<ul>\n<li>命名规范。</li>\n</ul>\n</blockquote>\n<pre><code>    常量名\n        全部大写并单词间用下划线分隔\n        如：CSS_BTN_CLOSE、TXT_LOADING\n\n\n    对象的属性或方法名\n        小驼峰式（little camel-case）\n        如：init、bindEvent、updatePosition\n        示例：Dialog.prototype = {\n                init: function () {},\n                bindEvent: function () {},\n                updatePosition: function () {}\n                 …\n            };\n    类名（构造器）\n        --&gt;小驼峰式但首字母大写\n        --&gt;如：Current、DefaultConfig\n    函数名\n        --&gt;小驼峰式\n        --&gt;如：current()、defaultConfig()\n    变量名\n        --&gt;小驼峰式\n        --&gt;如：current、defaultConfig\n    私有变量名\n        --&gt;小驼峰式但需要用_开头\n        --&gt;如：_current、_defaultConfig\n    变量名的前缀\n        --&gt;续</code></pre><blockquote>\n<ul>\n<li>代码格式。</li>\n</ul>\n</blockquote>\n<pre><code>    &quot;()&quot;前后需要跟空格\n    &quot;=&quot;前后需要跟空格\n    &quot;,&quot;后面需要跟空格\n    JSON对象需格式化对象参数\n    if、while、for、do语句的执行体用&quot;{}&quot;括起来</code></pre><blockquote>\n<pre><code>&quot;{}&quot;格式如下。</code></pre></blockquote>\n<pre><code>    if (a==1) {\n        //代码\n    };</code></pre><blockquote>\n<pre><code>避免额外的逗号。</code></pre></blockquote>\n<pre><code>    var arr = [1,2,3,];</code></pre><blockquote>\n<pre><code>`for-in`循环体中必须用`hasOwnProperty`方法检查成员是否为自身成员，避免来自原型链上的污染。</code></pre><ul>\n<li>长语句可考虑断行。</li>\n</ul>\n</blockquote>\n<pre><code>    TEMPL_SONGLIST.replace(&#39;{TABLE}&#39;, da[&#39;results&#39;])\n        .replace(&#39;{PREV_NUM}&#39;, prev)\n        .replace(&#39;{NEXT_NUM}&#39;, next)\n        .replace(&#39;{CURRENT_NUM}&#39;, current)\n        .replace(&#39;{TOTAL_NUM}&#39;, da.page_total);</code></pre><blockquote>\n<pre><code>为了避免和`JSLint`的检验机制冲突，“.”或“+”这类操作符放在行尾。</code></pre></blockquote>\n<pre><code>    TEMPL_SONGLIST.replace(&#39;{TABLE}&#39;, da[&#39;results&#39;]).\n        replace(&#39;{PREV_NUM}&#39;, prev).\n        replace(&#39;{NEXT_NUM}&#39;, next).\n        replace(&#39;{CURRENT_NUM}&#39;, current).\n        replace(&#39;{TOTAL_NUM}&#39;, da.page_total);</code></pre><blockquote>\n<pre><code>如果模块代码中，使用其它全局变量想跳过JSLint的检查，可以在该文件中加入`/*global*/`声明。</code></pre></blockquote>\n<pre><code>    /*global alert: true, console: true, top: true, setTimeout: true */</code></pre><blockquote>\n<ul>\n<li>使用严格的条件判断符。用===代替==，用!==代替!=，避免掉入==造成的陷阱 在条件判断时，这样的一些值表示 false。</li>\n</ul>\n</blockquote>\n<pre><code>    null\n    undefined与null相等\n    字符串&#39;&#39;\n    数字0\n    NaN</code></pre><blockquote>\n<pre><code>在==时，则会有一些让人难以理解的陷阱。</code></pre></blockquote>\n<pre><code>    (function () {\n        var undefined;\n        undefined == null; // true\n        1 == true; //true\n        2 == true; // false\n        0 == false; // true\n        0 == &#39;&#39;; // true\n        NaN == NaN;// false\n        [] == false; // true\n        [] == ![]; // true\n    })();</code></pre><blockquote>\n<pre><code>对于不同类型的 == 判断，有这样一些规则，顺序自上而下：</code></pre></blockquote>\n<pre><code>    undefined与null相等\n    一个是number一个是string时，会尝试将string转换为number\n    尝试将boolean转换为number\n    0或1\n    尝试将Object转换成number或string</code></pre><blockquote>\n<pre><code>而这些取决于另外一个对比量，即值的类型，所以对于0、空字符串的判断，建议使用`===`\n。`===`会先判断两边的值类型，类型不匹配时为`false`。</code></pre><ul>\n<li>下面类型的对象不建议用 new 构造。</li>\n</ul>\n</blockquote>\n<pre><code>    new Number\n    new String\n    new Boolean\n    new Object //用{}代替\n    new Array //用[]代替</code></pre><blockquote>\n<pre><code>引用对象成员用`obj.prop`代替`obj[&quot;prop&quot;]`，除非属性名是变量。</code></pre><ul>\n<li>从 number 到 string 的转换。</li>\n</ul>\n</blockquote>\n<pre><code>    /** 推荐写法*/\n    var a = 1;\n    typeof(a); //&quot;number&quot;\n    console.log(a); //1\n    var aa=a+&#39;&#39;;\n    typeof(aa); //&quot;string&quot;\n    console.log(aa); //&#39;1&#39;\n    /** 不推荐写法*/\n    new String(a)或a.toString()</code></pre><blockquote>\n<pre><code>从string到number的转换，使用parseInt，必须显式指定第二个参数的进制。</code></pre></blockquote>\n<pre><code>    /** 推荐写法*/\n    var a = &#39;1&#39;;\n    var aa = parseInt(a,10);\n    typeof(a); //&quot;string&quot;\n    console.log(a); //&#39;1&#39;\n    typeof(aa); //&quot;number&quot;\n    console.log(aa); //1</code></pre><blockquote>\n<pre><code>从float到integer的转换。</code></pre></blockquote>\n<pre><code>    /** 推荐写法*/\n    Math.floor/Math.round/Math.ceil\n    /** 不推荐写法*/\n    parseInt</code></pre><blockquote>\n<pre><code>字符串拼接应使用数组保存字符串片段，使用时调用join方法。避免使用+或+=的方式拼接较长的字符串，每个字符串都会使用一个小的内存片段，过多的内存片段会影响性能。</code></pre></blockquote>\n<pre><code>    /**推荐的拼接方式array的push、join*/\n    var str=[],\n        list=[&#39;测试A&#39;,&#39;测试B&#39;];\n    for (var i=0 , len=list.length; i &lt; len; i++) {\n        str.push( &#39;&#39;+ list[i] + &#39;&#39;);\n    };\n    console.log(str.join(&#39;&#39;)); //测试A测试B\n    /** 不推荐的拼接方式+=*/\n    var str = &#39;&#39;,\n        list=[&#39;测试A&#39;,&#39;测试B&#39;];\n    for (var i = 0, len = list.length; i&lt; len; i++) {\n        str+=&#39;&#39; + list[i] + &#39;&#39;;\n    };\n    console.log(str); //测试A测试B</code></pre><blockquote>\n<ul>\n<li>尽量避免使用存在兼容性及消耗资源的方法或属性。</li>\n</ul>\n</blockquote>\n<pre><code>    不要使用with，void，evil，eval_r，innerText</code></pre><blockquote>\n<ul>\n<li>注重<code>HTML</code>分离, 减小<code>reflow</code>, 注重性能。</li>\n</ul>\n</blockquote>\n<h3 id=\"图片规范：\"><a href=\"#图片规范：\" class=\"headerlink\" title=\"图片规范：\"></a><a href=\"https://github.com/xkloveme/houtai/blob/master/README.md#图片规范\" target=\"_blank\" rel=\"noopener\"></a>图片规范：</h3><hr>\n<blockquote>\n<ul>\n<li>命名应用<code>小写英文</code>、<code>数字</code>、<code>_</code>组合，便于团队其他成员理解。</li>\n</ul>\n</blockquote>\n<pre><code>    header_btn.gif\n    header_btn2.gif</code></pre><blockquote>\n<ul>\n<li>页面元素类图片均放入<code>img</code>文件夹,测试用图片放于<code>img/testimg</code>文件夹，psd 源图放入<code>img/psdimg</code>文件夹。</li>\n<li>图片格式仅限于<code>gif</code>、<code>png</code>、<code>jpg</code>等。</li>\n<li>用<code>png</code>图片做图片时, 要求图片格式为<code>png-8</code>格式,若<code>png-8</code>实在影响图片质量或其中有半透明效果,请为<code>ie-6</code>单独定义背景，并尽量避免使用半透明的 png 图片。</li>\n<li>背景图片请尽可能使用<code>sprite</code>技术, 减小<code>http</code>请求。</li>\n</ul>\n</blockquote>\n<h3 id=\"注释规范：\"><a href=\"#注释规范：\" class=\"headerlink\" title=\"注释规范：\"></a><a href=\"https://github.com/xkloveme/houtai/blob/master/README.md#注释规范\" target=\"_blank\" rel=\"noopener\"></a>注释规范：</h3><hr>\n<blockquote>\n<ul>\n<li><code>JAVASCRIPT</code>、<code>CSS</code>文件注释需要标明作者、文件版本、创建/修改时间、重大版本修改记录、函数描述、文件版本、创建或者修改时间、功能、作者等信息。</li>\n</ul>\n</blockquote>\n<pre><code>    /* * 注释块 */</code></pre><blockquote>\n<pre><code>中间可添加如下信息。</code></pre></blockquote>\n<pre><code>     @file 文件名\n    @addon 把一个函数标记为另一个函数的扩张，另一个函数的定义不在源文件中\n    @argument 用大括号中的自变量类型描述一个自变量\n    @author 函数/类作者的姓名\n    @base 如果类是继承得来，定义提供的类名称\n    @class 用来给一个类提供描述，不能用于构造器的文档中\n    @constructor 描述一个类的构造器\n    @deprecated 表示函数/类已被忽略\n    @exception 描述函数/类产生的一个错误\n    @exec @extends 表示派生出当前类的另一个类\n    @fileoverview 表示文档块将用于描述当前文件，这个标签应该放在其它任何标签之前\n    @final 指出函数/类\n    @ignore 让jsdoc忽视随后的代码\n    @link 类似于@link标签，用于连接许多其它页面\n    @member 定义随后的函数为提供的类名称的一个成员\n    @param 用大括号中的参数类型描述一个参数\n    @private 表示函数/类为私有，不应包含在生成的文档中\n    @requires 表示需要另一个函数/类\n    @return 描述一个函数的返回值\n    @see 连接到另一个函数/类\n    @throws 描述函数/类可能产生的错误\n    @type 指定函数/成员的返回类型\n    @version 函数/类的版本号</code></pre><h3 id=\"开发及测试工具约定：\"><a href=\"#开发及测试工具约定：\" class=\"headerlink\" title=\"开发及测试工具约定：\"></a><a href=\"https://github.com/xkloveme/houtai/blob/master/README.md#开发及测试工具约定\" target=\"_blank\" rel=\"noopener\"></a>开发及测试工具约定：</h3><hr>\n<blockquote>\n<ul>\n<li>编码格式化，三码统一。</li>\n<li>测试工具: 前期开发仅测试 FireFox &amp; IE6 &amp; IE7 &amp; IE8 &amp; IE9 &amp; Opera &amp; Chrome &amp; Safari</li>\n</ul>\n</blockquote>\n<h3 id=\"参考和借鉴了大家的经验，收集整理了这一篇开发规范，感谢所有的原作者，众人拾柴火焰高，技术无国界，持续更新中。\"><a href=\"#参考和借鉴了大家的经验，收集整理了这一篇开发规范，感谢所有的原作者，众人拾柴火焰高，技术无国界，持续更新中。\" class=\"headerlink\" title=\"参考和借鉴了大家的经验，收集整理了这一篇开发规范，感谢所有的原作者，众人拾柴火焰高，技术无国界，持续更新中。\"></a><a href=\"https://github.com/xkloveme/houtai/blob/master/README.md#参考和借鉴了大家的经验收集整理了这一篇开发规范感谢所有的原作者众人拾柴火焰高技术无国界持续更新中\" target=\"_blank\" rel=\"noopener\"></a>参考和借鉴了大家的经验，收集整理了这一篇开发规范，感谢所有的原作者，众人拾柴火焰高，技术无国界，持续更新中。</h3>","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h3 id=\"规范目的：\"><a href=\"#规范目的：\" class=\"headerlink\" title=\"规范目的：\"></a>规范目的：</h3><hr>\n<blockquote>\n<ul>\n<li>使开发流程更加规范化。</li>\n</ul>\n</blockquote>\n<h3 id=\"通用规范：\"><a href=\"#通用规范：\" class=\"headerlink\" title=\"通用规范：\"></a><a href=\"https://github.com/xkloveme/houtai/blob/master/README.md#通用规范\" target=\"_blank\" rel=\"noopener\"></a>通用规范：</h3><hr>\n<blockquote>\n<ul>\n<li>TAB 键用两个空格代替（<code>WINDOWS</code>下 TAB 键占四个空格，<code>LINUX</code>下 TAB 键占八个空格）。</li>\n<li><code>CSS</code>样式属性或者<code>JAVASCRIPT</code>代码后加“;”方便压缩工具“断句”。</li>\n<li>文件内容编码均统一为<code>UTF-8</code>。</li>\n<li><code>CSS</code>、<code>JAVASCRIPT</code>中的非注释类中文字符须转换成 unicode 编码使用,以避免编码错误时乱码显示。</li>\n</ul>\n</blockquote>\n<h3 id=\"文件规范：\"><a href=\"#文件规范：\" class=\"headerlink\" title=\"文件规范：\"></a><a href=\"https://github.com/xkloveme/houtai/blob/master/README.md#文件规范\" target=\"_blank\" rel=\"noopener\"></a>文件规范：</h3><hr>\n<blockquote>\n<ul>\n<li>文件名用英文单词，多个单词用驼峰命名法。</li>\n<li>一些浏览器会将含有这些词的作为广告拦截，文件命名、ID、CLASS 等所有命名避免以上词汇。<code>ad</code>、<code>ads</code>、<code>adv</code>、<code>banner</code>、<code>sponsor</code>、<code>gg</code>、<code>guangg</code>、<code>guanggao</code>等。</li>\n</ul>\n</blockquote>\n<h3 id=\"html-书写规范：\"><a href=\"#html-书写规范：\" class=\"headerlink\" title=\"html 书写规范：\"></a><a href=\"https://github.com/xkloveme/houtai/blob/master/README.md#html书写规范\" target=\"_blank\" rel=\"noopener\"></a>html 书写规范：</h3><hr>\n<blockquote>\n<ul>\n<li>为每个<code>HTML</code>页面的第一行添加标准模式（standard mode）的声明，确保在每个浏览器中拥有一致的展现。</li>\n</ul>\n</blockquote>\n<blockquote>\n<pre><code>`文档类型声明`统一为HTML5声明类型，`编码`统一为UTF-8。</code></pre></blockquote>\n<blockquote>\n<pre><code>``中添加信息。</code></pre></blockquote>\n<pre><code>    //作者\n    //网页描述\n    //关键字,“，”分隔\n    //设定网页的到期时间。一旦网页过期，必须到服务器上重新调阅\n    //禁止浏览器从本地机的缓存中调阅页面内容\n    //用来防止别人在框架里调用你的页面\n    //跳转页面，5指时间停留5秒 网页搜索机器人向导。用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引\n    //content的参数有all,none,index,noindex,follow,nofollow，默认是all\n    //收藏图标\n    //网页不会被缓存</code></pre><blockquote>\n<pre><code>`IE`支持通过特定&lt;meta&gt;标签来确定绘制当前页面所应该采用的`IE`版本。除非有强烈的特殊需求，否则最好是设置为`edge mode` ，从而通知`IE`采用其所支持的最新的模式。</code></pre></blockquote>\n<blockquote>\n<ul>\n<li>非特殊情况下<code>CSS</code>样式文件外链至 HEAD 之间，<code>JAVASCRIPT</code>文件外链至页面底部。</li>\n</ul>\n</blockquote>\n<blockquote>\n<pre><code>引入`JAVASCRIPT`库文件，文件名须包含库名称及版本号及是否为压缩版。</code></pre></blockquote>\n<pre><code>    jQuery-1.8.3.min.js</code></pre><blockquote>\n<pre><code>引入`JAVASCRIPT`插件, 文件名格式为库名称+`.`+插件名称。</code></pre></blockquote>\n<pre><code>    jQuery.cookie.js</code></pre><blockquote>\n<ul>\n<li><code>HTML</code>属性应当按照以下给出的顺序依次排列，来确保代码的易读性。</li>\n</ul>\n</blockquote>\n<pre><code>    class\n    id 、 name\n    data-*\n    src、for、 type、 href\n    title、alt\n    aria-*、 role</code></pre><blockquote>\n<pre><code>编码均遵循`XHTML`标准,\n标签、属性、属性命名由小写英文、数字和\\_组成，且所有标签必须闭合，属性值必须用双引号`&quot;&quot;`,\n避免使用中文拼音尽量简易并要求语义化。</code></pre></blockquote>\n<pre><code>    CLASS --&gt; nHeadTitle --&gt; CLASS遵循小驼峰命名法（little camel-case）\n    ID --&gt; n_head_title --&gt; ID遵循名称+_\n    NAME --&gt; N_Head_Title --&gt; NAME属性命名遵循首个字母大写+_</code></pre><blockquote>\n<pre><code>当`JAVASCRIPT`获取单个元素时，通常使用document.getElementById来获取dom元素，document.getElementById兼容所有浏览器，但IE浏览器会混淆元素的ID和NAME属性，所以要区分ID和NAME命名。</code></pre></blockquote>\n<blockquote>\n<ul>\n<li>特殊符号应使用转意符。</li>\n</ul>\n</blockquote>\n<pre><code>    &lt;    --&gt;    &lt;\n    &gt;    --&gt;    &gt;\n    空格  --&gt;     </code></pre><blockquote>\n<ul>\n<li>含有描述性表单元素（<code>INPUT</code>，<code>TEXTAREA</code>）添加<code>LABEL</code>。</li>\n</ul>\n</blockquote>\n<pre><code>        测试</code></pre><blockquote>\n<ul>\n<li><p>多用无兼容性问题的<code>HTML</code>内置标签,比如 SPAN、EM、STRONG、OPTGROUP、LABEL 等,需要自定义<code>HTML</code>标签属性时，首先考虑是否存在已有的合适标签可替换，如果没有,可使用须以“<code>data-</code>”为前缀来添加自定义属性，避免使用其他命名方式。</p>\n</li>\n<li><p>语义化<code>HTML</code>。</p>\n</li>\n<li><p>尽可能减少</p>\n<p>嵌套。</p>\n</li>\n<li><p>书写链接地址时避免重定向。</p>\n</li>\n</ul>\n</blockquote>\n<pre><code>    href=&quot;http://www.kahn1990.com/&quot; //即在URL地址后面加“/”</code></pre><blockquote>\n<ul>\n<li><code>HTML</code>中对于属性的定义，确保全部使用双引号，绝不要使用单引号</li>\n</ul>\n</blockquote>\n<h3 id=\"css-书写规范：\"><a href=\"#css-书写规范：\" class=\"headerlink\" title=\"css 书写规范：\"></a><a href=\"https://github.com/xkloveme/houtai/blob/master/README.md#css书写规范\" target=\"_blank\" rel=\"noopener\"></a>css 书写规范：</h3><hr>\n<blockquote>\n<ul>\n<li>为了欺骗<code>W3C</code>的验证工具,可将代码分为两个文件，一个是针对所有浏览器,一个只针对 IE。即将所有符合<code>W3C</code>的代码写到一个文件中,而一些 IE 中必须而又不能通过<code>W3C</code>验证的代码（如:<code>cursor:hand;</code>）放到另一个文件中，再用下面的方法导入。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li><code>CSS</code>样式新建或修改尽量遵循以下原则。</li>\n</ul>\n</blockquote>\n<pre><code>    根据新建样式的适用范围分为三级：全站级、产品级、页面级。\n    尽量通过继承和层叠重用已有样式。\n    不要轻易改动全站级CSS。改动后，要经过全面测试。</code></pre><blockquote>\n<ul>\n<li><code>CSS</code>属性显示顺序。</li>\n</ul>\n</blockquote>\n<pre><code>    显示属性\n    元素位置\n    元素属性\n    元素内容属性</code></pre><blockquote>\n<ul>\n<li><code>CSS</code>书写顺序。</li>\n</ul>\n</blockquote>\n<pre><code>    .header {\n    /* 显示属性 */\n        display || visibility\n        list-style\n        position top || right || bottom || left\n        z-index\n        clear\n        float\n    /* 自身属性 */\n        width max-width || min-width\n        height max-height || min-height\n        overflow || clip\n        margin\n        padding\n        outline\n        border\n        background\n    /* 文本属性 */\n        color\n        font\n        text-overflow\n        text-align\n        text-indent\n        line-height\n        white-space\n        vertical-align\n        cursor\n        content\n    };</code></pre><blockquote>\n<pre><code>兼容多个浏览器时，将标准属性写在底部。</code></pre></blockquote>\n<pre><code>    -moz-border-radius: 15px; /* Firefox */\n    -webkit-border-radius: 15px; /* Safari和Chrome */\n    -o-border-radius: 15px;\n    border-radius: 15px; /* Opera 10.5+, 以及使用了IE-CSS3的IE浏览器 *//标准属性</code></pre><blockquote>\n<ul>\n<li>使用选择器时，命名比较短的词汇或者缩写的不允许直接定义样式。</li>\n</ul>\n</blockquote>\n<pre><code>    .hd,.bd,.td{};//如这些命名</code></pre><blockquote>\n<pre><code>可用上级节点进行限定。</code></pre></blockquote>\n<pre><code>    .recommend-mod .hd</code></pre><blockquote>\n<pre><code>多选择器规则之间换行，即当样式针对多个选择器时每个选择器占一行。</code></pre></blockquote>\n<pre><code>    button.btn,\n    input.btn,\n    input[type=&quot;button&quot;] {…};</code></pre><blockquote>\n<pre><code>优化`CSS`选择器。</code></pre></blockquote>\n<pre><code>    #header a { color: #444; };/*CSS选择器是从右边到左边进行匹配*/</code></pre><blockquote>\n<pre><code>浏览器将检查整个文档中的所有链接和每个链接的父元素，并遍历文档树去查找ID为header的祖先元素，如果找不到header将追溯到文档的根节点，解决方法如下。</code></pre></blockquote>\n<pre><code>    避免使用通配规则和相邻兄弟选择符、子选择符,、后代选择符、属性选择符等选择器\n    不要限定id选择符，如div#header（提权的除外）\n    不要限定类选择器，如ul.recommend（提权的除外）\n    不要使用 ul li a 这样长的选择符\n    避免使用标签子选择符，如#header &gt; li &gt; a</code></pre><blockquote>\n<ul>\n<li>使用<code>z-index</code>属性尽量<code>z-index</code>的值不要超过 150（通用组的除外），页面中的元素内容的<code>z-index</code>不能超过 10（提示框等模块除外但维持在 150 以下），不允许直接使用（999~9999）之间大值。</li>\n<li>尽量避免使用 CSS Hack。</li>\n</ul>\n</blockquote>\n<pre><code>    property:value; /* 所有浏览器 */\n    +property:value; /* IE7 */\n    _property:value; /* IE6 */\n    *property:value; /* IE6/7 */\n    property:value\\9; /* IE6/7/8/9，即所有IE浏览器 */\n\n\n    * html selector { … }; /* IE6 */\n    *:first-child+html selector { … }; /* IE7 */\n    html&gt;body selector { … }; /* 非IE6 */\n    @-moz-document url-prefix() { … }; /* firefox */\n    @media all and (-webkit-min-device-pixel-ratio:0) { … }; /* saf3+/chrome1+ */\n    @media all and (-webkit-min-device-pixel-ratio:10000),not all and (-webkit-min-device-pixel-ratio:0) { … }; /* opera */\n    @media screen and (max-device-width: 480px) { … }; /* iPhone/mobile webkit */</code></pre><blockquote>\n<pre><code>避免使用低效的选择器。</code></pre></blockquote>\n<pre><code>    body &gt; * {…};\n    ul &gt; li &gt; a {…};\n    #footer &gt; h3 {…};\n    ul#top_blue_nav {…};\n    searbar span.submit a { … }; /* 反面示例 */</code></pre><blockquote>\n<ul>\n<li>六个不要三个避免一个使用。</li>\n</ul>\n</blockquote>\n<pre><code>    不要在标签上直接写样式\n    不要在CSS中使用expression\n    不要在CSS中使用@import\n    不要在CSS中使用!important\n    不要在CSS中使用“*”选择符\n    不要将CSS样式写为单行\n    避免使用filter\n    避免使用行内（inline）样式\n    避免使用“*”设置{margin: 0; padding: 0;}\n    使用after或overflow的方式清浮动</code></pre><blockquote>\n<ul>\n<li>减少使用影响性能的属性。</li>\n</ul>\n</blockquote>\n<pre><code>    position:absolute;\n    float:left;//如这些定位或浮动属性\n\n\n    减少在`CSS`中使用滤镜表达式和图片repeat,\n    尤其在body当中,渲染性能极差, 如果需要用repeat的话,\n    图片的宽或高不能少于8px。</code></pre><h3 id=\"javaScript-书写规范：\"><a href=\"#javaScript-书写规范：\" class=\"headerlink\" title=\"javaScript 书写规范：\"></a><a href=\"https://github.com/xkloveme/houtai/blob/master/README.md#javascript书写规范\" target=\"_blank\" rel=\"noopener\"></a>javaScript 书写规范：</h3><hr>\n<blockquote>\n<ul>\n<li>命名规范。</li>\n</ul>\n</blockquote>\n<pre><code>    常量名\n        全部大写并单词间用下划线分隔\n        如：CSS_BTN_CLOSE、TXT_LOADING\n\n\n    对象的属性或方法名\n        小驼峰式（little camel-case）\n        如：init、bindEvent、updatePosition\n        示例：Dialog.prototype = {\n                init: function () {},\n                bindEvent: function () {},\n                updatePosition: function () {}\n                 …\n            };\n    类名（构造器）\n        --&gt;小驼峰式但首字母大写\n        --&gt;如：Current、DefaultConfig\n    函数名\n        --&gt;小驼峰式\n        --&gt;如：current()、defaultConfig()\n    变量名\n        --&gt;小驼峰式\n        --&gt;如：current、defaultConfig\n    私有变量名\n        --&gt;小驼峰式但需要用_开头\n        --&gt;如：_current、_defaultConfig\n    变量名的前缀\n        --&gt;续</code></pre><blockquote>\n<ul>\n<li>代码格式。</li>\n</ul>\n</blockquote>\n<pre><code>    &quot;()&quot;前后需要跟空格\n    &quot;=&quot;前后需要跟空格\n    &quot;,&quot;后面需要跟空格\n    JSON对象需格式化对象参数\n    if、while、for、do语句的执行体用&quot;{}&quot;括起来</code></pre><blockquote>\n<pre><code>&quot;{}&quot;格式如下。</code></pre></blockquote>\n<pre><code>    if (a==1) {\n        //代码\n    };</code></pre><blockquote>\n<pre><code>避免额外的逗号。</code></pre></blockquote>\n<pre><code>    var arr = [1,2,3,];</code></pre><blockquote>\n<pre><code>`for-in`循环体中必须用`hasOwnProperty`方法检查成员是否为自身成员，避免来自原型链上的污染。</code></pre><ul>\n<li>长语句可考虑断行。</li>\n</ul>\n</blockquote>\n<pre><code>    TEMPL_SONGLIST.replace(&#39;{TABLE}&#39;, da[&#39;results&#39;])\n        .replace(&#39;{PREV_NUM}&#39;, prev)\n        .replace(&#39;{NEXT_NUM}&#39;, next)\n        .replace(&#39;{CURRENT_NUM}&#39;, current)\n        .replace(&#39;{TOTAL_NUM}&#39;, da.page_total);</code></pre><blockquote>\n<pre><code>为了避免和`JSLint`的检验机制冲突，“.”或“+”这类操作符放在行尾。</code></pre></blockquote>\n<pre><code>    TEMPL_SONGLIST.replace(&#39;{TABLE}&#39;, da[&#39;results&#39;]).\n        replace(&#39;{PREV_NUM}&#39;, prev).\n        replace(&#39;{NEXT_NUM}&#39;, next).\n        replace(&#39;{CURRENT_NUM}&#39;, current).\n        replace(&#39;{TOTAL_NUM}&#39;, da.page_total);</code></pre><blockquote>\n<pre><code>如果模块代码中，使用其它全局变量想跳过JSLint的检查，可以在该文件中加入`/*global*/`声明。</code></pre></blockquote>\n<pre><code>    /*global alert: true, console: true, top: true, setTimeout: true */</code></pre><blockquote>\n<ul>\n<li>使用严格的条件判断符。用===代替==，用!==代替!=，避免掉入==造成的陷阱 在条件判断时，这样的一些值表示 false。</li>\n</ul>\n</blockquote>\n<pre><code>    null\n    undefined与null相等\n    字符串&#39;&#39;\n    数字0\n    NaN</code></pre><blockquote>\n<pre><code>在==时，则会有一些让人难以理解的陷阱。</code></pre></blockquote>\n<pre><code>    (function () {\n        var undefined;\n        undefined == null; // true\n        1 == true; //true\n        2 == true; // false\n        0 == false; // true\n        0 == &#39;&#39;; // true\n        NaN == NaN;// false\n        [] == false; // true\n        [] == ![]; // true\n    })();</code></pre><blockquote>\n<pre><code>对于不同类型的 == 判断，有这样一些规则，顺序自上而下：</code></pre></blockquote>\n<pre><code>    undefined与null相等\n    一个是number一个是string时，会尝试将string转换为number\n    尝试将boolean转换为number\n    0或1\n    尝试将Object转换成number或string</code></pre><blockquote>\n<pre><code>而这些取决于另外一个对比量，即值的类型，所以对于0、空字符串的判断，建议使用`===`\n。`===`会先判断两边的值类型，类型不匹配时为`false`。</code></pre><ul>\n<li>下面类型的对象不建议用 new 构造。</li>\n</ul>\n</blockquote>\n<pre><code>    new Number\n    new String\n    new Boolean\n    new Object //用{}代替\n    new Array //用[]代替</code></pre><blockquote>\n<pre><code>引用对象成员用`obj.prop`代替`obj[&quot;prop&quot;]`，除非属性名是变量。</code></pre><ul>\n<li>从 number 到 string 的转换。</li>\n</ul>\n</blockquote>\n<pre><code>    /** 推荐写法*/\n    var a = 1;\n    typeof(a); //&quot;number&quot;\n    console.log(a); //1\n    var aa=a+&#39;&#39;;\n    typeof(aa); //&quot;string&quot;\n    console.log(aa); //&#39;1&#39;\n    /** 不推荐写法*/\n    new String(a)或a.toString()</code></pre><blockquote>\n<pre><code>从string到number的转换，使用parseInt，必须显式指定第二个参数的进制。</code></pre></blockquote>\n<pre><code>    /** 推荐写法*/\n    var a = &#39;1&#39;;\n    var aa = parseInt(a,10);\n    typeof(a); //&quot;string&quot;\n    console.log(a); //&#39;1&#39;\n    typeof(aa); //&quot;number&quot;\n    console.log(aa); //1</code></pre><blockquote>\n<pre><code>从float到integer的转换。</code></pre></blockquote>\n<pre><code>    /** 推荐写法*/\n    Math.floor/Math.round/Math.ceil\n    /** 不推荐写法*/\n    parseInt</code></pre><blockquote>\n<pre><code>字符串拼接应使用数组保存字符串片段，使用时调用join方法。避免使用+或+=的方式拼接较长的字符串，每个字符串都会使用一个小的内存片段，过多的内存片段会影响性能。</code></pre></blockquote>\n<pre><code>    /**推荐的拼接方式array的push、join*/\n    var str=[],\n        list=[&#39;测试A&#39;,&#39;测试B&#39;];\n    for (var i=0 , len=list.length; i &lt; len; i++) {\n        str.push( &#39;&#39;+ list[i] + &#39;&#39;);\n    };\n    console.log(str.join(&#39;&#39;)); //测试A测试B\n    /** 不推荐的拼接方式+=*/\n    var str = &#39;&#39;,\n        list=[&#39;测试A&#39;,&#39;测试B&#39;];\n    for (var i = 0, len = list.length; i&lt; len; i++) {\n        str+=&#39;&#39; + list[i] + &#39;&#39;;\n    };\n    console.log(str); //测试A测试B</code></pre><blockquote>\n<ul>\n<li>尽量避免使用存在兼容性及消耗资源的方法或属性。</li>\n</ul>\n</blockquote>\n<pre><code>    不要使用with，void，evil，eval_r，innerText</code></pre><blockquote>\n<ul>\n<li>注重<code>HTML</code>分离, 减小<code>reflow</code>, 注重性能。</li>\n</ul>\n</blockquote>\n<h3 id=\"图片规范：\"><a href=\"#图片规范：\" class=\"headerlink\" title=\"图片规范：\"></a><a href=\"https://github.com/xkloveme/houtai/blob/master/README.md#图片规范\" target=\"_blank\" rel=\"noopener\"></a>图片规范：</h3><hr>\n<blockquote>\n<ul>\n<li>命名应用<code>小写英文</code>、<code>数字</code>、<code>_</code>组合，便于团队其他成员理解。</li>\n</ul>\n</blockquote>\n<pre><code>    header_btn.gif\n    header_btn2.gif</code></pre><blockquote>\n<ul>\n<li>页面元素类图片均放入<code>img</code>文件夹,测试用图片放于<code>img/testimg</code>文件夹，psd 源图放入<code>img/psdimg</code>文件夹。</li>\n<li>图片格式仅限于<code>gif</code>、<code>png</code>、<code>jpg</code>等。</li>\n<li>用<code>png</code>图片做图片时, 要求图片格式为<code>png-8</code>格式,若<code>png-8</code>实在影响图片质量或其中有半透明效果,请为<code>ie-6</code>单独定义背景，并尽量避免使用半透明的 png 图片。</li>\n<li>背景图片请尽可能使用<code>sprite</code>技术, 减小<code>http</code>请求。</li>\n</ul>\n</blockquote>\n<h3 id=\"注释规范：\"><a href=\"#注释规范：\" class=\"headerlink\" title=\"注释规范：\"></a><a href=\"https://github.com/xkloveme/houtai/blob/master/README.md#注释规范\" target=\"_blank\" rel=\"noopener\"></a>注释规范：</h3><hr>\n<blockquote>\n<ul>\n<li><code>JAVASCRIPT</code>、<code>CSS</code>文件注释需要标明作者、文件版本、创建/修改时间、重大版本修改记录、函数描述、文件版本、创建或者修改时间、功能、作者等信息。</li>\n</ul>\n</blockquote>\n<pre><code>    /* * 注释块 */</code></pre><blockquote>\n<pre><code>中间可添加如下信息。</code></pre></blockquote>\n<pre><code>     @file 文件名\n    @addon 把一个函数标记为另一个函数的扩张，另一个函数的定义不在源文件中\n    @argument 用大括号中的自变量类型描述一个自变量\n    @author 函数/类作者的姓名\n    @base 如果类是继承得来，定义提供的类名称\n    @class 用来给一个类提供描述，不能用于构造器的文档中\n    @constructor 描述一个类的构造器\n    @deprecated 表示函数/类已被忽略\n    @exception 描述函数/类产生的一个错误\n    @exec @extends 表示派生出当前类的另一个类\n    @fileoverview 表示文档块将用于描述当前文件，这个标签应该放在其它任何标签之前\n    @final 指出函数/类\n    @ignore 让jsdoc忽视随后的代码\n    @link 类似于@link标签，用于连接许多其它页面\n    @member 定义随后的函数为提供的类名称的一个成员\n    @param 用大括号中的参数类型描述一个参数\n    @private 表示函数/类为私有，不应包含在生成的文档中\n    @requires 表示需要另一个函数/类\n    @return 描述一个函数的返回值\n    @see 连接到另一个函数/类\n    @throws 描述函数/类可能产生的错误\n    @type 指定函数/成员的返回类型\n    @version 函数/类的版本号</code></pre><h3 id=\"开发及测试工具约定：\"><a href=\"#开发及测试工具约定：\" class=\"headerlink\" title=\"开发及测试工具约定：\"></a><a href=\"https://github.com/xkloveme/houtai/blob/master/README.md#开发及测试工具约定\" target=\"_blank\" rel=\"noopener\"></a>开发及测试工具约定：</h3><hr>\n<blockquote>\n<ul>\n<li>编码格式化，三码统一。</li>\n<li>测试工具: 前期开发仅测试 FireFox &amp; IE6 &amp; IE7 &amp; IE8 &amp; IE9 &amp; Opera &amp; Chrome &amp; Safari</li>\n</ul>\n</blockquote>\n<h3 id=\"参考和借鉴了大家的经验，收集整理了这一篇开发规范，感谢所有的原作者，众人拾柴火焰高，技术无国界，持续更新中。\"><a href=\"#参考和借鉴了大家的经验，收集整理了这一篇开发规范，感谢所有的原作者，众人拾柴火焰高，技术无国界，持续更新中。\" class=\"headerlink\" title=\"参考和借鉴了大家的经验，收集整理了这一篇开发规范，感谢所有的原作者，众人拾柴火焰高，技术无国界，持续更新中。\"></a><a href=\"https://github.com/xkloveme/houtai/blob/master/README.md#参考和借鉴了大家的经验收集整理了这一篇开发规范感谢所有的原作者众人拾柴火焰高技术无国界持续更新中\" target=\"_blank\" rel=\"noopener\"></a>参考和借鉴了大家的经验，收集整理了这一篇开发规范，感谢所有的原作者，众人拾柴火焰高，技术无国界，持续更新中。</h3>"},{"title":"JS 开发者必须知道的十个 ES6 新特性","date":"2017-08-30T17:42:00.000Z","_content":"\n这篇文章会给你简单介绍一下 ES6。如果你还不知道什么是 ES6 的话，它是 JavaScript 一个新的实现，如果你是一个忙碌的 JavaScript 开发者（但谁不是呢），那么继续读下去吧，看看当今最热门的语言——JavaScript 的新一代实现中，最棒的十个特性。\n\n这是为忙碌的开发者准备的 ES6 中最棒的十个特性（无特定顺序）：\n\n1.  默认参数\n2.  模版表达式\n3.  多行字符串\n4.  拆包表达式\n5.  改进的对象表达式\n6.  箭头函数  `=&>`\n7.  Promise\n8.  块级作用域的`let`和`const`\n9.  类\n10. 模块化\n\n注意：这个列表十分主观并且带有偏见，其他未上榜的特性并不是因为没有作用，我这么做只是单纯的希望将这份列表中的项目保持在十个。\n\n首先，一个简单的 JavaScript 时间线，不了解历史的人也无法创造历史。\n\n1.  1995 年：JavaScript 以 LiveScript 之名诞生\n2.  1997 年：ECMAScript 标准确立\n3.  1999 年：ES3 发布，IE5 非常生气\n4.  2000 年-2005 年：`XMLHttpRequest`，熟知为`AJAX`，在如 Outlook Web Access(2002)、Oddpost(2002)、Gmail(2004)、Google Maps(2005)中得到了广泛的应用\n5.  2009 年：ES5 发布（这是我们目前用的最多的版本），带来了`forEach` / `Object.keys`/ `Object.create`（特地为 Douglas Crockford 所造，JSON 标准创建者） ，还有 JSON 标准。\n\n历史课上完了，我们回来讲编程。\n\n### 1\\. ES6 中的默认参数\n\n还记得我们以前要这样子来定义默认参数：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\nvar link = function (height, color, url) {\n\nvar height = height || 50\n\nvar color = color || 'red'\n\nvar url = url || 'http://azat.co'\n\n...\n\n}\n\n这样做一直都没什么问题，直到参数的值为`0`，因为`0`在 JavaScript 中算是`false`值，它会直接变成后面硬编码的值而不是`0`本身。当然了，谁要用`0`来传值啊（讽刺脸）？所以我们也忽略了这个瑕疵，沿用了这个逻辑，否则的话只能…..没有否则！在 ES6 中，我们可以把这些默认值直接放在函数签名中。\n\nJavaScript\n\n1\n\n2\n\n3\n\nvar link = function(height = 50, color = 'red', url = 'http://azat.co') {\n\n...\n\n}\n\n对了，这个语法和 Ruby 很像！\n\n### 2\\. ES6 中的模版表达式\n\n模版表达式在其他语言中一般是为了在模版字符串中输出变量，所以在 ES5 中，我们非得把字符串破开变成这样：\n\nJavaScript\n\n1\n\n2\n\nvar name = 'Your name is ' + first + ' ' + last + '.'\n\nvar url = 'http://localhost:3000/api/messages/' + id\n\n幸运的是在 ES6 中我们有了新语法，在反引号包裹的字符串中，使用\\${NAME}语法来表示模板字符:\n\nJavaScript\n\n1\n\n2\n\nvar name = `Your name is ${first} ${last}`\n\nvar url = `http://localhost:3000/api/messages/${id}`\n\n### 3\\. ES6 中的多行字符串\n\n另一个好吃的语法糖就是多行字符串，以前我们的实现是像这样的：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\nvar roadPoem = 'Then took the other, as just as fair,nt'\n\n- 'And having perhaps the better claimnt'\n\n- 'Because it was grassy and wanted wear,nt'\n\n- 'Though as for that the passing therent'\n\n- 'Had worn them really about the same,nt'\n\nvar fourAgreements = 'You have the right to be you.n\n\nYou can only be you when you do your best.'\n\n但是在 ES6 中，只要充分利用反引号。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\nvar roadPoem = `Then took the other, as just as fair,\n\nAnd having perhaps the better claim\n\nBecause it was grassy and wanted wear,\n\nThough as for that the passing there\n\nHad worn them really about the same,`\n\nvar fourAgreements = `You have the right to be you.\n\nYou can only be you when you do your best.`\n\n### 4\\. ES6 中的拆包表达式\n\n拆包可能是一个比较难理解的概念，因为这里面真的是有魔法发生。假如说你有一个简单的赋值表达式，把对象中的`house`的`mouse`赋值为`house`和`mouse`的变量。\n\nJavaScript\n\n1\n\n2\n\n3\n\nvar data = \\$('body').data(), // 假设 data 中有 mouse 和 house 的值\n\nhouse = data.house,\n\nmouse = data.mouse\n\n另一个拆包的实例（Node.js)：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\nvar jsonMiddleware = require('body-parser').json\n\nvar body = req.body, // body 中有用户名和密码值\n\nusername = body.username,\n\npassword = body.password\n\n但是在 ES6 中我们可以用以下语句替换：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\nvar { house, mouse} = \\$('body').data() // 我们会拿到 house 和 mouse 的值的\n\nvar {jsonMiddleware} = require('body-parser')\n\nvar {username, password} = req.body\n\n甚至在数组中也能用，简直疯狂！\n\nJavaScript\n\n1\n\n2\n\nvar \\[col1, col2\\]  = \\$('.column'),\n\n\\[line1, line2, line3, , line5\\] = file.split('n')\n\n习惯拆包语法可能需要一些时间，但是这绝对是糖衣炮弹。\n\n### 5\\. ES6 中改进的对象表达式\n\n你能用对象表达式所做的是超乎想象的！类定义的方法从 ES5 中一个美化版的 JSON，进化到 ES6 中更像类的构造。\n\n这是一个 ES5 中典型的对象表达式，定义了一些方法和属性。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\nvar serviceBase = {port: 3000, url: 'azat.co'},\n\ngetAccounts = function(){return \\[1,2,3\\]}\n\nvar accountServiceES5 = {\n\nport: serviceBase.port,\n\nurl: serviceBase.url,\n\ngetAccounts: getAccounts,\n\ntoString: function() {\n\nreturn JSON.stringify(this.valueOf())\n\n},\n\ngetUrl: function() {return 'http://' + this.url + ':' + this.port},\n\nvalueOf_1_2_3: getAccounts()\n\n}\n\n如果你想做的好看一点，我们可以用`Object.create`方法来让  `serviceBase`成为  `accountServiceES5`的  `prototype`从而实现继承。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\nvar accountServiceES5ObjectCreate = Object.create(serviceBase)\n\nvar accountServiceES5ObjectCreate = {\n\ngetAccounts: getAccounts,\n\ntoString: function() {\n\nreturn JSON.stringify(this.valueOf())\n\n},\n\ngetUrl: function() {return 'http://' + this.url + ':' + this.port},\n\nvalueOf_1_2_3: getAccounts()\n\n}\n\n我知道  `accountServiceES5ObjectCreate`和  `accountServiceES5`是**不完全相同**的。因为一个对象  `accountServiceES5`会有如下所示的  `__proto__`属性：  \n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/6941baebjw1f61bok7iv5j20cw07v0u4.jpg)\n\n但对于这个示例，我们就把这两者考虑为相同的。所以在 ES6 的对象表达式中，我们把`getAccounts: getAccounts`简化为`getAccounts,`，并且我们还可以用`__proto__`直接设置`prototype`，这样听起来合理的多。（不过并不是用`proto`）\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\nvar serviceBase = {port: 3000, url: 'azat.co'},\n\ngetAccounts = function(){return \\[1,2,3\\]}\n\nvar accountService = {\n\n\\_\\_proto\\_\\_: serviceBase,\n\ngetAccounts,\n\n还有，我们可以调用  `super`和动态索引(`valueOf_1_2_3`)\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n// 续上段代码\n\ntoString() {\n\nreturn JSON.stringify((super.valueOf()))\n\n},\n\ngetUrl() {return 'http://' + this.url + ':' + this.port},\n\n\\[ 'valueOf*' + getAccounts().join('*') \\]: getAccounts()\n\n};\n\nconsole.log(accountService)\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/6941baebjw1f61bokh01nj20ad0buta1.jpg)\n\n这是对老旧的对象表达式一个很大的改进！\n\n### 6\\. ES6 中的箭头函数\n\n这或许是我最想要的一个特性，我爱 CoffeeScript 就是因为他胖胖的箭头(`=&>`相对于`-&>`)，现在 ES6 中也有了。这些箭头最神奇的地方在于他会让你写正确的代码。比如，`this`在上下文和函数中的值应当是相同的，它不会变化，通常变化的原因都是因为你创建了闭包。\n\n使用箭头函数可以让我们不再用`that = this`或者`self = this`或者`_this = this`或者`.bind(this)`这样的代码，比如，这些代码在 ES5 中就特别丑。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\nvar \\_this = this\n\n\\$('.btn').click(function(event){\n\n\\_this.sendData()\n\n})\n\n这是在 ES6 中去掉`_this = this`之后：\n\nJavaScript\n\n1\n\n2\n\n3\n\n\\$('.btn').click((event) =>{\n\nthis.sendData()\n\n})\n\n可惜的是，ES6 委员会觉得再加上瘦箭头(`-&>`)的话就对我们太好了，所以他们留下了一个老旧的`function`。（[瘦箭头在 CoffeeScript 中的作用](https://www.udemy.com/coffeescript/?couponCode=a)就像 ES5/6 中一样）\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\nvar logUpperCase = function() {\n\nvar \\_this = this\n\nthis.string = this.string.toUpperCase()\n\nreturn function () {\n\nreturn console.log(\\_this.string)\n\n}\n\n}\n\nlogUpperCase.call({ string: 'es6 rocks' })()\n\n在 ES6 中我们无需`_this`\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\nvar logUpperCase = function() {\n\nthis.string = this.string.toUpperCase()\n\nreturn () => console.log(this.string)\n\n}\n\nlogUpperCase.call({ string: 'es6 rocks' })()\n\n注意，在 ES6 中你可以合理的把箭头函数和旧式  `function`函数混用。当箭头函数所在语句只有一行时，它就会变成一个表达式，它会直接返回这个语句的值。但是如果你有多行语句，你就要明确的使用`return`。\n\n这是 ES5 中利用`messages`数组创建一个数组的代码：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\nvar ids = \\['5632953c4e345e145fdf2df8','563295464e345e145fdf2df9'\\]\n\nvar messages = ids.map(function (value) {\n\nreturn 'ID is ' + value // 显式返回\n\n});\n\n在 ES6 中会变成这样：\n\nJavaScript\n\n1\n\n2\n\nvar ids = \\['5632953c4e345e145fdf2df8','563295464e345e145fdf2df9'\\]\n\nvar messages = ids.map(value => `ID is ${value}`) // 隐式返回\n\n注意到我用了字符串模版吗，又一个从 CoffeeScript 中来的功能，我爱它们！\n\n在只有一个参数的函数签名中，括号是可有可无的，但是如果多于一个参数时就要加上。\n\nJavaScript\n\n1\n\n2\n\nvar ids = \\['5632953c4e345e145fdf2df8','563295464e345e145fdf2df9'\\]\n\nvar messages = ids.map((value, index, list) => `ID of ${index} element is ${value}`) // 隐式返回\n\n### 7\\. ES6 中的 Promise\n\nPromise 是一个有争议的话题。现在有很多 Promise 实现，语法也大致相同，比如`q`/ `bluebird`/ `deferred.js`/ `vow`/ `avow`/ `jquery deferred`等等。其他人说我们并不需要 Promise，异步，回调和`generator`之类的就很好。庆幸的是，现在在 ES6 中终于有一个标准的 Promise 实现。\n\n我们来看一个相当微不足道的延迟异步执行，用`setTimeout`实现\n\nJavaScript\n\n1\n\n2\n\n3\n\nsetTimeout(function(){\n\nconsole.log('Yay!')\n\n}, 1000)\n\n我们可以用 ES6 中的 Promise 重写：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\nvar wait1000 =  new Promise(function(resolve, reject) {\n\nsetTimeout(resolve, 1000)\n\n}).then(function() {\n\nconsole.log('Yay!')\n\n})\n\n或者用 ES6 的箭头函数：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\nvar wait1000 =  new Promise((resolve, reject)=> {\n\nsetTimeout(resolve, 1000)\n\n}).then(()=> {\n\nconsole.log('Yay!')\n\n})\n\n到现在为止，我们只是单纯增加了代码的行数，还明显没有带来任何好处，你说的对。但是如果我们有更多复杂的逻辑内嵌在`setTimeout()`中的回调时好处就来了：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\nsetTimeout(function(){\n\nconsole.log('Yay!')\n\nsetTimeout(function(){\n\nconsole.log('Wheeyee!')\n\n}, 1000)\n\n}, 1000)\n\n可以用 ES6 中的 Promise 重写：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\nvar wait1000 =  ()=> new Promise((resolve, reject)=> {setTimeout(resolve, 1000)})\n\nwait1000()\n\n.then(function() {\n\nconsole.log('Yay!')\n\nreturn wait1000()\n\n})\n\n.then(function() {\n\nconsole.log('Wheeyee!')\n\n});\n\n还是无法相信 Promise 比普通回调要好？我也不信。我想一旦知道了回调这个方法它就会在你脑中萦绕，额外的复杂的 Promise 也没有必要存在了。\n\n不论怎么说，ES6 中的 Promise 是为会欣赏的人准备的，Promise 有一个不错的`失败-捕捉`回调机制，看看这篇文章吧，里面有更多关于 Promise 的信息。[ES6 Promise 介绍](https://www.udemy.com/coffeescript)\n\n### 8\\. 块级作用域的`let`和`const`\n\n你可能早就听过对 ES6 中的`let`那些奇怪的传说，我记得我第一次到伦敦时为那些 TO LET 牌子感到非常困惑。但是 ES6 中的`let`和出租无关，这不算是语法糖，它很复杂。`let`是一个更新的`var`，可以让你把变量作用域限制在当前块里。我们用`{}`来定义块，但是在 ES5 中这些花括号起不到任何作用。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\nfunction calculateTotalAmount (vip) {\n\nvar amount = 0\n\nif (vip) {\n\nvar amount = 1\n\n}\n\n{ // 让块来的更疯狂\n\nvar amount = 100\n\n{\n\nvar amount = 1000\n\n}\n\n}\n\nreturn amount\n\n}\n\nconsole.log(calculateTotalAmount(true))\n\n运行结果将会是`1000`。天啊！这是多大的一个 Bug。在 ES6 中，我们用`let`来限制变量作用域为函数内。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\nfunction calculateTotalAmount (vip) {\n\nvar amount = 0 // 或许应该用 let, 但你可以混用\n\nif (vip) {\n\nlet amount = 1 // 第一个数量为 0\n\n}\n\n{ // 更多的块\n\nlet amount = 100 // 第一个数量为 0\n\n{\n\nlet amount = 1000 // 第一个数量为 0\n\n}\n\n}\n\nreturn amount\n\n}\n\nconsole.log(calculateTotalAmount(true))\n\n运行结果是`0`，因为在`if`块中也有`let`。如果什么都没有的话(`amount=1`)，那么结果将会是`1`。\n\n说到`const`，事情就简单多了。他仅仅产生是一个不可变的变量，并且他的作用域也像`let`一样只有块级。为了演示，这里有定义了一堆常量，并且由于作用域的原因，这些定义都是有效的。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\nfunction calculateTotalAmount (vip) {\n\nconst amount = 0\n\nif (vip) {\n\nconst amount = 1\n\n}\n\n{ // 更多的块\n\nconst amount = 100\n\n{\n\nconst amount = 1000\n\n}\n\n}\n\nreturn amount\n\n}\n\nconsole.log(calculateTotalAmount(true))\n\n依我愚见，`let`和`const`让这门语言变得更加复杂，没有这些的时候我们只有一条路可以走，但是现在可以要考虑更多的情景。;-(\n\n### 9\\. ES6 中的类\n\n如果你喜欢面向对象编程，那么你会特别喜欢这个特性。他让你编写和继承类时就跟在 Facebook 上发一个评论这么简单。\n\n在 ES5 中，因为没有`class`关键字（但它是毫无作用的保留字），类的创建和使用是让人十分痛苦的事情。更惨的是，很多伪类的实现像[pseude-classical](http://javascript.info/tutorial/pseudo-classical-pattern), [classical](http://www.crockford.com/javascript/inheritance.html), [functional](http://javascript.info/tutorial/factory-constructor-pattern)让人越来越摸不着头脑，为 JavaScript 的信仰战争火上浇油。\n\n我不会给你展示在 ES5 中怎么去编写一个类（是啦是啦从对象可以衍生出来其他的类和对象），因为有太多方法去完成。我们直接看 ES6 的示例，告诉你 ES6 的类会用`prototype`来实现而不是`function`。现在有一个`baseModel`类，其中我们可以定义构造函数和`getName()`方法。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\nclass baseModel {\n\nconstructor(options = {}, data = \\[\\]) { // class constructor\n\nthis.name = 'Base'\n\nthis.url = 'http://azat.co/api'\n\nthis.data = data\n\nthis.options = options\n\n}\n\ngetName() { // class method\n\nconsole.log(`Class name: ${this.name}`)\n\n}\n\n}\n\n注意到我给`options`和`data`用了默认参数，而且方法名再也不用加上`function`或者`:`了。还有一个很大的区别，你不能像构造函数里面一样向`this.Name`指派值。怎么说呢，和`函数`有相同缩进的代码里，你不能向`name`赋值。如果有这个需要的话，在构造函数里面完成。\n\n使用`NAME extends PARENT_NAME`语法，`AccountModel`从`baseModel`继承而来。\n\nJavaScript\n\n1\n\n2\n\nclass AccountModel extends baseModel {\n\nconstructor(options, data) {\n\n调用父类构造函数时，只需带上参数轻松的调用`super()`方法。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\nsuper({private: true}, \\['32113123123', '524214691'\\]) //call the parent method with super\n\nthis.name = 'Account Model'\n\nthis.url +='/accounts/'\n\n}\n\n想要高级一点的话，你可以像这样弄一个`getter`方法，这样`accountsData`就会变成一个属性。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\nget accountsData() { // 返回计算后的数据\n\n// ... make XHR\n\nreturn this.data\n\n}\n\n}\n\n现在你要怎么用这个魔咒，很简单，就跟让三岁小孩相信圣诞老人存在一样。\n\nJavaScript\n\n1\n\n2\n\n3\n\nlet accounts = new AccountModel(5)\n\naccounts.getName()\n\nconsole.log('Data is %s', accounts.accountsData)\n\n如果好奇输出结果的话：\n\nJavaScript\n\n1\n\n2\n\nClass name: Account Model\n\nData is 32113123123,524214691\n\n### 10\\. ES6 中的模块化\n\n你可能知道，ES6 之前 JavaScript 并没有对模块化有过原生的支持，人们想出来`AMD`，`RequireJS`，`CommenJS`等等，现在终于有`import`和`export`运算符来实现了。\n\nES5 中你会用`script`标签和`IIFE(立即执行函数)`，或者是其他的像`AMD`之类的库，但是 ES6 中你可以用`export`来暴露你的类。我是喜欢 Node.js 的人，所以我用和 Node.js 语法一样的`CommonJS`，然后用[Browserfy](http://browserify.org/)来浏览器化。现在我们有一个`port`变量和`getAccounts`方法，在 ES5 中：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\nmodule.exports = {\n\nport: 3000,\n\ngetAccounts: function() {\n\n...\n\n}\n\n}\n\n在 ES5 的`main.js`中，用`require('模块')`来导入：\n\nJavaScript\n\n1\n\n2\n\nvar service = require('module.js')\n\nconsole.log(service.port) // 3000\n\n但是在 ES6 中，我们用`export`和`import`。比如这是 ES6 中的`module.js`文件：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\nexport var port = 3000\n\nexport function getAccounts(url) {\n\n...\n\n}\n\n在需要引入的`main.js`文件中，可以用`import {名称} from '模块'`语法：\n\nJavaScript\n\n1\n\n2\n\nimport {port, getAccounts} from 'module'\n\nconsole.log(port) // 3000\n\n或者就直接在`main.js`中引入所有的变量：\n\nJavaScript\n\n1\n\n2\n\nimport \\* as service from 'module'\n\nconsole.log(service.port) // 3000\n\n个人来说，我觉得这样的模块化有些搞不懂。确实，这样会更传神一些 。但是 Node.js 中的模块不会马上就改过来，浏览器和服务器的代码最好是用同样的标准，所以目前我还是会坚持`CommonJS/Node.js`的方式。\n\n目前来说浏览器对 ES6 的支持还遥遥无期（本文写作时），所以你需要一些像[jspm](http://jspm.io/)这样的工具来用 ES6 的模块。\n\n想要了解更多 ES6 中的模块化和例子的话，来看[这篇文章](http://exploringjs.com/es6/ch_modules.html)，不管怎么说，写现代化的 JavaScript 吧！\n\n### 怎么样可以在今天就用上 ES6（Babel）\n\nES6 标准已经敲定，但还未被所有浏览器支持（[Firefox 的 ES6 功能一览](https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla)），如果想马上就用上 ES6，需要一个像[Babel](https://babeljs.io/)这样的编译器。你可以把他当独立工具用，也可以将他集成到构建系统里，Babel 对`Gulp`，`Grunt`和`Webpack`都有对应的[插件](http://babeljs.io/docs/setup)。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/6941baebjw1f61bokq3xbj20yb0pdq6a.jpg)\n\n安装 Gulp 插件示例：\n\nJavaScript\n\n1\n\n\\$ npm install --save-dev gulp-babel\n\n在`gulpfile.js`中，定义这么一个任务，将`src`目录下的`app.js`文件编译到`build`目录下：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\nvar gulp = require('gulp'),\n\nbabel = require('gulp-babel')\n\ngulp.task('build', function () {\n\nreturn gulp.src('src/app.js')\n\n.pipe(babel())\n\n.pipe(gulp.dest('build'))\n\n})\n\n### Node.js 和 ES6\n\n对于 Node.js，你可以用构建工具或者直接用独立模块`babel-core`：\n\nJavaScript\n\n1\n\n\\$ npm install --save-dev babel-core\n\n然后在 Node.js 中调用这个函数：\n\nJavaScript\n\n1\n\nrequire('babel-core').transform(es5Code, options)\n\n### ES6 的一些总结\n\nES6 中还有很多你可能都用不上（至少现在用不上）的可圈可点的特性，以下无特定顺序：\n\n1.  `Math` / `Number` / `String` / `Array` / `Object`中新的方法\n2.  二进制和八进制数据类型\n3.  自动展开多余参数\n4.  `For of`循环（又见面了 CoffeeScript）\n5.  `Symbols`\n6.  尾部调用优化\n7.  `generator`\n8.  更新的数据结构（如`Map`和`Set`）\n","source":"_posts/2017-08-31-JS 开发者必须知道的十个 ES6 新特性.md","raw":"---\ntitle: JS 开发者必须知道的十个 ES6 新特性\ntags:\n  - 技术\ndate: 2017-08-31 01:42:00\ncategories: 前端\n---\n\n这篇文章会给你简单介绍一下 ES6。如果你还不知道什么是 ES6 的话，它是 JavaScript 一个新的实现，如果你是一个忙碌的 JavaScript 开发者（但谁不是呢），那么继续读下去吧，看看当今最热门的语言——JavaScript 的新一代实现中，最棒的十个特性。\n\n这是为忙碌的开发者准备的 ES6 中最棒的十个特性（无特定顺序）：\n\n1.  默认参数\n2.  模版表达式\n3.  多行字符串\n4.  拆包表达式\n5.  改进的对象表达式\n6.  箭头函数  `=&>`\n7.  Promise\n8.  块级作用域的`let`和`const`\n9.  类\n10. 模块化\n\n注意：这个列表十分主观并且带有偏见，其他未上榜的特性并不是因为没有作用，我这么做只是单纯的希望将这份列表中的项目保持在十个。\n\n首先，一个简单的 JavaScript 时间线，不了解历史的人也无法创造历史。\n\n1.  1995 年：JavaScript 以 LiveScript 之名诞生\n2.  1997 年：ECMAScript 标准确立\n3.  1999 年：ES3 发布，IE5 非常生气\n4.  2000 年-2005 年：`XMLHttpRequest`，熟知为`AJAX`，在如 Outlook Web Access(2002)、Oddpost(2002)、Gmail(2004)、Google Maps(2005)中得到了广泛的应用\n5.  2009 年：ES5 发布（这是我们目前用的最多的版本），带来了`forEach` / `Object.keys`/ `Object.create`（特地为 Douglas Crockford 所造，JSON 标准创建者） ，还有 JSON 标准。\n\n历史课上完了，我们回来讲编程。\n\n### 1\\. ES6 中的默认参数\n\n还记得我们以前要这样子来定义默认参数：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\nvar link = function (height, color, url) {\n\nvar height = height || 50\n\nvar color = color || 'red'\n\nvar url = url || 'http://azat.co'\n\n...\n\n}\n\n这样做一直都没什么问题，直到参数的值为`0`，因为`0`在 JavaScript 中算是`false`值，它会直接变成后面硬编码的值而不是`0`本身。当然了，谁要用`0`来传值啊（讽刺脸）？所以我们也忽略了这个瑕疵，沿用了这个逻辑，否则的话只能…..没有否则！在 ES6 中，我们可以把这些默认值直接放在函数签名中。\n\nJavaScript\n\n1\n\n2\n\n3\n\nvar link = function(height = 50, color = 'red', url = 'http://azat.co') {\n\n...\n\n}\n\n对了，这个语法和 Ruby 很像！\n\n### 2\\. ES6 中的模版表达式\n\n模版表达式在其他语言中一般是为了在模版字符串中输出变量，所以在 ES5 中，我们非得把字符串破开变成这样：\n\nJavaScript\n\n1\n\n2\n\nvar name = 'Your name is ' + first + ' ' + last + '.'\n\nvar url = 'http://localhost:3000/api/messages/' + id\n\n幸运的是在 ES6 中我们有了新语法，在反引号包裹的字符串中，使用\\${NAME}语法来表示模板字符:\n\nJavaScript\n\n1\n\n2\n\nvar name = `Your name is ${first} ${last}`\n\nvar url = `http://localhost:3000/api/messages/${id}`\n\n### 3\\. ES6 中的多行字符串\n\n另一个好吃的语法糖就是多行字符串，以前我们的实现是像这样的：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\nvar roadPoem = 'Then took the other, as just as fair,nt'\n\n- 'And having perhaps the better claimnt'\n\n- 'Because it was grassy and wanted wear,nt'\n\n- 'Though as for that the passing therent'\n\n- 'Had worn them really about the same,nt'\n\nvar fourAgreements = 'You have the right to be you.n\n\nYou can only be you when you do your best.'\n\n但是在 ES6 中，只要充分利用反引号。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\nvar roadPoem = `Then took the other, as just as fair,\n\nAnd having perhaps the better claim\n\nBecause it was grassy and wanted wear,\n\nThough as for that the passing there\n\nHad worn them really about the same,`\n\nvar fourAgreements = `You have the right to be you.\n\nYou can only be you when you do your best.`\n\n### 4\\. ES6 中的拆包表达式\n\n拆包可能是一个比较难理解的概念，因为这里面真的是有魔法发生。假如说你有一个简单的赋值表达式，把对象中的`house`的`mouse`赋值为`house`和`mouse`的变量。\n\nJavaScript\n\n1\n\n2\n\n3\n\nvar data = \\$('body').data(), // 假设 data 中有 mouse 和 house 的值\n\nhouse = data.house,\n\nmouse = data.mouse\n\n另一个拆包的实例（Node.js)：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\nvar jsonMiddleware = require('body-parser').json\n\nvar body = req.body, // body 中有用户名和密码值\n\nusername = body.username,\n\npassword = body.password\n\n但是在 ES6 中我们可以用以下语句替换：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\nvar { house, mouse} = \\$('body').data() // 我们会拿到 house 和 mouse 的值的\n\nvar {jsonMiddleware} = require('body-parser')\n\nvar {username, password} = req.body\n\n甚至在数组中也能用，简直疯狂！\n\nJavaScript\n\n1\n\n2\n\nvar \\[col1, col2\\]  = \\$('.column'),\n\n\\[line1, line2, line3, , line5\\] = file.split('n')\n\n习惯拆包语法可能需要一些时间，但是这绝对是糖衣炮弹。\n\n### 5\\. ES6 中改进的对象表达式\n\n你能用对象表达式所做的是超乎想象的！类定义的方法从 ES5 中一个美化版的 JSON，进化到 ES6 中更像类的构造。\n\n这是一个 ES5 中典型的对象表达式，定义了一些方法和属性。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\nvar serviceBase = {port: 3000, url: 'azat.co'},\n\ngetAccounts = function(){return \\[1,2,3\\]}\n\nvar accountServiceES5 = {\n\nport: serviceBase.port,\n\nurl: serviceBase.url,\n\ngetAccounts: getAccounts,\n\ntoString: function() {\n\nreturn JSON.stringify(this.valueOf())\n\n},\n\ngetUrl: function() {return 'http://' + this.url + ':' + this.port},\n\nvalueOf_1_2_3: getAccounts()\n\n}\n\n如果你想做的好看一点，我们可以用`Object.create`方法来让  `serviceBase`成为  `accountServiceES5`的  `prototype`从而实现继承。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\nvar accountServiceES5ObjectCreate = Object.create(serviceBase)\n\nvar accountServiceES5ObjectCreate = {\n\ngetAccounts: getAccounts,\n\ntoString: function() {\n\nreturn JSON.stringify(this.valueOf())\n\n},\n\ngetUrl: function() {return 'http://' + this.url + ':' + this.port},\n\nvalueOf_1_2_3: getAccounts()\n\n}\n\n我知道  `accountServiceES5ObjectCreate`和  `accountServiceES5`是**不完全相同**的。因为一个对象  `accountServiceES5`会有如下所示的  `__proto__`属性：  \n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/6941baebjw1f61bok7iv5j20cw07v0u4.jpg)\n\n但对于这个示例，我们就把这两者考虑为相同的。所以在 ES6 的对象表达式中，我们把`getAccounts: getAccounts`简化为`getAccounts,`，并且我们还可以用`__proto__`直接设置`prototype`，这样听起来合理的多。（不过并不是用`proto`）\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\nvar serviceBase = {port: 3000, url: 'azat.co'},\n\ngetAccounts = function(){return \\[1,2,3\\]}\n\nvar accountService = {\n\n\\_\\_proto\\_\\_: serviceBase,\n\ngetAccounts,\n\n还有，我们可以调用  `super`和动态索引(`valueOf_1_2_3`)\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n// 续上段代码\n\ntoString() {\n\nreturn JSON.stringify((super.valueOf()))\n\n},\n\ngetUrl() {return 'http://' + this.url + ':' + this.port},\n\n\\[ 'valueOf*' + getAccounts().join('*') \\]: getAccounts()\n\n};\n\nconsole.log(accountService)\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/6941baebjw1f61bokh01nj20ad0buta1.jpg)\n\n这是对老旧的对象表达式一个很大的改进！\n\n### 6\\. ES6 中的箭头函数\n\n这或许是我最想要的一个特性，我爱 CoffeeScript 就是因为他胖胖的箭头(`=&>`相对于`-&>`)，现在 ES6 中也有了。这些箭头最神奇的地方在于他会让你写正确的代码。比如，`this`在上下文和函数中的值应当是相同的，它不会变化，通常变化的原因都是因为你创建了闭包。\n\n使用箭头函数可以让我们不再用`that = this`或者`self = this`或者`_this = this`或者`.bind(this)`这样的代码，比如，这些代码在 ES5 中就特别丑。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\nvar \\_this = this\n\n\\$('.btn').click(function(event){\n\n\\_this.sendData()\n\n})\n\n这是在 ES6 中去掉`_this = this`之后：\n\nJavaScript\n\n1\n\n2\n\n3\n\n\\$('.btn').click((event) =>{\n\nthis.sendData()\n\n})\n\n可惜的是，ES6 委员会觉得再加上瘦箭头(`-&>`)的话就对我们太好了，所以他们留下了一个老旧的`function`。（[瘦箭头在 CoffeeScript 中的作用](https://www.udemy.com/coffeescript/?couponCode=a)就像 ES5/6 中一样）\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\nvar logUpperCase = function() {\n\nvar \\_this = this\n\nthis.string = this.string.toUpperCase()\n\nreturn function () {\n\nreturn console.log(\\_this.string)\n\n}\n\n}\n\nlogUpperCase.call({ string: 'es6 rocks' })()\n\n在 ES6 中我们无需`_this`\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\nvar logUpperCase = function() {\n\nthis.string = this.string.toUpperCase()\n\nreturn () => console.log(this.string)\n\n}\n\nlogUpperCase.call({ string: 'es6 rocks' })()\n\n注意，在 ES6 中你可以合理的把箭头函数和旧式  `function`函数混用。当箭头函数所在语句只有一行时，它就会变成一个表达式，它会直接返回这个语句的值。但是如果你有多行语句，你就要明确的使用`return`。\n\n这是 ES5 中利用`messages`数组创建一个数组的代码：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\nvar ids = \\['5632953c4e345e145fdf2df8','563295464e345e145fdf2df9'\\]\n\nvar messages = ids.map(function (value) {\n\nreturn 'ID is ' + value // 显式返回\n\n});\n\n在 ES6 中会变成这样：\n\nJavaScript\n\n1\n\n2\n\nvar ids = \\['5632953c4e345e145fdf2df8','563295464e345e145fdf2df9'\\]\n\nvar messages = ids.map(value => `ID is ${value}`) // 隐式返回\n\n注意到我用了字符串模版吗，又一个从 CoffeeScript 中来的功能，我爱它们！\n\n在只有一个参数的函数签名中，括号是可有可无的，但是如果多于一个参数时就要加上。\n\nJavaScript\n\n1\n\n2\n\nvar ids = \\['5632953c4e345e145fdf2df8','563295464e345e145fdf2df9'\\]\n\nvar messages = ids.map((value, index, list) => `ID of ${index} element is ${value}`) // 隐式返回\n\n### 7\\. ES6 中的 Promise\n\nPromise 是一个有争议的话题。现在有很多 Promise 实现，语法也大致相同，比如`q`/ `bluebird`/ `deferred.js`/ `vow`/ `avow`/ `jquery deferred`等等。其他人说我们并不需要 Promise，异步，回调和`generator`之类的就很好。庆幸的是，现在在 ES6 中终于有一个标准的 Promise 实现。\n\n我们来看一个相当微不足道的延迟异步执行，用`setTimeout`实现\n\nJavaScript\n\n1\n\n2\n\n3\n\nsetTimeout(function(){\n\nconsole.log('Yay!')\n\n}, 1000)\n\n我们可以用 ES6 中的 Promise 重写：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\nvar wait1000 =  new Promise(function(resolve, reject) {\n\nsetTimeout(resolve, 1000)\n\n}).then(function() {\n\nconsole.log('Yay!')\n\n})\n\n或者用 ES6 的箭头函数：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\nvar wait1000 =  new Promise((resolve, reject)=> {\n\nsetTimeout(resolve, 1000)\n\n}).then(()=> {\n\nconsole.log('Yay!')\n\n})\n\n到现在为止，我们只是单纯增加了代码的行数，还明显没有带来任何好处，你说的对。但是如果我们有更多复杂的逻辑内嵌在`setTimeout()`中的回调时好处就来了：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\nsetTimeout(function(){\n\nconsole.log('Yay!')\n\nsetTimeout(function(){\n\nconsole.log('Wheeyee!')\n\n}, 1000)\n\n}, 1000)\n\n可以用 ES6 中的 Promise 重写：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\nvar wait1000 =  ()=> new Promise((resolve, reject)=> {setTimeout(resolve, 1000)})\n\nwait1000()\n\n.then(function() {\n\nconsole.log('Yay!')\n\nreturn wait1000()\n\n})\n\n.then(function() {\n\nconsole.log('Wheeyee!')\n\n});\n\n还是无法相信 Promise 比普通回调要好？我也不信。我想一旦知道了回调这个方法它就会在你脑中萦绕，额外的复杂的 Promise 也没有必要存在了。\n\n不论怎么说，ES6 中的 Promise 是为会欣赏的人准备的，Promise 有一个不错的`失败-捕捉`回调机制，看看这篇文章吧，里面有更多关于 Promise 的信息。[ES6 Promise 介绍](https://www.udemy.com/coffeescript)\n\n### 8\\. 块级作用域的`let`和`const`\n\n你可能早就听过对 ES6 中的`let`那些奇怪的传说，我记得我第一次到伦敦时为那些 TO LET 牌子感到非常困惑。但是 ES6 中的`let`和出租无关，这不算是语法糖，它很复杂。`let`是一个更新的`var`，可以让你把变量作用域限制在当前块里。我们用`{}`来定义块，但是在 ES5 中这些花括号起不到任何作用。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\nfunction calculateTotalAmount (vip) {\n\nvar amount = 0\n\nif (vip) {\n\nvar amount = 1\n\n}\n\n{ // 让块来的更疯狂\n\nvar amount = 100\n\n{\n\nvar amount = 1000\n\n}\n\n}\n\nreturn amount\n\n}\n\nconsole.log(calculateTotalAmount(true))\n\n运行结果将会是`1000`。天啊！这是多大的一个 Bug。在 ES6 中，我们用`let`来限制变量作用域为函数内。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\nfunction calculateTotalAmount (vip) {\n\nvar amount = 0 // 或许应该用 let, 但你可以混用\n\nif (vip) {\n\nlet amount = 1 // 第一个数量为 0\n\n}\n\n{ // 更多的块\n\nlet amount = 100 // 第一个数量为 0\n\n{\n\nlet amount = 1000 // 第一个数量为 0\n\n}\n\n}\n\nreturn amount\n\n}\n\nconsole.log(calculateTotalAmount(true))\n\n运行结果是`0`，因为在`if`块中也有`let`。如果什么都没有的话(`amount=1`)，那么结果将会是`1`。\n\n说到`const`，事情就简单多了。他仅仅产生是一个不可变的变量，并且他的作用域也像`let`一样只有块级。为了演示，这里有定义了一堆常量，并且由于作用域的原因，这些定义都是有效的。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\nfunction calculateTotalAmount (vip) {\n\nconst amount = 0\n\nif (vip) {\n\nconst amount = 1\n\n}\n\n{ // 更多的块\n\nconst amount = 100\n\n{\n\nconst amount = 1000\n\n}\n\n}\n\nreturn amount\n\n}\n\nconsole.log(calculateTotalAmount(true))\n\n依我愚见，`let`和`const`让这门语言变得更加复杂，没有这些的时候我们只有一条路可以走，但是现在可以要考虑更多的情景。;-(\n\n### 9\\. ES6 中的类\n\n如果你喜欢面向对象编程，那么你会特别喜欢这个特性。他让你编写和继承类时就跟在 Facebook 上发一个评论这么简单。\n\n在 ES5 中，因为没有`class`关键字（但它是毫无作用的保留字），类的创建和使用是让人十分痛苦的事情。更惨的是，很多伪类的实现像[pseude-classical](http://javascript.info/tutorial/pseudo-classical-pattern), [classical](http://www.crockford.com/javascript/inheritance.html), [functional](http://javascript.info/tutorial/factory-constructor-pattern)让人越来越摸不着头脑，为 JavaScript 的信仰战争火上浇油。\n\n我不会给你展示在 ES5 中怎么去编写一个类（是啦是啦从对象可以衍生出来其他的类和对象），因为有太多方法去完成。我们直接看 ES6 的示例，告诉你 ES6 的类会用`prototype`来实现而不是`function`。现在有一个`baseModel`类，其中我们可以定义构造函数和`getName()`方法。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\nclass baseModel {\n\nconstructor(options = {}, data = \\[\\]) { // class constructor\n\nthis.name = 'Base'\n\nthis.url = 'http://azat.co/api'\n\nthis.data = data\n\nthis.options = options\n\n}\n\ngetName() { // class method\n\nconsole.log(`Class name: ${this.name}`)\n\n}\n\n}\n\n注意到我给`options`和`data`用了默认参数，而且方法名再也不用加上`function`或者`:`了。还有一个很大的区别，你不能像构造函数里面一样向`this.Name`指派值。怎么说呢，和`函数`有相同缩进的代码里，你不能向`name`赋值。如果有这个需要的话，在构造函数里面完成。\n\n使用`NAME extends PARENT_NAME`语法，`AccountModel`从`baseModel`继承而来。\n\nJavaScript\n\n1\n\n2\n\nclass AccountModel extends baseModel {\n\nconstructor(options, data) {\n\n调用父类构造函数时，只需带上参数轻松的调用`super()`方法。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\nsuper({private: true}, \\['32113123123', '524214691'\\]) //call the parent method with super\n\nthis.name = 'Account Model'\n\nthis.url +='/accounts/'\n\n}\n\n想要高级一点的话，你可以像这样弄一个`getter`方法，这样`accountsData`就会变成一个属性。\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\nget accountsData() { // 返回计算后的数据\n\n// ... make XHR\n\nreturn this.data\n\n}\n\n}\n\n现在你要怎么用这个魔咒，很简单，就跟让三岁小孩相信圣诞老人存在一样。\n\nJavaScript\n\n1\n\n2\n\n3\n\nlet accounts = new AccountModel(5)\n\naccounts.getName()\n\nconsole.log('Data is %s', accounts.accountsData)\n\n如果好奇输出结果的话：\n\nJavaScript\n\n1\n\n2\n\nClass name: Account Model\n\nData is 32113123123,524214691\n\n### 10\\. ES6 中的模块化\n\n你可能知道，ES6 之前 JavaScript 并没有对模块化有过原生的支持，人们想出来`AMD`，`RequireJS`，`CommenJS`等等，现在终于有`import`和`export`运算符来实现了。\n\nES5 中你会用`script`标签和`IIFE(立即执行函数)`，或者是其他的像`AMD`之类的库，但是 ES6 中你可以用`export`来暴露你的类。我是喜欢 Node.js 的人，所以我用和 Node.js 语法一样的`CommonJS`，然后用[Browserfy](http://browserify.org/)来浏览器化。现在我们有一个`port`变量和`getAccounts`方法，在 ES5 中：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\nmodule.exports = {\n\nport: 3000,\n\ngetAccounts: function() {\n\n...\n\n}\n\n}\n\n在 ES5 的`main.js`中，用`require('模块')`来导入：\n\nJavaScript\n\n1\n\n2\n\nvar service = require('module.js')\n\nconsole.log(service.port) // 3000\n\n但是在 ES6 中，我们用`export`和`import`。比如这是 ES6 中的`module.js`文件：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\nexport var port = 3000\n\nexport function getAccounts(url) {\n\n...\n\n}\n\n在需要引入的`main.js`文件中，可以用`import {名称} from '模块'`语法：\n\nJavaScript\n\n1\n\n2\n\nimport {port, getAccounts} from 'module'\n\nconsole.log(port) // 3000\n\n或者就直接在`main.js`中引入所有的变量：\n\nJavaScript\n\n1\n\n2\n\nimport \\* as service from 'module'\n\nconsole.log(service.port) // 3000\n\n个人来说，我觉得这样的模块化有些搞不懂。确实，这样会更传神一些 。但是 Node.js 中的模块不会马上就改过来，浏览器和服务器的代码最好是用同样的标准，所以目前我还是会坚持`CommonJS/Node.js`的方式。\n\n目前来说浏览器对 ES6 的支持还遥遥无期（本文写作时），所以你需要一些像[jspm](http://jspm.io/)这样的工具来用 ES6 的模块。\n\n想要了解更多 ES6 中的模块化和例子的话，来看[这篇文章](http://exploringjs.com/es6/ch_modules.html)，不管怎么说，写现代化的 JavaScript 吧！\n\n### 怎么样可以在今天就用上 ES6（Babel）\n\nES6 标准已经敲定，但还未被所有浏览器支持（[Firefox 的 ES6 功能一览](https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla)），如果想马上就用上 ES6，需要一个像[Babel](https://babeljs.io/)这样的编译器。你可以把他当独立工具用，也可以将他集成到构建系统里，Babel 对`Gulp`，`Grunt`和`Webpack`都有对应的[插件](http://babeljs.io/docs/setup)。\n\n![](http://www.jixiaokang.com/wp-content/uploads/2018/05/6941baebjw1f61bokq3xbj20yb0pdq6a.jpg)\n\n安装 Gulp 插件示例：\n\nJavaScript\n\n1\n\n\\$ npm install --save-dev gulp-babel\n\n在`gulpfile.js`中，定义这么一个任务，将`src`目录下的`app.js`文件编译到`build`目录下：\n\nJavaScript\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\nvar gulp = require('gulp'),\n\nbabel = require('gulp-babel')\n\ngulp.task('build', function () {\n\nreturn gulp.src('src/app.js')\n\n.pipe(babel())\n\n.pipe(gulp.dest('build'))\n\n})\n\n### Node.js 和 ES6\n\n对于 Node.js，你可以用构建工具或者直接用独立模块`babel-core`：\n\nJavaScript\n\n1\n\n\\$ npm install --save-dev babel-core\n\n然后在 Node.js 中调用这个函数：\n\nJavaScript\n\n1\n\nrequire('babel-core').transform(es5Code, options)\n\n### ES6 的一些总结\n\nES6 中还有很多你可能都用不上（至少现在用不上）的可圈可点的特性，以下无特定顺序：\n\n1.  `Math` / `Number` / `String` / `Array` / `Object`中新的方法\n2.  二进制和八进制数据类型\n3.  自动展开多余参数\n4.  `For of`循环（又见面了 CoffeeScript）\n5.  `Symbols`\n6.  尾部调用优化\n7.  `generator`\n8.  更新的数据结构（如`Map`和`Set`）\n","slug":"2017-08-31-JS 开发者必须知道的十个 ES6 新特性","published":1,"updated":"2020-03-14T06:47:08.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvno00664k8y80p89c4b","content":"<p>这篇文章会给你简单介绍一下 ES6。如果你还不知道什么是 ES6 的话，它是 JavaScript 一个新的实现，如果你是一个忙碌的 JavaScript 开发者（但谁不是呢），那么继续读下去吧，看看当今最热门的语言——JavaScript 的新一代实现中，最棒的十个特性。</p>\n<p>这是为忙碌的开发者准备的 ES6 中最棒的十个特性（无特定顺序）：</p>\n<ol>\n<li>默认参数</li>\n<li>模版表达式</li>\n<li>多行字符串</li>\n<li>拆包表达式</li>\n<li>改进的对象表达式</li>\n<li>箭头函数  <code>=&amp;&gt;</code></li>\n<li>Promise</li>\n<li>块级作用域的<code>let</code>和<code>const</code></li>\n<li>类</li>\n<li>模块化</li>\n</ol>\n<p>注意：这个列表十分主观并且带有偏见，其他未上榜的特性并不是因为没有作用，我这么做只是单纯的希望将这份列表中的项目保持在十个。</p>\n<p>首先，一个简单的 JavaScript 时间线，不了解历史的人也无法创造历史。</p>\n<ol>\n<li>1995 年：JavaScript 以 LiveScript 之名诞生</li>\n<li>1997 年：ECMAScript 标准确立</li>\n<li>1999 年：ES3 发布，IE5 非常生气</li>\n<li>2000 年-2005 年：<code>XMLHttpRequest</code>，熟知为<code>AJAX</code>，在如 Outlook Web Access(2002)、Oddpost(2002)、Gmail(2004)、Google Maps(2005)中得到了广泛的应用</li>\n<li>2009 年：ES5 发布（这是我们目前用的最多的版本），带来了<code>forEach</code> / <code>Object.keys</code>/ <code>Object.create</code>（特地为 Douglas Crockford 所造，JSON 标准创建者） ，还有 JSON 标准。</li>\n</ol>\n<p>历史课上完了，我们回来讲编程。</p>\n<h3 id=\"1-ES6-中的默认参数\"><a href=\"#1-ES6-中的默认参数\" class=\"headerlink\" title=\"1. ES6 中的默认参数\"></a>1. ES6 中的默认参数</h3><p>还记得我们以前要这样子来定义默认参数：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>var link = function (height, color, url) {</p>\n<p>var height = height || 50</p>\n<p>var color = color || ‘red’</p>\n<p>var url = url || ‘<a href=\"http://azat.co&#39;\" target=\"_blank\" rel=\"noopener\">http://azat.co&#39;</a></p>\n<p>…</p>\n<p>}</p>\n<p>这样做一直都没什么问题，直到参数的值为<code>0</code>，因为<code>0</code>在 JavaScript 中算是<code>false</code>值，它会直接变成后面硬编码的值而不是<code>0</code>本身。当然了，谁要用<code>0</code>来传值啊（讽刺脸）？所以我们也忽略了这个瑕疵，沿用了这个逻辑，否则的话只能…..没有否则！在 ES6 中，我们可以把这些默认值直接放在函数签名中。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>var link = function(height = 50, color = ‘red’, url = ‘<a href=\"http://azat.co&#39;\" target=\"_blank\" rel=\"noopener\">http://azat.co&#39;</a>) {</p>\n<p>…</p>\n<p>}</p>\n<p>对了，这个语法和 Ruby 很像！</p>\n<h3 id=\"2-ES6-中的模版表达式\"><a href=\"#2-ES6-中的模版表达式\" class=\"headerlink\" title=\"2. ES6 中的模版表达式\"></a>2. ES6 中的模版表达式</h3><p>模版表达式在其他语言中一般是为了在模版字符串中输出变量，所以在 ES5 中，我们非得把字符串破开变成这样：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>var name = ‘Your name is ‘ + first + ‘ ‘ + last + ‘.’</p>\n<p>var url = ‘<a href=\"http://localhost:3000/api/messages/&#39;\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/api/messages/&#39;</a> + id</p>\n<p>幸运的是在 ES6 中我们有了新语法，在反引号包裹的字符串中，使用${NAME}语法来表示模板字符:</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>var name = <code>Your name is ${first} ${last}</code></p>\n<p>var url = <code>http://localhost:3000/api/messages/${id}</code></p>\n<h3 id=\"3-ES6-中的多行字符串\"><a href=\"#3-ES6-中的多行字符串\" class=\"headerlink\" title=\"3. ES6 中的多行字符串\"></a>3. ES6 中的多行字符串</h3><p>另一个好吃的语法糖就是多行字符串，以前我们的实现是像这样的：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>var roadPoem = ‘Then took the other, as just as fair,nt’</p>\n<ul>\n<li><p>‘And having perhaps the better claimnt’</p>\n</li>\n<li><p>‘Because it was grassy and wanted wear,nt’</p>\n</li>\n<li><p>‘Though as for that the passing therent’</p>\n</li>\n<li><p>‘Had worn them really about the same,nt’</p>\n</li>\n</ul>\n<p>var fourAgreements = ‘You have the right to be you.n</p>\n<p>You can only be you when you do your best.’</p>\n<p>但是在 ES6 中，只要充分利用反引号。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>var roadPoem = `Then took the other, as just as fair,</p>\n<p>And having perhaps the better claim</p>\n<p>Because it was grassy and wanted wear,</p>\n<p>Though as for that the passing there</p>\n<p>Had worn them really about the same,`</p>\n<p>var fourAgreements = `You have the right to be you.</p>\n<p>You can only be you when you do your best.`</p>\n<h3 id=\"4-ES6-中的拆包表达式\"><a href=\"#4-ES6-中的拆包表达式\" class=\"headerlink\" title=\"4. ES6 中的拆包表达式\"></a>4. ES6 中的拆包表达式</h3><p>拆包可能是一个比较难理解的概念，因为这里面真的是有魔法发生。假如说你有一个简单的赋值表达式，把对象中的<code>house</code>的<code>mouse</code>赋值为<code>house</code>和<code>mouse</code>的变量。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>var data = $(‘body’).data(), // 假设 data 中有 mouse 和 house 的值</p>\n<p>house = data.house,</p>\n<p>mouse = data.mouse</p>\n<p>另一个拆包的实例（Node.js)：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>var jsonMiddleware = require(‘body-parser’).json</p>\n<p>var body = req.body, // body 中有用户名和密码值</p>\n<p>username = body.username,</p>\n<p>password = body.password</p>\n<p>但是在 ES6 中我们可以用以下语句替换：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>var { house, mouse} = $(‘body’).data() // 我们会拿到 house 和 mouse 的值的</p>\n<p>var {jsonMiddleware} = require(‘body-parser’)</p>\n<p>var {username, password} = req.body</p>\n<p>甚至在数组中也能用，简直疯狂！</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>var [col1, col2]  = $(‘.column’),</p>\n<p>[line1, line2, line3, , line5] = file.split(‘n’)</p>\n<p>习惯拆包语法可能需要一些时间，但是这绝对是糖衣炮弹。</p>\n<h3 id=\"5-ES6-中改进的对象表达式\"><a href=\"#5-ES6-中改进的对象表达式\" class=\"headerlink\" title=\"5. ES6 中改进的对象表达式\"></a>5. ES6 中改进的对象表达式</h3><p>你能用对象表达式所做的是超乎想象的！类定义的方法从 ES5 中一个美化版的 JSON，进化到 ES6 中更像类的构造。</p>\n<p>这是一个 ES5 中典型的对象表达式，定义了一些方法和属性。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>11</p>\n<p>12</p>\n<p>13</p>\n<p>var serviceBase = {port: 3000, url: ‘azat.co’},</p>\n<p>getAccounts = function(){return [1,2,3]}</p>\n<p>var accountServiceES5 = {</p>\n<p>port: serviceBase.port,</p>\n<p>url: serviceBase.url,</p>\n<p>getAccounts: getAccounts,</p>\n<p>toString: function() {</p>\n<p>return JSON.stringify(this.valueOf())</p>\n<p>},</p>\n<p>getUrl: function() {return ‘http://‘ + this.url + ‘:’ + this.port},</p>\n<p>valueOf_1_2_3: getAccounts()</p>\n<p>}</p>\n<p>如果你想做的好看一点，我们可以用<code>Object.create</code>方法来让  <code>serviceBase</code>成为  <code>accountServiceES5</code>的  <code>prototype</code>从而实现继承。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>var accountServiceES5ObjectCreate = Object.create(serviceBase)</p>\n<p>var accountServiceES5ObjectCreate = {</p>\n<p>getAccounts: getAccounts,</p>\n<p>toString: function() {</p>\n<p>return JSON.stringify(this.valueOf())</p>\n<p>},</p>\n<p>getUrl: function() {return ‘http://‘ + this.url + ‘:’ + this.port},</p>\n<p>valueOf_1_2_3: getAccounts()</p>\n<p>}</p>\n<p>我知道  <code>accountServiceES5ObjectCreate</code>和  <code>accountServiceES5</code>是<strong>不完全相同</strong>的。因为一个对象  <code>accountServiceES5</code>会有如下所示的  <code>__proto__</code>属性：<br><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/6941baebjw1f61bok7iv5j20cw07v0u4.jpg\" alt=\"\"></p>\n<p>但对于这个示例，我们就把这两者考虑为相同的。所以在 ES6 的对象表达式中，我们把<code>getAccounts: getAccounts</code>简化为<code>getAccounts,</code>，并且我们还可以用<code>__proto__</code>直接设置<code>prototype</code>，这样听起来合理的多。（不过并不是用<code>proto</code>）</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>var serviceBase = {port: 3000, url: ‘azat.co’},</p>\n<p>getAccounts = function(){return [1,2,3]}</p>\n<p>var accountService = {</p>\n<p>__proto__: serviceBase,</p>\n<p>getAccounts,</p>\n<p>还有，我们可以调用  <code>super</code>和动态索引(<code>valueOf_1_2_3</code>)</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>// 续上段代码</p>\n<p>toString() {</p>\n<p>return JSON.stringify((super.valueOf()))</p>\n<p>},</p>\n<p>getUrl() {return ‘http://‘ + this.url + ‘:’ + this.port},</p>\n<p>[ ‘valueOf<em>‘ + getAccounts().join(‘</em>‘) ]: getAccounts()</p>\n<p>};</p>\n<p>console.log(accountService)</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/6941baebjw1f61bokh01nj20ad0buta1.jpg\" alt=\"\"></p>\n<p>这是对老旧的对象表达式一个很大的改进！</p>\n<h3 id=\"6-ES6-中的箭头函数\"><a href=\"#6-ES6-中的箭头函数\" class=\"headerlink\" title=\"6. ES6 中的箭头函数\"></a>6. ES6 中的箭头函数</h3><p>这或许是我最想要的一个特性，我爱 CoffeeScript 就是因为他胖胖的箭头(<code>=&amp;&gt;</code>相对于<code>-&amp;&gt;</code>)，现在 ES6 中也有了。这些箭头最神奇的地方在于他会让你写正确的代码。比如，<code>this</code>在上下文和函数中的值应当是相同的，它不会变化，通常变化的原因都是因为你创建了闭包。</p>\n<p>使用箭头函数可以让我们不再用<code>that = this</code>或者<code>self = this</code>或者<code>_this = this</code>或者<code>.bind(this)</code>这样的代码，比如，这些代码在 ES5 中就特别丑。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>var _this = this</p>\n<p>$(‘.btn’).click(function(event){</p>\n<p>_this.sendData()</p>\n<p>})</p>\n<p>这是在 ES6 中去掉<code>_this = this</code>之后：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>$(‘.btn’).click((event) =&gt;{</p>\n<p>this.sendData()</p>\n<p>})</p>\n<p>可惜的是，ES6 委员会觉得再加上瘦箭头(<code>-&amp;&gt;</code>)的话就对我们太好了，所以他们留下了一个老旧的<code>function</code>。（<a href=\"https://www.udemy.com/coffeescript/?couponCode=a\" target=\"_blank\" rel=\"noopener\">瘦箭头在 CoffeeScript 中的作用</a>就像 ES5/6 中一样）</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>var logUpperCase = function() {</p>\n<p>var _this = this</p>\n<p>this.string = this.string.toUpperCase()</p>\n<p>return function () {</p>\n<p>return console.log(_this.string)</p>\n<p>}</p>\n<p>}</p>\n<p>logUpperCase.call({ string: ‘es6 rocks’ })()</p>\n<p>在 ES6 中我们无需<code>_this</code></p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>var logUpperCase = function() {</p>\n<p>this.string = this.string.toUpperCase()</p>\n<p>return () =&gt; console.log(this.string)</p>\n<p>}</p>\n<p>logUpperCase.call({ string: ‘es6 rocks’ })()</p>\n<p>注意，在 ES6 中你可以合理的把箭头函数和旧式  <code>function</code>函数混用。当箭头函数所在语句只有一行时，它就会变成一个表达式，它会直接返回这个语句的值。但是如果你有多行语句，你就要明确的使用<code>return</code>。</p>\n<p>这是 ES5 中利用<code>messages</code>数组创建一个数组的代码：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>var ids = [‘5632953c4e345e145fdf2df8’,’563295464e345e145fdf2df9’]</p>\n<p>var messages = ids.map(function (value) {</p>\n<p>return ‘ID is ‘ + value // 显式返回</p>\n<p>});</p>\n<p>在 ES6 中会变成这样：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>var ids = [‘5632953c4e345e145fdf2df8’,’563295464e345e145fdf2df9’]</p>\n<p>var messages = ids.map(value =&gt; <code>ID is ${value}</code>) // 隐式返回</p>\n<p>注意到我用了字符串模版吗，又一个从 CoffeeScript 中来的功能，我爱它们！</p>\n<p>在只有一个参数的函数签名中，括号是可有可无的，但是如果多于一个参数时就要加上。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>var ids = [‘5632953c4e345e145fdf2df8’,’563295464e345e145fdf2df9’]</p>\n<p>var messages = ids.map((value, index, list) =&gt; <code>ID of ${index} element is ${value}</code>) // 隐式返回</p>\n<h3 id=\"7-ES6-中的-Promise\"><a href=\"#7-ES6-中的-Promise\" class=\"headerlink\" title=\"7. ES6 中的 Promise\"></a>7. ES6 中的 Promise</h3><p>Promise 是一个有争议的话题。现在有很多 Promise 实现，语法也大致相同，比如<code>q</code>/ <code>bluebird</code>/ <code>deferred.js</code>/ <code>vow</code>/ <code>avow</code>/ <code>jquery deferred</code>等等。其他人说我们并不需要 Promise，异步，回调和<code>generator</code>之类的就很好。庆幸的是，现在在 ES6 中终于有一个标准的 Promise 实现。</p>\n<p>我们来看一个相当微不足道的延迟异步执行，用<code>setTimeout</code>实现</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>setTimeout(function(){</p>\n<p>console.log(‘Yay!’)</p>\n<p>}, 1000)</p>\n<p>我们可以用 ES6 中的 Promise 重写：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>var wait1000 =  new Promise(function(resolve, reject) {</p>\n<p>setTimeout(resolve, 1000)</p>\n<p>}).then(function() {</p>\n<p>console.log(‘Yay!’)</p>\n<p>})</p>\n<p>或者用 ES6 的箭头函数：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>var wait1000 =  new Promise((resolve, reject)=&gt; {</p>\n<p>setTimeout(resolve, 1000)</p>\n<p>}).then(()=&gt; {</p>\n<p>console.log(‘Yay!’)</p>\n<p>})</p>\n<p>到现在为止，我们只是单纯增加了代码的行数，还明显没有带来任何好处，你说的对。但是如果我们有更多复杂的逻辑内嵌在<code>setTimeout()</code>中的回调时好处就来了：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>setTimeout(function(){</p>\n<p>console.log(‘Yay!’)</p>\n<p>setTimeout(function(){</p>\n<p>console.log(‘Wheeyee!’)</p>\n<p>}, 1000)</p>\n<p>}, 1000)</p>\n<p>可以用 ES6 中的 Promise 重写：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>var wait1000 =  ()=&gt; new Promise((resolve, reject)=&gt; {setTimeout(resolve, 1000)})</p>\n<p>wait1000()</p>\n<p>.then(function() {</p>\n<p>console.log(‘Yay!’)</p>\n<p>return wait1000()</p>\n<p>})</p>\n<p>.then(function() {</p>\n<p>console.log(‘Wheeyee!’)</p>\n<p>});</p>\n<p>还是无法相信 Promise 比普通回调要好？我也不信。我想一旦知道了回调这个方法它就会在你脑中萦绕，额外的复杂的 Promise 也没有必要存在了。</p>\n<p>不论怎么说，ES6 中的 Promise 是为会欣赏的人准备的，Promise 有一个不错的<code>失败-捕捉</code>回调机制，看看这篇文章吧，里面有更多关于 Promise 的信息。<a href=\"https://www.udemy.com/coffeescript\" target=\"_blank\" rel=\"noopener\">ES6 Promise 介绍</a></p>\n<h3 id=\"8-块级作用域的let和const\"><a href=\"#8-块级作用域的let和const\" class=\"headerlink\" title=\"8. 块级作用域的let和const\"></a>8. 块级作用域的<code>let</code>和<code>const</code></h3><p>你可能早就听过对 ES6 中的<code>let</code>那些奇怪的传说，我记得我第一次到伦敦时为那些 TO LET 牌子感到非常困惑。但是 ES6 中的<code>let</code>和出租无关，这不算是语法糖，它很复杂。<code>let</code>是一个更新的<code>var</code>，可以让你把变量作用域限制在当前块里。我们用<code>{}</code>来定义块，但是在 ES5 中这些花括号起不到任何作用。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>11</p>\n<p>12</p>\n<p>13</p>\n<p>14</p>\n<p>15</p>\n<p>function calculateTotalAmount (vip) {</p>\n<p>var amount = 0</p>\n<p>if (vip) {</p>\n<p>var amount = 1</p>\n<p>}</p>\n<p>{ // 让块来的更疯狂</p>\n<p>var amount = 100</p>\n<p>{</p>\n<p>var amount = 1000</p>\n<p>}</p>\n<p>}</p>\n<p>return amount</p>\n<p>}</p>\n<p>console.log(calculateTotalAmount(true))</p>\n<p>运行结果将会是<code>1000</code>。天啊！这是多大的一个 Bug。在 ES6 中，我们用<code>let</code>来限制变量作用域为函数内。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>11</p>\n<p>12</p>\n<p>13</p>\n<p>14</p>\n<p>15</p>\n<p>function calculateTotalAmount (vip) {</p>\n<p>var amount = 0 // 或许应该用 let, 但你可以混用</p>\n<p>if (vip) {</p>\n<p>let amount = 1 // 第一个数量为 0</p>\n<p>}</p>\n<p>{ // 更多的块</p>\n<p>let amount = 100 // 第一个数量为 0</p>\n<p>{</p>\n<p>let amount = 1000 // 第一个数量为 0</p>\n<p>}</p>\n<p>}</p>\n<p>return amount</p>\n<p>}</p>\n<p>console.log(calculateTotalAmount(true))</p>\n<p>运行结果是<code>0</code>，因为在<code>if</code>块中也有<code>let</code>。如果什么都没有的话(<code>amount=1</code>)，那么结果将会是<code>1</code>。</p>\n<p>说到<code>const</code>，事情就简单多了。他仅仅产生是一个不可变的变量，并且他的作用域也像<code>let</code>一样只有块级。为了演示，这里有定义了一堆常量，并且由于作用域的原因，这些定义都是有效的。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>11</p>\n<p>12</p>\n<p>13</p>\n<p>14</p>\n<p>15</p>\n<p>function calculateTotalAmount (vip) {</p>\n<p>const amount = 0</p>\n<p>if (vip) {</p>\n<p>const amount = 1</p>\n<p>}</p>\n<p>{ // 更多的块</p>\n<p>const amount = 100</p>\n<p>{</p>\n<p>const amount = 1000</p>\n<p>}</p>\n<p>}</p>\n<p>return amount</p>\n<p>}</p>\n<p>console.log(calculateTotalAmount(true))</p>\n<p>依我愚见，<code>let</code>和<code>const</code>让这门语言变得更加复杂，没有这些的时候我们只有一条路可以走，但是现在可以要考虑更多的情景。;-(</p>\n<h3 id=\"9-ES6-中的类\"><a href=\"#9-ES6-中的类\" class=\"headerlink\" title=\"9. ES6 中的类\"></a>9. ES6 中的类</h3><p>如果你喜欢面向对象编程，那么你会特别喜欢这个特性。他让你编写和继承类时就跟在 Facebook 上发一个评论这么简单。</p>\n<p>在 ES5 中，因为没有<code>class</code>关键字（但它是毫无作用的保留字），类的创建和使用是让人十分痛苦的事情。更惨的是，很多伪类的实现像<a href=\"http://javascript.info/tutorial/pseudo-classical-pattern\" target=\"_blank\" rel=\"noopener\">pseude-classical</a>, <a href=\"http://www.crockford.com/javascript/inheritance.html\" target=\"_blank\" rel=\"noopener\">classical</a>, <a href=\"http://javascript.info/tutorial/factory-constructor-pattern\" target=\"_blank\" rel=\"noopener\">functional</a>让人越来越摸不着头脑，为 JavaScript 的信仰战争火上浇油。</p>\n<p>我不会给你展示在 ES5 中怎么去编写一个类（是啦是啦从对象可以衍生出来其他的类和对象），因为有太多方法去完成。我们直接看 ES6 的示例，告诉你 ES6 的类会用<code>prototype</code>来实现而不是<code>function</code>。现在有一个<code>baseModel</code>类，其中我们可以定义构造函数和<code>getName()</code>方法。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>11</p>\n<p>12</p>\n<p>class baseModel {</p>\n<p>constructor(options = {}, data = []) { // class constructor</p>\n<p>this.name = ‘Base’</p>\n<p>this.url = ‘<a href=\"http://azat.co/api&#39;\" target=\"_blank\" rel=\"noopener\">http://azat.co/api&#39;</a></p>\n<p>this.data = data</p>\n<p>this.options = options</p>\n<p>}</p>\n<p>getName() { // class method</p>\n<p>console.log(<code>Class name: ${this.name}</code>)</p>\n<p>}</p>\n<p>}</p>\n<p>注意到我给<code>options</code>和<code>data</code>用了默认参数，而且方法名再也不用加上<code>function</code>或者<code>:</code>了。还有一个很大的区别，你不能像构造函数里面一样向<code>this.Name</code>指派值。怎么说呢，和<code>函数</code>有相同缩进的代码里，你不能向<code>name</code>赋值。如果有这个需要的话，在构造函数里面完成。</p>\n<p>使用<code>NAME extends PARENT_NAME</code>语法，<code>AccountModel</code>从<code>baseModel</code>继承而来。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>class AccountModel extends baseModel {</p>\n<p>constructor(options, data) {</p>\n<p>调用父类构造函数时，只需带上参数轻松的调用<code>super()</code>方法。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>super({private: true}, [‘32113123123’, ‘524214691’]) //call the parent method with super</p>\n<p>this.name = ‘Account Model’</p>\n<p>this.url +=’/accounts/‘</p>\n<p>}</p>\n<p>想要高级一点的话，你可以像这样弄一个<code>getter</code>方法，这样<code>accountsData</code>就会变成一个属性。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>get accountsData() { // 返回计算后的数据</p>\n<p>// … make XHR</p>\n<p>return this.data</p>\n<p>}</p>\n<p>}</p>\n<p>现在你要怎么用这个魔咒，很简单，就跟让三岁小孩相信圣诞老人存在一样。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>let accounts = new AccountModel(5)</p>\n<p>accounts.getName()</p>\n<p>console.log(‘Data is %s’, accounts.accountsData)</p>\n<p>如果好奇输出结果的话：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>Class name: Account Model</p>\n<p>Data is 32113123123,524214691</p>\n<h3 id=\"10-ES6-中的模块化\"><a href=\"#10-ES6-中的模块化\" class=\"headerlink\" title=\"10. ES6 中的模块化\"></a>10. ES6 中的模块化</h3><p>你可能知道，ES6 之前 JavaScript 并没有对模块化有过原生的支持，人们想出来<code>AMD</code>，<code>RequireJS</code>，<code>CommenJS</code>等等，现在终于有<code>import</code>和<code>export</code>运算符来实现了。</p>\n<p>ES5 中你会用<code>script</code>标签和<code>IIFE(立即执行函数)</code>，或者是其他的像<code>AMD</code>之类的库，但是 ES6 中你可以用<code>export</code>来暴露你的类。我是喜欢 Node.js 的人，所以我用和 Node.js 语法一样的<code>CommonJS</code>，然后用<a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">Browserfy</a>来浏览器化。现在我们有一个<code>port</code>变量和<code>getAccounts</code>方法，在 ES5 中：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>module.exports = {</p>\n<p>port: 3000,</p>\n<p>getAccounts: function() {</p>\n<p>…</p>\n<p>}</p>\n<p>}</p>\n<p>在 ES5 的<code>main.js</code>中，用<code>require(&#39;模块&#39;)</code>来导入：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>var service = require(‘module.js’)</p>\n<p>console.log(service.port) // 3000</p>\n<p>但是在 ES6 中，我们用<code>export</code>和<code>import</code>。比如这是 ES6 中的<code>module.js</code>文件：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>export var port = 3000</p>\n<p>export function getAccounts(url) {</p>\n<p>…</p>\n<p>}</p>\n<p>在需要引入的<code>main.js</code>文件中，可以用<code>import {名称} from &#39;模块&#39;</code>语法：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>import {port, getAccounts} from ‘module’</p>\n<p>console.log(port) // 3000</p>\n<p>或者就直接在<code>main.js</code>中引入所有的变量：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>import * as service from ‘module’</p>\n<p>console.log(service.port) // 3000</p>\n<p>个人来说，我觉得这样的模块化有些搞不懂。确实，这样会更传神一些 。但是 Node.js 中的模块不会马上就改过来，浏览器和服务器的代码最好是用同样的标准，所以目前我还是会坚持<code>CommonJS/Node.js</code>的方式。</p>\n<p>目前来说浏览器对 ES6 的支持还遥遥无期（本文写作时），所以你需要一些像<a href=\"http://jspm.io/\" target=\"_blank\" rel=\"noopener\">jspm</a>这样的工具来用 ES6 的模块。</p>\n<p>想要了解更多 ES6 中的模块化和例子的话，来看<a href=\"http://exploringjs.com/es6/ch_modules.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，不管怎么说，写现代化的 JavaScript 吧！</p>\n<h3 id=\"怎么样可以在今天就用上-ES6（Babel）\"><a href=\"#怎么样可以在今天就用上-ES6（Babel）\" class=\"headerlink\" title=\"怎么样可以在今天就用上 ES6（Babel）\"></a>怎么样可以在今天就用上 ES6（Babel）</h3><p>ES6 标准已经敲定，但还未被所有浏览器支持（<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla\" target=\"_blank\" rel=\"noopener\">Firefox 的 ES6 功能一览</a>），如果想马上就用上 ES6，需要一个像<a href=\"https://babeljs.io/\" target=\"_blank\" rel=\"noopener\">Babel</a>这样的编译器。你可以把他当独立工具用，也可以将他集成到构建系统里，Babel 对<code>Gulp</code>，<code>Grunt</code>和<code>Webpack</code>都有对应的<a href=\"http://babeljs.io/docs/setup\" target=\"_blank\" rel=\"noopener\">插件</a>。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/6941baebjw1f61bokq3xbj20yb0pdq6a.jpg\" alt=\"\"></p>\n<p>安装 Gulp 插件示例：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>$ npm install –save-dev gulp-babel</p>\n<p>在<code>gulpfile.js</code>中，定义这么一个任务，将<code>src</code>目录下的<code>app.js</code>文件编译到<code>build</code>目录下：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>var gulp = require(‘gulp’),</p>\n<p>babel = require(‘gulp-babel’)</p>\n<p>gulp.task(‘build’, function () {</p>\n<p>return gulp.src(‘src/app.js’)</p>\n<p>.pipe(babel())</p>\n<p>.pipe(gulp.dest(‘build’))</p>\n<p>})</p>\n<h3 id=\"Node-js-和-ES6\"><a href=\"#Node-js-和-ES6\" class=\"headerlink\" title=\"Node.js 和 ES6\"></a>Node.js 和 ES6</h3><p>对于 Node.js，你可以用构建工具或者直接用独立模块<code>babel-core</code>：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>$ npm install –save-dev babel-core</p>\n<p>然后在 Node.js 中调用这个函数：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>require(‘babel-core’).transform(es5Code, options)</p>\n<h3 id=\"ES6-的一些总结\"><a href=\"#ES6-的一些总结\" class=\"headerlink\" title=\"ES6 的一些总结\"></a>ES6 的一些总结</h3><p>ES6 中还有很多你可能都用不上（至少现在用不上）的可圈可点的特性，以下无特定顺序：</p>\n<ol>\n<li><code>Math</code> / <code>Number</code> / <code>String</code> / <code>Array</code> / <code>Object</code>中新的方法</li>\n<li>二进制和八进制数据类型</li>\n<li>自动展开多余参数</li>\n<li><code>For of</code>循环（又见面了 CoffeeScript）</li>\n<li><code>Symbols</code></li>\n<li>尾部调用优化</li>\n<li><code>generator</code></li>\n<li>更新的数据结构（如<code>Map</code>和<code>Set</code>）</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>这篇文章会给你简单介绍一下 ES6。如果你还不知道什么是 ES6 的话，它是 JavaScript 一个新的实现，如果你是一个忙碌的 JavaScript 开发者（但谁不是呢），那么继续读下去吧，看看当今最热门的语言——JavaScript 的新一代实现中，最棒的十个特性。</p>\n<p>这是为忙碌的开发者准备的 ES6 中最棒的十个特性（无特定顺序）：</p>\n<ol>\n<li>默认参数</li>\n<li>模版表达式</li>\n<li>多行字符串</li>\n<li>拆包表达式</li>\n<li>改进的对象表达式</li>\n<li>箭头函数  <code>=&amp;&gt;</code></li>\n<li>Promise</li>\n<li>块级作用域的<code>let</code>和<code>const</code></li>\n<li>类</li>\n<li>模块化</li>\n</ol>\n<p>注意：这个列表十分主观并且带有偏见，其他未上榜的特性并不是因为没有作用，我这么做只是单纯的希望将这份列表中的项目保持在十个。</p>\n<p>首先，一个简单的 JavaScript 时间线，不了解历史的人也无法创造历史。</p>\n<ol>\n<li>1995 年：JavaScript 以 LiveScript 之名诞生</li>\n<li>1997 年：ECMAScript 标准确立</li>\n<li>1999 年：ES3 发布，IE5 非常生气</li>\n<li>2000 年-2005 年：<code>XMLHttpRequest</code>，熟知为<code>AJAX</code>，在如 Outlook Web Access(2002)、Oddpost(2002)、Gmail(2004)、Google Maps(2005)中得到了广泛的应用</li>\n<li>2009 年：ES5 发布（这是我们目前用的最多的版本），带来了<code>forEach</code> / <code>Object.keys</code>/ <code>Object.create</code>（特地为 Douglas Crockford 所造，JSON 标准创建者） ，还有 JSON 标准。</li>\n</ol>\n<p>历史课上完了，我们回来讲编程。</p>\n<h3 id=\"1-ES6-中的默认参数\"><a href=\"#1-ES6-中的默认参数\" class=\"headerlink\" title=\"1. ES6 中的默认参数\"></a>1. ES6 中的默认参数</h3><p>还记得我们以前要这样子来定义默认参数：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>var link = function (height, color, url) {</p>\n<p>var height = height || 50</p>\n<p>var color = color || ‘red’</p>\n<p>var url = url || ‘<a href=\"http://azat.co&#39;\" target=\"_blank\" rel=\"noopener\">http://azat.co&#39;</a></p>\n<p>…</p>\n<p>}</p>\n<p>这样做一直都没什么问题，直到参数的值为<code>0</code>，因为<code>0</code>在 JavaScript 中算是<code>false</code>值，它会直接变成后面硬编码的值而不是<code>0</code>本身。当然了，谁要用<code>0</code>来传值啊（讽刺脸）？所以我们也忽略了这个瑕疵，沿用了这个逻辑，否则的话只能…..没有否则！在 ES6 中，我们可以把这些默认值直接放在函数签名中。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>var link = function(height = 50, color = ‘red’, url = ‘<a href=\"http://azat.co&#39;\" target=\"_blank\" rel=\"noopener\">http://azat.co&#39;</a>) {</p>\n<p>…</p>\n<p>}</p>\n<p>对了，这个语法和 Ruby 很像！</p>\n<h3 id=\"2-ES6-中的模版表达式\"><a href=\"#2-ES6-中的模版表达式\" class=\"headerlink\" title=\"2. ES6 中的模版表达式\"></a>2. ES6 中的模版表达式</h3><p>模版表达式在其他语言中一般是为了在模版字符串中输出变量，所以在 ES5 中，我们非得把字符串破开变成这样：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>var name = ‘Your name is ‘ + first + ‘ ‘ + last + ‘.’</p>\n<p>var url = ‘<a href=\"http://localhost:3000/api/messages/&#39;\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/api/messages/&#39;</a> + id</p>\n<p>幸运的是在 ES6 中我们有了新语法，在反引号包裹的字符串中，使用${NAME}语法来表示模板字符:</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>var name = <code>Your name is ${first} ${last}</code></p>\n<p>var url = <code>http://localhost:3000/api/messages/${id}</code></p>\n<h3 id=\"3-ES6-中的多行字符串\"><a href=\"#3-ES6-中的多行字符串\" class=\"headerlink\" title=\"3. ES6 中的多行字符串\"></a>3. ES6 中的多行字符串</h3><p>另一个好吃的语法糖就是多行字符串，以前我们的实现是像这样的：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>var roadPoem = ‘Then took the other, as just as fair,nt’</p>\n<ul>\n<li><p>‘And having perhaps the better claimnt’</p>\n</li>\n<li><p>‘Because it was grassy and wanted wear,nt’</p>\n</li>\n<li><p>‘Though as for that the passing therent’</p>\n</li>\n<li><p>‘Had worn them really about the same,nt’</p>\n</li>\n</ul>\n<p>var fourAgreements = ‘You have the right to be you.n</p>\n<p>You can only be you when you do your best.’</p>\n<p>但是在 ES6 中，只要充分利用反引号。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>var roadPoem = `Then took the other, as just as fair,</p>\n<p>And having perhaps the better claim</p>\n<p>Because it was grassy and wanted wear,</p>\n<p>Though as for that the passing there</p>\n<p>Had worn them really about the same,`</p>\n<p>var fourAgreements = `You have the right to be you.</p>\n<p>You can only be you when you do your best.`</p>\n<h3 id=\"4-ES6-中的拆包表达式\"><a href=\"#4-ES6-中的拆包表达式\" class=\"headerlink\" title=\"4. ES6 中的拆包表达式\"></a>4. ES6 中的拆包表达式</h3><p>拆包可能是一个比较难理解的概念，因为这里面真的是有魔法发生。假如说你有一个简单的赋值表达式，把对象中的<code>house</code>的<code>mouse</code>赋值为<code>house</code>和<code>mouse</code>的变量。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>var data = $(‘body’).data(), // 假设 data 中有 mouse 和 house 的值</p>\n<p>house = data.house,</p>\n<p>mouse = data.mouse</p>\n<p>另一个拆包的实例（Node.js)：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>var jsonMiddleware = require(‘body-parser’).json</p>\n<p>var body = req.body, // body 中有用户名和密码值</p>\n<p>username = body.username,</p>\n<p>password = body.password</p>\n<p>但是在 ES6 中我们可以用以下语句替换：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>var { house, mouse} = $(‘body’).data() // 我们会拿到 house 和 mouse 的值的</p>\n<p>var {jsonMiddleware} = require(‘body-parser’)</p>\n<p>var {username, password} = req.body</p>\n<p>甚至在数组中也能用，简直疯狂！</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>var [col1, col2]  = $(‘.column’),</p>\n<p>[line1, line2, line3, , line5] = file.split(‘n’)</p>\n<p>习惯拆包语法可能需要一些时间，但是这绝对是糖衣炮弹。</p>\n<h3 id=\"5-ES6-中改进的对象表达式\"><a href=\"#5-ES6-中改进的对象表达式\" class=\"headerlink\" title=\"5. ES6 中改进的对象表达式\"></a>5. ES6 中改进的对象表达式</h3><p>你能用对象表达式所做的是超乎想象的！类定义的方法从 ES5 中一个美化版的 JSON，进化到 ES6 中更像类的构造。</p>\n<p>这是一个 ES5 中典型的对象表达式，定义了一些方法和属性。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>11</p>\n<p>12</p>\n<p>13</p>\n<p>var serviceBase = {port: 3000, url: ‘azat.co’},</p>\n<p>getAccounts = function(){return [1,2,3]}</p>\n<p>var accountServiceES5 = {</p>\n<p>port: serviceBase.port,</p>\n<p>url: serviceBase.url,</p>\n<p>getAccounts: getAccounts,</p>\n<p>toString: function() {</p>\n<p>return JSON.stringify(this.valueOf())</p>\n<p>},</p>\n<p>getUrl: function() {return ‘http://‘ + this.url + ‘:’ + this.port},</p>\n<p>valueOf_1_2_3: getAccounts()</p>\n<p>}</p>\n<p>如果你想做的好看一点，我们可以用<code>Object.create</code>方法来让  <code>serviceBase</code>成为  <code>accountServiceES5</code>的  <code>prototype</code>从而实现继承。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>var accountServiceES5ObjectCreate = Object.create(serviceBase)</p>\n<p>var accountServiceES5ObjectCreate = {</p>\n<p>getAccounts: getAccounts,</p>\n<p>toString: function() {</p>\n<p>return JSON.stringify(this.valueOf())</p>\n<p>},</p>\n<p>getUrl: function() {return ‘http://‘ + this.url + ‘:’ + this.port},</p>\n<p>valueOf_1_2_3: getAccounts()</p>\n<p>}</p>\n<p>我知道  <code>accountServiceES5ObjectCreate</code>和  <code>accountServiceES5</code>是<strong>不完全相同</strong>的。因为一个对象  <code>accountServiceES5</code>会有如下所示的  <code>__proto__</code>属性：<br><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/6941baebjw1f61bok7iv5j20cw07v0u4.jpg\" alt=\"\"></p>\n<p>但对于这个示例，我们就把这两者考虑为相同的。所以在 ES6 的对象表达式中，我们把<code>getAccounts: getAccounts</code>简化为<code>getAccounts,</code>，并且我们还可以用<code>__proto__</code>直接设置<code>prototype</code>，这样听起来合理的多。（不过并不是用<code>proto</code>）</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>var serviceBase = {port: 3000, url: ‘azat.co’},</p>\n<p>getAccounts = function(){return [1,2,3]}</p>\n<p>var accountService = {</p>\n<p>__proto__: serviceBase,</p>\n<p>getAccounts,</p>\n<p>还有，我们可以调用  <code>super</code>和动态索引(<code>valueOf_1_2_3</code>)</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>// 续上段代码</p>\n<p>toString() {</p>\n<p>return JSON.stringify((super.valueOf()))</p>\n<p>},</p>\n<p>getUrl() {return ‘http://‘ + this.url + ‘:’ + this.port},</p>\n<p>[ ‘valueOf<em>‘ + getAccounts().join(‘</em>‘) ]: getAccounts()</p>\n<p>};</p>\n<p>console.log(accountService)</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/6941baebjw1f61bokh01nj20ad0buta1.jpg\" alt=\"\"></p>\n<p>这是对老旧的对象表达式一个很大的改进！</p>\n<h3 id=\"6-ES6-中的箭头函数\"><a href=\"#6-ES6-中的箭头函数\" class=\"headerlink\" title=\"6. ES6 中的箭头函数\"></a>6. ES6 中的箭头函数</h3><p>这或许是我最想要的一个特性，我爱 CoffeeScript 就是因为他胖胖的箭头(<code>=&amp;&gt;</code>相对于<code>-&amp;&gt;</code>)，现在 ES6 中也有了。这些箭头最神奇的地方在于他会让你写正确的代码。比如，<code>this</code>在上下文和函数中的值应当是相同的，它不会变化，通常变化的原因都是因为你创建了闭包。</p>\n<p>使用箭头函数可以让我们不再用<code>that = this</code>或者<code>self = this</code>或者<code>_this = this</code>或者<code>.bind(this)</code>这样的代码，比如，这些代码在 ES5 中就特别丑。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>var _this = this</p>\n<p>$(‘.btn’).click(function(event){</p>\n<p>_this.sendData()</p>\n<p>})</p>\n<p>这是在 ES6 中去掉<code>_this = this</code>之后：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>$(‘.btn’).click((event) =&gt;{</p>\n<p>this.sendData()</p>\n<p>})</p>\n<p>可惜的是，ES6 委员会觉得再加上瘦箭头(<code>-&amp;&gt;</code>)的话就对我们太好了，所以他们留下了一个老旧的<code>function</code>。（<a href=\"https://www.udemy.com/coffeescript/?couponCode=a\" target=\"_blank\" rel=\"noopener\">瘦箭头在 CoffeeScript 中的作用</a>就像 ES5/6 中一样）</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>var logUpperCase = function() {</p>\n<p>var _this = this</p>\n<p>this.string = this.string.toUpperCase()</p>\n<p>return function () {</p>\n<p>return console.log(_this.string)</p>\n<p>}</p>\n<p>}</p>\n<p>logUpperCase.call({ string: ‘es6 rocks’ })()</p>\n<p>在 ES6 中我们无需<code>_this</code></p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>var logUpperCase = function() {</p>\n<p>this.string = this.string.toUpperCase()</p>\n<p>return () =&gt; console.log(this.string)</p>\n<p>}</p>\n<p>logUpperCase.call({ string: ‘es6 rocks’ })()</p>\n<p>注意，在 ES6 中你可以合理的把箭头函数和旧式  <code>function</code>函数混用。当箭头函数所在语句只有一行时，它就会变成一个表达式，它会直接返回这个语句的值。但是如果你有多行语句，你就要明确的使用<code>return</code>。</p>\n<p>这是 ES5 中利用<code>messages</code>数组创建一个数组的代码：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>var ids = [‘5632953c4e345e145fdf2df8’,’563295464e345e145fdf2df9’]</p>\n<p>var messages = ids.map(function (value) {</p>\n<p>return ‘ID is ‘ + value // 显式返回</p>\n<p>});</p>\n<p>在 ES6 中会变成这样：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>var ids = [‘5632953c4e345e145fdf2df8’,’563295464e345e145fdf2df9’]</p>\n<p>var messages = ids.map(value =&gt; <code>ID is ${value}</code>) // 隐式返回</p>\n<p>注意到我用了字符串模版吗，又一个从 CoffeeScript 中来的功能，我爱它们！</p>\n<p>在只有一个参数的函数签名中，括号是可有可无的，但是如果多于一个参数时就要加上。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>var ids = [‘5632953c4e345e145fdf2df8’,’563295464e345e145fdf2df9’]</p>\n<p>var messages = ids.map((value, index, list) =&gt; <code>ID of ${index} element is ${value}</code>) // 隐式返回</p>\n<h3 id=\"7-ES6-中的-Promise\"><a href=\"#7-ES6-中的-Promise\" class=\"headerlink\" title=\"7. ES6 中的 Promise\"></a>7. ES6 中的 Promise</h3><p>Promise 是一个有争议的话题。现在有很多 Promise 实现，语法也大致相同，比如<code>q</code>/ <code>bluebird</code>/ <code>deferred.js</code>/ <code>vow</code>/ <code>avow</code>/ <code>jquery deferred</code>等等。其他人说我们并不需要 Promise，异步，回调和<code>generator</code>之类的就很好。庆幸的是，现在在 ES6 中终于有一个标准的 Promise 实现。</p>\n<p>我们来看一个相当微不足道的延迟异步执行，用<code>setTimeout</code>实现</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>setTimeout(function(){</p>\n<p>console.log(‘Yay!’)</p>\n<p>}, 1000)</p>\n<p>我们可以用 ES6 中的 Promise 重写：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>var wait1000 =  new Promise(function(resolve, reject) {</p>\n<p>setTimeout(resolve, 1000)</p>\n<p>}).then(function() {</p>\n<p>console.log(‘Yay!’)</p>\n<p>})</p>\n<p>或者用 ES6 的箭头函数：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>var wait1000 =  new Promise((resolve, reject)=&gt; {</p>\n<p>setTimeout(resolve, 1000)</p>\n<p>}).then(()=&gt; {</p>\n<p>console.log(‘Yay!’)</p>\n<p>})</p>\n<p>到现在为止，我们只是单纯增加了代码的行数，还明显没有带来任何好处，你说的对。但是如果我们有更多复杂的逻辑内嵌在<code>setTimeout()</code>中的回调时好处就来了：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>setTimeout(function(){</p>\n<p>console.log(‘Yay!’)</p>\n<p>setTimeout(function(){</p>\n<p>console.log(‘Wheeyee!’)</p>\n<p>}, 1000)</p>\n<p>}, 1000)</p>\n<p>可以用 ES6 中的 Promise 重写：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>var wait1000 =  ()=&gt; new Promise((resolve, reject)=&gt; {setTimeout(resolve, 1000)})</p>\n<p>wait1000()</p>\n<p>.then(function() {</p>\n<p>console.log(‘Yay!’)</p>\n<p>return wait1000()</p>\n<p>})</p>\n<p>.then(function() {</p>\n<p>console.log(‘Wheeyee!’)</p>\n<p>});</p>\n<p>还是无法相信 Promise 比普通回调要好？我也不信。我想一旦知道了回调这个方法它就会在你脑中萦绕，额外的复杂的 Promise 也没有必要存在了。</p>\n<p>不论怎么说，ES6 中的 Promise 是为会欣赏的人准备的，Promise 有一个不错的<code>失败-捕捉</code>回调机制，看看这篇文章吧，里面有更多关于 Promise 的信息。<a href=\"https://www.udemy.com/coffeescript\" target=\"_blank\" rel=\"noopener\">ES6 Promise 介绍</a></p>\n<h3 id=\"8-块级作用域的let和const\"><a href=\"#8-块级作用域的let和const\" class=\"headerlink\" title=\"8. 块级作用域的let和const\"></a>8. 块级作用域的<code>let</code>和<code>const</code></h3><p>你可能早就听过对 ES6 中的<code>let</code>那些奇怪的传说，我记得我第一次到伦敦时为那些 TO LET 牌子感到非常困惑。但是 ES6 中的<code>let</code>和出租无关，这不算是语法糖，它很复杂。<code>let</code>是一个更新的<code>var</code>，可以让你把变量作用域限制在当前块里。我们用<code>{}</code>来定义块，但是在 ES5 中这些花括号起不到任何作用。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>11</p>\n<p>12</p>\n<p>13</p>\n<p>14</p>\n<p>15</p>\n<p>function calculateTotalAmount (vip) {</p>\n<p>var amount = 0</p>\n<p>if (vip) {</p>\n<p>var amount = 1</p>\n<p>}</p>\n<p>{ // 让块来的更疯狂</p>\n<p>var amount = 100</p>\n<p>{</p>\n<p>var amount = 1000</p>\n<p>}</p>\n<p>}</p>\n<p>return amount</p>\n<p>}</p>\n<p>console.log(calculateTotalAmount(true))</p>\n<p>运行结果将会是<code>1000</code>。天啊！这是多大的一个 Bug。在 ES6 中，我们用<code>let</code>来限制变量作用域为函数内。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>11</p>\n<p>12</p>\n<p>13</p>\n<p>14</p>\n<p>15</p>\n<p>function calculateTotalAmount (vip) {</p>\n<p>var amount = 0 // 或许应该用 let, 但你可以混用</p>\n<p>if (vip) {</p>\n<p>let amount = 1 // 第一个数量为 0</p>\n<p>}</p>\n<p>{ // 更多的块</p>\n<p>let amount = 100 // 第一个数量为 0</p>\n<p>{</p>\n<p>let amount = 1000 // 第一个数量为 0</p>\n<p>}</p>\n<p>}</p>\n<p>return amount</p>\n<p>}</p>\n<p>console.log(calculateTotalAmount(true))</p>\n<p>运行结果是<code>0</code>，因为在<code>if</code>块中也有<code>let</code>。如果什么都没有的话(<code>amount=1</code>)，那么结果将会是<code>1</code>。</p>\n<p>说到<code>const</code>，事情就简单多了。他仅仅产生是一个不可变的变量，并且他的作用域也像<code>let</code>一样只有块级。为了演示，这里有定义了一堆常量，并且由于作用域的原因，这些定义都是有效的。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>11</p>\n<p>12</p>\n<p>13</p>\n<p>14</p>\n<p>15</p>\n<p>function calculateTotalAmount (vip) {</p>\n<p>const amount = 0</p>\n<p>if (vip) {</p>\n<p>const amount = 1</p>\n<p>}</p>\n<p>{ // 更多的块</p>\n<p>const amount = 100</p>\n<p>{</p>\n<p>const amount = 1000</p>\n<p>}</p>\n<p>}</p>\n<p>return amount</p>\n<p>}</p>\n<p>console.log(calculateTotalAmount(true))</p>\n<p>依我愚见，<code>let</code>和<code>const</code>让这门语言变得更加复杂，没有这些的时候我们只有一条路可以走，但是现在可以要考虑更多的情景。;-(</p>\n<h3 id=\"9-ES6-中的类\"><a href=\"#9-ES6-中的类\" class=\"headerlink\" title=\"9. ES6 中的类\"></a>9. ES6 中的类</h3><p>如果你喜欢面向对象编程，那么你会特别喜欢这个特性。他让你编写和继承类时就跟在 Facebook 上发一个评论这么简单。</p>\n<p>在 ES5 中，因为没有<code>class</code>关键字（但它是毫无作用的保留字），类的创建和使用是让人十分痛苦的事情。更惨的是，很多伪类的实现像<a href=\"http://javascript.info/tutorial/pseudo-classical-pattern\" target=\"_blank\" rel=\"noopener\">pseude-classical</a>, <a href=\"http://www.crockford.com/javascript/inheritance.html\" target=\"_blank\" rel=\"noopener\">classical</a>, <a href=\"http://javascript.info/tutorial/factory-constructor-pattern\" target=\"_blank\" rel=\"noopener\">functional</a>让人越来越摸不着头脑，为 JavaScript 的信仰战争火上浇油。</p>\n<p>我不会给你展示在 ES5 中怎么去编写一个类（是啦是啦从对象可以衍生出来其他的类和对象），因为有太多方法去完成。我们直接看 ES6 的示例，告诉你 ES6 的类会用<code>prototype</code>来实现而不是<code>function</code>。现在有一个<code>baseModel</code>类，其中我们可以定义构造函数和<code>getName()</code>方法。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>11</p>\n<p>12</p>\n<p>class baseModel {</p>\n<p>constructor(options = {}, data = []) { // class constructor</p>\n<p>this.name = ‘Base’</p>\n<p>this.url = ‘<a href=\"http://azat.co/api&#39;\" target=\"_blank\" rel=\"noopener\">http://azat.co/api&#39;</a></p>\n<p>this.data = data</p>\n<p>this.options = options</p>\n<p>}</p>\n<p>getName() { // class method</p>\n<p>console.log(<code>Class name: ${this.name}</code>)</p>\n<p>}</p>\n<p>}</p>\n<p>注意到我给<code>options</code>和<code>data</code>用了默认参数，而且方法名再也不用加上<code>function</code>或者<code>:</code>了。还有一个很大的区别，你不能像构造函数里面一样向<code>this.Name</code>指派值。怎么说呢，和<code>函数</code>有相同缩进的代码里，你不能向<code>name</code>赋值。如果有这个需要的话，在构造函数里面完成。</p>\n<p>使用<code>NAME extends PARENT_NAME</code>语法，<code>AccountModel</code>从<code>baseModel</code>继承而来。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>class AccountModel extends baseModel {</p>\n<p>constructor(options, data) {</p>\n<p>调用父类构造函数时，只需带上参数轻松的调用<code>super()</code>方法。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>super({private: true}, [‘32113123123’, ‘524214691’]) //call the parent method with super</p>\n<p>this.name = ‘Account Model’</p>\n<p>this.url +=’/accounts/‘</p>\n<p>}</p>\n<p>想要高级一点的话，你可以像这样弄一个<code>getter</code>方法，这样<code>accountsData</code>就会变成一个属性。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>get accountsData() { // 返回计算后的数据</p>\n<p>// … make XHR</p>\n<p>return this.data</p>\n<p>}</p>\n<p>}</p>\n<p>现在你要怎么用这个魔咒，很简单，就跟让三岁小孩相信圣诞老人存在一样。</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>let accounts = new AccountModel(5)</p>\n<p>accounts.getName()</p>\n<p>console.log(‘Data is %s’, accounts.accountsData)</p>\n<p>如果好奇输出结果的话：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>Class name: Account Model</p>\n<p>Data is 32113123123,524214691</p>\n<h3 id=\"10-ES6-中的模块化\"><a href=\"#10-ES6-中的模块化\" class=\"headerlink\" title=\"10. ES6 中的模块化\"></a>10. ES6 中的模块化</h3><p>你可能知道，ES6 之前 JavaScript 并没有对模块化有过原生的支持，人们想出来<code>AMD</code>，<code>RequireJS</code>，<code>CommenJS</code>等等，现在终于有<code>import</code>和<code>export</code>运算符来实现了。</p>\n<p>ES5 中你会用<code>script</code>标签和<code>IIFE(立即执行函数)</code>，或者是其他的像<code>AMD</code>之类的库，但是 ES6 中你可以用<code>export</code>来暴露你的类。我是喜欢 Node.js 的人，所以我用和 Node.js 语法一样的<code>CommonJS</code>，然后用<a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">Browserfy</a>来浏览器化。现在我们有一个<code>port</code>变量和<code>getAccounts</code>方法，在 ES5 中：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>module.exports = {</p>\n<p>port: 3000,</p>\n<p>getAccounts: function() {</p>\n<p>…</p>\n<p>}</p>\n<p>}</p>\n<p>在 ES5 的<code>main.js</code>中，用<code>require(&#39;模块&#39;)</code>来导入：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>var service = require(‘module.js’)</p>\n<p>console.log(service.port) // 3000</p>\n<p>但是在 ES6 中，我们用<code>export</code>和<code>import</code>。比如这是 ES6 中的<code>module.js</code>文件：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>export var port = 3000</p>\n<p>export function getAccounts(url) {</p>\n<p>…</p>\n<p>}</p>\n<p>在需要引入的<code>main.js</code>文件中，可以用<code>import {名称} from &#39;模块&#39;</code>语法：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>import {port, getAccounts} from ‘module’</p>\n<p>console.log(port) // 3000</p>\n<p>或者就直接在<code>main.js</code>中引入所有的变量：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>import * as service from ‘module’</p>\n<p>console.log(service.port) // 3000</p>\n<p>个人来说，我觉得这样的模块化有些搞不懂。确实，这样会更传神一些 。但是 Node.js 中的模块不会马上就改过来，浏览器和服务器的代码最好是用同样的标准，所以目前我还是会坚持<code>CommonJS/Node.js</code>的方式。</p>\n<p>目前来说浏览器对 ES6 的支持还遥遥无期（本文写作时），所以你需要一些像<a href=\"http://jspm.io/\" target=\"_blank\" rel=\"noopener\">jspm</a>这样的工具来用 ES6 的模块。</p>\n<p>想要了解更多 ES6 中的模块化和例子的话，来看<a href=\"http://exploringjs.com/es6/ch_modules.html\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，不管怎么说，写现代化的 JavaScript 吧！</p>\n<h3 id=\"怎么样可以在今天就用上-ES6（Babel）\"><a href=\"#怎么样可以在今天就用上-ES6（Babel）\" class=\"headerlink\" title=\"怎么样可以在今天就用上 ES6（Babel）\"></a>怎么样可以在今天就用上 ES6（Babel）</h3><p>ES6 标准已经敲定，但还未被所有浏览器支持（<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla\" target=\"_blank\" rel=\"noopener\">Firefox 的 ES6 功能一览</a>），如果想马上就用上 ES6，需要一个像<a href=\"https://babeljs.io/\" target=\"_blank\" rel=\"noopener\">Babel</a>这样的编译器。你可以把他当独立工具用，也可以将他集成到构建系统里，Babel 对<code>Gulp</code>，<code>Grunt</code>和<code>Webpack</code>都有对应的<a href=\"http://babeljs.io/docs/setup\" target=\"_blank\" rel=\"noopener\">插件</a>。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/6941baebjw1f61bokq3xbj20yb0pdq6a.jpg\" alt=\"\"></p>\n<p>安装 Gulp 插件示例：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>$ npm install –save-dev gulp-babel</p>\n<p>在<code>gulpfile.js</code>中，定义这么一个任务，将<code>src</code>目录下的<code>app.js</code>文件编译到<code>build</code>目录下：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>var gulp = require(‘gulp’),</p>\n<p>babel = require(‘gulp-babel’)</p>\n<p>gulp.task(‘build’, function () {</p>\n<p>return gulp.src(‘src/app.js’)</p>\n<p>.pipe(babel())</p>\n<p>.pipe(gulp.dest(‘build’))</p>\n<p>})</p>\n<h3 id=\"Node-js-和-ES6\"><a href=\"#Node-js-和-ES6\" class=\"headerlink\" title=\"Node.js 和 ES6\"></a>Node.js 和 ES6</h3><p>对于 Node.js，你可以用构建工具或者直接用独立模块<code>babel-core</code>：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>$ npm install –save-dev babel-core</p>\n<p>然后在 Node.js 中调用这个函数：</p>\n<p>JavaScript</p>\n<p>1</p>\n<p>require(‘babel-core’).transform(es5Code, options)</p>\n<h3 id=\"ES6-的一些总结\"><a href=\"#ES6-的一些总结\" class=\"headerlink\" title=\"ES6 的一些总结\"></a>ES6 的一些总结</h3><p>ES6 中还有很多你可能都用不上（至少现在用不上）的可圈可点的特性，以下无特定顺序：</p>\n<ol>\n<li><code>Math</code> / <code>Number</code> / <code>String</code> / <code>Array</code> / <code>Object</code>中新的方法</li>\n<li>二进制和八进制数据类型</li>\n<li>自动展开多余参数</li>\n<li><code>For of</code>循环（又见面了 CoffeeScript）</li>\n<li><code>Symbols</code></li>\n<li>尾部调用优化</li>\n<li><code>generator</code></li>\n<li>更新的数据结构（如<code>Map</code>和<code>Set</code>）</li>\n</ol>\n"},{"title":"如何更好地运用 Chrome (Google)","date":"2017-09-09T07:10:00.000Z","_content":"\n已经在很多工具类文章前言中，提及使用工具的重要性；以至于在写这篇时候，大为窘迫：穷尽了脑海中那些名句箴言，目测都已然在先前文章中被引用。鉴于杳让人心底意识到工具的重要性，并且能践行之，远比介绍如何使用重要的多，所以，开篇之前，还是得再次重申：工欲善其事，必先利其器。如能领悟，善莫大焉；然而根据长期观察，这个现状并不容乐观，所以就有了这篇文章的存在；毕竟[晚晴幽草轩](https://jeffjade.com/)有部分职责，就是作为经世致用的布道者般的存在。\n\n[![如何更好地使用 Chrome (Google)](http://www.jixiaokang.com/wp-content/uploads/2018/05/E799BDE587A4.jpg)](http://www.jixiaokang.com/wp-content/uploads/2018/05/E799BDE587A4.jpg \"如何更好地使用 Chrome (Google)\")如何更好地使用 Chrome (Google)\n\n> 微注：  写博，本就不是易事，非朝夕可至，尤其这种整理总结性文章；故此，这里将采取阶段性更新手法，一来防止了拖延之；二来，也能不断学习提炼，减少内容的错误误导，三来，也是防止些许聚合网恶意抓取的尝试。（Update @2017-05-16）\n\n## 科学上网篇\n\n使用浏览器，懂得如何去科学上网，这一点再重要不过了（个别浏览器除外，有些浏览器的存在，就只是用来下载其他浏览器的，大家都懂得）。其中，这首要的的就是选择合适搜索引擎。在国内，倒是有那么几家可选，譬如百度，360，搜狗，Bing 等等，搜索写娱乐八卦什么的，倒也无妨。但是，要搜索些专业性、原味性的干货，你当知道，此时该选择谷歌(Google)，这就跟饿了知道该吃饭一般；然而，这在我国大陆，多半只存在于好的程序员之间。然后就是如何能使用谷歌（Google）了——须翻墙，你知道在国内，无法直接使用 Google 搜索（略大型点的科技公司除外）。\n\n谈起这翻墙，可供选择的办法就很多了。愿意花钱的话，购买个靠谱的 VPN 即可。需要流量不是很多，则可以选择像  [lantern (蓝灯)](https://github.com/getlantern/lantern)这样产品，据悉每天可有几百兆可供使用。不怕麻烦的话，大可到网上搜索，时常会有些好心人，贡献出些 Shadowsocks 免费服务，只不过，这好比像是在打游击，时间长了既累也烦。倒不如，自己动手，丰衣足食。稍微一折腾，即可自己搭建一套 VPS ，来达到科学上网的目的，这里推荐使用 Shadowsocks，对于它的使用，在[Shadowsocks 使用说明](https://github.com/shadowsocks/shadowsocks/wiki/Shadowsocks-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E)，已经写明，为确保文章完整性，特此补充一份心得：\n\n### 搭建 Shadowsocks 服务器\n\n首先需要一台服务器(这得是国外的)，推荐使用  [DigitalOcean](https://m.do.co/c/046a8e6b255c)；注册，完成 SSH 配置（具体操作可参考  [如何设置添加 SSH](https://jeffjade.com/2015/06/26/2015-06-26-ssh-setting/)），直接用 root 用户登录即可：\n\n> ssh root@your_server_ip\n\n- 安装 Shadowsocks 服务端\n\n运行以下命令即可快速安装(For Debian / Ubuntu System)：\n\n> apt-get install python-pip  \n> pip install shadowsocks  \n> apt-get install ssserver\n\n- 配置 Shadowsocks 服务端  \n  安装好 Shadowsocks 以后，可以通过以下指令，来启动 Shadowsocks 服务：\n\n1\n\nssserver -p 8836 -k yourPassword -m rc4-md5\n\n以上这种法子，诸多不便，推荐使用配置文件来操纵；新建配置文件，运行命令  `vim /etc/shadowsocks.json`\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n{\n\n\"server\":\"your_server_ip\",\n\n\"server_port\":8388,\n\n\"password\":\"yourpassword\",\n\n\"timeout\":300,\n\n\"method\":\"aes-256-cfb\",\n\n\"fast_open\":false,\n\n\"workers\": 1\n\n}\n\n> server：服务器 IP 地址 (IPv4/IPv6)  \n> server_port：服务器监听的端口，一般设为 80，443 等，注意不要设为使用中的端口  \n> password：设置密码，自定义  \n> timeout：超时时间（单位：秒）  \n> method：加密方法，可选择 “aes-256-cfb”, “rc4-md5”等等。推荐使用 “rc4-md5”  \n> fast_open：true 或 false。如果你的服务器 Linux 内核在 3.7+，可以开启 fast_open 以降低延迟。  \n> workers：workers 数量，默认为 1。\n\n备注：亦配置多个 Shadowsocks 账户，具体可以参考如下的代码配置：\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n{\n\n\"server\":\"your_server_ip\",\n\n\"port_password\":{\n\n\"8001\":\"pass01\",\n\n\"8002\":\"pass02\",\n\n\"8003\":\"pass03\",\n\n\"8004\":\"pass04\"\n\n},\n\n\"timeout\":60,\n\n\"method\":\"rc4-md5\",\n\n\"fast_open\":false,\n\n\"workers\":1\n\n}\n\n接下来,你就可以使用下面这个指令启动服务咯，是不是很简单？\n\n1\n\nssserver -c /etc/shadowsocks.json\n\n- 下载 Shadowsocks 客户端并填入  \n  这里没什么好介绍的，Shadowsocks 的客户端支持各大主流平台，而且客户端的配置相当简单；下载之，填入需要对应的: 服务器 IP，端口，密码，加密方式，即可；至此就可以在浩瀚无垠的网上浪起来了。Shadowsocks 客户端下载地址传送门：[OS X](https://sourceforge.net/projects/shadowsocksgui/files/dist/)、 [Windows](https://sourceforge.net/projects/shadowsocksgui/files/dist/)、 [Android](https://github.com/shadowsocks/shadowsocks/wiki/Ports-and-Clients#android)、[IOS](https://github.com/shadowsocks/shadowsocks-iOS/wiki/Help)。\n\n---\n\n【做个补充】：运用命令  `ssserver -c /etc/shadowsocks.json`  来开启服务，很不方便，一旦退出服务器，下次就得再次开启。于此，Shadowsocks 也提供了后台运行的命令：\n\n1\n\n2\n\nssserver -c /etc/shadowsocks.json -d start\n\nssserver -c /etc/shadowsocks.json -d stop\n\n然而在真正实施上，却会遭遇报错：[option -d not recognized](https://github.com/shadowsocks/shadowsocks/issues/320)，根据 Issues 给出的回答，唯有升级版本才能解决该问题。而事实上，shadowsocks 开源库，已经根据规定被移除（Removed according to regulations）。折腾再三，幸而找见了更好的衍生产品： [shadowsocks-libev](https://github.com/shadowsocks/shadowsocks-libev) —— 一个纯 C 实现，并且对于数千个连接而言具有非常小的占用空间（几兆字节），用于嵌入式设备和低端盒的轻量级的安全 SOCKS5 代理；值得推荐使用。对于安装和配置也都挺方便，如果你是 Ubuntu 14.04 and 16.04 使用者的话：\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n// install from PPA\n\nsudo add-apt-repository ppa:max-c-lv/shadowsocks-libev\n\nsudo apt-get update\n\nsudo apt install shadowsocks-libev\n\n// Build deb package from source\n\nmkdir -p ~/build-area/\n\ncp ./scripts/build_deb.sh ~/build-area/\n\ncd ~/build-area\n\n./build_deb.sh\n\n// Configure and start the service（配置，同上文所讲）\n\n\\# Edit the configuration file\n\nsudo vim /etc/shadowsocks-libev/config.json\n\n\\# Start the service\n\nsudo /etc/init.d/shadowsocks-libev start # for sysvinit, or\n\nsudo systemctl start shadowsocks-libev # for systemd\n\n如此，简单的一次操作之后，就能长久的欢乐嗨皮了；更多系统的安装配置方法，请自行参见  [shadowsocks-libev](https://github.com/shadowsocks/shadowsocks-libev)。还需要提及的是，使用这个库，也有些弊端性，就是不能方便的支持多端口，可以参见[issues/#5](https://github.com/shadowsocks/shadowsocks-libev/issues/5)；可以有的办法是，启用多个配置来曲线达成所愿，操作方法如下：\n\n1\n\n2\n\n3\n\nss-server -c config1.json -f pid1\n\nss-server -c config2.json -f pid2\n\nss-server -c config3.json -f pid3\n\n如此即可；也可通过运行  `netstat -tlnp`  命令，查看 ss-server 是否监听了多个配置文件的端口。如果略嫌这样操作麻烦的话，也可以用 Shadowsocks 的 Go 版本 —— [shadowsocks-go](https://github.com/shadowsocks/shadowsocks-go)，它更为方便的支持多端口的设置（update@2017-05-15）。\n\n---\n\n> 有个广告：  突入一则利人利己的广告：服务器推荐使用  [DigitalOcean](https://m.do.co/c/046a8e6b255c), 它简单灵活、价格公道(最低 5\\$/月)，童叟无欺，可免费试用 30 天。堪称业界良心。此处广告的缘由在于，你若有意使用它，不妨用我的专属推荐链接  [DigitalOcean For JeffJade](https://m.do.co/c/046a8e6b255c)，注册即可获得 10 美刀，当花费了 25 美刀，我就可获取 25 美刀；如有意向，不妨一试；用上一年，算下来每天也不到一元。欲查看更多广告，请[点击我](https://jeffjade.com/Links?form=me)。\n\n---\n\n## 搜索技巧篇\n\n### 精确搜索\n\n精确搜索，就是搜索的关键字用`“”`（双引号，中英文皆可）包含。也叫完整搜索，表示查询词不能被拆分，在搜索结果中必须完整出现。举例说明：\n\n> “胜天半子，其又奈何”  \n> 胜天半子，其又奈何\n\n前者搜索出来的内容，就是必须包含指定关键字；如果没有查询到任何内容，Google 会在下方给出不包含引号的结果。后者，搜索的内容，是关键词以一定规则被拆分的结果。\n\n### 模糊搜索\n\n星号（`*`） 是常用的通配符，也可以用在搜索中，实现模糊匹配搜索。比如在 Google 中搜索：`\"搜索*擎\"`，精确模糊，搭配使用，效果更显著。其中的  `*`  号代表任何文字。返回的结果就不仅包含“搜索引擎”，还包含了“搜索收擎”，“搜索巨擎”等内容。\n\n### 站内搜索\n\n顾名思义，就是我们可以指定仅在某个站点下搜索，这很有用，可以加快定位出你想要的内容；而且也可以用它来替代些许论坛 or 博客自带的站内搜索。譬如，我自己就常这样使用：\n\n> site:jeffjade.com 数组  \n> site:ruanyifeng.com npm\n\n### 排除搜索\n\n如果你想更精确你的搜索，此法大有可为；在想搜索结果中不包含某个词，就在该词的前面加一个 -（减号，⚠️ 这个得是半角英文，并和之后的词得连着，不能有空格）。表示所有搜索结果不包含减号后面的词，含有它的网页将被过滤掉。举例说明，ListView 控件在 Android 跟 React Native 都会含有，如果你想要更精确你的结果，即可屏蔽掉另一方，相这样：\n\n> ListView -Android  \n> ListView -ReactNative // (这 React Native 得连起来，否则会被拆分)\n\n### 标题中搜索\n\n这标题中搜索，即在查询的关键字前面加上  `intitle:` (冒号得是半角英文，且与关键词间不能有空格)， 表示搜索结果的标题都必须含有  `intitle:`  后的查询关键词，以帮助排除无关网页。\n\n> intitle:静晴轩  \n> intitle:天意人间舫\n\n这里可以补充说明的是：还可以加  `allintitle:`；如此搜索，返回的内容是，页面标题中包含多组关键词的页面。例如：allintitle:SEO 搜索引擎优化，就相当于：intitle:SEO intitle:搜索引擎优化，返回的是标题中既包含“SEO”，也包含“搜索引擎优化”的页面。\n\n### 文件类型\n\n在搜索的时候，是可以指定文件格式的，指定格式用：filetype ，表示搜索特定的文件格式；如此一来，我们搜索出来的内容，就是指定格式文件（eg：PDF）。看姑姑(Google)是不是很贴心？\n\n> 代码大全 filetype:PDF  \n> Clean Code filetype:PDF\n\n以上，只是 Google 搜索技巧中常用的几个，其他还有很多，比如：`inurl`， `inanchor`，`allinurl`诸次等等，更多玩法，可以参考知乎  [如何用好谷歌等搜索引擎？](https://www.zhihu.com/question/20161362)；熟练运用，灵活搭配，从而大幅度提升工作效率，并更好地解决问题。此处需要补充的是，以上诸法，并非都适用于百度；即使支持，因为其自身缘由(比如收录不及时)，并不能很好的起到应有的效用。\n\n## 插件扩展篇\n\n当你发现，有人使用 Chrome，而插件扩展栏目，竟空空如也，你就知道：Ta 的业余是专业的，尤其是开发者。Chrome，以及很多主流工具，比如手机，Mac，编辑器等等，都是基于按需索取的理念，这才是一种更合理的存在。将更多功能，以插件、扩展的形式按需注入，不仅更合理地满足所有人所需，也给出了更多选择余地的同时，还能让软件本身更加轻盈体瘦。这一点需要讲明的是，如果说“小白”执意甘为小白，那么这里未有苦劝之义务。关于这部分，早先有在  [Awesome Chrome 插件集锦](https://jeffjade.com/2017/01/23/118-chrome_awesome_plug-in/?from=me)一文中做过记载，并持续更新，此不赘述。\n\n这里还需郑重声明的是：欲要优雅地使用 Chrome，首先也得注册谷歌账号，并保持登录。登录使你所有的东西（书签，应用，扩展，浏览记录等），都可以保存到云端，如此在不同的环境（如家 or 公司）下可以方便的同步。试想，重装系统，或者换台电脑之后，如果要逐个去找之前装的扩展，保存的书签，这样的事情，怎能称不上优雅？不是么?\n\n## 快捷操作篇\n\n天下武功，唯快不破。掌握了搜索技巧，用对了合适插件，此为策略方法层面的事儿。这好比是在玩儿竞技游戏，能犀利而灵动的操作，也是取胜的关键。何况，在你的阵地上（Eg：电脑，浏览器，Terminal 等），手随脑动，运指如飞，是一件多么酷的存在。而这，只需划分一点点时间，了解之熟悉之，享受快捷中寻求进阶，假以时日，便可心指合一，臻至化界。\n\n首先，你需要了解其快捷键操作（常用），毕竟键盘操作，远比鼠标要迅捷且准确；这一点，Chrome 做的非常好，在于它跟很多软件操作习惯，是大致相同的（比如 Sublime），一通则百通。这个可以 在 Setting（F1 呼出） 项中的 Shortcuts 中查看。如果不符合固有操作习惯，也可以更改。然，欲穷千里目，则须更上一层楼；如要更为便捷的去操作，则强烈推荐  `Vimium`（或者 cVim），他们犀利的存在，好如游戏手柄，可以让你在 Chrome 上纵横捭阖；具体可以参见[Vimium~让您的 Chrome 起飞](http://www.jeffjade.com/2015/10/19/2015-10-18-chrome-vimium/)。举例来说，比较常用  `r`  来刷新，`x`  来关闭当前，`t`  来新建标签，`gg`  回到页首等等；当然，这看起来方便的不是太多，可是有些需求，比如：你想拷贝当前标签页，一般操作可分为: ctrl+l  选中当前网址，然后  ctrl+c，ctrl+t  新建标签页之后  ctrl+v，最后还需  Enter  一回。如果使用  `Vimium`呢，只需  `yt`  即可，更可贵的在于，这还是深度拷贝，可将当前网页不仅是内容，还包括浏览历史，Session 等一并都复制了去，相比之下，真是贴心到了天际。\n\n当你在搜索引擎搜某关键词时，多半会展示有一堆列表，一一点开查看，这样的效率实在是不高；这时候，就可以借助  [Linkclump](https://chrome.google.com/webstore/detail/linkclump/lfpjkncokllnfokkgpkobnkbkmelfefj?hl=zh-CN),一款用来批量打开多个网页链接的插件, 她能让你用鼠标框出你想打开的链接，就能在后台自动打开。这样的例子实在数不胜数，只要你足够懒，并积极探索与折腾，总能不断的提升效率，达至极致。\n\n除此外，还可以讲的是，很有必要管理好书签；你应该将其按一定规则，分门别类，放置于不同的书签夹中，以便自己清晰快速的检索。如果能略微记得，书签所存网址的个别单词，又完全可以借助  `Vimium`  去搜索，快捷键  `b(/B)`，分别是在当前页和新标签页打开，如此，效率的提升又进了一步，善哉。\n\n## 使用技巧篇\n\n强大如  Chrome，其亿万行代码的背后，存在着你无法想象的强大，如果你了解的越多，你越发深信这一点。倘若，你是一位有经验的开发者，你会明白，Chrome 不仅仅是一个浏览器那么简单。下面一起来学习下，Chrome 有哪些不为所致的技巧：\n\n- Chrome 的隐身模式：  快捷键：Command + Shift + n （window 下是 Ctrl + Shift + N）。它的好处在于：保护你的隐私。具体表现为，在此窗口中查看的网页，不会显示在浏览器历史记录，或搜索历史记录中，关闭隐身窗口后，也不会在计算机上留下 Cookie 之类的其他痕迹（但会保留所有下载的文件或创建的书签）；明白这一点，浏览些不想让人知道内容，是不是多了许多大胆的自由呢？需要在意的是，事实上隐身模式并非是万能的，该注意的还得谨慎。\n- Chrome 的 about 指令：  作为一个 Chrome 用户，你该懂得 Chrome 地址栏功能，这让你变得更像一个合格的主人。试着在 Chrome 地址栏，输入  `chrome://about/`，这会展示出：List of Chrome URLs，如下图所示：\n\n[![List of Chrome URLs](http://www.jixiaokang.com/wp-content/uploads/2018/05/list-of-chrome-urls.png)](http://www.jixiaokang.com/wp-content/uploads/2018/05/list-of-chrome-urls.png \"List of Chrome URLs\")List of Chrome URLs\n\n仔细研究的话，发现这其中有些十分有意思，也很有价值，一起来看几个：\n\n> chrome://apps/ Chrome 网上应用商店  \n> chrome://accessibility 查看浏览器当前访问的标签  \n> chrome://appcache-internals/ 对 HTML5 应用的离线存储进行管理  \n> chrome://cache/ Chrome 缓存（只读）  \n> chrome://components/ 查看相关组件  \n> chrome://dns/ 查看 DNS 记录  \n> chrome://extensions/ 查看扩展程序  \n> chrome://plugins/ 停用启用相关插件  \n> chrome://omnibox/  能地址栏（强大啊，你输入“晚晴”试试？）  \n> chrome://predictors/ URl 输入命中率（结合 omnibox 使用）  \n> chrome://net-internals Chrome 的抓包工具  \n> chrome://quota-internals/ 显示磁盘详细可用空间以及各个网站的使用配额  \n> chrome://thumbnails/ 近期浏览的网站的首页快照（以相册的形式）  \n> view-source:<网页地址> 显示网页的源代码  \n> … …\n\n- Tab 搜索：  支持 OpenSearch 的网站，在浏览器地址栏输入网址后，按 Tab 键，可在此网站内部进行搜索，这对部分 .com 结尾网站有效。例如地址栏输入“zhihu.com”，然后按一下 Tab 键，直接在知乎内部进行搜索，相当于  `site:zhihu.com`。\n","source":"_posts/2017-09-09-如何更好地运用 Chrome.md","raw":"---\ntitle: 如何更好地运用 Chrome (Google)\ntags:\n  - 工具\ndate: 2017-09-09 15:10:00\ncategories: 工具\n---\n\n已经在很多工具类文章前言中，提及使用工具的重要性；以至于在写这篇时候，大为窘迫：穷尽了脑海中那些名句箴言，目测都已然在先前文章中被引用。鉴于杳让人心底意识到工具的重要性，并且能践行之，远比介绍如何使用重要的多，所以，开篇之前，还是得再次重申：工欲善其事，必先利其器。如能领悟，善莫大焉；然而根据长期观察，这个现状并不容乐观，所以就有了这篇文章的存在；毕竟[晚晴幽草轩](https://jeffjade.com/)有部分职责，就是作为经世致用的布道者般的存在。\n\n[![如何更好地使用 Chrome (Google)](http://www.jixiaokang.com/wp-content/uploads/2018/05/E799BDE587A4.jpg)](http://www.jixiaokang.com/wp-content/uploads/2018/05/E799BDE587A4.jpg \"如何更好地使用 Chrome (Google)\")如何更好地使用 Chrome (Google)\n\n> 微注：  写博，本就不是易事，非朝夕可至，尤其这种整理总结性文章；故此，这里将采取阶段性更新手法，一来防止了拖延之；二来，也能不断学习提炼，减少内容的错误误导，三来，也是防止些许聚合网恶意抓取的尝试。（Update @2017-05-16）\n\n## 科学上网篇\n\n使用浏览器，懂得如何去科学上网，这一点再重要不过了（个别浏览器除外，有些浏览器的存在，就只是用来下载其他浏览器的，大家都懂得）。其中，这首要的的就是选择合适搜索引擎。在国内，倒是有那么几家可选，譬如百度，360，搜狗，Bing 等等，搜索写娱乐八卦什么的，倒也无妨。但是，要搜索些专业性、原味性的干货，你当知道，此时该选择谷歌(Google)，这就跟饿了知道该吃饭一般；然而，这在我国大陆，多半只存在于好的程序员之间。然后就是如何能使用谷歌（Google）了——须翻墙，你知道在国内，无法直接使用 Google 搜索（略大型点的科技公司除外）。\n\n谈起这翻墙，可供选择的办法就很多了。愿意花钱的话，购买个靠谱的 VPN 即可。需要流量不是很多，则可以选择像  [lantern (蓝灯)](https://github.com/getlantern/lantern)这样产品，据悉每天可有几百兆可供使用。不怕麻烦的话，大可到网上搜索，时常会有些好心人，贡献出些 Shadowsocks 免费服务，只不过，这好比像是在打游击，时间长了既累也烦。倒不如，自己动手，丰衣足食。稍微一折腾，即可自己搭建一套 VPS ，来达到科学上网的目的，这里推荐使用 Shadowsocks，对于它的使用，在[Shadowsocks 使用说明](https://github.com/shadowsocks/shadowsocks/wiki/Shadowsocks-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E)，已经写明，为确保文章完整性，特此补充一份心得：\n\n### 搭建 Shadowsocks 服务器\n\n首先需要一台服务器(这得是国外的)，推荐使用  [DigitalOcean](https://m.do.co/c/046a8e6b255c)；注册，完成 SSH 配置（具体操作可参考  [如何设置添加 SSH](https://jeffjade.com/2015/06/26/2015-06-26-ssh-setting/)），直接用 root 用户登录即可：\n\n> ssh root@your_server_ip\n\n- 安装 Shadowsocks 服务端\n\n运行以下命令即可快速安装(For Debian / Ubuntu System)：\n\n> apt-get install python-pip  \n> pip install shadowsocks  \n> apt-get install ssserver\n\n- 配置 Shadowsocks 服务端  \n  安装好 Shadowsocks 以后，可以通过以下指令，来启动 Shadowsocks 服务：\n\n1\n\nssserver -p 8836 -k yourPassword -m rc4-md5\n\n以上这种法子，诸多不便，推荐使用配置文件来操纵；新建配置文件，运行命令  `vim /etc/shadowsocks.json`\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n{\n\n\"server\":\"your_server_ip\",\n\n\"server_port\":8388,\n\n\"password\":\"yourpassword\",\n\n\"timeout\":300,\n\n\"method\":\"aes-256-cfb\",\n\n\"fast_open\":false,\n\n\"workers\": 1\n\n}\n\n> server：服务器 IP 地址 (IPv4/IPv6)  \n> server_port：服务器监听的端口，一般设为 80，443 等，注意不要设为使用中的端口  \n> password：设置密码，自定义  \n> timeout：超时时间（单位：秒）  \n> method：加密方法，可选择 “aes-256-cfb”, “rc4-md5”等等。推荐使用 “rc4-md5”  \n> fast_open：true 或 false。如果你的服务器 Linux 内核在 3.7+，可以开启 fast_open 以降低延迟。  \n> workers：workers 数量，默认为 1。\n\n备注：亦配置多个 Shadowsocks 账户，具体可以参考如下的代码配置：\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n{\n\n\"server\":\"your_server_ip\",\n\n\"port_password\":{\n\n\"8001\":\"pass01\",\n\n\"8002\":\"pass02\",\n\n\"8003\":\"pass03\",\n\n\"8004\":\"pass04\"\n\n},\n\n\"timeout\":60,\n\n\"method\":\"rc4-md5\",\n\n\"fast_open\":false,\n\n\"workers\":1\n\n}\n\n接下来,你就可以使用下面这个指令启动服务咯，是不是很简单？\n\n1\n\nssserver -c /etc/shadowsocks.json\n\n- 下载 Shadowsocks 客户端并填入  \n  这里没什么好介绍的，Shadowsocks 的客户端支持各大主流平台，而且客户端的配置相当简单；下载之，填入需要对应的: 服务器 IP，端口，密码，加密方式，即可；至此就可以在浩瀚无垠的网上浪起来了。Shadowsocks 客户端下载地址传送门：[OS X](https://sourceforge.net/projects/shadowsocksgui/files/dist/)、 [Windows](https://sourceforge.net/projects/shadowsocksgui/files/dist/)、 [Android](https://github.com/shadowsocks/shadowsocks/wiki/Ports-and-Clients#android)、[IOS](https://github.com/shadowsocks/shadowsocks-iOS/wiki/Help)。\n\n---\n\n【做个补充】：运用命令  `ssserver -c /etc/shadowsocks.json`  来开启服务，很不方便，一旦退出服务器，下次就得再次开启。于此，Shadowsocks 也提供了后台运行的命令：\n\n1\n\n2\n\nssserver -c /etc/shadowsocks.json -d start\n\nssserver -c /etc/shadowsocks.json -d stop\n\n然而在真正实施上，却会遭遇报错：[option -d not recognized](https://github.com/shadowsocks/shadowsocks/issues/320)，根据 Issues 给出的回答，唯有升级版本才能解决该问题。而事实上，shadowsocks 开源库，已经根据规定被移除（Removed according to regulations）。折腾再三，幸而找见了更好的衍生产品： [shadowsocks-libev](https://github.com/shadowsocks/shadowsocks-libev) —— 一个纯 C 实现，并且对于数千个连接而言具有非常小的占用空间（几兆字节），用于嵌入式设备和低端盒的轻量级的安全 SOCKS5 代理；值得推荐使用。对于安装和配置也都挺方便，如果你是 Ubuntu 14.04 and 16.04 使用者的话：\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n// install from PPA\n\nsudo add-apt-repository ppa:max-c-lv/shadowsocks-libev\n\nsudo apt-get update\n\nsudo apt install shadowsocks-libev\n\n// Build deb package from source\n\nmkdir -p ~/build-area/\n\ncp ./scripts/build_deb.sh ~/build-area/\n\ncd ~/build-area\n\n./build_deb.sh\n\n// Configure and start the service（配置，同上文所讲）\n\n\\# Edit the configuration file\n\nsudo vim /etc/shadowsocks-libev/config.json\n\n\\# Start the service\n\nsudo /etc/init.d/shadowsocks-libev start # for sysvinit, or\n\nsudo systemctl start shadowsocks-libev # for systemd\n\n如此，简单的一次操作之后，就能长久的欢乐嗨皮了；更多系统的安装配置方法，请自行参见  [shadowsocks-libev](https://github.com/shadowsocks/shadowsocks-libev)。还需要提及的是，使用这个库，也有些弊端性，就是不能方便的支持多端口，可以参见[issues/#5](https://github.com/shadowsocks/shadowsocks-libev/issues/5)；可以有的办法是，启用多个配置来曲线达成所愿，操作方法如下：\n\n1\n\n2\n\n3\n\nss-server -c config1.json -f pid1\n\nss-server -c config2.json -f pid2\n\nss-server -c config3.json -f pid3\n\n如此即可；也可通过运行  `netstat -tlnp`  命令，查看 ss-server 是否监听了多个配置文件的端口。如果略嫌这样操作麻烦的话，也可以用 Shadowsocks 的 Go 版本 —— [shadowsocks-go](https://github.com/shadowsocks/shadowsocks-go)，它更为方便的支持多端口的设置（update@2017-05-15）。\n\n---\n\n> 有个广告：  突入一则利人利己的广告：服务器推荐使用  [DigitalOcean](https://m.do.co/c/046a8e6b255c), 它简单灵活、价格公道(最低 5\\$/月)，童叟无欺，可免费试用 30 天。堪称业界良心。此处广告的缘由在于，你若有意使用它，不妨用我的专属推荐链接  [DigitalOcean For JeffJade](https://m.do.co/c/046a8e6b255c)，注册即可获得 10 美刀，当花费了 25 美刀，我就可获取 25 美刀；如有意向，不妨一试；用上一年，算下来每天也不到一元。欲查看更多广告，请[点击我](https://jeffjade.com/Links?form=me)。\n\n---\n\n## 搜索技巧篇\n\n### 精确搜索\n\n精确搜索，就是搜索的关键字用`“”`（双引号，中英文皆可）包含。也叫完整搜索，表示查询词不能被拆分，在搜索结果中必须完整出现。举例说明：\n\n> “胜天半子，其又奈何”  \n> 胜天半子，其又奈何\n\n前者搜索出来的内容，就是必须包含指定关键字；如果没有查询到任何内容，Google 会在下方给出不包含引号的结果。后者，搜索的内容，是关键词以一定规则被拆分的结果。\n\n### 模糊搜索\n\n星号（`*`） 是常用的通配符，也可以用在搜索中，实现模糊匹配搜索。比如在 Google 中搜索：`\"搜索*擎\"`，精确模糊，搭配使用，效果更显著。其中的  `*`  号代表任何文字。返回的结果就不仅包含“搜索引擎”，还包含了“搜索收擎”，“搜索巨擎”等内容。\n\n### 站内搜索\n\n顾名思义，就是我们可以指定仅在某个站点下搜索，这很有用，可以加快定位出你想要的内容；而且也可以用它来替代些许论坛 or 博客自带的站内搜索。譬如，我自己就常这样使用：\n\n> site:jeffjade.com 数组  \n> site:ruanyifeng.com npm\n\n### 排除搜索\n\n如果你想更精确你的搜索，此法大有可为；在想搜索结果中不包含某个词，就在该词的前面加一个 -（减号，⚠️ 这个得是半角英文，并和之后的词得连着，不能有空格）。表示所有搜索结果不包含减号后面的词，含有它的网页将被过滤掉。举例说明，ListView 控件在 Android 跟 React Native 都会含有，如果你想要更精确你的结果，即可屏蔽掉另一方，相这样：\n\n> ListView -Android  \n> ListView -ReactNative // (这 React Native 得连起来，否则会被拆分)\n\n### 标题中搜索\n\n这标题中搜索，即在查询的关键字前面加上  `intitle:` (冒号得是半角英文，且与关键词间不能有空格)， 表示搜索结果的标题都必须含有  `intitle:`  后的查询关键词，以帮助排除无关网页。\n\n> intitle:静晴轩  \n> intitle:天意人间舫\n\n这里可以补充说明的是：还可以加  `allintitle:`；如此搜索，返回的内容是，页面标题中包含多组关键词的页面。例如：allintitle:SEO 搜索引擎优化，就相当于：intitle:SEO intitle:搜索引擎优化，返回的是标题中既包含“SEO”，也包含“搜索引擎优化”的页面。\n\n### 文件类型\n\n在搜索的时候，是可以指定文件格式的，指定格式用：filetype ，表示搜索特定的文件格式；如此一来，我们搜索出来的内容，就是指定格式文件（eg：PDF）。看姑姑(Google)是不是很贴心？\n\n> 代码大全 filetype:PDF  \n> Clean Code filetype:PDF\n\n以上，只是 Google 搜索技巧中常用的几个，其他还有很多，比如：`inurl`， `inanchor`，`allinurl`诸次等等，更多玩法，可以参考知乎  [如何用好谷歌等搜索引擎？](https://www.zhihu.com/question/20161362)；熟练运用，灵活搭配，从而大幅度提升工作效率，并更好地解决问题。此处需要补充的是，以上诸法，并非都适用于百度；即使支持，因为其自身缘由(比如收录不及时)，并不能很好的起到应有的效用。\n\n## 插件扩展篇\n\n当你发现，有人使用 Chrome，而插件扩展栏目，竟空空如也，你就知道：Ta 的业余是专业的，尤其是开发者。Chrome，以及很多主流工具，比如手机，Mac，编辑器等等，都是基于按需索取的理念，这才是一种更合理的存在。将更多功能，以插件、扩展的形式按需注入，不仅更合理地满足所有人所需，也给出了更多选择余地的同时，还能让软件本身更加轻盈体瘦。这一点需要讲明的是，如果说“小白”执意甘为小白，那么这里未有苦劝之义务。关于这部分，早先有在  [Awesome Chrome 插件集锦](https://jeffjade.com/2017/01/23/118-chrome_awesome_plug-in/?from=me)一文中做过记载，并持续更新，此不赘述。\n\n这里还需郑重声明的是：欲要优雅地使用 Chrome，首先也得注册谷歌账号，并保持登录。登录使你所有的东西（书签，应用，扩展，浏览记录等），都可以保存到云端，如此在不同的环境（如家 or 公司）下可以方便的同步。试想，重装系统，或者换台电脑之后，如果要逐个去找之前装的扩展，保存的书签，这样的事情，怎能称不上优雅？不是么?\n\n## 快捷操作篇\n\n天下武功，唯快不破。掌握了搜索技巧，用对了合适插件，此为策略方法层面的事儿。这好比是在玩儿竞技游戏，能犀利而灵动的操作，也是取胜的关键。何况，在你的阵地上（Eg：电脑，浏览器，Terminal 等），手随脑动，运指如飞，是一件多么酷的存在。而这，只需划分一点点时间，了解之熟悉之，享受快捷中寻求进阶，假以时日，便可心指合一，臻至化界。\n\n首先，你需要了解其快捷键操作（常用），毕竟键盘操作，远比鼠标要迅捷且准确；这一点，Chrome 做的非常好，在于它跟很多软件操作习惯，是大致相同的（比如 Sublime），一通则百通。这个可以 在 Setting（F1 呼出） 项中的 Shortcuts 中查看。如果不符合固有操作习惯，也可以更改。然，欲穷千里目，则须更上一层楼；如要更为便捷的去操作，则强烈推荐  `Vimium`（或者 cVim），他们犀利的存在，好如游戏手柄，可以让你在 Chrome 上纵横捭阖；具体可以参见[Vimium~让您的 Chrome 起飞](http://www.jeffjade.com/2015/10/19/2015-10-18-chrome-vimium/)。举例来说，比较常用  `r`  来刷新，`x`  来关闭当前，`t`  来新建标签，`gg`  回到页首等等；当然，这看起来方便的不是太多，可是有些需求，比如：你想拷贝当前标签页，一般操作可分为: ctrl+l  选中当前网址，然后  ctrl+c，ctrl+t  新建标签页之后  ctrl+v，最后还需  Enter  一回。如果使用  `Vimium`呢，只需  `yt`  即可，更可贵的在于，这还是深度拷贝，可将当前网页不仅是内容，还包括浏览历史，Session 等一并都复制了去，相比之下，真是贴心到了天际。\n\n当你在搜索引擎搜某关键词时，多半会展示有一堆列表，一一点开查看，这样的效率实在是不高；这时候，就可以借助  [Linkclump](https://chrome.google.com/webstore/detail/linkclump/lfpjkncokllnfokkgpkobnkbkmelfefj?hl=zh-CN),一款用来批量打开多个网页链接的插件, 她能让你用鼠标框出你想打开的链接，就能在后台自动打开。这样的例子实在数不胜数，只要你足够懒，并积极探索与折腾，总能不断的提升效率，达至极致。\n\n除此外，还可以讲的是，很有必要管理好书签；你应该将其按一定规则，分门别类，放置于不同的书签夹中，以便自己清晰快速的检索。如果能略微记得，书签所存网址的个别单词，又完全可以借助  `Vimium`  去搜索，快捷键  `b(/B)`，分别是在当前页和新标签页打开，如此，效率的提升又进了一步，善哉。\n\n## 使用技巧篇\n\n强大如  Chrome，其亿万行代码的背后，存在着你无法想象的强大，如果你了解的越多，你越发深信这一点。倘若，你是一位有经验的开发者，你会明白，Chrome 不仅仅是一个浏览器那么简单。下面一起来学习下，Chrome 有哪些不为所致的技巧：\n\n- Chrome 的隐身模式：  快捷键：Command + Shift + n （window 下是 Ctrl + Shift + N）。它的好处在于：保护你的隐私。具体表现为，在此窗口中查看的网页，不会显示在浏览器历史记录，或搜索历史记录中，关闭隐身窗口后，也不会在计算机上留下 Cookie 之类的其他痕迹（但会保留所有下载的文件或创建的书签）；明白这一点，浏览些不想让人知道内容，是不是多了许多大胆的自由呢？需要在意的是，事实上隐身模式并非是万能的，该注意的还得谨慎。\n- Chrome 的 about 指令：  作为一个 Chrome 用户，你该懂得 Chrome 地址栏功能，这让你变得更像一个合格的主人。试着在 Chrome 地址栏，输入  `chrome://about/`，这会展示出：List of Chrome URLs，如下图所示：\n\n[![List of Chrome URLs](http://www.jixiaokang.com/wp-content/uploads/2018/05/list-of-chrome-urls.png)](http://www.jixiaokang.com/wp-content/uploads/2018/05/list-of-chrome-urls.png \"List of Chrome URLs\")List of Chrome URLs\n\n仔细研究的话，发现这其中有些十分有意思，也很有价值，一起来看几个：\n\n> chrome://apps/ Chrome 网上应用商店  \n> chrome://accessibility 查看浏览器当前访问的标签  \n> chrome://appcache-internals/ 对 HTML5 应用的离线存储进行管理  \n> chrome://cache/ Chrome 缓存（只读）  \n> chrome://components/ 查看相关组件  \n> chrome://dns/ 查看 DNS 记录  \n> chrome://extensions/ 查看扩展程序  \n> chrome://plugins/ 停用启用相关插件  \n> chrome://omnibox/  能地址栏（强大啊，你输入“晚晴”试试？）  \n> chrome://predictors/ URl 输入命中率（结合 omnibox 使用）  \n> chrome://net-internals Chrome 的抓包工具  \n> chrome://quota-internals/ 显示磁盘详细可用空间以及各个网站的使用配额  \n> chrome://thumbnails/ 近期浏览的网站的首页快照（以相册的形式）  \n> view-source:<网页地址> 显示网页的源代码  \n> … …\n\n- Tab 搜索：  支持 OpenSearch 的网站，在浏览器地址栏输入网址后，按 Tab 键，可在此网站内部进行搜索，这对部分 .com 结尾网站有效。例如地址栏输入“zhihu.com”，然后按一下 Tab 键，直接在知乎内部进行搜索，相当于  `site:zhihu.com`。\n","slug":"2017-09-09-如何更好地运用 Chrome","published":1,"updated":"2020-03-14T06:47:30.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvnp00684k8y74gkf1yy","content":"<p>已经在很多工具类文章前言中，提及使用工具的重要性；以至于在写这篇时候，大为窘迫：穷尽了脑海中那些名句箴言，目测都已然在先前文章中被引用。鉴于杳让人心底意识到工具的重要性，并且能践行之，远比介绍如何使用重要的多，所以，开篇之前，还是得再次重申：工欲善其事，必先利其器。如能领悟，善莫大焉；然而根据长期观察，这个现状并不容乐观，所以就有了这篇文章的存在；毕竟<a href=\"https://jeffjade.com/\" target=\"_blank\" rel=\"noopener\">晚晴幽草轩</a>有部分职责，就是作为经世致用的布道者般的存在。</p>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/E799BDE587A4.jpg\" target=\"_blank\" rel=\"noopener\" title=\"如何更好地使用 Chrome (Google)\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/E799BDE587A4.jpg\" alt=\"如何更好地使用 Chrome (Google)\"></a>如何更好地使用 Chrome (Google)</p>\n<blockquote>\n<p>微注：  写博，本就不是易事，非朝夕可至，尤其这种整理总结性文章；故此，这里将采取阶段性更新手法，一来防止了拖延之；二来，也能不断学习提炼，减少内容的错误误导，三来，也是防止些许聚合网恶意抓取的尝试。（Update @2017-05-16）</p>\n</blockquote>\n<h2 id=\"科学上网篇\"><a href=\"#科学上网篇\" class=\"headerlink\" title=\"科学上网篇\"></a>科学上网篇</h2><p>使用浏览器，懂得如何去科学上网，这一点再重要不过了（个别浏览器除外，有些浏览器的存在，就只是用来下载其他浏览器的，大家都懂得）。其中，这首要的的就是选择合适搜索引擎。在国内，倒是有那么几家可选，譬如百度，360，搜狗，Bing 等等，搜索写娱乐八卦什么的，倒也无妨。但是，要搜索些专业性、原味性的干货，你当知道，此时该选择谷歌(Google)，这就跟饿了知道该吃饭一般；然而，这在我国大陆，多半只存在于好的程序员之间。然后就是如何能使用谷歌（Google）了——须翻墙，你知道在国内，无法直接使用 Google 搜索（略大型点的科技公司除外）。</p>\n<p>谈起这翻墙，可供选择的办法就很多了。愿意花钱的话，购买个靠谱的 VPN 即可。需要流量不是很多，则可以选择像  <a href=\"https://github.com/getlantern/lantern\" target=\"_blank\" rel=\"noopener\">lantern (蓝灯)</a>这样产品，据悉每天可有几百兆可供使用。不怕麻烦的话，大可到网上搜索，时常会有些好心人，贡献出些 Shadowsocks 免费服务，只不过，这好比像是在打游击，时间长了既累也烦。倒不如，自己动手，丰衣足食。稍微一折腾，即可自己搭建一套 VPS ，来达到科学上网的目的，这里推荐使用 Shadowsocks，对于它的使用，在<a href=\"https://github.com/shadowsocks/shadowsocks/wiki/Shadowsocks-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E\" target=\"_blank\" rel=\"noopener\">Shadowsocks 使用说明</a>，已经写明，为确保文章完整性，特此补充一份心得：</p>\n<h3 id=\"搭建-Shadowsocks-服务器\"><a href=\"#搭建-Shadowsocks-服务器\" class=\"headerlink\" title=\"搭建 Shadowsocks 服务器\"></a>搭建 Shadowsocks 服务器</h3><p>首先需要一台服务器(这得是国外的)，推荐使用  <a href=\"https://m.do.co/c/046a8e6b255c\" target=\"_blank\" rel=\"noopener\">DigitalOcean</a>；注册，完成 SSH 配置（具体操作可参考  <a href=\"https://jeffjade.com/2015/06/26/2015-06-26-ssh-setting/\" target=\"_blank\" rel=\"noopener\">如何设置添加 SSH</a>），直接用 root 用户登录即可：</p>\n<blockquote>\n<p>ssh root@your_server_ip</p>\n</blockquote>\n<ul>\n<li>安装 Shadowsocks 服务端</li>\n</ul>\n<p>运行以下命令即可快速安装(For Debian / Ubuntu System)：</p>\n<blockquote>\n<p>apt-get install python-pip<br>pip install shadowsocks<br>apt-get install ssserver</p>\n</blockquote>\n<ul>\n<li>配置 Shadowsocks 服务端<br>安装好 Shadowsocks 以后，可以通过以下指令，来启动 Shadowsocks 服务：</li>\n</ul>\n<p>1</p>\n<p>ssserver -p 8836 -k yourPassword -m rc4-md5</p>\n<p>以上这种法子，诸多不便，推荐使用配置文件来操纵；新建配置文件，运行命令  <code>vim /etc/shadowsocks.json</code></p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>{</p>\n<p>“server”:”your_server_ip”,</p>\n<p>“server_port”:8388,</p>\n<p>“password”:”yourpassword”,</p>\n<p>“timeout”:300,</p>\n<p>“method”:”aes-256-cfb”,</p>\n<p>“fast_open”:false,</p>\n<p>“workers”: 1</p>\n<p>}</p>\n<blockquote>\n<p>server：服务器 IP 地址 (IPv4/IPv6)<br>server_port：服务器监听的端口，一般设为 80，443 等，注意不要设为使用中的端口<br>password：设置密码，自定义<br>timeout：超时时间（单位：秒）<br>method：加密方法，可选择 “aes-256-cfb”, “rc4-md5”等等。推荐使用 “rc4-md5”<br>fast_open：true 或 false。如果你的服务器 Linux 内核在 3.7+，可以开启 fast_open 以降低延迟。<br>workers：workers 数量，默认为 1。</p>\n</blockquote>\n<p>备注：亦配置多个 Shadowsocks 账户，具体可以参考如下的代码配置：</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>11</p>\n<p>12</p>\n<p>13</p>\n<p>{</p>\n<p>“server”:”your_server_ip”,</p>\n<p>“port_password”:{</p>\n<p>“8001”:”pass01”,</p>\n<p>“8002”:”pass02”,</p>\n<p>“8003”:”pass03”,</p>\n<p>“8004”:”pass04”</p>\n<p>},</p>\n<p>“timeout”:60,</p>\n<p>“method”:”rc4-md5”,</p>\n<p>“fast_open”:false,</p>\n<p>“workers”:1</p>\n<p>}</p>\n<p>接下来,你就可以使用下面这个指令启动服务咯，是不是很简单？</p>\n<p>1</p>\n<p>ssserver -c /etc/shadowsocks.json</p>\n<ul>\n<li>下载 Shadowsocks 客户端并填入<br>这里没什么好介绍的，Shadowsocks 的客户端支持各大主流平台，而且客户端的配置相当简单；下载之，填入需要对应的: 服务器 IP，端口，密码，加密方式，即可；至此就可以在浩瀚无垠的网上浪起来了。Shadowsocks 客户端下载地址传送门：<a href=\"https://sourceforge.net/projects/shadowsocksgui/files/dist/\" target=\"_blank\" rel=\"noopener\">OS X</a>、 <a href=\"https://sourceforge.net/projects/shadowsocksgui/files/dist/\" target=\"_blank\" rel=\"noopener\">Windows</a>、 <a href=\"https://github.com/shadowsocks/shadowsocks/wiki/Ports-and-Clients#android\" target=\"_blank\" rel=\"noopener\">Android</a>、<a href=\"https://github.com/shadowsocks/shadowsocks-iOS/wiki/Help\" target=\"_blank\" rel=\"noopener\">IOS</a>。</li>\n</ul>\n<hr>\n<p>【做个补充】：运用命令  <code>ssserver -c /etc/shadowsocks.json</code>  来开启服务，很不方便，一旦退出服务器，下次就得再次开启。于此，Shadowsocks 也提供了后台运行的命令：</p>\n<p>1</p>\n<p>2</p>\n<p>ssserver -c /etc/shadowsocks.json -d start</p>\n<p>ssserver -c /etc/shadowsocks.json -d stop</p>\n<p>然而在真正实施上，却会遭遇报错：<a href=\"https://github.com/shadowsocks/shadowsocks/issues/320\" target=\"_blank\" rel=\"noopener\">option -d not recognized</a>，根据 Issues 给出的回答，唯有升级版本才能解决该问题。而事实上，shadowsocks 开源库，已经根据规定被移除（Removed according to regulations）。折腾再三，幸而找见了更好的衍生产品： <a href=\"https://github.com/shadowsocks/shadowsocks-libev\" target=\"_blank\" rel=\"noopener\">shadowsocks-libev</a> —— 一个纯 C 实现，并且对于数千个连接而言具有非常小的占用空间（几兆字节），用于嵌入式设备和低端盒的轻量级的安全 SOCKS5 代理；值得推荐使用。对于安装和配置也都挺方便，如果你是 Ubuntu 14.04 and 16.04 使用者的话：</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>11</p>\n<p>12</p>\n<p>13</p>\n<p>14</p>\n<p>15</p>\n<p>16</p>\n<p>17</p>\n<p>18</p>\n<p>// install from PPA</p>\n<p>sudo add-apt-repository ppa:max-c-lv/shadowsocks-libev</p>\n<p>sudo apt-get update</p>\n<p>sudo apt install shadowsocks-libev</p>\n<p>// Build deb package from source</p>\n<p>mkdir -p ~/build-area/</p>\n<p>cp ./scripts/build_deb.sh ~/build-area/</p>\n<p>cd ~/build-area</p>\n<p>./build_deb.sh</p>\n<p>// Configure and start the service（配置，同上文所讲）</p>\n<p># Edit the configuration file</p>\n<p>sudo vim /etc/shadowsocks-libev/config.json</p>\n<p># Start the service</p>\n<p>sudo /etc/init.d/shadowsocks-libev start # for sysvinit, or</p>\n<p>sudo systemctl start shadowsocks-libev # for systemd</p>\n<p>如此，简单的一次操作之后，就能长久的欢乐嗨皮了；更多系统的安装配置方法，请自行参见  <a href=\"https://github.com/shadowsocks/shadowsocks-libev\" target=\"_blank\" rel=\"noopener\">shadowsocks-libev</a>。还需要提及的是，使用这个库，也有些弊端性，就是不能方便的支持多端口，可以参见<a href=\"https://github.com/shadowsocks/shadowsocks-libev/issues/5\" target=\"_blank\" rel=\"noopener\">issues/#5</a>；可以有的办法是，启用多个配置来曲线达成所愿，操作方法如下：</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>ss-server -c config1.json -f pid1</p>\n<p>ss-server -c config2.json -f pid2</p>\n<p>ss-server -c config3.json -f pid3</p>\n<p>如此即可；也可通过运行  <code>netstat -tlnp</code>  命令，查看 ss-server 是否监听了多个配置文件的端口。如果略嫌这样操作麻烦的话，也可以用 Shadowsocks 的 Go 版本 —— <a href=\"https://github.com/shadowsocks/shadowsocks-go\" target=\"_blank\" rel=\"noopener\">shadowsocks-go</a>，它更为方便的支持多端口的设置（update@2017-05-15）。</p>\n<hr>\n<blockquote>\n<p>有个广告：  突入一则利人利己的广告：服务器推荐使用  <a href=\"https://m.do.co/c/046a8e6b255c\" target=\"_blank\" rel=\"noopener\">DigitalOcean</a>, 它简单灵活、价格公道(最低 5$/月)，童叟无欺，可免费试用 30 天。堪称业界良心。此处广告的缘由在于，你若有意使用它，不妨用我的专属推荐链接  <a href=\"https://m.do.co/c/046a8e6b255c\" target=\"_blank\" rel=\"noopener\">DigitalOcean For JeffJade</a>，注册即可获得 10 美刀，当花费了 25 美刀，我就可获取 25 美刀；如有意向，不妨一试；用上一年，算下来每天也不到一元。欲查看更多广告，请<a href=\"https://jeffjade.com/Links?form=me\" target=\"_blank\" rel=\"noopener\">点击我</a>。</p>\n</blockquote>\n<hr>\n<h2 id=\"搜索技巧篇\"><a href=\"#搜索技巧篇\" class=\"headerlink\" title=\"搜索技巧篇\"></a>搜索技巧篇</h2><h3 id=\"精确搜索\"><a href=\"#精确搜索\" class=\"headerlink\" title=\"精确搜索\"></a>精确搜索</h3><p>精确搜索，就是搜索的关键字用<code>“”</code>（双引号，中英文皆可）包含。也叫完整搜索，表示查询词不能被拆分，在搜索结果中必须完整出现。举例说明：</p>\n<blockquote>\n<p>“胜天半子，其又奈何”<br>胜天半子，其又奈何</p>\n</blockquote>\n<p>前者搜索出来的内容，就是必须包含指定关键字；如果没有查询到任何内容，Google 会在下方给出不包含引号的结果。后者，搜索的内容，是关键词以一定规则被拆分的结果。</p>\n<h3 id=\"模糊搜索\"><a href=\"#模糊搜索\" class=\"headerlink\" title=\"模糊搜索\"></a>模糊搜索</h3><p>星号（<code>*</code>） 是常用的通配符，也可以用在搜索中，实现模糊匹配搜索。比如在 Google 中搜索：<code>&quot;搜索*擎&quot;</code>，精确模糊，搭配使用，效果更显著。其中的  <code>*</code>  号代表任何文字。返回的结果就不仅包含“搜索引擎”，还包含了“搜索收擎”，“搜索巨擎”等内容。</p>\n<h3 id=\"站内搜索\"><a href=\"#站内搜索\" class=\"headerlink\" title=\"站内搜索\"></a>站内搜索</h3><p>顾名思义，就是我们可以指定仅在某个站点下搜索，这很有用，可以加快定位出你想要的内容；而且也可以用它来替代些许论坛 or 博客自带的站内搜索。譬如，我自己就常这样使用：</p>\n<blockquote>\n<p>site:jeffjade.com 数组<br>site:ruanyifeng.com npm</p>\n</blockquote>\n<h3 id=\"排除搜索\"><a href=\"#排除搜索\" class=\"headerlink\" title=\"排除搜索\"></a>排除搜索</h3><p>如果你想更精确你的搜索，此法大有可为；在想搜索结果中不包含某个词，就在该词的前面加一个 -（减号，⚠️ 这个得是半角英文，并和之后的词得连着，不能有空格）。表示所有搜索结果不包含减号后面的词，含有它的网页将被过滤掉。举例说明，ListView 控件在 Android 跟 React Native 都会含有，如果你想要更精确你的结果，即可屏蔽掉另一方，相这样：</p>\n<blockquote>\n<p>ListView -Android<br>ListView -ReactNative // (这 React Native 得连起来，否则会被拆分)</p>\n</blockquote>\n<h3 id=\"标题中搜索\"><a href=\"#标题中搜索\" class=\"headerlink\" title=\"标题中搜索\"></a>标题中搜索</h3><p>这标题中搜索，即在查询的关键字前面加上  <code>intitle:</code> (冒号得是半角英文，且与关键词间不能有空格)， 表示搜索结果的标题都必须含有  <code>intitle:</code>  后的查询关键词，以帮助排除无关网页。</p>\n<blockquote>\n<p>intitle:静晴轩<br>intitle:天意人间舫</p>\n</blockquote>\n<p>这里可以补充说明的是：还可以加  <code>allintitle:</code>；如此搜索，返回的内容是，页面标题中包含多组关键词的页面。例如：allintitle:SEO 搜索引擎优化，就相当于：intitle:SEO intitle:搜索引擎优化，返回的是标题中既包含“SEO”，也包含“搜索引擎优化”的页面。</p>\n<h3 id=\"文件类型\"><a href=\"#文件类型\" class=\"headerlink\" title=\"文件类型\"></a>文件类型</h3><p>在搜索的时候，是可以指定文件格式的，指定格式用：filetype ，表示搜索特定的文件格式；如此一来，我们搜索出来的内容，就是指定格式文件（eg：PDF）。看姑姑(Google)是不是很贴心？</p>\n<blockquote>\n<p>代码大全 filetype:PDF<br>Clean Code filetype:PDF</p>\n</blockquote>\n<p>以上，只是 Google 搜索技巧中常用的几个，其他还有很多，比如：<code>inurl</code>， <code>inanchor</code>，<code>allinurl</code>诸次等等，更多玩法，可以参考知乎  <a href=\"https://www.zhihu.com/question/20161362\" target=\"_blank\" rel=\"noopener\">如何用好谷歌等搜索引擎？</a>；熟练运用，灵活搭配，从而大幅度提升工作效率，并更好地解决问题。此处需要补充的是，以上诸法，并非都适用于百度；即使支持，因为其自身缘由(比如收录不及时)，并不能很好的起到应有的效用。</p>\n<h2 id=\"插件扩展篇\"><a href=\"#插件扩展篇\" class=\"headerlink\" title=\"插件扩展篇\"></a>插件扩展篇</h2><p>当你发现，有人使用 Chrome，而插件扩展栏目，竟空空如也，你就知道：Ta 的业余是专业的，尤其是开发者。Chrome，以及很多主流工具，比如手机，Mac，编辑器等等，都是基于按需索取的理念，这才是一种更合理的存在。将更多功能，以插件、扩展的形式按需注入，不仅更合理地满足所有人所需，也给出了更多选择余地的同时，还能让软件本身更加轻盈体瘦。这一点需要讲明的是，如果说“小白”执意甘为小白，那么这里未有苦劝之义务。关于这部分，早先有在  <a href=\"https://jeffjade.com/2017/01/23/118-chrome_awesome_plug-in/?from=me\" target=\"_blank\" rel=\"noopener\">Awesome Chrome 插件集锦</a>一文中做过记载，并持续更新，此不赘述。</p>\n<p>这里还需郑重声明的是：欲要优雅地使用 Chrome，首先也得注册谷歌账号，并保持登录。登录使你所有的东西（书签，应用，扩展，浏览记录等），都可以保存到云端，如此在不同的环境（如家 or 公司）下可以方便的同步。试想，重装系统，或者换台电脑之后，如果要逐个去找之前装的扩展，保存的书签，这样的事情，怎能称不上优雅？不是么?</p>\n<h2 id=\"快捷操作篇\"><a href=\"#快捷操作篇\" class=\"headerlink\" title=\"快捷操作篇\"></a>快捷操作篇</h2><p>天下武功，唯快不破。掌握了搜索技巧，用对了合适插件，此为策略方法层面的事儿。这好比是在玩儿竞技游戏，能犀利而灵动的操作，也是取胜的关键。何况，在你的阵地上（Eg：电脑，浏览器，Terminal 等），手随脑动，运指如飞，是一件多么酷的存在。而这，只需划分一点点时间，了解之熟悉之，享受快捷中寻求进阶，假以时日，便可心指合一，臻至化界。</p>\n<p>首先，你需要了解其快捷键操作（常用），毕竟键盘操作，远比鼠标要迅捷且准确；这一点，Chrome 做的非常好，在于它跟很多软件操作习惯，是大致相同的（比如 Sublime），一通则百通。这个可以 在 Setting（F1 呼出） 项中的 Shortcuts 中查看。如果不符合固有操作习惯，也可以更改。然，欲穷千里目，则须更上一层楼；如要更为便捷的去操作，则强烈推荐  <code>Vimium</code>（或者 cVim），他们犀利的存在，好如游戏手柄，可以让你在 Chrome 上纵横捭阖；具体可以参见<a href=\"http://www.jeffjade.com/2015/10/19/2015-10-18-chrome-vimium/\" target=\"_blank\" rel=\"noopener\">Vimium~让您的 Chrome 起飞</a>。举例来说，比较常用  <code>r</code>  来刷新，<code>x</code>  来关闭当前，<code>t</code>  来新建标签，<code>gg</code>  回到页首等等；当然，这看起来方便的不是太多，可是有些需求，比如：你想拷贝当前标签页，一般操作可分为: ctrl+l  选中当前网址，然后  ctrl+c，ctrl+t  新建标签页之后  ctrl+v，最后还需  Enter  一回。如果使用  <code>Vimium</code>呢，只需  <code>yt</code>  即可，更可贵的在于，这还是深度拷贝，可将当前网页不仅是内容，还包括浏览历史，Session 等一并都复制了去，相比之下，真是贴心到了天际。</p>\n<p>当你在搜索引擎搜某关键词时，多半会展示有一堆列表，一一点开查看，这样的效率实在是不高；这时候，就可以借助  <a href=\"https://chrome.google.com/webstore/detail/linkclump/lfpjkncokllnfokkgpkobnkbkmelfefj?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">Linkclump</a>,一款用来批量打开多个网页链接的插件, 她能让你用鼠标框出你想打开的链接，就能在后台自动打开。这样的例子实在数不胜数，只要你足够懒，并积极探索与折腾，总能不断的提升效率，达至极致。</p>\n<p>除此外，还可以讲的是，很有必要管理好书签；你应该将其按一定规则，分门别类，放置于不同的书签夹中，以便自己清晰快速的检索。如果能略微记得，书签所存网址的个别单词，又完全可以借助  <code>Vimium</code>  去搜索，快捷键  <code>b(/B)</code>，分别是在当前页和新标签页打开，如此，效率的提升又进了一步，善哉。</p>\n<h2 id=\"使用技巧篇\"><a href=\"#使用技巧篇\" class=\"headerlink\" title=\"使用技巧篇\"></a>使用技巧篇</h2><p>强大如  Chrome，其亿万行代码的背后，存在着你无法想象的强大，如果你了解的越多，你越发深信这一点。倘若，你是一位有经验的开发者，你会明白，Chrome 不仅仅是一个浏览器那么简单。下面一起来学习下，Chrome 有哪些不为所致的技巧：</p>\n<ul>\n<li>Chrome 的隐身模式：  快捷键：Command + Shift + n （window 下是 Ctrl + Shift + N）。它的好处在于：保护你的隐私。具体表现为，在此窗口中查看的网页，不会显示在浏览器历史记录，或搜索历史记录中，关闭隐身窗口后，也不会在计算机上留下 Cookie 之类的其他痕迹（但会保留所有下载的文件或创建的书签）；明白这一点，浏览些不想让人知道内容，是不是多了许多大胆的自由呢？需要在意的是，事实上隐身模式并非是万能的，该注意的还得谨慎。</li>\n<li>Chrome 的 about 指令：  作为一个 Chrome 用户，你该懂得 Chrome 地址栏功能，这让你变得更像一个合格的主人。试着在 Chrome 地址栏，输入  <code>chrome://about/</code>，这会展示出：List of Chrome URLs，如下图所示：</li>\n</ul>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/list-of-chrome-urls.png\" target=\"_blank\" rel=\"noopener\" title=\"List of Chrome URLs\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/list-of-chrome-urls.png\" alt=\"List of Chrome URLs\"></a>List of Chrome URLs</p>\n<p>仔细研究的话，发现这其中有些十分有意思，也很有价值，一起来看几个：</p>\n<blockquote>\n<p>chrome://apps/ Chrome 网上应用商店<br>chrome://accessibility 查看浏览器当前访问的标签<br>chrome://appcache-internals/ 对 HTML5 应用的离线存储进行管理<br>chrome://cache/ Chrome 缓存（只读）<br>chrome://components/ 查看相关组件<br>chrome://dns/ 查看 DNS 记录<br>chrome://extensions/ 查看扩展程序<br>chrome://plugins/ 停用启用相关插件<br>chrome://omnibox/  能地址栏（强大啊，你输入“晚晴”试试？）<br>chrome://predictors/ URl 输入命中率（结合 omnibox 使用）<br>chrome://net-internals Chrome 的抓包工具<br>chrome://quota-internals/ 显示磁盘详细可用空间以及各个网站的使用配额<br>chrome://thumbnails/ 近期浏览的网站的首页快照（以相册的形式）<br>view-source:&lt;网页地址&gt; 显示网页的源代码<br>… …</p>\n</blockquote>\n<ul>\n<li>Tab 搜索：  支持 OpenSearch 的网站，在浏览器地址栏输入网址后，按 Tab 键，可在此网站内部进行搜索，这对部分 .com 结尾网站有效。例如地址栏输入“zhihu.com”，然后按一下 Tab 键，直接在知乎内部进行搜索，相当于  <code>site:zhihu.com</code>。</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>已经在很多工具类文章前言中，提及使用工具的重要性；以至于在写这篇时候，大为窘迫：穷尽了脑海中那些名句箴言，目测都已然在先前文章中被引用。鉴于杳让人心底意识到工具的重要性，并且能践行之，远比介绍如何使用重要的多，所以，开篇之前，还是得再次重申：工欲善其事，必先利其器。如能领悟，善莫大焉；然而根据长期观察，这个现状并不容乐观，所以就有了这篇文章的存在；毕竟<a href=\"https://jeffjade.com/\" target=\"_blank\" rel=\"noopener\">晚晴幽草轩</a>有部分职责，就是作为经世致用的布道者般的存在。</p>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/E799BDE587A4.jpg\" target=\"_blank\" rel=\"noopener\" title=\"如何更好地使用 Chrome (Google)\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/E799BDE587A4.jpg\" alt=\"如何更好地使用 Chrome (Google)\"></a>如何更好地使用 Chrome (Google)</p>\n<blockquote>\n<p>微注：  写博，本就不是易事，非朝夕可至，尤其这种整理总结性文章；故此，这里将采取阶段性更新手法，一来防止了拖延之；二来，也能不断学习提炼，减少内容的错误误导，三来，也是防止些许聚合网恶意抓取的尝试。（Update @2017-05-16）</p>\n</blockquote>\n<h2 id=\"科学上网篇\"><a href=\"#科学上网篇\" class=\"headerlink\" title=\"科学上网篇\"></a>科学上网篇</h2><p>使用浏览器，懂得如何去科学上网，这一点再重要不过了（个别浏览器除外，有些浏览器的存在，就只是用来下载其他浏览器的，大家都懂得）。其中，这首要的的就是选择合适搜索引擎。在国内，倒是有那么几家可选，譬如百度，360，搜狗，Bing 等等，搜索写娱乐八卦什么的，倒也无妨。但是，要搜索些专业性、原味性的干货，你当知道，此时该选择谷歌(Google)，这就跟饿了知道该吃饭一般；然而，这在我国大陆，多半只存在于好的程序员之间。然后就是如何能使用谷歌（Google）了——须翻墙，你知道在国内，无法直接使用 Google 搜索（略大型点的科技公司除外）。</p>\n<p>谈起这翻墙，可供选择的办法就很多了。愿意花钱的话，购买个靠谱的 VPN 即可。需要流量不是很多，则可以选择像  <a href=\"https://github.com/getlantern/lantern\" target=\"_blank\" rel=\"noopener\">lantern (蓝灯)</a>这样产品，据悉每天可有几百兆可供使用。不怕麻烦的话，大可到网上搜索，时常会有些好心人，贡献出些 Shadowsocks 免费服务，只不过，这好比像是在打游击，时间长了既累也烦。倒不如，自己动手，丰衣足食。稍微一折腾，即可自己搭建一套 VPS ，来达到科学上网的目的，这里推荐使用 Shadowsocks，对于它的使用，在<a href=\"https://github.com/shadowsocks/shadowsocks/wiki/Shadowsocks-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E\" target=\"_blank\" rel=\"noopener\">Shadowsocks 使用说明</a>，已经写明，为确保文章完整性，特此补充一份心得：</p>\n<h3 id=\"搭建-Shadowsocks-服务器\"><a href=\"#搭建-Shadowsocks-服务器\" class=\"headerlink\" title=\"搭建 Shadowsocks 服务器\"></a>搭建 Shadowsocks 服务器</h3><p>首先需要一台服务器(这得是国外的)，推荐使用  <a href=\"https://m.do.co/c/046a8e6b255c\" target=\"_blank\" rel=\"noopener\">DigitalOcean</a>；注册，完成 SSH 配置（具体操作可参考  <a href=\"https://jeffjade.com/2015/06/26/2015-06-26-ssh-setting/\" target=\"_blank\" rel=\"noopener\">如何设置添加 SSH</a>），直接用 root 用户登录即可：</p>\n<blockquote>\n<p>ssh root@your_server_ip</p>\n</blockquote>\n<ul>\n<li>安装 Shadowsocks 服务端</li>\n</ul>\n<p>运行以下命令即可快速安装(For Debian / Ubuntu System)：</p>\n<blockquote>\n<p>apt-get install python-pip<br>pip install shadowsocks<br>apt-get install ssserver</p>\n</blockquote>\n<ul>\n<li>配置 Shadowsocks 服务端<br>安装好 Shadowsocks 以后，可以通过以下指令，来启动 Shadowsocks 服务：</li>\n</ul>\n<p>1</p>\n<p>ssserver -p 8836 -k yourPassword -m rc4-md5</p>\n<p>以上这种法子，诸多不便，推荐使用配置文件来操纵；新建配置文件，运行命令  <code>vim /etc/shadowsocks.json</code></p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>{</p>\n<p>“server”:”your_server_ip”,</p>\n<p>“server_port”:8388,</p>\n<p>“password”:”yourpassword”,</p>\n<p>“timeout”:300,</p>\n<p>“method”:”aes-256-cfb”,</p>\n<p>“fast_open”:false,</p>\n<p>“workers”: 1</p>\n<p>}</p>\n<blockquote>\n<p>server：服务器 IP 地址 (IPv4/IPv6)<br>server_port：服务器监听的端口，一般设为 80，443 等，注意不要设为使用中的端口<br>password：设置密码，自定义<br>timeout：超时时间（单位：秒）<br>method：加密方法，可选择 “aes-256-cfb”, “rc4-md5”等等。推荐使用 “rc4-md5”<br>fast_open：true 或 false。如果你的服务器 Linux 内核在 3.7+，可以开启 fast_open 以降低延迟。<br>workers：workers 数量，默认为 1。</p>\n</blockquote>\n<p>备注：亦配置多个 Shadowsocks 账户，具体可以参考如下的代码配置：</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>11</p>\n<p>12</p>\n<p>13</p>\n<p>{</p>\n<p>“server”:”your_server_ip”,</p>\n<p>“port_password”:{</p>\n<p>“8001”:”pass01”,</p>\n<p>“8002”:”pass02”,</p>\n<p>“8003”:”pass03”,</p>\n<p>“8004”:”pass04”</p>\n<p>},</p>\n<p>“timeout”:60,</p>\n<p>“method”:”rc4-md5”,</p>\n<p>“fast_open”:false,</p>\n<p>“workers”:1</p>\n<p>}</p>\n<p>接下来,你就可以使用下面这个指令启动服务咯，是不是很简单？</p>\n<p>1</p>\n<p>ssserver -c /etc/shadowsocks.json</p>\n<ul>\n<li>下载 Shadowsocks 客户端并填入<br>这里没什么好介绍的，Shadowsocks 的客户端支持各大主流平台，而且客户端的配置相当简单；下载之，填入需要对应的: 服务器 IP，端口，密码，加密方式，即可；至此就可以在浩瀚无垠的网上浪起来了。Shadowsocks 客户端下载地址传送门：<a href=\"https://sourceforge.net/projects/shadowsocksgui/files/dist/\" target=\"_blank\" rel=\"noopener\">OS X</a>、 <a href=\"https://sourceforge.net/projects/shadowsocksgui/files/dist/\" target=\"_blank\" rel=\"noopener\">Windows</a>、 <a href=\"https://github.com/shadowsocks/shadowsocks/wiki/Ports-and-Clients#android\" target=\"_blank\" rel=\"noopener\">Android</a>、<a href=\"https://github.com/shadowsocks/shadowsocks-iOS/wiki/Help\" target=\"_blank\" rel=\"noopener\">IOS</a>。</li>\n</ul>\n<hr>\n<p>【做个补充】：运用命令  <code>ssserver -c /etc/shadowsocks.json</code>  来开启服务，很不方便，一旦退出服务器，下次就得再次开启。于此，Shadowsocks 也提供了后台运行的命令：</p>\n<p>1</p>\n<p>2</p>\n<p>ssserver -c /etc/shadowsocks.json -d start</p>\n<p>ssserver -c /etc/shadowsocks.json -d stop</p>\n<p>然而在真正实施上，却会遭遇报错：<a href=\"https://github.com/shadowsocks/shadowsocks/issues/320\" target=\"_blank\" rel=\"noopener\">option -d not recognized</a>，根据 Issues 给出的回答，唯有升级版本才能解决该问题。而事实上，shadowsocks 开源库，已经根据规定被移除（Removed according to regulations）。折腾再三，幸而找见了更好的衍生产品： <a href=\"https://github.com/shadowsocks/shadowsocks-libev\" target=\"_blank\" rel=\"noopener\">shadowsocks-libev</a> —— 一个纯 C 实现，并且对于数千个连接而言具有非常小的占用空间（几兆字节），用于嵌入式设备和低端盒的轻量级的安全 SOCKS5 代理；值得推荐使用。对于安装和配置也都挺方便，如果你是 Ubuntu 14.04 and 16.04 使用者的话：</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>4</p>\n<p>5</p>\n<p>6</p>\n<p>7</p>\n<p>8</p>\n<p>9</p>\n<p>10</p>\n<p>11</p>\n<p>12</p>\n<p>13</p>\n<p>14</p>\n<p>15</p>\n<p>16</p>\n<p>17</p>\n<p>18</p>\n<p>// install from PPA</p>\n<p>sudo add-apt-repository ppa:max-c-lv/shadowsocks-libev</p>\n<p>sudo apt-get update</p>\n<p>sudo apt install shadowsocks-libev</p>\n<p>// Build deb package from source</p>\n<p>mkdir -p ~/build-area/</p>\n<p>cp ./scripts/build_deb.sh ~/build-area/</p>\n<p>cd ~/build-area</p>\n<p>./build_deb.sh</p>\n<p>// Configure and start the service（配置，同上文所讲）</p>\n<p># Edit the configuration file</p>\n<p>sudo vim /etc/shadowsocks-libev/config.json</p>\n<p># Start the service</p>\n<p>sudo /etc/init.d/shadowsocks-libev start # for sysvinit, or</p>\n<p>sudo systemctl start shadowsocks-libev # for systemd</p>\n<p>如此，简单的一次操作之后，就能长久的欢乐嗨皮了；更多系统的安装配置方法，请自行参见  <a href=\"https://github.com/shadowsocks/shadowsocks-libev\" target=\"_blank\" rel=\"noopener\">shadowsocks-libev</a>。还需要提及的是，使用这个库，也有些弊端性，就是不能方便的支持多端口，可以参见<a href=\"https://github.com/shadowsocks/shadowsocks-libev/issues/5\" target=\"_blank\" rel=\"noopener\">issues/#5</a>；可以有的办法是，启用多个配置来曲线达成所愿，操作方法如下：</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<p>ss-server -c config1.json -f pid1</p>\n<p>ss-server -c config2.json -f pid2</p>\n<p>ss-server -c config3.json -f pid3</p>\n<p>如此即可；也可通过运行  <code>netstat -tlnp</code>  命令，查看 ss-server 是否监听了多个配置文件的端口。如果略嫌这样操作麻烦的话，也可以用 Shadowsocks 的 Go 版本 —— <a href=\"https://github.com/shadowsocks/shadowsocks-go\" target=\"_blank\" rel=\"noopener\">shadowsocks-go</a>，它更为方便的支持多端口的设置（update@2017-05-15）。</p>\n<hr>\n<blockquote>\n<p>有个广告：  突入一则利人利己的广告：服务器推荐使用  <a href=\"https://m.do.co/c/046a8e6b255c\" target=\"_blank\" rel=\"noopener\">DigitalOcean</a>, 它简单灵活、价格公道(最低 5$/月)，童叟无欺，可免费试用 30 天。堪称业界良心。此处广告的缘由在于，你若有意使用它，不妨用我的专属推荐链接  <a href=\"https://m.do.co/c/046a8e6b255c\" target=\"_blank\" rel=\"noopener\">DigitalOcean For JeffJade</a>，注册即可获得 10 美刀，当花费了 25 美刀，我就可获取 25 美刀；如有意向，不妨一试；用上一年，算下来每天也不到一元。欲查看更多广告，请<a href=\"https://jeffjade.com/Links?form=me\" target=\"_blank\" rel=\"noopener\">点击我</a>。</p>\n</blockquote>\n<hr>\n<h2 id=\"搜索技巧篇\"><a href=\"#搜索技巧篇\" class=\"headerlink\" title=\"搜索技巧篇\"></a>搜索技巧篇</h2><h3 id=\"精确搜索\"><a href=\"#精确搜索\" class=\"headerlink\" title=\"精确搜索\"></a>精确搜索</h3><p>精确搜索，就是搜索的关键字用<code>“”</code>（双引号，中英文皆可）包含。也叫完整搜索，表示查询词不能被拆分，在搜索结果中必须完整出现。举例说明：</p>\n<blockquote>\n<p>“胜天半子，其又奈何”<br>胜天半子，其又奈何</p>\n</blockquote>\n<p>前者搜索出来的内容，就是必须包含指定关键字；如果没有查询到任何内容，Google 会在下方给出不包含引号的结果。后者，搜索的内容，是关键词以一定规则被拆分的结果。</p>\n<h3 id=\"模糊搜索\"><a href=\"#模糊搜索\" class=\"headerlink\" title=\"模糊搜索\"></a>模糊搜索</h3><p>星号（<code>*</code>） 是常用的通配符，也可以用在搜索中，实现模糊匹配搜索。比如在 Google 中搜索：<code>&quot;搜索*擎&quot;</code>，精确模糊，搭配使用，效果更显著。其中的  <code>*</code>  号代表任何文字。返回的结果就不仅包含“搜索引擎”，还包含了“搜索收擎”，“搜索巨擎”等内容。</p>\n<h3 id=\"站内搜索\"><a href=\"#站内搜索\" class=\"headerlink\" title=\"站内搜索\"></a>站内搜索</h3><p>顾名思义，就是我们可以指定仅在某个站点下搜索，这很有用，可以加快定位出你想要的内容；而且也可以用它来替代些许论坛 or 博客自带的站内搜索。譬如，我自己就常这样使用：</p>\n<blockquote>\n<p>site:jeffjade.com 数组<br>site:ruanyifeng.com npm</p>\n</blockquote>\n<h3 id=\"排除搜索\"><a href=\"#排除搜索\" class=\"headerlink\" title=\"排除搜索\"></a>排除搜索</h3><p>如果你想更精确你的搜索，此法大有可为；在想搜索结果中不包含某个词，就在该词的前面加一个 -（减号，⚠️ 这个得是半角英文，并和之后的词得连着，不能有空格）。表示所有搜索结果不包含减号后面的词，含有它的网页将被过滤掉。举例说明，ListView 控件在 Android 跟 React Native 都会含有，如果你想要更精确你的结果，即可屏蔽掉另一方，相这样：</p>\n<blockquote>\n<p>ListView -Android<br>ListView -ReactNative // (这 React Native 得连起来，否则会被拆分)</p>\n</blockquote>\n<h3 id=\"标题中搜索\"><a href=\"#标题中搜索\" class=\"headerlink\" title=\"标题中搜索\"></a>标题中搜索</h3><p>这标题中搜索，即在查询的关键字前面加上  <code>intitle:</code> (冒号得是半角英文，且与关键词间不能有空格)， 表示搜索结果的标题都必须含有  <code>intitle:</code>  后的查询关键词，以帮助排除无关网页。</p>\n<blockquote>\n<p>intitle:静晴轩<br>intitle:天意人间舫</p>\n</blockquote>\n<p>这里可以补充说明的是：还可以加  <code>allintitle:</code>；如此搜索，返回的内容是，页面标题中包含多组关键词的页面。例如：allintitle:SEO 搜索引擎优化，就相当于：intitle:SEO intitle:搜索引擎优化，返回的是标题中既包含“SEO”，也包含“搜索引擎优化”的页面。</p>\n<h3 id=\"文件类型\"><a href=\"#文件类型\" class=\"headerlink\" title=\"文件类型\"></a>文件类型</h3><p>在搜索的时候，是可以指定文件格式的，指定格式用：filetype ，表示搜索特定的文件格式；如此一来，我们搜索出来的内容，就是指定格式文件（eg：PDF）。看姑姑(Google)是不是很贴心？</p>\n<blockquote>\n<p>代码大全 filetype:PDF<br>Clean Code filetype:PDF</p>\n</blockquote>\n<p>以上，只是 Google 搜索技巧中常用的几个，其他还有很多，比如：<code>inurl</code>， <code>inanchor</code>，<code>allinurl</code>诸次等等，更多玩法，可以参考知乎  <a href=\"https://www.zhihu.com/question/20161362\" target=\"_blank\" rel=\"noopener\">如何用好谷歌等搜索引擎？</a>；熟练运用，灵活搭配，从而大幅度提升工作效率，并更好地解决问题。此处需要补充的是，以上诸法，并非都适用于百度；即使支持，因为其自身缘由(比如收录不及时)，并不能很好的起到应有的效用。</p>\n<h2 id=\"插件扩展篇\"><a href=\"#插件扩展篇\" class=\"headerlink\" title=\"插件扩展篇\"></a>插件扩展篇</h2><p>当你发现，有人使用 Chrome，而插件扩展栏目，竟空空如也，你就知道：Ta 的业余是专业的，尤其是开发者。Chrome，以及很多主流工具，比如手机，Mac，编辑器等等，都是基于按需索取的理念，这才是一种更合理的存在。将更多功能，以插件、扩展的形式按需注入，不仅更合理地满足所有人所需，也给出了更多选择余地的同时，还能让软件本身更加轻盈体瘦。这一点需要讲明的是，如果说“小白”执意甘为小白，那么这里未有苦劝之义务。关于这部分，早先有在  <a href=\"https://jeffjade.com/2017/01/23/118-chrome_awesome_plug-in/?from=me\" target=\"_blank\" rel=\"noopener\">Awesome Chrome 插件集锦</a>一文中做过记载，并持续更新，此不赘述。</p>\n<p>这里还需郑重声明的是：欲要优雅地使用 Chrome，首先也得注册谷歌账号，并保持登录。登录使你所有的东西（书签，应用，扩展，浏览记录等），都可以保存到云端，如此在不同的环境（如家 or 公司）下可以方便的同步。试想，重装系统，或者换台电脑之后，如果要逐个去找之前装的扩展，保存的书签，这样的事情，怎能称不上优雅？不是么?</p>\n<h2 id=\"快捷操作篇\"><a href=\"#快捷操作篇\" class=\"headerlink\" title=\"快捷操作篇\"></a>快捷操作篇</h2><p>天下武功，唯快不破。掌握了搜索技巧，用对了合适插件，此为策略方法层面的事儿。这好比是在玩儿竞技游戏，能犀利而灵动的操作，也是取胜的关键。何况，在你的阵地上（Eg：电脑，浏览器，Terminal 等），手随脑动，运指如飞，是一件多么酷的存在。而这，只需划分一点点时间，了解之熟悉之，享受快捷中寻求进阶，假以时日，便可心指合一，臻至化界。</p>\n<p>首先，你需要了解其快捷键操作（常用），毕竟键盘操作，远比鼠标要迅捷且准确；这一点，Chrome 做的非常好，在于它跟很多软件操作习惯，是大致相同的（比如 Sublime），一通则百通。这个可以 在 Setting（F1 呼出） 项中的 Shortcuts 中查看。如果不符合固有操作习惯，也可以更改。然，欲穷千里目，则须更上一层楼；如要更为便捷的去操作，则强烈推荐  <code>Vimium</code>（或者 cVim），他们犀利的存在，好如游戏手柄，可以让你在 Chrome 上纵横捭阖；具体可以参见<a href=\"http://www.jeffjade.com/2015/10/19/2015-10-18-chrome-vimium/\" target=\"_blank\" rel=\"noopener\">Vimium~让您的 Chrome 起飞</a>。举例来说，比较常用  <code>r</code>  来刷新，<code>x</code>  来关闭当前，<code>t</code>  来新建标签，<code>gg</code>  回到页首等等；当然，这看起来方便的不是太多，可是有些需求，比如：你想拷贝当前标签页，一般操作可分为: ctrl+l  选中当前网址，然后  ctrl+c，ctrl+t  新建标签页之后  ctrl+v，最后还需  Enter  一回。如果使用  <code>Vimium</code>呢，只需  <code>yt</code>  即可，更可贵的在于，这还是深度拷贝，可将当前网页不仅是内容，还包括浏览历史，Session 等一并都复制了去，相比之下，真是贴心到了天际。</p>\n<p>当你在搜索引擎搜某关键词时，多半会展示有一堆列表，一一点开查看，这样的效率实在是不高；这时候，就可以借助  <a href=\"https://chrome.google.com/webstore/detail/linkclump/lfpjkncokllnfokkgpkobnkbkmelfefj?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">Linkclump</a>,一款用来批量打开多个网页链接的插件, 她能让你用鼠标框出你想打开的链接，就能在后台自动打开。这样的例子实在数不胜数，只要你足够懒，并积极探索与折腾，总能不断的提升效率，达至极致。</p>\n<p>除此外，还可以讲的是，很有必要管理好书签；你应该将其按一定规则，分门别类，放置于不同的书签夹中，以便自己清晰快速的检索。如果能略微记得，书签所存网址的个别单词，又完全可以借助  <code>Vimium</code>  去搜索，快捷键  <code>b(/B)</code>，分别是在当前页和新标签页打开，如此，效率的提升又进了一步，善哉。</p>\n<h2 id=\"使用技巧篇\"><a href=\"#使用技巧篇\" class=\"headerlink\" title=\"使用技巧篇\"></a>使用技巧篇</h2><p>强大如  Chrome，其亿万行代码的背后，存在着你无法想象的强大，如果你了解的越多，你越发深信这一点。倘若，你是一位有经验的开发者，你会明白，Chrome 不仅仅是一个浏览器那么简单。下面一起来学习下，Chrome 有哪些不为所致的技巧：</p>\n<ul>\n<li>Chrome 的隐身模式：  快捷键：Command + Shift + n （window 下是 Ctrl + Shift + N）。它的好处在于：保护你的隐私。具体表现为，在此窗口中查看的网页，不会显示在浏览器历史记录，或搜索历史记录中，关闭隐身窗口后，也不会在计算机上留下 Cookie 之类的其他痕迹（但会保留所有下载的文件或创建的书签）；明白这一点，浏览些不想让人知道内容，是不是多了许多大胆的自由呢？需要在意的是，事实上隐身模式并非是万能的，该注意的还得谨慎。</li>\n<li>Chrome 的 about 指令：  作为一个 Chrome 用户，你该懂得 Chrome 地址栏功能，这让你变得更像一个合格的主人。试着在 Chrome 地址栏，输入  <code>chrome://about/</code>，这会展示出：List of Chrome URLs，如下图所示：</li>\n</ul>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/list-of-chrome-urls.png\" target=\"_blank\" rel=\"noopener\" title=\"List of Chrome URLs\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/list-of-chrome-urls.png\" alt=\"List of Chrome URLs\"></a>List of Chrome URLs</p>\n<p>仔细研究的话，发现这其中有些十分有意思，也很有价值，一起来看几个：</p>\n<blockquote>\n<p>chrome://apps/ Chrome 网上应用商店<br>chrome://accessibility 查看浏览器当前访问的标签<br>chrome://appcache-internals/ 对 HTML5 应用的离线存储进行管理<br>chrome://cache/ Chrome 缓存（只读）<br>chrome://components/ 查看相关组件<br>chrome://dns/ 查看 DNS 记录<br>chrome://extensions/ 查看扩展程序<br>chrome://plugins/ 停用启用相关插件<br>chrome://omnibox/  能地址栏（强大啊，你输入“晚晴”试试？）<br>chrome://predictors/ URl 输入命中率（结合 omnibox 使用）<br>chrome://net-internals Chrome 的抓包工具<br>chrome://quota-internals/ 显示磁盘详细可用空间以及各个网站的使用配额<br>chrome://thumbnails/ 近期浏览的网站的首页快照（以相册的形式）<br>view-source:&lt;网页地址&gt; 显示网页的源代码<br>… …</p>\n</blockquote>\n<ul>\n<li>Tab 搜索：  支持 OpenSearch 的网站，在浏览器地址栏输入网址后，按 Tab 键，可在此网站内部进行搜索，这对部分 .com 结尾网站有效。例如地址栏输入“zhihu.com”，然后按一下 Tab 键，直接在知乎内部进行搜索，相当于  <code>site:zhihu.com</code>。</li>\n</ul>\n"},{"title":"字符串方法","date":"2018-02-26T03:02:00.000Z","_content":"\n## 前言:\n\n> 在平常的数据解析中，数组，字符串，对象是必不可少的三种类型，今天就字符串的一些常用方法做一个整理，每个方法对应都会相应的示例，不仅是为了能够让大家一目了然，节约时间，更是为了以后自己以后也方便查阅！ （在下面的方法中，有解析错误的地方，还望大家提出意见或建议，感谢！）\n\n## 0、从原始字符串到模版字面量\n\n### （1.）我们原来使用的字符串：\n\n```\n    `hello world` `hello! world!` `hello ${who}` escape `${who}`\n```\n\n> 字符串不区分单引号' '和双引号\" \"所有的字符串拼接都会识别，如果你的字符串比较长，可分行使用“+”来拼接。\n\n例如：\n\n```\n        let longString = \"This is a very long string which needs \" +\n                            \"to wrap across multiple lines because \" +\n                            \"otherwise my code is unreadable.\";\n\n        console.log(longString);\n\n      //  \"This is a very long string which needs to wrap across multiple lines because otherwise my code is unreadable.\"\n```\n\n> 或者也可以使用 \"\\\\\" 来告诉浏览器，你需要继续写这个字符串，但需要保证 \"\\\\\"后面是没有任何符号或者是空格的；\n\n    例如：\n\n```\n    let longString = \"This is a very long string which needs \\\n    to wrap across multiple lines because \\\n    otherwise my code is unreadable.\";\n\n    console.log(longString)\n\n    // \"This is a very long string which needs to wrap across multiple lines because otherwise my code is unreadable.\"\n```\n\n**以前，我们用单引号或双引号表示字符串。**\n\n```\n    let a = '123';  //单引号\n\n\n    let b = \"123\"; //双引号\n```\n\n### （2.）我们现在使用的模板字面量:\n\n**现在，使用模板字面量反撇号``。在实际开发中，这是经常都要用到的方法。**\n\n```\n    let c = `123` //反撇号\n```\n\n**在字符串中使用反撇号，只需要加上转义符 ，这时中间的 `，没有什么意义：**\n\n```\n    let d = `12\\`3` //字符串内插入反撇号的方式。  //   \"12`3\"\n```\n\n**在多行字符串的使用价值：**\n\n**在没有模板字面量的时候，我们要实现多行字符串，必须用到换行符：**\n\n```\n    let a = '123\\n456';\n    console.log(a);\n    // 123\n    // 456\n```\n\n使用模板字面量，就可以非常简单的实现需求。\n\n```\n    let a = `123\n    456`;\n\n    console.log(a)       //      123\n                         //      456\n```\n\n**在模板字面量插入变量的方法**\n\n> 在原来的我们要在字符串中拼接变量，需要用‘\\+变量\\+’或者 \\+ 来实现，而现在 而是使用\\${params}直接插入你需要添加到字符串的位置。这种方式也叫作字符串占位符。占位符支持互相嵌套模板字面量，强大吧。有了它，我们终于可以抛弃 + 拼接字符串的恶心做法了。\n\n**字符串和变量拼接：**\n\n```\n    var str=\"xiaoming\";\n    console.log(`wo shi ${str0}`)   // \"wo shi xiaoming\"\n```\n\n**变量和变量拼接：**\n\n```\n    var str0=\"wo shi \";\n    var str=\"xiaoming\";\n    console.log(str0+`${str}`)      // wo shi xiaoming\n```\n\n模板字面量的终极用法`tag`是一个方法，方法名你可以任意命名，这种写法被称作标签模板。\n\n```\n    function tag(literals, ...substitutions) {\n        //literals是数组，第一个位置是\"\"，第二个位置是占位符之间的字符串，在本例中是haha\n        //substitutions是字符串中的模板字面量，可能多个\n\n        //函数最终返回字符串\n    }\n```\n\n## 1、charAt() 根据下标查询访问字符串的某个字符\n\n在 1 个字符串中，我们知道某个字符的索引值，那么就可以通过索引值来获取当前字符\n\n    例如：\n\n```\n    var str1=\"age\";\n    console.log(str1.charAt(2))  //  e\n\n    // 还可以使用  [ ] 的形式来访问,中括号填写的是字符串的下标\n\n    var str1=\"age\";\n    console.log(str1[2])       //  e\n```\n\n## 2、字符串的比较\">\" , \"<\"  ,\"===\"  ,\">=\" ,\"<=\" ,\"!==\"\n\n    (1).字母字符串比较，会先转成ascii码，再进行比较\n\n    var str1=\"aa\";\n    var str2=\"bb\";\n    console.log(str1true\n\n    (2).数字字符串比较（会比较两个数字的大小）\n\n    var str1=\"10\";\n    var str2=\"15\";\n    var str3=\"10\";\n    console.log(str1true,true\n\n## 3、字符串的长度 length\n\n在我们之前只使用过数组的`length`来判断，更改，清空数组等，这次我们来看一下字符串的`length`。 例如：\n\n    var str=\"我爱你中国\";\n\n    console.log(str.length)   // 5\n\n**`string` 的`length` 是只读属性,下面我们做一下验证：**\n\n    var str=\"This is an apple\";\n\n    console.log(str.length)   //  16\n\n    str.length=5;\n\n    console.log(str.length)  //  16\n\n## 4、charCodeAt(index) 返回表示给定索引的字符的 Unicode 的值。\n\n> 方法返回 0 到 65535 之间的 `UTF-16` 编码单元匹配 `Unicode` 编码单元整数，当`charCodeAt()`括号中没有值时，默认为查询字符串首位的位置;当有参数时，查询的是字符串的索引值， `index`的值为一个大于等于 0，小于字符串长度的整数。\n\n例：\n\n    var  str=\"abc\";\n    console.log(str.charCodeAt())        //  97\n\n    var  str=\"abc\";\n    console.log(str.charCodeAt(0))       //  97\n\n**结果都是一样的，查询到\"a\"在编码中的位置为 97**\n\n    var  str=\"abc\";\n    console.log(str.charCodeAt(1))      //  98\n\n**字母\"b\"在编码中的位置为 98**\n\n## 5、str.concat（str1,str2....）字符串拼接\n\n**在字符串拼接中，最常用的还是“+”；**\n\n    var str = \"d\";\n    var str1 = \"e\";\n    var str2 = \"f\";\n    var str3 = str+str1+str2;\n    console.log(str3)              //  \"def\"\n\n**当然我们也可以使用**`concat(....)`\n\n    var str1 = \"a\";\n    var str2 = \"b\";\n    var str3 = \"c\";\n    console.log(str1.concat(str2,str3))  // \"abc\"\n\n## 6、includes（str）检测一个字符串是否在另一个字符串里包含，区分大小写\n\n例： 我们测试`def` 是否在字符串`str`中\n\n    var str=\"abcdef\";\n    console.log(str.includes(\"def\"));     //  true\n\n**而我们把“def”换成大写的“DEF”时，并不能检测到**\n\n    var str=\"abcdef\";\n    console.log(str.includes(\"DEF\"));     //  false\n\n## 7、endsWith() 检测字符串是不是以“str”结尾的\n\n    str.endsWith(searchString [, position]);\n\n\n    searchString 要搜索的子字符串。\n\n\n    position 在 str 中搜索 searchString 的结束位置\n\n`position` 当不填写值时，默认值为`str.length`，也就是真正的字符串结尾处，从`1`开始，空格和符号也算字符。 也是开始的位置。\n\n例：\n\n**1、当没有第二个参数时。默认第二个参数为字符串的**`length`\n\n    var str = \"To be, or not to be, that is the question.\";\n    console.log(str.endsWith(\"question.\"))    // true\n\n**2、 第二个参数的开始时从“1”开始的，而不是从“0”**\n\n    var str = \"To be, or not to be, that is the question.\";\n    console.log(str.endsWith(\"T\",1))         // true;\n\n**3、第二个参数的计算是包含空格和标点符号的**\n\n    var str = \"To be, or not to be, that is the question.\";\n    console.log(str.endsWith(\"To be\", 5))    // true\n\n## 8、`indexOf()`方法返回`str`查找的结果，如果是有返回指定索引（查找到结果的第一个字符的位置），如果没有返回“-1”，区别大小写\n\n例：\n\n    \"ABC\".indexOf(\"A\")    // 0 查询到“A”,返回位置为索引“0”\n\n    \"ABC\".indexOf(\"e\")    // -1并没有查询到“e”,返回-1\n\n    \"ABC\".indexOf(\"AB\")   // 0 如果查询连续字符，返回连续字符的首位位置\n\n**检测是否存在某字符串:**\n\n当检测某个字符串是否存在于另一个字符串中时，可使用下面的方法：\n\n    \"Blue Whale\".indexOf(\"Blue\") !== -1; // true\n    \"Blue Whale\".indexOf(\"Bloe\") !== -1; // false\n\n> 使用 indexOf 统计一个字符串中某个字母出现的次数 在下例中，设置了 count 来记录字母 e 在字符串 str 中出现的次数：\n\n    var str = 'To be, or not to be, that is the question.';\n    var count = 0;\n    var pos = str.indexOf('e');\n        while (pos !== -1) {\n            count++;\n            pos = str.indexOf('e', pos + 1);\n    //重新给pos赋值，从上个查询到str的位置+1的位置继续查找，如果能查到就会再进循环，count+1\n        }\n\n    console.log(count);   // 4\n\n## 9、`lastIndexOf()`方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回-1\n\n    str.lastIndexOf(searchValue[, fromIndex])\n\n参数:\n\n    searchValue  一个字符串，表示被查找的值。\n\n\n    fromIndex  从调用该方法字符串的此位置处开始查找。可以是任意整数。默认值为 str.length。如果为负值，则被看作 0。如果 fromIndex > str.length，则 fromIndex 被看作 str.length。\n\n例： **当只有一个参数的时候，第二个值默认 str.length,也就是查询整个字符串，查找到这个 str 在整个字符串中最后出现的位置**\n\n    \"AVBDHIUOKL\".lastIndexOf(\"O\");     //7\n\n    \"AFGHJKLL:JJHKAJALKA\".lastIndexOf(\"A\");   //18\n\n**当有第二个参数时，第二个参数会被看成查询这个字符串的结束位置**\n\n    //从0到第10个索引值时，只在0的位置查询到\"A\",所以返回0\n\n    \"AFGHJKLL:JJHKAJALKA\".lastIndexOf(\"A\",10);  // 0\n\n    //从0到第15个索引值时，在第15的位置查询到\"A\",所以返回15\n\n    \"AFGHJKLL:JJHKAJALKA\".lastIndexOf(\"A\",15);  // 15\n\n## 10、`str.repeat(count)`构造并返回一个新字符串，该字符串是循环完成后的新字符串\n\n`repeat(count)`的值一般为数字，就好比`\"a\".repeat(5)==\"a\"*5==\"aaaaa\"`, 但也会出现其他情况，例如以下：\n\n**1.当值为“-1”时，会报错，所以值不能为负数。**\n\n    \"abc\".repeat(-1)\n    // RangeError: repeat count must be positive and less than inifinity\n\n**2.那我们值为“0”时，会有什么情况呢？将不会循环，返回一个空字符串。**\n\n    \"abc\".repeat(0)   // \"\"\n\n**3.那么我们接下来输入一个正常的数字“1”，`repeat`给我们返回了`\"abc\"*1`的结果,它将循环一遍。**\n\n    \"abc\".repeat(1)   // \"abc\"\n\n**4.那么我们试试“2”，看看会不会返回循环两次，确实它返回了字符串循环两遍的结果。**\n\n    \"abc\".repeat(2)  // \"abcabc\"\n\n**5.那我们来试试小数，看看是循环几次呢，结果是它将小数点后面的抹去了，只循环了前面的数字。**\n\n    \"abc\".repeat(3.5)  // \"abcabcabc\" 参数count将会被自动转换成整数.\n\n**6.那我们试试“1/0 ”，并没有解析出来，因为**`1/0==inifinity`\n\n    \"abc\".repeat(1/0)\n    // RangeError: repeat count must be positive and less than inifinity\n\n**7.那我们再来试试字符串呢？结果它将字符串自动转为了 number,并正确循环并返回了。**\n\n    \"abcd\".repeat(\"2\")   // \"abcabc\"\n\n**8.看看它是否能解析中文汉字呢？ 结果是并没有，也没有报错。**\n\n    \"abcd\".repeat(\"二\")   // \"\"\n\n## 11、str.slice(beginSlice,endSlice)截取字符串，第一个参数为开始位置，第二个参数为结束位置，前包后不包\n\n**1.`slice()`从一个字符串中提取字符串并返回新字符串。在一个字符串中的改变不会影响另一个字符串。也就是说，`slice`不修改原字符串，只会返回一个包含了原字符串中部分字符的新字符串。**\n\n    var str = \"avxdsdfasd\";\n    var str2 = str.slice(1, 4);\n\n    console.log(str,str2)  //  \"avxdsdfasd\",\"vxd\"\n\n**2.注意：`slice()` 提取的新字符串包括`beginSlice`但不包括 `endSlice`。**\n\n    var str = \"avxdsdfasd\";\n    var str2 = str.slice(0,2);\n\n    console.log(str2)  //\"av\"\n\n**3.提取新字符串从第二个字符到第四个 (字符索引值为 1, 2, 和 3)。**\n\n    \"avxdsdfasd\".slice(1, 4)       //\"vxd\"\n\n**4\\. 提取第三个字符到倒数第二个字符。-1 为倒数第一个。**\n\n    \"abckdesdf\".slice(2, -1)       //\"ckdesd\"\n\n**5.当开始的值和结束的值都为负数时,结果会从后向前数，从-3 到-1 之间的值（前包后不包）**\n\n    \"abckdesdf\".slice(-3, -1)       //\"sd\"\n\n## 12、`str.split()`方法，使用指定的分隔符字符串将一个`string`对象分割成字符串数组\n\n**1.当括号中为空值时，直接将它转为字符串数组**\n\n    console.log(\"abcdefg\".split());    //  [\"abcdefg\"]\n\n**2.当括号中为空引号时，它将每个字符串都分割了出来**\n\n    console.log(\"abcdefg\".split(\"\"));    // [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\n\n当在空引号中加上一个空格时，它会以你原字符串的空格来分割\n\n    \"Webkit Moz O ms Khtml\".split( \"\" )  //   [\"Webkit\", \"Moz\", \"O\", \"ms\", \"Khtml\"]\n\n**3.当括号中为字符串中的字母，它将以当前字母分割字符串**\n\n    console.log(\"abcdefg\".split(\"a\"));    // [\"\", \"bcdefg\"]\n\n    console.log(\"abcdefg\".split(\"b\"));    // [\"a\", \"cdefg\"]\n\n**4.当括号中字符串并不是当前字符串中包含的，它只接转成数组字符串，不做其他操作**\n\n    console.log(\"abcdefg\".split(\"bbbb\"));   // [\"abcdefg\"]\n\n## 13、`startsWith()`检测字符串是不是以`“str”`开头的，根据判断返回`true`,`false`(ES6 新添，与`endsWith`相反)\n\n    str.startsWith(searchString [, position]);\n\n参数:\n\n    searchString  要搜索的子字符串。\n\n\n    position  在`str`中搜索`searchString`的开始位置，默认值为 0，也就是真正的字符串开头处。\n\n\n    var str = \"To be, or not to be, that is the question.\";\n\n    console.log(str.startsWith(\"To be\"))            // true\n\n    console.log(str.startsWith(\" be\"))              //false\n\n    console.log(str.startsWith(\"not to be\", 10))    // true\n\n## 14、str.substr()方法返回一个字符串中从指定位置开始到指定字符数的字符。\n\n    str.substr(start[, length])\n\n\n    start:开始截取的位置，开始索引为0，最大为str.length-1，也可为负数；\n\n\n    length:要截取的长度，如果不填写，默认为str.length-1;最小为1，最大为str.length-1.负数无效，如果为0或者负值，返回一个空字符串。\n\n\n    var str = \"abcdefghij\";\n\n**1.当两个值都为正值，且都在范围之内：**\n\n    console.log(\"(1,2): \"    + str.substr(1,2));   // (1,2): bc\n\n**2.当截取位置为负数时，会从后向前数，倒数第一个索引为-1，截取的长度会从当前位置向后数**\n\n    console.log(\"(-3,2): \"   + str.substr(-3,2));  // (-3,2): hi\n\n**3.当只有开始位置的值，并且为负值时，会从当前位置，截取到字符串的末尾**\n\n    console.log(\"(-3): \"     + str.substr(-3));    // (-3): hij\n\n**4.当只有开始的位置，为正值，第二个值默认是 str.length-1,也就是截取到字符串的末尾**\n\n    console.log(\"(1): \"      + str.substr(1));     // (1): bcdefghij\n\n**5.当开始的索引是超过字符串长度的负数时，就相当于字符串一直是从后向前数的**\n\n    console.log(\"(-20, 2): \" + str.substr(-20,2)); // (-20, 2): ab\n\n**6.当开始的索引是超过字符串的长度的正值时，无法截取到内容，返回空字符串**\n\n    console.log(\"(20, 2): \"  + str.substr(20,2));  // (20, 2):\"\"\n\n## 15、`str.substring()`截取开始位置和结束位置之间的字符串，前包后不包\n\n    str.substring(start,stop)\n\n    start:开始截取的位置，不为负数；\n\n    stop：结束的截取位置，不为负数；\n\n**当参数为负数时，不识别，默认转为 0；当第二个值为负数时，默认转为 0，,并调换开始和结束的两个值的位置，**\n\n    var str= \"abcdefghij\";\n\n**1.当开始和结束都为正值，并都在范围内，从索引为 1 的位置截取到索引为 2 的位置；**\n\n    console.log(\"(1,2): \"    + str.substring(1,2));         // (1,2): b\n\n**2.当只有一个开始位置的值时，会从开始位置直接截取到结束位置；**\n\n    console.log(\"(1): \"    + str.substring(1));              // (1): bcdefghij\n\n**3.当开始位置为负数时,会直接转为 0 来截取；**\n\n    console.log(\"(-1): \"    + str.substring(-1));            // (-1): abcdefghij\n\n**4.当结束位置超过字符串的长度，会默认忽略第二个参数；**\n\n    console.log(\"(1,20): \"    + str.substring(1,20));        // ((-1): bcdefghij\n\n**5.当结束位置为负数，会直接转为 0，并交换开始和结束的位置；**\n\n    console.log(\"(1,-5): \"    + \"sdsdfsdf\".substring(1,-5));// ((1,-5): s\n\n**6.当开始位置和结束位置的值为同一值时，返回空字符串**\n\n    console.log(\"(1,1): \"    + \"sdsdfsdf\".substring(1,1)) ;  // ((1,1): \"\"\n\n## 16、str.toLowerCase()将字符串转为小写的形式（并不会影响字符串本身的值）\n\n    console.log(\"ABC\".toLowerCase());    // \"abc\"\n\n## 17、str.UpperCase()将字符串转为大写的形式（并不会影响字符串本身的值）\n\n    console.log( \"alphabet\".toUpperCase() ); // \"ALPHABET\"\n\n## 18、str.toString()方法用于将现有的对象转为字符串；\n\n**1.数组转字符串；**\n\n    console.log( [1,2,3,4,5].toString());   //\"1,2,3,4,5\"\n\n**2.对象转字符串，将会返回\\[object Object\\]，故不支持转换**\n\n    var a={a:1,b:2};\n    console.log( a.toString());         // [object Object]\n\n## 19、`str.trim()`方法会从一个字符串的两端删除空白字符，在这个上下文中的空白字符是所有的空白字符（`space`（空格键)，`tab`,` no-break``space `等）以及所有行终止字符（如`LF`，`CR`）。\n\n    trim()方法并不会影响原字符串，会返回一个新字符串。\n\n例： **1.当字符串两侧都有空格时，会全部删除**\n\n    var orig = '   foo  ';\n    console.log(orig.trim()); // 'foo'\n\n**2.当字符串单侧有空格，则就从单侧删除**\n\n    var orig = 'foo    ';\n    console.log(orig.trim()); // 'foo'\n\n## 20、`String.fromCharCode(num1,num2,、、numN)`用于返回当前数字所对应的字符\n\n    String.fromCharCode(num1, ..., numN)\n\n参数\n\n    num1, ..., numN  一组序列数字，表示 Unicode 值。\n\n> 该方法返回一个字符串，而不是一个 String 对象。 由于 `fromCharCode` 是`String`的静态方法，所以应该像这样使用：`String.fromCharCode()`，而不是作为你创建的 `String` 对象的方法。\n\n例：\n\n    console.log(String.fromCharCode(65,66,67));  //\"ABC\"\n","source":"_posts/2018-02-26-字符串方法.md","raw":"---\ntitle: 字符串方法\ntags:\n  - js\ndate: 2018-02-26 11:02:00\ncategories: 前端\n---\n\n## 前言:\n\n> 在平常的数据解析中，数组，字符串，对象是必不可少的三种类型，今天就字符串的一些常用方法做一个整理，每个方法对应都会相应的示例，不仅是为了能够让大家一目了然，节约时间，更是为了以后自己以后也方便查阅！ （在下面的方法中，有解析错误的地方，还望大家提出意见或建议，感谢！）\n\n## 0、从原始字符串到模版字面量\n\n### （1.）我们原来使用的字符串：\n\n```\n    `hello world` `hello! world!` `hello ${who}` escape `${who}`\n```\n\n> 字符串不区分单引号' '和双引号\" \"所有的字符串拼接都会识别，如果你的字符串比较长，可分行使用“+”来拼接。\n\n例如：\n\n```\n        let longString = \"This is a very long string which needs \" +\n                            \"to wrap across multiple lines because \" +\n                            \"otherwise my code is unreadable.\";\n\n        console.log(longString);\n\n      //  \"This is a very long string which needs to wrap across multiple lines because otherwise my code is unreadable.\"\n```\n\n> 或者也可以使用 \"\\\\\" 来告诉浏览器，你需要继续写这个字符串，但需要保证 \"\\\\\"后面是没有任何符号或者是空格的；\n\n    例如：\n\n```\n    let longString = \"This is a very long string which needs \\\n    to wrap across multiple lines because \\\n    otherwise my code is unreadable.\";\n\n    console.log(longString)\n\n    // \"This is a very long string which needs to wrap across multiple lines because otherwise my code is unreadable.\"\n```\n\n**以前，我们用单引号或双引号表示字符串。**\n\n```\n    let a = '123';  //单引号\n\n\n    let b = \"123\"; //双引号\n```\n\n### （2.）我们现在使用的模板字面量:\n\n**现在，使用模板字面量反撇号``。在实际开发中，这是经常都要用到的方法。**\n\n```\n    let c = `123` //反撇号\n```\n\n**在字符串中使用反撇号，只需要加上转义符 ，这时中间的 `，没有什么意义：**\n\n```\n    let d = `12\\`3` //字符串内插入反撇号的方式。  //   \"12`3\"\n```\n\n**在多行字符串的使用价值：**\n\n**在没有模板字面量的时候，我们要实现多行字符串，必须用到换行符：**\n\n```\n    let a = '123\\n456';\n    console.log(a);\n    // 123\n    // 456\n```\n\n使用模板字面量，就可以非常简单的实现需求。\n\n```\n    let a = `123\n    456`;\n\n    console.log(a)       //      123\n                         //      456\n```\n\n**在模板字面量插入变量的方法**\n\n> 在原来的我们要在字符串中拼接变量，需要用‘\\+变量\\+’或者 \\+ 来实现，而现在 而是使用\\${params}直接插入你需要添加到字符串的位置。这种方式也叫作字符串占位符。占位符支持互相嵌套模板字面量，强大吧。有了它，我们终于可以抛弃 + 拼接字符串的恶心做法了。\n\n**字符串和变量拼接：**\n\n```\n    var str=\"xiaoming\";\n    console.log(`wo shi ${str0}`)   // \"wo shi xiaoming\"\n```\n\n**变量和变量拼接：**\n\n```\n    var str0=\"wo shi \";\n    var str=\"xiaoming\";\n    console.log(str0+`${str}`)      // wo shi xiaoming\n```\n\n模板字面量的终极用法`tag`是一个方法，方法名你可以任意命名，这种写法被称作标签模板。\n\n```\n    function tag(literals, ...substitutions) {\n        //literals是数组，第一个位置是\"\"，第二个位置是占位符之间的字符串，在本例中是haha\n        //substitutions是字符串中的模板字面量，可能多个\n\n        //函数最终返回字符串\n    }\n```\n\n## 1、charAt() 根据下标查询访问字符串的某个字符\n\n在 1 个字符串中，我们知道某个字符的索引值，那么就可以通过索引值来获取当前字符\n\n    例如：\n\n```\n    var str1=\"age\";\n    console.log(str1.charAt(2))  //  e\n\n    // 还可以使用  [ ] 的形式来访问,中括号填写的是字符串的下标\n\n    var str1=\"age\";\n    console.log(str1[2])       //  e\n```\n\n## 2、字符串的比较\">\" , \"<\"  ,\"===\"  ,\">=\" ,\"<=\" ,\"!==\"\n\n    (1).字母字符串比较，会先转成ascii码，再进行比较\n\n    var str1=\"aa\";\n    var str2=\"bb\";\n    console.log(str1true\n\n    (2).数字字符串比较（会比较两个数字的大小）\n\n    var str1=\"10\";\n    var str2=\"15\";\n    var str3=\"10\";\n    console.log(str1true,true\n\n## 3、字符串的长度 length\n\n在我们之前只使用过数组的`length`来判断，更改，清空数组等，这次我们来看一下字符串的`length`。 例如：\n\n    var str=\"我爱你中国\";\n\n    console.log(str.length)   // 5\n\n**`string` 的`length` 是只读属性,下面我们做一下验证：**\n\n    var str=\"This is an apple\";\n\n    console.log(str.length)   //  16\n\n    str.length=5;\n\n    console.log(str.length)  //  16\n\n## 4、charCodeAt(index) 返回表示给定索引的字符的 Unicode 的值。\n\n> 方法返回 0 到 65535 之间的 `UTF-16` 编码单元匹配 `Unicode` 编码单元整数，当`charCodeAt()`括号中没有值时，默认为查询字符串首位的位置;当有参数时，查询的是字符串的索引值， `index`的值为一个大于等于 0，小于字符串长度的整数。\n\n例：\n\n    var  str=\"abc\";\n    console.log(str.charCodeAt())        //  97\n\n    var  str=\"abc\";\n    console.log(str.charCodeAt(0))       //  97\n\n**结果都是一样的，查询到\"a\"在编码中的位置为 97**\n\n    var  str=\"abc\";\n    console.log(str.charCodeAt(1))      //  98\n\n**字母\"b\"在编码中的位置为 98**\n\n## 5、str.concat（str1,str2....）字符串拼接\n\n**在字符串拼接中，最常用的还是“+”；**\n\n    var str = \"d\";\n    var str1 = \"e\";\n    var str2 = \"f\";\n    var str3 = str+str1+str2;\n    console.log(str3)              //  \"def\"\n\n**当然我们也可以使用**`concat(....)`\n\n    var str1 = \"a\";\n    var str2 = \"b\";\n    var str3 = \"c\";\n    console.log(str1.concat(str2,str3))  // \"abc\"\n\n## 6、includes（str）检测一个字符串是否在另一个字符串里包含，区分大小写\n\n例： 我们测试`def` 是否在字符串`str`中\n\n    var str=\"abcdef\";\n    console.log(str.includes(\"def\"));     //  true\n\n**而我们把“def”换成大写的“DEF”时，并不能检测到**\n\n    var str=\"abcdef\";\n    console.log(str.includes(\"DEF\"));     //  false\n\n## 7、endsWith() 检测字符串是不是以“str”结尾的\n\n    str.endsWith(searchString [, position]);\n\n\n    searchString 要搜索的子字符串。\n\n\n    position 在 str 中搜索 searchString 的结束位置\n\n`position` 当不填写值时，默认值为`str.length`，也就是真正的字符串结尾处，从`1`开始，空格和符号也算字符。 也是开始的位置。\n\n例：\n\n**1、当没有第二个参数时。默认第二个参数为字符串的**`length`\n\n    var str = \"To be, or not to be, that is the question.\";\n    console.log(str.endsWith(\"question.\"))    // true\n\n**2、 第二个参数的开始时从“1”开始的，而不是从“0”**\n\n    var str = \"To be, or not to be, that is the question.\";\n    console.log(str.endsWith(\"T\",1))         // true;\n\n**3、第二个参数的计算是包含空格和标点符号的**\n\n    var str = \"To be, or not to be, that is the question.\";\n    console.log(str.endsWith(\"To be\", 5))    // true\n\n## 8、`indexOf()`方法返回`str`查找的结果，如果是有返回指定索引（查找到结果的第一个字符的位置），如果没有返回“-1”，区别大小写\n\n例：\n\n    \"ABC\".indexOf(\"A\")    // 0 查询到“A”,返回位置为索引“0”\n\n    \"ABC\".indexOf(\"e\")    // -1并没有查询到“e”,返回-1\n\n    \"ABC\".indexOf(\"AB\")   // 0 如果查询连续字符，返回连续字符的首位位置\n\n**检测是否存在某字符串:**\n\n当检测某个字符串是否存在于另一个字符串中时，可使用下面的方法：\n\n    \"Blue Whale\".indexOf(\"Blue\") !== -1; // true\n    \"Blue Whale\".indexOf(\"Bloe\") !== -1; // false\n\n> 使用 indexOf 统计一个字符串中某个字母出现的次数 在下例中，设置了 count 来记录字母 e 在字符串 str 中出现的次数：\n\n    var str = 'To be, or not to be, that is the question.';\n    var count = 0;\n    var pos = str.indexOf('e');\n        while (pos !== -1) {\n            count++;\n            pos = str.indexOf('e', pos + 1);\n    //重新给pos赋值，从上个查询到str的位置+1的位置继续查找，如果能查到就会再进循环，count+1\n        }\n\n    console.log(count);   // 4\n\n## 9、`lastIndexOf()`方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回-1\n\n    str.lastIndexOf(searchValue[, fromIndex])\n\n参数:\n\n    searchValue  一个字符串，表示被查找的值。\n\n\n    fromIndex  从调用该方法字符串的此位置处开始查找。可以是任意整数。默认值为 str.length。如果为负值，则被看作 0。如果 fromIndex > str.length，则 fromIndex 被看作 str.length。\n\n例： **当只有一个参数的时候，第二个值默认 str.length,也就是查询整个字符串，查找到这个 str 在整个字符串中最后出现的位置**\n\n    \"AVBDHIUOKL\".lastIndexOf(\"O\");     //7\n\n    \"AFGHJKLL:JJHKAJALKA\".lastIndexOf(\"A\");   //18\n\n**当有第二个参数时，第二个参数会被看成查询这个字符串的结束位置**\n\n    //从0到第10个索引值时，只在0的位置查询到\"A\",所以返回0\n\n    \"AFGHJKLL:JJHKAJALKA\".lastIndexOf(\"A\",10);  // 0\n\n    //从0到第15个索引值时，在第15的位置查询到\"A\",所以返回15\n\n    \"AFGHJKLL:JJHKAJALKA\".lastIndexOf(\"A\",15);  // 15\n\n## 10、`str.repeat(count)`构造并返回一个新字符串，该字符串是循环完成后的新字符串\n\n`repeat(count)`的值一般为数字，就好比`\"a\".repeat(5)==\"a\"*5==\"aaaaa\"`, 但也会出现其他情况，例如以下：\n\n**1.当值为“-1”时，会报错，所以值不能为负数。**\n\n    \"abc\".repeat(-1)\n    // RangeError: repeat count must be positive and less than inifinity\n\n**2.那我们值为“0”时，会有什么情况呢？将不会循环，返回一个空字符串。**\n\n    \"abc\".repeat(0)   // \"\"\n\n**3.那么我们接下来输入一个正常的数字“1”，`repeat`给我们返回了`\"abc\"*1`的结果,它将循环一遍。**\n\n    \"abc\".repeat(1)   // \"abc\"\n\n**4.那么我们试试“2”，看看会不会返回循环两次，确实它返回了字符串循环两遍的结果。**\n\n    \"abc\".repeat(2)  // \"abcabc\"\n\n**5.那我们来试试小数，看看是循环几次呢，结果是它将小数点后面的抹去了，只循环了前面的数字。**\n\n    \"abc\".repeat(3.5)  // \"abcabcabc\" 参数count将会被自动转换成整数.\n\n**6.那我们试试“1/0 ”，并没有解析出来，因为**`1/0==inifinity`\n\n    \"abc\".repeat(1/0)\n    // RangeError: repeat count must be positive and less than inifinity\n\n**7.那我们再来试试字符串呢？结果它将字符串自动转为了 number,并正确循环并返回了。**\n\n    \"abcd\".repeat(\"2\")   // \"abcabc\"\n\n**8.看看它是否能解析中文汉字呢？ 结果是并没有，也没有报错。**\n\n    \"abcd\".repeat(\"二\")   // \"\"\n\n## 11、str.slice(beginSlice,endSlice)截取字符串，第一个参数为开始位置，第二个参数为结束位置，前包后不包\n\n**1.`slice()`从一个字符串中提取字符串并返回新字符串。在一个字符串中的改变不会影响另一个字符串。也就是说，`slice`不修改原字符串，只会返回一个包含了原字符串中部分字符的新字符串。**\n\n    var str = \"avxdsdfasd\";\n    var str2 = str.slice(1, 4);\n\n    console.log(str,str2)  //  \"avxdsdfasd\",\"vxd\"\n\n**2.注意：`slice()` 提取的新字符串包括`beginSlice`但不包括 `endSlice`。**\n\n    var str = \"avxdsdfasd\";\n    var str2 = str.slice(0,2);\n\n    console.log(str2)  //\"av\"\n\n**3.提取新字符串从第二个字符到第四个 (字符索引值为 1, 2, 和 3)。**\n\n    \"avxdsdfasd\".slice(1, 4)       //\"vxd\"\n\n**4\\. 提取第三个字符到倒数第二个字符。-1 为倒数第一个。**\n\n    \"abckdesdf\".slice(2, -1)       //\"ckdesd\"\n\n**5.当开始的值和结束的值都为负数时,结果会从后向前数，从-3 到-1 之间的值（前包后不包）**\n\n    \"abckdesdf\".slice(-3, -1)       //\"sd\"\n\n## 12、`str.split()`方法，使用指定的分隔符字符串将一个`string`对象分割成字符串数组\n\n**1.当括号中为空值时，直接将它转为字符串数组**\n\n    console.log(\"abcdefg\".split());    //  [\"abcdefg\"]\n\n**2.当括号中为空引号时，它将每个字符串都分割了出来**\n\n    console.log(\"abcdefg\".split(\"\"));    // [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\n\n当在空引号中加上一个空格时，它会以你原字符串的空格来分割\n\n    \"Webkit Moz O ms Khtml\".split( \"\" )  //   [\"Webkit\", \"Moz\", \"O\", \"ms\", \"Khtml\"]\n\n**3.当括号中为字符串中的字母，它将以当前字母分割字符串**\n\n    console.log(\"abcdefg\".split(\"a\"));    // [\"\", \"bcdefg\"]\n\n    console.log(\"abcdefg\".split(\"b\"));    // [\"a\", \"cdefg\"]\n\n**4.当括号中字符串并不是当前字符串中包含的，它只接转成数组字符串，不做其他操作**\n\n    console.log(\"abcdefg\".split(\"bbbb\"));   // [\"abcdefg\"]\n\n## 13、`startsWith()`检测字符串是不是以`“str”`开头的，根据判断返回`true`,`false`(ES6 新添，与`endsWith`相反)\n\n    str.startsWith(searchString [, position]);\n\n参数:\n\n    searchString  要搜索的子字符串。\n\n\n    position  在`str`中搜索`searchString`的开始位置，默认值为 0，也就是真正的字符串开头处。\n\n\n    var str = \"To be, or not to be, that is the question.\";\n\n    console.log(str.startsWith(\"To be\"))            // true\n\n    console.log(str.startsWith(\" be\"))              //false\n\n    console.log(str.startsWith(\"not to be\", 10))    // true\n\n## 14、str.substr()方法返回一个字符串中从指定位置开始到指定字符数的字符。\n\n    str.substr(start[, length])\n\n\n    start:开始截取的位置，开始索引为0，最大为str.length-1，也可为负数；\n\n\n    length:要截取的长度，如果不填写，默认为str.length-1;最小为1，最大为str.length-1.负数无效，如果为0或者负值，返回一个空字符串。\n\n\n    var str = \"abcdefghij\";\n\n**1.当两个值都为正值，且都在范围之内：**\n\n    console.log(\"(1,2): \"    + str.substr(1,2));   // (1,2): bc\n\n**2.当截取位置为负数时，会从后向前数，倒数第一个索引为-1，截取的长度会从当前位置向后数**\n\n    console.log(\"(-3,2): \"   + str.substr(-3,2));  // (-3,2): hi\n\n**3.当只有开始位置的值，并且为负值时，会从当前位置，截取到字符串的末尾**\n\n    console.log(\"(-3): \"     + str.substr(-3));    // (-3): hij\n\n**4.当只有开始的位置，为正值，第二个值默认是 str.length-1,也就是截取到字符串的末尾**\n\n    console.log(\"(1): \"      + str.substr(1));     // (1): bcdefghij\n\n**5.当开始的索引是超过字符串长度的负数时，就相当于字符串一直是从后向前数的**\n\n    console.log(\"(-20, 2): \" + str.substr(-20,2)); // (-20, 2): ab\n\n**6.当开始的索引是超过字符串的长度的正值时，无法截取到内容，返回空字符串**\n\n    console.log(\"(20, 2): \"  + str.substr(20,2));  // (20, 2):\"\"\n\n## 15、`str.substring()`截取开始位置和结束位置之间的字符串，前包后不包\n\n    str.substring(start,stop)\n\n    start:开始截取的位置，不为负数；\n\n    stop：结束的截取位置，不为负数；\n\n**当参数为负数时，不识别，默认转为 0；当第二个值为负数时，默认转为 0，,并调换开始和结束的两个值的位置，**\n\n    var str= \"abcdefghij\";\n\n**1.当开始和结束都为正值，并都在范围内，从索引为 1 的位置截取到索引为 2 的位置；**\n\n    console.log(\"(1,2): \"    + str.substring(1,2));         // (1,2): b\n\n**2.当只有一个开始位置的值时，会从开始位置直接截取到结束位置；**\n\n    console.log(\"(1): \"    + str.substring(1));              // (1): bcdefghij\n\n**3.当开始位置为负数时,会直接转为 0 来截取；**\n\n    console.log(\"(-1): \"    + str.substring(-1));            // (-1): abcdefghij\n\n**4.当结束位置超过字符串的长度，会默认忽略第二个参数；**\n\n    console.log(\"(1,20): \"    + str.substring(1,20));        // ((-1): bcdefghij\n\n**5.当结束位置为负数，会直接转为 0，并交换开始和结束的位置；**\n\n    console.log(\"(1,-5): \"    + \"sdsdfsdf\".substring(1,-5));// ((1,-5): s\n\n**6.当开始位置和结束位置的值为同一值时，返回空字符串**\n\n    console.log(\"(1,1): \"    + \"sdsdfsdf\".substring(1,1)) ;  // ((1,1): \"\"\n\n## 16、str.toLowerCase()将字符串转为小写的形式（并不会影响字符串本身的值）\n\n    console.log(\"ABC\".toLowerCase());    // \"abc\"\n\n## 17、str.UpperCase()将字符串转为大写的形式（并不会影响字符串本身的值）\n\n    console.log( \"alphabet\".toUpperCase() ); // \"ALPHABET\"\n\n## 18、str.toString()方法用于将现有的对象转为字符串；\n\n**1.数组转字符串；**\n\n    console.log( [1,2,3,4,5].toString());   //\"1,2,3,4,5\"\n\n**2.对象转字符串，将会返回\\[object Object\\]，故不支持转换**\n\n    var a={a:1,b:2};\n    console.log( a.toString());         // [object Object]\n\n## 19、`str.trim()`方法会从一个字符串的两端删除空白字符，在这个上下文中的空白字符是所有的空白字符（`space`（空格键)，`tab`,` no-break``space `等）以及所有行终止字符（如`LF`，`CR`）。\n\n    trim()方法并不会影响原字符串，会返回一个新字符串。\n\n例： **1.当字符串两侧都有空格时，会全部删除**\n\n    var orig = '   foo  ';\n    console.log(orig.trim()); // 'foo'\n\n**2.当字符串单侧有空格，则就从单侧删除**\n\n    var orig = 'foo    ';\n    console.log(orig.trim()); // 'foo'\n\n## 20、`String.fromCharCode(num1,num2,、、numN)`用于返回当前数字所对应的字符\n\n    String.fromCharCode(num1, ..., numN)\n\n参数\n\n    num1, ..., numN  一组序列数字，表示 Unicode 值。\n\n> 该方法返回一个字符串，而不是一个 String 对象。 由于 `fromCharCode` 是`String`的静态方法，所以应该像这样使用：`String.fromCharCode()`，而不是作为你创建的 `String` 对象的方法。\n\n例：\n\n    console.log(String.fromCharCode(65,66,67));  //\"ABC\"\n","slug":"2018-02-26-字符串方法","published":1,"updated":"2020-03-14T06:50:27.685Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvnp006a4k8ybzyncbo4","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言:\"></a>前言:</h2><blockquote>\n<p>在平常的数据解析中，数组，字符串，对象是必不可少的三种类型，今天就字符串的一些常用方法做一个整理，每个方法对应都会相应的示例，不仅是为了能够让大家一目了然，节约时间，更是为了以后自己以后也方便查阅！ （在下面的方法中，有解析错误的地方，还望大家提出意见或建议，感谢！）</p>\n</blockquote>\n<h2 id=\"0、从原始字符串到模版字面量\"><a href=\"#0、从原始字符串到模版字面量\" class=\"headerlink\" title=\"0、从原始字符串到模版字面量\"></a>0、从原始字符串到模版字面量</h2><h3 id=\"（1-）我们原来使用的字符串：\"><a href=\"#（1-）我们原来使用的字符串：\" class=\"headerlink\" title=\"（1.）我们原来使用的字符串：\"></a>（1.）我们原来使用的字符串：</h3><pre><code>    `hello world` `hello! world!` `hello ${who}` escape `${who}`</code></pre><blockquote>\n<p>字符串不区分单引号’ ‘和双引号” “所有的字符串拼接都会识别，如果你的字符串比较长，可分行使用“+”来拼接。</p>\n</blockquote>\n<p>例如：</p>\n<pre><code>        let longString = &quot;This is a very long string which needs &quot; +\n                            &quot;to wrap across multiple lines because &quot; +\n                            &quot;otherwise my code is unreadable.&quot;;\n\n        console.log(longString);\n\n      //  &quot;This is a very long string which needs to wrap across multiple lines because otherwise my code is unreadable.&quot;</code></pre><blockquote>\n<p>或者也可以使用 “\\“ 来告诉浏览器，你需要继续写这个字符串，但需要保证 “\\“后面是没有任何符号或者是空格的；</p>\n</blockquote>\n<pre><code>例如：</code></pre><pre><code>    let longString = &quot;This is a very long string which needs \\\n    to wrap across multiple lines because \\\n    otherwise my code is unreadable.&quot;;\n\n    console.log(longString)\n\n    // &quot;This is a very long string which needs to wrap across multiple lines because otherwise my code is unreadable.&quot;</code></pre><p><strong>以前，我们用单引号或双引号表示字符串。</strong></p>\n<pre><code>    let a = &#39;123&#39;;  //单引号\n\n\n    let b = &quot;123&quot;; //双引号</code></pre><h3 id=\"（2-）我们现在使用的模板字面量\"><a href=\"#（2-）我们现在使用的模板字面量\" class=\"headerlink\" title=\"（2.）我们现在使用的模板字面量:\"></a>（2.）我们现在使用的模板字面量:</h3><p><strong>现在，使用模板字面量反撇号``。在实际开发中，这是经常都要用到的方法。</strong></p>\n<pre><code>    let c = `123` //反撇号</code></pre><p><strong>在字符串中使用反撇号，只需要加上转义符 ，这时中间的 `，没有什么意义：</strong></p>\n<pre><code>    let d = `12\\`3` //字符串内插入反撇号的方式。  //   &quot;12`3&quot;</code></pre><p><strong>在多行字符串的使用价值：</strong></p>\n<p><strong>在没有模板字面量的时候，我们要实现多行字符串，必须用到换行符：</strong></p>\n<pre><code>    let a = &#39;123\\n456&#39;;\n    console.log(a);\n    // 123\n    // 456</code></pre><p>使用模板字面量，就可以非常简单的实现需求。</p>\n<pre><code>    let a = `123\n    456`;\n\n    console.log(a)       //      123\n                         //      456</code></pre><p><strong>在模板字面量插入变量的方法</strong></p>\n<blockquote>\n<p>在原来的我们要在字符串中拼接变量，需要用‘+变量+’或者 + 来实现，而现在 而是使用${params}直接插入你需要添加到字符串的位置。这种方式也叫作字符串占位符。占位符支持互相嵌套模板字面量，强大吧。有了它，我们终于可以抛弃 + 拼接字符串的恶心做法了。</p>\n</blockquote>\n<p><strong>字符串和变量拼接：</strong></p>\n<pre><code>    var str=&quot;xiaoming&quot;;\n    console.log(`wo shi ${str0}`)   // &quot;wo shi xiaoming&quot;</code></pre><p><strong>变量和变量拼接：</strong></p>\n<pre><code>    var str0=&quot;wo shi &quot;;\n    var str=&quot;xiaoming&quot;;\n    console.log(str0+`${str}`)      // wo shi xiaoming</code></pre><p>模板字面量的终极用法<code>tag</code>是一个方法，方法名你可以任意命名，这种写法被称作标签模板。</p>\n<pre><code>    function tag(literals, ...substitutions) {\n        //literals是数组，第一个位置是&quot;&quot;，第二个位置是占位符之间的字符串，在本例中是haha\n        //substitutions是字符串中的模板字面量，可能多个\n\n        //函数最终返回字符串\n    }</code></pre><h2 id=\"1、charAt-根据下标查询访问字符串的某个字符\"><a href=\"#1、charAt-根据下标查询访问字符串的某个字符\" class=\"headerlink\" title=\"1、charAt() 根据下标查询访问字符串的某个字符\"></a>1、charAt() 根据下标查询访问字符串的某个字符</h2><p>在 1 个字符串中，我们知道某个字符的索引值，那么就可以通过索引值来获取当前字符</p>\n<pre><code>例如：</code></pre><pre><code>    var str1=&quot;age&quot;;\n    console.log(str1.charAt(2))  //  e\n\n    // 还可以使用  [ ] 的形式来访问,中括号填写的是字符串的下标\n\n    var str1=&quot;age&quot;;\n    console.log(str1[2])       //  e</code></pre><h2 id=\"2、字符串的比较”-gt-”-“-lt-”-”-”-”-gt-”-”-lt-”-”-”\"><a href=\"#2、字符串的比较”-gt-”-“-lt-”-”-”-”-gt-”-”-lt-”-”-”\" class=\"headerlink\" title=\"2、字符串的比较”&gt;” , “&lt;”  ,”===”  ,”&gt;=” ,”&lt;=” ,”!==”\"></a>2、字符串的比较”&gt;” , “&lt;”  ,”===”  ,”&gt;=” ,”&lt;=” ,”!==”</h2><pre><code>(1).字母字符串比较，会先转成ascii码，再进行比较\n\nvar str1=&quot;aa&quot;;\nvar str2=&quot;bb&quot;;\nconsole.log(str1true\n\n(2).数字字符串比较（会比较两个数字的大小）\n\nvar str1=&quot;10&quot;;\nvar str2=&quot;15&quot;;\nvar str3=&quot;10&quot;;\nconsole.log(str1true,true</code></pre><h2 id=\"3、字符串的长度-length\"><a href=\"#3、字符串的长度-length\" class=\"headerlink\" title=\"3、字符串的长度 length\"></a>3、字符串的长度 length</h2><p>在我们之前只使用过数组的<code>length</code>来判断，更改，清空数组等，这次我们来看一下字符串的<code>length</code>。 例如：</p>\n<pre><code>var str=&quot;我爱你中国&quot;;\n\nconsole.log(str.length)   // 5</code></pre><p><strong><code>string</code> 的<code>length</code> 是只读属性,下面我们做一下验证：</strong></p>\n<pre><code>var str=&quot;This is an apple&quot;;\n\nconsole.log(str.length)   //  16\n\nstr.length=5;\n\nconsole.log(str.length)  //  16</code></pre><h2 id=\"4、charCodeAt-index-返回表示给定索引的字符的-Unicode-的值。\"><a href=\"#4、charCodeAt-index-返回表示给定索引的字符的-Unicode-的值。\" class=\"headerlink\" title=\"4、charCodeAt(index) 返回表示给定索引的字符的 Unicode 的值。\"></a>4、charCodeAt(index) 返回表示给定索引的字符的 Unicode 的值。</h2><blockquote>\n<p>方法返回 0 到 65535 之间的 <code>UTF-16</code> 编码单元匹配 <code>Unicode</code> 编码单元整数，当<code>charCodeAt()</code>括号中没有值时，默认为查询字符串首位的位置;当有参数时，查询的是字符串的索引值， <code>index</code>的值为一个大于等于 0，小于字符串长度的整数。</p>\n</blockquote>\n<p>例：</p>\n<pre><code>var  str=&quot;abc&quot;;\nconsole.log(str.charCodeAt())        //  97\n\nvar  str=&quot;abc&quot;;\nconsole.log(str.charCodeAt(0))       //  97</code></pre><p><strong>结果都是一样的，查询到”a”在编码中的位置为 97</strong></p>\n<pre><code>var  str=&quot;abc&quot;;\nconsole.log(str.charCodeAt(1))      //  98</code></pre><p><strong>字母”b”在编码中的位置为 98</strong></p>\n<h2 id=\"5、str-concat（str1-str2…-）字符串拼接\"><a href=\"#5、str-concat（str1-str2…-）字符串拼接\" class=\"headerlink\" title=\"5、str.concat（str1,str2….）字符串拼接\"></a>5、str.concat（str1,str2….）字符串拼接</h2><p><strong>在字符串拼接中，最常用的还是“+”；</strong></p>\n<pre><code>var str = &quot;d&quot;;\nvar str1 = &quot;e&quot;;\nvar str2 = &quot;f&quot;;\nvar str3 = str+str1+str2;\nconsole.log(str3)              //  &quot;def&quot;</code></pre><p><strong>当然我们也可以使用</strong><code>concat(....)</code></p>\n<pre><code>var str1 = &quot;a&quot;;\nvar str2 = &quot;b&quot;;\nvar str3 = &quot;c&quot;;\nconsole.log(str1.concat(str2,str3))  // &quot;abc&quot;</code></pre><h2 id=\"6、includes（str）检测一个字符串是否在另一个字符串里包含，区分大小写\"><a href=\"#6、includes（str）检测一个字符串是否在另一个字符串里包含，区分大小写\" class=\"headerlink\" title=\"6、includes（str）检测一个字符串是否在另一个字符串里包含，区分大小写\"></a>6、includes（str）检测一个字符串是否在另一个字符串里包含，区分大小写</h2><p>例： 我们测试<code>def</code> 是否在字符串<code>str</code>中</p>\n<pre><code>var str=&quot;abcdef&quot;;\nconsole.log(str.includes(&quot;def&quot;));     //  true</code></pre><p><strong>而我们把“def”换成大写的“DEF”时，并不能检测到</strong></p>\n<pre><code>var str=&quot;abcdef&quot;;\nconsole.log(str.includes(&quot;DEF&quot;));     //  false</code></pre><h2 id=\"7、endsWith-检测字符串是不是以“str”结尾的\"><a href=\"#7、endsWith-检测字符串是不是以“str”结尾的\" class=\"headerlink\" title=\"7、endsWith() 检测字符串是不是以“str”结尾的\"></a>7、endsWith() 检测字符串是不是以“str”结尾的</h2><pre><code>str.endsWith(searchString [, position]);\n\n\nsearchString 要搜索的子字符串。\n\n\nposition 在 str 中搜索 searchString 的结束位置</code></pre><p><code>position</code> 当不填写值时，默认值为<code>str.length</code>，也就是真正的字符串结尾处，从<code>1</code>开始，空格和符号也算字符。 也是开始的位置。</p>\n<p>例：</p>\n<p><strong>1、当没有第二个参数时。默认第二个参数为字符串的</strong><code>length</code></p>\n<pre><code>var str = &quot;To be, or not to be, that is the question.&quot;;\nconsole.log(str.endsWith(&quot;question.&quot;))    // true</code></pre><p><strong>2、 第二个参数的开始时从“1”开始的，而不是从“0”</strong></p>\n<pre><code>var str = &quot;To be, or not to be, that is the question.&quot;;\nconsole.log(str.endsWith(&quot;T&quot;,1))         // true;</code></pre><p><strong>3、第二个参数的计算是包含空格和标点符号的</strong></p>\n<pre><code>var str = &quot;To be, or not to be, that is the question.&quot;;\nconsole.log(str.endsWith(&quot;To be&quot;, 5))    // true</code></pre><h2 id=\"8、indexOf-方法返回str查找的结果，如果是有返回指定索引（查找到结果的第一个字符的位置），如果没有返回“-1”，区别大小写\"><a href=\"#8、indexOf-方法返回str查找的结果，如果是有返回指定索引（查找到结果的第一个字符的位置），如果没有返回“-1”，区别大小写\" class=\"headerlink\" title=\"8、indexOf()方法返回str查找的结果，如果是有返回指定索引（查找到结果的第一个字符的位置），如果没有返回“-1”，区别大小写\"></a>8、<code>indexOf()</code>方法返回<code>str</code>查找的结果，如果是有返回指定索引（查找到结果的第一个字符的位置），如果没有返回“-1”，区别大小写</h2><p>例：</p>\n<pre><code>&quot;ABC&quot;.indexOf(&quot;A&quot;)    // 0 查询到“A”,返回位置为索引“0”\n\n&quot;ABC&quot;.indexOf(&quot;e&quot;)    // -1并没有查询到“e”,返回-1\n\n&quot;ABC&quot;.indexOf(&quot;AB&quot;)   // 0 如果查询连续字符，返回连续字符的首位位置</code></pre><p><strong>检测是否存在某字符串:</strong></p>\n<p>当检测某个字符串是否存在于另一个字符串中时，可使用下面的方法：</p>\n<pre><code>&quot;Blue Whale&quot;.indexOf(&quot;Blue&quot;) !== -1; // true\n&quot;Blue Whale&quot;.indexOf(&quot;Bloe&quot;) !== -1; // false</code></pre><blockquote>\n<p>使用 indexOf 统计一个字符串中某个字母出现的次数 在下例中，设置了 count 来记录字母 e 在字符串 str 中出现的次数：</p>\n</blockquote>\n<pre><code>var str = &#39;To be, or not to be, that is the question.&#39;;\nvar count = 0;\nvar pos = str.indexOf(&#39;e&#39;);\n    while (pos !== -1) {\n        count++;\n        pos = str.indexOf(&#39;e&#39;, pos + 1);\n//重新给pos赋值，从上个查询到str的位置+1的位置继续查找，如果能查到就会再进循环，count+1\n    }\n\nconsole.log(count);   // 4</code></pre><h2 id=\"9、lastIndexOf-方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回-1\"><a href=\"#9、lastIndexOf-方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回-1\" class=\"headerlink\" title=\"9、lastIndexOf()方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回-1\"></a>9、<code>lastIndexOf()</code>方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回-1</h2><pre><code>str.lastIndexOf(searchValue[, fromIndex])</code></pre><p>参数:</p>\n<pre><code>searchValue  一个字符串，表示被查找的值。\n\n\nfromIndex  从调用该方法字符串的此位置处开始查找。可以是任意整数。默认值为 str.length。如果为负值，则被看作 0。如果 fromIndex &gt; str.length，则 fromIndex 被看作 str.length。</code></pre><p>例： <strong>当只有一个参数的时候，第二个值默认 str.length,也就是查询整个字符串，查找到这个 str 在整个字符串中最后出现的位置</strong></p>\n<pre><code>&quot;AVBDHIUOKL&quot;.lastIndexOf(&quot;O&quot;);     //7\n\n&quot;AFGHJKLL:JJHKAJALKA&quot;.lastIndexOf(&quot;A&quot;);   //18</code></pre><p><strong>当有第二个参数时，第二个参数会被看成查询这个字符串的结束位置</strong></p>\n<pre><code>//从0到第10个索引值时，只在0的位置查询到&quot;A&quot;,所以返回0\n\n&quot;AFGHJKLL:JJHKAJALKA&quot;.lastIndexOf(&quot;A&quot;,10);  // 0\n\n//从0到第15个索引值时，在第15的位置查询到&quot;A&quot;,所以返回15\n\n&quot;AFGHJKLL:JJHKAJALKA&quot;.lastIndexOf(&quot;A&quot;,15);  // 15</code></pre><h2 id=\"10、str-repeat-count-构造并返回一个新字符串，该字符串是循环完成后的新字符串\"><a href=\"#10、str-repeat-count-构造并返回一个新字符串，该字符串是循环完成后的新字符串\" class=\"headerlink\" title=\"10、str.repeat(count)构造并返回一个新字符串，该字符串是循环完成后的新字符串\"></a>10、<code>str.repeat(count)</code>构造并返回一个新字符串，该字符串是循环完成后的新字符串</h2><p><code>repeat(count)</code>的值一般为数字，就好比<code>&quot;a&quot;.repeat(5)==&quot;a&quot;*5==&quot;aaaaa&quot;</code>, 但也会出现其他情况，例如以下：</p>\n<p><strong>1.当值为“-1”时，会报错，所以值不能为负数。</strong></p>\n<pre><code>&quot;abc&quot;.repeat(-1)\n// RangeError: repeat count must be positive and less than inifinity</code></pre><p><strong>2.那我们值为“0”时，会有什么情况呢？将不会循环，返回一个空字符串。</strong></p>\n<pre><code>&quot;abc&quot;.repeat(0)   // &quot;&quot;</code></pre><p><strong>3.那么我们接下来输入一个正常的数字“1”，<code>repeat</code>给我们返回了<code>&quot;abc&quot;*1</code>的结果,它将循环一遍。</strong></p>\n<pre><code>&quot;abc&quot;.repeat(1)   // &quot;abc&quot;</code></pre><p><strong>4.那么我们试试“2”，看看会不会返回循环两次，确实它返回了字符串循环两遍的结果。</strong></p>\n<pre><code>&quot;abc&quot;.repeat(2)  // &quot;abcabc&quot;</code></pre><p><strong>5.那我们来试试小数，看看是循环几次呢，结果是它将小数点后面的抹去了，只循环了前面的数字。</strong></p>\n<pre><code>&quot;abc&quot;.repeat(3.5)  // &quot;abcabcabc&quot; 参数count将会被自动转换成整数.</code></pre><p><strong>6.那我们试试“1/0 ”，并没有解析出来，因为</strong><code>1/0==inifinity</code></p>\n<pre><code>&quot;abc&quot;.repeat(1/0)\n// RangeError: repeat count must be positive and less than inifinity</code></pre><p><strong>7.那我们再来试试字符串呢？结果它将字符串自动转为了 number,并正确循环并返回了。</strong></p>\n<pre><code>&quot;abcd&quot;.repeat(&quot;2&quot;)   // &quot;abcabc&quot;</code></pre><p><strong>8.看看它是否能解析中文汉字呢？ 结果是并没有，也没有报错。</strong></p>\n<pre><code>&quot;abcd&quot;.repeat(&quot;二&quot;)   // &quot;&quot;</code></pre><h2 id=\"11、str-slice-beginSlice-endSlice-截取字符串，第一个参数为开始位置，第二个参数为结束位置，前包后不包\"><a href=\"#11、str-slice-beginSlice-endSlice-截取字符串，第一个参数为开始位置，第二个参数为结束位置，前包后不包\" class=\"headerlink\" title=\"11、str.slice(beginSlice,endSlice)截取字符串，第一个参数为开始位置，第二个参数为结束位置，前包后不包\"></a>11、str.slice(beginSlice,endSlice)截取字符串，第一个参数为开始位置，第二个参数为结束位置，前包后不包</h2><p><strong>1.<code>slice()</code>从一个字符串中提取字符串并返回新字符串。在一个字符串中的改变不会影响另一个字符串。也就是说，<code>slice</code>不修改原字符串，只会返回一个包含了原字符串中部分字符的新字符串。</strong></p>\n<pre><code>var str = &quot;avxdsdfasd&quot;;\nvar str2 = str.slice(1, 4);\n\nconsole.log(str,str2)  //  &quot;avxdsdfasd&quot;,&quot;vxd&quot;</code></pre><p><strong>2.注意：<code>slice()</code> 提取的新字符串包括<code>beginSlice</code>但不包括 <code>endSlice</code>。</strong></p>\n<pre><code>var str = &quot;avxdsdfasd&quot;;\nvar str2 = str.slice(0,2);\n\nconsole.log(str2)  //&quot;av&quot;</code></pre><p><strong>3.提取新字符串从第二个字符到第四个 (字符索引值为 1, 2, 和 3)。</strong></p>\n<pre><code>&quot;avxdsdfasd&quot;.slice(1, 4)       //&quot;vxd&quot;</code></pre><p><strong>4. 提取第三个字符到倒数第二个字符。-1 为倒数第一个。</strong></p>\n<pre><code>&quot;abckdesdf&quot;.slice(2, -1)       //&quot;ckdesd&quot;</code></pre><p><strong>5.当开始的值和结束的值都为负数时,结果会从后向前数，从-3 到-1 之间的值（前包后不包）</strong></p>\n<pre><code>&quot;abckdesdf&quot;.slice(-3, -1)       //&quot;sd&quot;</code></pre><h2 id=\"12、str-split-方法，使用指定的分隔符字符串将一个string对象分割成字符串数组\"><a href=\"#12、str-split-方法，使用指定的分隔符字符串将一个string对象分割成字符串数组\" class=\"headerlink\" title=\"12、str.split()方法，使用指定的分隔符字符串将一个string对象分割成字符串数组\"></a>12、<code>str.split()</code>方法，使用指定的分隔符字符串将一个<code>string</code>对象分割成字符串数组</h2><p><strong>1.当括号中为空值时，直接将它转为字符串数组</strong></p>\n<pre><code>console.log(&quot;abcdefg&quot;.split());    //  [&quot;abcdefg&quot;]</code></pre><p><strong>2.当括号中为空引号时，它将每个字符串都分割了出来</strong></p>\n<pre><code>console.log(&quot;abcdefg&quot;.split(&quot;&quot;));    // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]</code></pre><p>当在空引号中加上一个空格时，它会以你原字符串的空格来分割</p>\n<pre><code>&quot;Webkit Moz O ms Khtml&quot;.split( &quot;&quot; )  //   [&quot;Webkit&quot;, &quot;Moz&quot;, &quot;O&quot;, &quot;ms&quot;, &quot;Khtml&quot;]</code></pre><p><strong>3.当括号中为字符串中的字母，它将以当前字母分割字符串</strong></p>\n<pre><code>console.log(&quot;abcdefg&quot;.split(&quot;a&quot;));    // [&quot;&quot;, &quot;bcdefg&quot;]\n\nconsole.log(&quot;abcdefg&quot;.split(&quot;b&quot;));    // [&quot;a&quot;, &quot;cdefg&quot;]</code></pre><p><strong>4.当括号中字符串并不是当前字符串中包含的，它只接转成数组字符串，不做其他操作</strong></p>\n<pre><code>console.log(&quot;abcdefg&quot;.split(&quot;bbbb&quot;));   // [&quot;abcdefg&quot;]</code></pre><h2 id=\"13、startsWith-检测字符串是不是以“str”开头的，根据判断返回true-false-ES6-新添，与endsWith相反\"><a href=\"#13、startsWith-检测字符串是不是以“str”开头的，根据判断返回true-false-ES6-新添，与endsWith相反\" class=\"headerlink\" title=\"13、startsWith()检测字符串是不是以“str”开头的，根据判断返回true,false(ES6 新添，与endsWith相反)\"></a>13、<code>startsWith()</code>检测字符串是不是以<code>“str”</code>开头的，根据判断返回<code>true</code>,<code>false</code>(ES6 新添，与<code>endsWith</code>相反)</h2><pre><code>str.startsWith(searchString [, position]);</code></pre><p>参数:</p>\n<pre><code>searchString  要搜索的子字符串。\n\n\nposition  在`str`中搜索`searchString`的开始位置，默认值为 0，也就是真正的字符串开头处。\n\n\nvar str = &quot;To be, or not to be, that is the question.&quot;;\n\nconsole.log(str.startsWith(&quot;To be&quot;))            // true\n\nconsole.log(str.startsWith(&quot; be&quot;))              //false\n\nconsole.log(str.startsWith(&quot;not to be&quot;, 10))    // true</code></pre><h2 id=\"14、str-substr-方法返回一个字符串中从指定位置开始到指定字符数的字符。\"><a href=\"#14、str-substr-方法返回一个字符串中从指定位置开始到指定字符数的字符。\" class=\"headerlink\" title=\"14、str.substr()方法返回一个字符串中从指定位置开始到指定字符数的字符。\"></a>14、str.substr()方法返回一个字符串中从指定位置开始到指定字符数的字符。</h2><pre><code>str.substr(start[, length])\n\n\nstart:开始截取的位置，开始索引为0，最大为str.length-1，也可为负数；\n\n\nlength:要截取的长度，如果不填写，默认为str.length-1;最小为1，最大为str.length-1.负数无效，如果为0或者负值，返回一个空字符串。\n\n\nvar str = &quot;abcdefghij&quot;;</code></pre><p><strong>1.当两个值都为正值，且都在范围之内：</strong></p>\n<pre><code>console.log(&quot;(1,2): &quot;    + str.substr(1,2));   // (1,2): bc</code></pre><p><strong>2.当截取位置为负数时，会从后向前数，倒数第一个索引为-1，截取的长度会从当前位置向后数</strong></p>\n<pre><code>console.log(&quot;(-3,2): &quot;   + str.substr(-3,2));  // (-3,2): hi</code></pre><p><strong>3.当只有开始位置的值，并且为负值时，会从当前位置，截取到字符串的末尾</strong></p>\n<pre><code>console.log(&quot;(-3): &quot;     + str.substr(-3));    // (-3): hij</code></pre><p><strong>4.当只有开始的位置，为正值，第二个值默认是 str.length-1,也就是截取到字符串的末尾</strong></p>\n<pre><code>console.log(&quot;(1): &quot;      + str.substr(1));     // (1): bcdefghij</code></pre><p><strong>5.当开始的索引是超过字符串长度的负数时，就相当于字符串一直是从后向前数的</strong></p>\n<pre><code>console.log(&quot;(-20, 2): &quot; + str.substr(-20,2)); // (-20, 2): ab</code></pre><p><strong>6.当开始的索引是超过字符串的长度的正值时，无法截取到内容，返回空字符串</strong></p>\n<pre><code>console.log(&quot;(20, 2): &quot;  + str.substr(20,2));  // (20, 2):&quot;&quot;</code></pre><h2 id=\"15、str-substring-截取开始位置和结束位置之间的字符串，前包后不包\"><a href=\"#15、str-substring-截取开始位置和结束位置之间的字符串，前包后不包\" class=\"headerlink\" title=\"15、str.substring()截取开始位置和结束位置之间的字符串，前包后不包\"></a>15、<code>str.substring()</code>截取开始位置和结束位置之间的字符串，前包后不包</h2><pre><code>str.substring(start,stop)\n\nstart:开始截取的位置，不为负数；\n\nstop：结束的截取位置，不为负数；</code></pre><p><strong>当参数为负数时，不识别，默认转为 0；当第二个值为负数时，默认转为 0，,并调换开始和结束的两个值的位置，</strong></p>\n<pre><code>var str= &quot;abcdefghij&quot;;</code></pre><p><strong>1.当开始和结束都为正值，并都在范围内，从索引为 1 的位置截取到索引为 2 的位置；</strong></p>\n<pre><code>console.log(&quot;(1,2): &quot;    + str.substring(1,2));         // (1,2): b</code></pre><p><strong>2.当只有一个开始位置的值时，会从开始位置直接截取到结束位置；</strong></p>\n<pre><code>console.log(&quot;(1): &quot;    + str.substring(1));              // (1): bcdefghij</code></pre><p><strong>3.当开始位置为负数时,会直接转为 0 来截取；</strong></p>\n<pre><code>console.log(&quot;(-1): &quot;    + str.substring(-1));            // (-1): abcdefghij</code></pre><p><strong>4.当结束位置超过字符串的长度，会默认忽略第二个参数；</strong></p>\n<pre><code>console.log(&quot;(1,20): &quot;    + str.substring(1,20));        // ((-1): bcdefghij</code></pre><p><strong>5.当结束位置为负数，会直接转为 0，并交换开始和结束的位置；</strong></p>\n<pre><code>console.log(&quot;(1,-5): &quot;    + &quot;sdsdfsdf&quot;.substring(1,-5));// ((1,-5): s</code></pre><p><strong>6.当开始位置和结束位置的值为同一值时，返回空字符串</strong></p>\n<pre><code>console.log(&quot;(1,1): &quot;    + &quot;sdsdfsdf&quot;.substring(1,1)) ;  // ((1,1): &quot;&quot;</code></pre><h2 id=\"16、str-toLowerCase-将字符串转为小写的形式（并不会影响字符串本身的值）\"><a href=\"#16、str-toLowerCase-将字符串转为小写的形式（并不会影响字符串本身的值）\" class=\"headerlink\" title=\"16、str.toLowerCase()将字符串转为小写的形式（并不会影响字符串本身的值）\"></a>16、str.toLowerCase()将字符串转为小写的形式（并不会影响字符串本身的值）</h2><pre><code>console.log(&quot;ABC&quot;.toLowerCase());    // &quot;abc&quot;</code></pre><h2 id=\"17、str-UpperCase-将字符串转为大写的形式（并不会影响字符串本身的值）\"><a href=\"#17、str-UpperCase-将字符串转为大写的形式（并不会影响字符串本身的值）\" class=\"headerlink\" title=\"17、str.UpperCase()将字符串转为大写的形式（并不会影响字符串本身的值）\"></a>17、str.UpperCase()将字符串转为大写的形式（并不会影响字符串本身的值）</h2><pre><code>console.log( &quot;alphabet&quot;.toUpperCase() ); // &quot;ALPHABET&quot;</code></pre><h2 id=\"18、str-toString-方法用于将现有的对象转为字符串；\"><a href=\"#18、str-toString-方法用于将现有的对象转为字符串；\" class=\"headerlink\" title=\"18、str.toString()方法用于将现有的对象转为字符串；\"></a>18、str.toString()方法用于将现有的对象转为字符串；</h2><p><strong>1.数组转字符串；</strong></p>\n<pre><code>console.log( [1,2,3,4,5].toString());   //&quot;1,2,3,4,5&quot;</code></pre><p><strong>2.对象转字符串，将会返回[object Object]，故不支持转换</strong></p>\n<pre><code>var a={a:1,b:2};\nconsole.log( a.toString());         // [object Object]</code></pre><h2 id=\"19、str-trim-方法会从一个字符串的两端删除空白字符，在这个上下文中的空白字符是所有的空白字符（space（空格键-，tab-no-break-space等）以及所有行终止字符（如LF，CR）。\"><a href=\"#19、str-trim-方法会从一个字符串的两端删除空白字符，在这个上下文中的空白字符是所有的空白字符（space（空格键-，tab-no-break-space等）以及所有行终止字符（如LF，CR）。\" class=\"headerlink\" title=\"19、str.trim()方法会从一个字符串的两端删除空白字符，在这个上下文中的空白字符是所有的空白字符（space（空格键)，tab,no-break``space等）以及所有行终止字符（如LF，CR）。\"></a>19、<code>str.trim()</code>方法会从一个字符串的两端删除空白字符，在这个上下文中的空白字符是所有的空白字符（<code>space</code>（空格键)，<code>tab</code>,<code>no-break``space</code>等）以及所有行终止字符（如<code>LF</code>，<code>CR</code>）。</h2><pre><code>trim()方法并不会影响原字符串，会返回一个新字符串。</code></pre><p>例： <strong>1.当字符串两侧都有空格时，会全部删除</strong></p>\n<pre><code>var orig = &#39;   foo  &#39;;\nconsole.log(orig.trim()); // &#39;foo&#39;</code></pre><p><strong>2.当字符串单侧有空格，则就从单侧删除</strong></p>\n<pre><code>var orig = &#39;foo    &#39;;\nconsole.log(orig.trim()); // &#39;foo&#39;</code></pre><h2 id=\"20、String-fromCharCode-num1-num2-、、numN-用于返回当前数字所对应的字符\"><a href=\"#20、String-fromCharCode-num1-num2-、、numN-用于返回当前数字所对应的字符\" class=\"headerlink\" title=\"20、String.fromCharCode(num1,num2,、、numN)用于返回当前数字所对应的字符\"></a>20、<code>String.fromCharCode(num1,num2,、、numN)</code>用于返回当前数字所对应的字符</h2><pre><code>String.fromCharCode(num1, ..., numN)</code></pre><p>参数</p>\n<pre><code>num1, ..., numN  一组序列数字，表示 Unicode 值。</code></pre><blockquote>\n<p>该方法返回一个字符串，而不是一个 String 对象。 由于 <code>fromCharCode</code> 是<code>String</code>的静态方法，所以应该像这样使用：<code>String.fromCharCode()</code>，而不是作为你创建的 <code>String</code> 对象的方法。</p>\n</blockquote>\n<p>例：</p>\n<pre><code>console.log(String.fromCharCode(65,66,67));  //&quot;ABC&quot;</code></pre>","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言:\"></a>前言:</h2><blockquote>\n<p>在平常的数据解析中，数组，字符串，对象是必不可少的三种类型，今天就字符串的一些常用方法做一个整理，每个方法对应都会相应的示例，不仅是为了能够让大家一目了然，节约时间，更是为了以后自己以后也方便查阅！ （在下面的方法中，有解析错误的地方，还望大家提出意见或建议，感谢！）</p>\n</blockquote>\n<h2 id=\"0、从原始字符串到模版字面量\"><a href=\"#0、从原始字符串到模版字面量\" class=\"headerlink\" title=\"0、从原始字符串到模版字面量\"></a>0、从原始字符串到模版字面量</h2><h3 id=\"（1-）我们原来使用的字符串：\"><a href=\"#（1-）我们原来使用的字符串：\" class=\"headerlink\" title=\"（1.）我们原来使用的字符串：\"></a>（1.）我们原来使用的字符串：</h3><pre><code>    `hello world` `hello! world!` `hello ${who}` escape `${who}`</code></pre><blockquote>\n<p>字符串不区分单引号’ ‘和双引号” “所有的字符串拼接都会识别，如果你的字符串比较长，可分行使用“+”来拼接。</p>\n</blockquote>\n<p>例如：</p>\n<pre><code>        let longString = &quot;This is a very long string which needs &quot; +\n                            &quot;to wrap across multiple lines because &quot; +\n                            &quot;otherwise my code is unreadable.&quot;;\n\n        console.log(longString);\n\n      //  &quot;This is a very long string which needs to wrap across multiple lines because otherwise my code is unreadable.&quot;</code></pre><blockquote>\n<p>或者也可以使用 “\\“ 来告诉浏览器，你需要继续写这个字符串，但需要保证 “\\“后面是没有任何符号或者是空格的；</p>\n</blockquote>\n<pre><code>例如：</code></pre><pre><code>    let longString = &quot;This is a very long string which needs \\\n    to wrap across multiple lines because \\\n    otherwise my code is unreadable.&quot;;\n\n    console.log(longString)\n\n    // &quot;This is a very long string which needs to wrap across multiple lines because otherwise my code is unreadable.&quot;</code></pre><p><strong>以前，我们用单引号或双引号表示字符串。</strong></p>\n<pre><code>    let a = &#39;123&#39;;  //单引号\n\n\n    let b = &quot;123&quot;; //双引号</code></pre><h3 id=\"（2-）我们现在使用的模板字面量\"><a href=\"#（2-）我们现在使用的模板字面量\" class=\"headerlink\" title=\"（2.）我们现在使用的模板字面量:\"></a>（2.）我们现在使用的模板字面量:</h3><p><strong>现在，使用模板字面量反撇号``。在实际开发中，这是经常都要用到的方法。</strong></p>\n<pre><code>    let c = `123` //反撇号</code></pre><p><strong>在字符串中使用反撇号，只需要加上转义符 ，这时中间的 `，没有什么意义：</strong></p>\n<pre><code>    let d = `12\\`3` //字符串内插入反撇号的方式。  //   &quot;12`3&quot;</code></pre><p><strong>在多行字符串的使用价值：</strong></p>\n<p><strong>在没有模板字面量的时候，我们要实现多行字符串，必须用到换行符：</strong></p>\n<pre><code>    let a = &#39;123\\n456&#39;;\n    console.log(a);\n    // 123\n    // 456</code></pre><p>使用模板字面量，就可以非常简单的实现需求。</p>\n<pre><code>    let a = `123\n    456`;\n\n    console.log(a)       //      123\n                         //      456</code></pre><p><strong>在模板字面量插入变量的方法</strong></p>\n<blockquote>\n<p>在原来的我们要在字符串中拼接变量，需要用‘+变量+’或者 + 来实现，而现在 而是使用${params}直接插入你需要添加到字符串的位置。这种方式也叫作字符串占位符。占位符支持互相嵌套模板字面量，强大吧。有了它，我们终于可以抛弃 + 拼接字符串的恶心做法了。</p>\n</blockquote>\n<p><strong>字符串和变量拼接：</strong></p>\n<pre><code>    var str=&quot;xiaoming&quot;;\n    console.log(`wo shi ${str0}`)   // &quot;wo shi xiaoming&quot;</code></pre><p><strong>变量和变量拼接：</strong></p>\n<pre><code>    var str0=&quot;wo shi &quot;;\n    var str=&quot;xiaoming&quot;;\n    console.log(str0+`${str}`)      // wo shi xiaoming</code></pre><p>模板字面量的终极用法<code>tag</code>是一个方法，方法名你可以任意命名，这种写法被称作标签模板。</p>\n<pre><code>    function tag(literals, ...substitutions) {\n        //literals是数组，第一个位置是&quot;&quot;，第二个位置是占位符之间的字符串，在本例中是haha\n        //substitutions是字符串中的模板字面量，可能多个\n\n        //函数最终返回字符串\n    }</code></pre><h2 id=\"1、charAt-根据下标查询访问字符串的某个字符\"><a href=\"#1、charAt-根据下标查询访问字符串的某个字符\" class=\"headerlink\" title=\"1、charAt() 根据下标查询访问字符串的某个字符\"></a>1、charAt() 根据下标查询访问字符串的某个字符</h2><p>在 1 个字符串中，我们知道某个字符的索引值，那么就可以通过索引值来获取当前字符</p>\n<pre><code>例如：</code></pre><pre><code>    var str1=&quot;age&quot;;\n    console.log(str1.charAt(2))  //  e\n\n    // 还可以使用  [ ] 的形式来访问,中括号填写的是字符串的下标\n\n    var str1=&quot;age&quot;;\n    console.log(str1[2])       //  e</code></pre><h2 id=\"2、字符串的比较”-gt-”-“-lt-”-”-”-”-gt-”-”-lt-”-”-”\"><a href=\"#2、字符串的比较”-gt-”-“-lt-”-”-”-”-gt-”-”-lt-”-”-”\" class=\"headerlink\" title=\"2、字符串的比较”&gt;” , “&lt;”  ,”===”  ,”&gt;=” ,”&lt;=” ,”!==”\"></a>2、字符串的比较”&gt;” , “&lt;”  ,”===”  ,”&gt;=” ,”&lt;=” ,”!==”</h2><pre><code>(1).字母字符串比较，会先转成ascii码，再进行比较\n\nvar str1=&quot;aa&quot;;\nvar str2=&quot;bb&quot;;\nconsole.log(str1true\n\n(2).数字字符串比较（会比较两个数字的大小）\n\nvar str1=&quot;10&quot;;\nvar str2=&quot;15&quot;;\nvar str3=&quot;10&quot;;\nconsole.log(str1true,true</code></pre><h2 id=\"3、字符串的长度-length\"><a href=\"#3、字符串的长度-length\" class=\"headerlink\" title=\"3、字符串的长度 length\"></a>3、字符串的长度 length</h2><p>在我们之前只使用过数组的<code>length</code>来判断，更改，清空数组等，这次我们来看一下字符串的<code>length</code>。 例如：</p>\n<pre><code>var str=&quot;我爱你中国&quot;;\n\nconsole.log(str.length)   // 5</code></pre><p><strong><code>string</code> 的<code>length</code> 是只读属性,下面我们做一下验证：</strong></p>\n<pre><code>var str=&quot;This is an apple&quot;;\n\nconsole.log(str.length)   //  16\n\nstr.length=5;\n\nconsole.log(str.length)  //  16</code></pre><h2 id=\"4、charCodeAt-index-返回表示给定索引的字符的-Unicode-的值。\"><a href=\"#4、charCodeAt-index-返回表示给定索引的字符的-Unicode-的值。\" class=\"headerlink\" title=\"4、charCodeAt(index) 返回表示给定索引的字符的 Unicode 的值。\"></a>4、charCodeAt(index) 返回表示给定索引的字符的 Unicode 的值。</h2><blockquote>\n<p>方法返回 0 到 65535 之间的 <code>UTF-16</code> 编码单元匹配 <code>Unicode</code> 编码单元整数，当<code>charCodeAt()</code>括号中没有值时，默认为查询字符串首位的位置;当有参数时，查询的是字符串的索引值， <code>index</code>的值为一个大于等于 0，小于字符串长度的整数。</p>\n</blockquote>\n<p>例：</p>\n<pre><code>var  str=&quot;abc&quot;;\nconsole.log(str.charCodeAt())        //  97\n\nvar  str=&quot;abc&quot;;\nconsole.log(str.charCodeAt(0))       //  97</code></pre><p><strong>结果都是一样的，查询到”a”在编码中的位置为 97</strong></p>\n<pre><code>var  str=&quot;abc&quot;;\nconsole.log(str.charCodeAt(1))      //  98</code></pre><p><strong>字母”b”在编码中的位置为 98</strong></p>\n<h2 id=\"5、str-concat（str1-str2…-）字符串拼接\"><a href=\"#5、str-concat（str1-str2…-）字符串拼接\" class=\"headerlink\" title=\"5、str.concat（str1,str2….）字符串拼接\"></a>5、str.concat（str1,str2….）字符串拼接</h2><p><strong>在字符串拼接中，最常用的还是“+”；</strong></p>\n<pre><code>var str = &quot;d&quot;;\nvar str1 = &quot;e&quot;;\nvar str2 = &quot;f&quot;;\nvar str3 = str+str1+str2;\nconsole.log(str3)              //  &quot;def&quot;</code></pre><p><strong>当然我们也可以使用</strong><code>concat(....)</code></p>\n<pre><code>var str1 = &quot;a&quot;;\nvar str2 = &quot;b&quot;;\nvar str3 = &quot;c&quot;;\nconsole.log(str1.concat(str2,str3))  // &quot;abc&quot;</code></pre><h2 id=\"6、includes（str）检测一个字符串是否在另一个字符串里包含，区分大小写\"><a href=\"#6、includes（str）检测一个字符串是否在另一个字符串里包含，区分大小写\" class=\"headerlink\" title=\"6、includes（str）检测一个字符串是否在另一个字符串里包含，区分大小写\"></a>6、includes（str）检测一个字符串是否在另一个字符串里包含，区分大小写</h2><p>例： 我们测试<code>def</code> 是否在字符串<code>str</code>中</p>\n<pre><code>var str=&quot;abcdef&quot;;\nconsole.log(str.includes(&quot;def&quot;));     //  true</code></pre><p><strong>而我们把“def”换成大写的“DEF”时，并不能检测到</strong></p>\n<pre><code>var str=&quot;abcdef&quot;;\nconsole.log(str.includes(&quot;DEF&quot;));     //  false</code></pre><h2 id=\"7、endsWith-检测字符串是不是以“str”结尾的\"><a href=\"#7、endsWith-检测字符串是不是以“str”结尾的\" class=\"headerlink\" title=\"7、endsWith() 检测字符串是不是以“str”结尾的\"></a>7、endsWith() 检测字符串是不是以“str”结尾的</h2><pre><code>str.endsWith(searchString [, position]);\n\n\nsearchString 要搜索的子字符串。\n\n\nposition 在 str 中搜索 searchString 的结束位置</code></pre><p><code>position</code> 当不填写值时，默认值为<code>str.length</code>，也就是真正的字符串结尾处，从<code>1</code>开始，空格和符号也算字符。 也是开始的位置。</p>\n<p>例：</p>\n<p><strong>1、当没有第二个参数时。默认第二个参数为字符串的</strong><code>length</code></p>\n<pre><code>var str = &quot;To be, or not to be, that is the question.&quot;;\nconsole.log(str.endsWith(&quot;question.&quot;))    // true</code></pre><p><strong>2、 第二个参数的开始时从“1”开始的，而不是从“0”</strong></p>\n<pre><code>var str = &quot;To be, or not to be, that is the question.&quot;;\nconsole.log(str.endsWith(&quot;T&quot;,1))         // true;</code></pre><p><strong>3、第二个参数的计算是包含空格和标点符号的</strong></p>\n<pre><code>var str = &quot;To be, or not to be, that is the question.&quot;;\nconsole.log(str.endsWith(&quot;To be&quot;, 5))    // true</code></pre><h2 id=\"8、indexOf-方法返回str查找的结果，如果是有返回指定索引（查找到结果的第一个字符的位置），如果没有返回“-1”，区别大小写\"><a href=\"#8、indexOf-方法返回str查找的结果，如果是有返回指定索引（查找到结果的第一个字符的位置），如果没有返回“-1”，区别大小写\" class=\"headerlink\" title=\"8、indexOf()方法返回str查找的结果，如果是有返回指定索引（查找到结果的第一个字符的位置），如果没有返回“-1”，区别大小写\"></a>8、<code>indexOf()</code>方法返回<code>str</code>查找的结果，如果是有返回指定索引（查找到结果的第一个字符的位置），如果没有返回“-1”，区别大小写</h2><p>例：</p>\n<pre><code>&quot;ABC&quot;.indexOf(&quot;A&quot;)    // 0 查询到“A”,返回位置为索引“0”\n\n&quot;ABC&quot;.indexOf(&quot;e&quot;)    // -1并没有查询到“e”,返回-1\n\n&quot;ABC&quot;.indexOf(&quot;AB&quot;)   // 0 如果查询连续字符，返回连续字符的首位位置</code></pre><p><strong>检测是否存在某字符串:</strong></p>\n<p>当检测某个字符串是否存在于另一个字符串中时，可使用下面的方法：</p>\n<pre><code>&quot;Blue Whale&quot;.indexOf(&quot;Blue&quot;) !== -1; // true\n&quot;Blue Whale&quot;.indexOf(&quot;Bloe&quot;) !== -1; // false</code></pre><blockquote>\n<p>使用 indexOf 统计一个字符串中某个字母出现的次数 在下例中，设置了 count 来记录字母 e 在字符串 str 中出现的次数：</p>\n</blockquote>\n<pre><code>var str = &#39;To be, or not to be, that is the question.&#39;;\nvar count = 0;\nvar pos = str.indexOf(&#39;e&#39;);\n    while (pos !== -1) {\n        count++;\n        pos = str.indexOf(&#39;e&#39;, pos + 1);\n//重新给pos赋值，从上个查询到str的位置+1的位置继续查找，如果能查到就会再进循环，count+1\n    }\n\nconsole.log(count);   // 4</code></pre><h2 id=\"9、lastIndexOf-方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回-1\"><a href=\"#9、lastIndexOf-方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回-1\" class=\"headerlink\" title=\"9、lastIndexOf()方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回-1\"></a>9、<code>lastIndexOf()</code>方法返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回-1</h2><pre><code>str.lastIndexOf(searchValue[, fromIndex])</code></pre><p>参数:</p>\n<pre><code>searchValue  一个字符串，表示被查找的值。\n\n\nfromIndex  从调用该方法字符串的此位置处开始查找。可以是任意整数。默认值为 str.length。如果为负值，则被看作 0。如果 fromIndex &gt; str.length，则 fromIndex 被看作 str.length。</code></pre><p>例： <strong>当只有一个参数的时候，第二个值默认 str.length,也就是查询整个字符串，查找到这个 str 在整个字符串中最后出现的位置</strong></p>\n<pre><code>&quot;AVBDHIUOKL&quot;.lastIndexOf(&quot;O&quot;);     //7\n\n&quot;AFGHJKLL:JJHKAJALKA&quot;.lastIndexOf(&quot;A&quot;);   //18</code></pre><p><strong>当有第二个参数时，第二个参数会被看成查询这个字符串的结束位置</strong></p>\n<pre><code>//从0到第10个索引值时，只在0的位置查询到&quot;A&quot;,所以返回0\n\n&quot;AFGHJKLL:JJHKAJALKA&quot;.lastIndexOf(&quot;A&quot;,10);  // 0\n\n//从0到第15个索引值时，在第15的位置查询到&quot;A&quot;,所以返回15\n\n&quot;AFGHJKLL:JJHKAJALKA&quot;.lastIndexOf(&quot;A&quot;,15);  // 15</code></pre><h2 id=\"10、str-repeat-count-构造并返回一个新字符串，该字符串是循环完成后的新字符串\"><a href=\"#10、str-repeat-count-构造并返回一个新字符串，该字符串是循环完成后的新字符串\" class=\"headerlink\" title=\"10、str.repeat(count)构造并返回一个新字符串，该字符串是循环完成后的新字符串\"></a>10、<code>str.repeat(count)</code>构造并返回一个新字符串，该字符串是循环完成后的新字符串</h2><p><code>repeat(count)</code>的值一般为数字，就好比<code>&quot;a&quot;.repeat(5)==&quot;a&quot;*5==&quot;aaaaa&quot;</code>, 但也会出现其他情况，例如以下：</p>\n<p><strong>1.当值为“-1”时，会报错，所以值不能为负数。</strong></p>\n<pre><code>&quot;abc&quot;.repeat(-1)\n// RangeError: repeat count must be positive and less than inifinity</code></pre><p><strong>2.那我们值为“0”时，会有什么情况呢？将不会循环，返回一个空字符串。</strong></p>\n<pre><code>&quot;abc&quot;.repeat(0)   // &quot;&quot;</code></pre><p><strong>3.那么我们接下来输入一个正常的数字“1”，<code>repeat</code>给我们返回了<code>&quot;abc&quot;*1</code>的结果,它将循环一遍。</strong></p>\n<pre><code>&quot;abc&quot;.repeat(1)   // &quot;abc&quot;</code></pre><p><strong>4.那么我们试试“2”，看看会不会返回循环两次，确实它返回了字符串循环两遍的结果。</strong></p>\n<pre><code>&quot;abc&quot;.repeat(2)  // &quot;abcabc&quot;</code></pre><p><strong>5.那我们来试试小数，看看是循环几次呢，结果是它将小数点后面的抹去了，只循环了前面的数字。</strong></p>\n<pre><code>&quot;abc&quot;.repeat(3.5)  // &quot;abcabcabc&quot; 参数count将会被自动转换成整数.</code></pre><p><strong>6.那我们试试“1/0 ”，并没有解析出来，因为</strong><code>1/0==inifinity</code></p>\n<pre><code>&quot;abc&quot;.repeat(1/0)\n// RangeError: repeat count must be positive and less than inifinity</code></pre><p><strong>7.那我们再来试试字符串呢？结果它将字符串自动转为了 number,并正确循环并返回了。</strong></p>\n<pre><code>&quot;abcd&quot;.repeat(&quot;2&quot;)   // &quot;abcabc&quot;</code></pre><p><strong>8.看看它是否能解析中文汉字呢？ 结果是并没有，也没有报错。</strong></p>\n<pre><code>&quot;abcd&quot;.repeat(&quot;二&quot;)   // &quot;&quot;</code></pre><h2 id=\"11、str-slice-beginSlice-endSlice-截取字符串，第一个参数为开始位置，第二个参数为结束位置，前包后不包\"><a href=\"#11、str-slice-beginSlice-endSlice-截取字符串，第一个参数为开始位置，第二个参数为结束位置，前包后不包\" class=\"headerlink\" title=\"11、str.slice(beginSlice,endSlice)截取字符串，第一个参数为开始位置，第二个参数为结束位置，前包后不包\"></a>11、str.slice(beginSlice,endSlice)截取字符串，第一个参数为开始位置，第二个参数为结束位置，前包后不包</h2><p><strong>1.<code>slice()</code>从一个字符串中提取字符串并返回新字符串。在一个字符串中的改变不会影响另一个字符串。也就是说，<code>slice</code>不修改原字符串，只会返回一个包含了原字符串中部分字符的新字符串。</strong></p>\n<pre><code>var str = &quot;avxdsdfasd&quot;;\nvar str2 = str.slice(1, 4);\n\nconsole.log(str,str2)  //  &quot;avxdsdfasd&quot;,&quot;vxd&quot;</code></pre><p><strong>2.注意：<code>slice()</code> 提取的新字符串包括<code>beginSlice</code>但不包括 <code>endSlice</code>。</strong></p>\n<pre><code>var str = &quot;avxdsdfasd&quot;;\nvar str2 = str.slice(0,2);\n\nconsole.log(str2)  //&quot;av&quot;</code></pre><p><strong>3.提取新字符串从第二个字符到第四个 (字符索引值为 1, 2, 和 3)。</strong></p>\n<pre><code>&quot;avxdsdfasd&quot;.slice(1, 4)       //&quot;vxd&quot;</code></pre><p><strong>4. 提取第三个字符到倒数第二个字符。-1 为倒数第一个。</strong></p>\n<pre><code>&quot;abckdesdf&quot;.slice(2, -1)       //&quot;ckdesd&quot;</code></pre><p><strong>5.当开始的值和结束的值都为负数时,结果会从后向前数，从-3 到-1 之间的值（前包后不包）</strong></p>\n<pre><code>&quot;abckdesdf&quot;.slice(-3, -1)       //&quot;sd&quot;</code></pre><h2 id=\"12、str-split-方法，使用指定的分隔符字符串将一个string对象分割成字符串数组\"><a href=\"#12、str-split-方法，使用指定的分隔符字符串将一个string对象分割成字符串数组\" class=\"headerlink\" title=\"12、str.split()方法，使用指定的分隔符字符串将一个string对象分割成字符串数组\"></a>12、<code>str.split()</code>方法，使用指定的分隔符字符串将一个<code>string</code>对象分割成字符串数组</h2><p><strong>1.当括号中为空值时，直接将它转为字符串数组</strong></p>\n<pre><code>console.log(&quot;abcdefg&quot;.split());    //  [&quot;abcdefg&quot;]</code></pre><p><strong>2.当括号中为空引号时，它将每个字符串都分割了出来</strong></p>\n<pre><code>console.log(&quot;abcdefg&quot;.split(&quot;&quot;));    // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]</code></pre><p>当在空引号中加上一个空格时，它会以你原字符串的空格来分割</p>\n<pre><code>&quot;Webkit Moz O ms Khtml&quot;.split( &quot;&quot; )  //   [&quot;Webkit&quot;, &quot;Moz&quot;, &quot;O&quot;, &quot;ms&quot;, &quot;Khtml&quot;]</code></pre><p><strong>3.当括号中为字符串中的字母，它将以当前字母分割字符串</strong></p>\n<pre><code>console.log(&quot;abcdefg&quot;.split(&quot;a&quot;));    // [&quot;&quot;, &quot;bcdefg&quot;]\n\nconsole.log(&quot;abcdefg&quot;.split(&quot;b&quot;));    // [&quot;a&quot;, &quot;cdefg&quot;]</code></pre><p><strong>4.当括号中字符串并不是当前字符串中包含的，它只接转成数组字符串，不做其他操作</strong></p>\n<pre><code>console.log(&quot;abcdefg&quot;.split(&quot;bbbb&quot;));   // [&quot;abcdefg&quot;]</code></pre><h2 id=\"13、startsWith-检测字符串是不是以“str”开头的，根据判断返回true-false-ES6-新添，与endsWith相反\"><a href=\"#13、startsWith-检测字符串是不是以“str”开头的，根据判断返回true-false-ES6-新添，与endsWith相反\" class=\"headerlink\" title=\"13、startsWith()检测字符串是不是以“str”开头的，根据判断返回true,false(ES6 新添，与endsWith相反)\"></a>13、<code>startsWith()</code>检测字符串是不是以<code>“str”</code>开头的，根据判断返回<code>true</code>,<code>false</code>(ES6 新添，与<code>endsWith</code>相反)</h2><pre><code>str.startsWith(searchString [, position]);</code></pre><p>参数:</p>\n<pre><code>searchString  要搜索的子字符串。\n\n\nposition  在`str`中搜索`searchString`的开始位置，默认值为 0，也就是真正的字符串开头处。\n\n\nvar str = &quot;To be, or not to be, that is the question.&quot;;\n\nconsole.log(str.startsWith(&quot;To be&quot;))            // true\n\nconsole.log(str.startsWith(&quot; be&quot;))              //false\n\nconsole.log(str.startsWith(&quot;not to be&quot;, 10))    // true</code></pre><h2 id=\"14、str-substr-方法返回一个字符串中从指定位置开始到指定字符数的字符。\"><a href=\"#14、str-substr-方法返回一个字符串中从指定位置开始到指定字符数的字符。\" class=\"headerlink\" title=\"14、str.substr()方法返回一个字符串中从指定位置开始到指定字符数的字符。\"></a>14、str.substr()方法返回一个字符串中从指定位置开始到指定字符数的字符。</h2><pre><code>str.substr(start[, length])\n\n\nstart:开始截取的位置，开始索引为0，最大为str.length-1，也可为负数；\n\n\nlength:要截取的长度，如果不填写，默认为str.length-1;最小为1，最大为str.length-1.负数无效，如果为0或者负值，返回一个空字符串。\n\n\nvar str = &quot;abcdefghij&quot;;</code></pre><p><strong>1.当两个值都为正值，且都在范围之内：</strong></p>\n<pre><code>console.log(&quot;(1,2): &quot;    + str.substr(1,2));   // (1,2): bc</code></pre><p><strong>2.当截取位置为负数时，会从后向前数，倒数第一个索引为-1，截取的长度会从当前位置向后数</strong></p>\n<pre><code>console.log(&quot;(-3,2): &quot;   + str.substr(-3,2));  // (-3,2): hi</code></pre><p><strong>3.当只有开始位置的值，并且为负值时，会从当前位置，截取到字符串的末尾</strong></p>\n<pre><code>console.log(&quot;(-3): &quot;     + str.substr(-3));    // (-3): hij</code></pre><p><strong>4.当只有开始的位置，为正值，第二个值默认是 str.length-1,也就是截取到字符串的末尾</strong></p>\n<pre><code>console.log(&quot;(1): &quot;      + str.substr(1));     // (1): bcdefghij</code></pre><p><strong>5.当开始的索引是超过字符串长度的负数时，就相当于字符串一直是从后向前数的</strong></p>\n<pre><code>console.log(&quot;(-20, 2): &quot; + str.substr(-20,2)); // (-20, 2): ab</code></pre><p><strong>6.当开始的索引是超过字符串的长度的正值时，无法截取到内容，返回空字符串</strong></p>\n<pre><code>console.log(&quot;(20, 2): &quot;  + str.substr(20,2));  // (20, 2):&quot;&quot;</code></pre><h2 id=\"15、str-substring-截取开始位置和结束位置之间的字符串，前包后不包\"><a href=\"#15、str-substring-截取开始位置和结束位置之间的字符串，前包后不包\" class=\"headerlink\" title=\"15、str.substring()截取开始位置和结束位置之间的字符串，前包后不包\"></a>15、<code>str.substring()</code>截取开始位置和结束位置之间的字符串，前包后不包</h2><pre><code>str.substring(start,stop)\n\nstart:开始截取的位置，不为负数；\n\nstop：结束的截取位置，不为负数；</code></pre><p><strong>当参数为负数时，不识别，默认转为 0；当第二个值为负数时，默认转为 0，,并调换开始和结束的两个值的位置，</strong></p>\n<pre><code>var str= &quot;abcdefghij&quot;;</code></pre><p><strong>1.当开始和结束都为正值，并都在范围内，从索引为 1 的位置截取到索引为 2 的位置；</strong></p>\n<pre><code>console.log(&quot;(1,2): &quot;    + str.substring(1,2));         // (1,2): b</code></pre><p><strong>2.当只有一个开始位置的值时，会从开始位置直接截取到结束位置；</strong></p>\n<pre><code>console.log(&quot;(1): &quot;    + str.substring(1));              // (1): bcdefghij</code></pre><p><strong>3.当开始位置为负数时,会直接转为 0 来截取；</strong></p>\n<pre><code>console.log(&quot;(-1): &quot;    + str.substring(-1));            // (-1): abcdefghij</code></pre><p><strong>4.当结束位置超过字符串的长度，会默认忽略第二个参数；</strong></p>\n<pre><code>console.log(&quot;(1,20): &quot;    + str.substring(1,20));        // ((-1): bcdefghij</code></pre><p><strong>5.当结束位置为负数，会直接转为 0，并交换开始和结束的位置；</strong></p>\n<pre><code>console.log(&quot;(1,-5): &quot;    + &quot;sdsdfsdf&quot;.substring(1,-5));// ((1,-5): s</code></pre><p><strong>6.当开始位置和结束位置的值为同一值时，返回空字符串</strong></p>\n<pre><code>console.log(&quot;(1,1): &quot;    + &quot;sdsdfsdf&quot;.substring(1,1)) ;  // ((1,1): &quot;&quot;</code></pre><h2 id=\"16、str-toLowerCase-将字符串转为小写的形式（并不会影响字符串本身的值）\"><a href=\"#16、str-toLowerCase-将字符串转为小写的形式（并不会影响字符串本身的值）\" class=\"headerlink\" title=\"16、str.toLowerCase()将字符串转为小写的形式（并不会影响字符串本身的值）\"></a>16、str.toLowerCase()将字符串转为小写的形式（并不会影响字符串本身的值）</h2><pre><code>console.log(&quot;ABC&quot;.toLowerCase());    // &quot;abc&quot;</code></pre><h2 id=\"17、str-UpperCase-将字符串转为大写的形式（并不会影响字符串本身的值）\"><a href=\"#17、str-UpperCase-将字符串转为大写的形式（并不会影响字符串本身的值）\" class=\"headerlink\" title=\"17、str.UpperCase()将字符串转为大写的形式（并不会影响字符串本身的值）\"></a>17、str.UpperCase()将字符串转为大写的形式（并不会影响字符串本身的值）</h2><pre><code>console.log( &quot;alphabet&quot;.toUpperCase() ); // &quot;ALPHABET&quot;</code></pre><h2 id=\"18、str-toString-方法用于将现有的对象转为字符串；\"><a href=\"#18、str-toString-方法用于将现有的对象转为字符串；\" class=\"headerlink\" title=\"18、str.toString()方法用于将现有的对象转为字符串；\"></a>18、str.toString()方法用于将现有的对象转为字符串；</h2><p><strong>1.数组转字符串；</strong></p>\n<pre><code>console.log( [1,2,3,4,5].toString());   //&quot;1,2,3,4,5&quot;</code></pre><p><strong>2.对象转字符串，将会返回[object Object]，故不支持转换</strong></p>\n<pre><code>var a={a:1,b:2};\nconsole.log( a.toString());         // [object Object]</code></pre><h2 id=\"19、str-trim-方法会从一个字符串的两端删除空白字符，在这个上下文中的空白字符是所有的空白字符（space（空格键-，tab-no-break-space等）以及所有行终止字符（如LF，CR）。\"><a href=\"#19、str-trim-方法会从一个字符串的两端删除空白字符，在这个上下文中的空白字符是所有的空白字符（space（空格键-，tab-no-break-space等）以及所有行终止字符（如LF，CR）。\" class=\"headerlink\" title=\"19、str.trim()方法会从一个字符串的两端删除空白字符，在这个上下文中的空白字符是所有的空白字符（space（空格键)，tab,no-break``space等）以及所有行终止字符（如LF，CR）。\"></a>19、<code>str.trim()</code>方法会从一个字符串的两端删除空白字符，在这个上下文中的空白字符是所有的空白字符（<code>space</code>（空格键)，<code>tab</code>,<code>no-break``space</code>等）以及所有行终止字符（如<code>LF</code>，<code>CR</code>）。</h2><pre><code>trim()方法并不会影响原字符串，会返回一个新字符串。</code></pre><p>例： <strong>1.当字符串两侧都有空格时，会全部删除</strong></p>\n<pre><code>var orig = &#39;   foo  &#39;;\nconsole.log(orig.trim()); // &#39;foo&#39;</code></pre><p><strong>2.当字符串单侧有空格，则就从单侧删除</strong></p>\n<pre><code>var orig = &#39;foo    &#39;;\nconsole.log(orig.trim()); // &#39;foo&#39;</code></pre><h2 id=\"20、String-fromCharCode-num1-num2-、、numN-用于返回当前数字所对应的字符\"><a href=\"#20、String-fromCharCode-num1-num2-、、numN-用于返回当前数字所对应的字符\" class=\"headerlink\" title=\"20、String.fromCharCode(num1,num2,、、numN)用于返回当前数字所对应的字符\"></a>20、<code>String.fromCharCode(num1,num2,、、numN)</code>用于返回当前数字所对应的字符</h2><pre><code>String.fromCharCode(num1, ..., numN)</code></pre><p>参数</p>\n<pre><code>num1, ..., numN  一组序列数字，表示 Unicode 值。</code></pre><blockquote>\n<p>该方法返回一个字符串，而不是一个 String 对象。 由于 <code>fromCharCode</code> 是<code>String</code>的静态方法，所以应该像这样使用：<code>String.fromCharCode()</code>，而不是作为你创建的 <code>String</code> 对象的方法。</p>\n</blockquote>\n<p>例：</p>\n<pre><code>console.log(String.fromCharCode(65,66,67));  //&quot;ABC&quot;</code></pre>"},{"title":"黑匣子里到底装了什么","date":"2018-07-24T04:47:29.000Z","toc":false,"_content":"\n> **脏乱不堪的房间里忽然透进来一道微弱的光。多希望有人能一脚把门踹开，让房间里的人都能看到这些“脏乱“。**\n>\n> ---文昭\n>\n> **当民族主义与爱国情怀在中国氤氲蒸腾之时，千疮百孔的食药安全已经成为最为腐朽的短板，它让日益凝聚的共同体显得格外脆弱，撕扯出的每个裂痕都再难修复**\n>\n> --《疫苗事件击穿社会底线 中共构建共同体面临危机 》\n\n**长春长生的狂犬病疫苗造假事件继续发酵。一场关于国产疫苗的信任危机，在民间迅速蔓延。让我们不仅发问，是哪个环节出了问题？会带给人什么影响？是从什么时候开始的？为什么在山东去年九月份就发现了，怎么现在才查出来？为什么长春长生为什么从一个国企，有如何一步一步变成私企的？又是如何后来居上的？总理发话彻查，能否从根治理，以后还还出现类似的事情么？国家又是如何去建设国民对疫苗的自信心的？这样的事情发生后，为什么屡禁不止？为何管理三鹿的人和管理疫苗的人是同一个？为何有的人觉得和自己没关系就可以置若罔闻？为何看到报道少之又少，那些报道都去了哪里？。。。** ![](http://www.jixiaokang.com/wp-content/uploads/2018/07/weibo.jpg) 7 月 21 日，夜晚 22:00 时许，广州天河区的徐丽（化名）临睡前点开小区业主微信群，发现群里的妈妈们都在着急翻看自己孩子的《儿童预防接种证》。她们期待着，曾经注射进孩子体内的白百破疫苗，千万不要是长春长生生产的。 而在 1200 公里外的武汉市，31 岁的妈妈阿琳，则带着自己一岁半的女儿，踏上了前往香港接种肺炎 13 价疫苗的道路。 但是，阿琳不知道的是，她的目的地香港，也正在遭受疫苗断供的危机。来自顺德的珍姐，已经在香港尖沙咀的一家诊所里接种了两针。但自今年 5 月以来，HPV 九价疫苗不仅从 6100 港币三针，涨到了 7800 —9000 港币，还经常缺货。 **一针仅有 0.5 毫升的疫苗，牵动着千家万户的心。**\n\n- **65 万支不合格白百破疫苗 流去了哪里**\n\n[GitHub](https://github.com/fuckcqcs)      这是一个 程序员搜集政府网站上纰漏的疫苗流向，真是个大好人\n\n- **那些被疫苗毒害的人--摘自博谈网**\n\n2009 年 5 月，董梓欣的出生给家人带来了莫大的快乐。同年 12 月，奶奶带孩子去卫生所接种了 A 群流脑疫苗和口服轮状病毒疫苗，结果孩子当天就开始发烧，辗转多家医院后，医院告诉他们：孩子造成的脑损害不可逆转，任何治疗均不再有价值。 从死亡线上被救回来的许译文大脑严重受损，在经过多次干细胞移植之后，唯一的进步就是会在父母的要求下击打几次小鼓。2011 年 2 月，许伟的妻子带女儿许译文接种了百白破的第二针和脊灰的第三剂。5 天之后孩子突然出现发热、抽搐等症状，两天下了四份病危通知书。历经三家医院一个多月的治疗，女儿生命体征才得以稳定下来。但此时孩子已经脑部萎缩，基本处于无意识状态，失去肢体活动能力，市人民医院的诊断为：病毒性脑病。 2012 年 4 月 23 日，龚建的妻子抱着孩子去了社区卫生服务中心接种疫苗，疫苗接种后孩子身体出现异常，在血常规检查的时候发现血小板竟然只剩下 11 个（人体正常值是 100~300），孩子连夜住进了 ICU。医院连下了几次病危通知书，并很快在 5 月 8 日做了第一次骨髓穿刺。在一次次的骨髓穿刺中，这个一岁半的孩子受尽了折磨，妈妈精神也接近崩溃。可最终还是没能停住死神的脚步，2013 年 4 月 22 日凌晨，龚子崇因血小板过低导致的颅内出血去世。 谢俊杰今年 5 岁，本应该是起淘气不消停的年纪，但他大部分的玩耍时间都是在阁楼上独自度过，一刻也不能离开父母的视线。注射疫苗导致的 ‌‌‌‌“血小板减少性紫癜 ‌‌‌‌”，这个拗口的名字如同一个隐身的魔鬼，随时威胁着他的生命。 方灶群陪着小沁怡在楼下的空地玩耍，小家伙将手里的玩具娃娃甩来甩去，稍不满意就大喊大叫，‌‌‌‌“从小就住院，孩子的性格受到很大影响 ‌‌‌‌”。2011 年 3 月，方灶群夫妇带着女儿方沁怡接种卡介苗，5 月底时，作为护士的妻子在一次给孩子洗澡时发现其腋下淋巴肿大，直到 7 月份，孩子的淋巴肿大已经有鸡蛋大小了，还出现溃烂。在不断奔波治疗的同时，方灶群也不断地找疾控中心要求鉴定。最终得到了 ‌‌‌‌“接种卡介苗后淋巴结严重反应 ‌‌‌‌”的结论，并给出了三级丙等的伤残鉴定。 2013 年清明节，夫妻俩回了老家给去世已经三年的孩子的坟头立了块碑，并冲洗了和孩子等大的照片，就像孩子还活着。2009 年，女儿费晶铭正值花季，天生一副好嗓子学美声，梦想考上解放军艺术学院。同年 11 月打了甲流疫苗，之后被诊断为 ‌‌‌‌“急性重症再生障碍性贫血 ‌‌‌‌”。晶晶在入院到去世前，三个月的时间里做了四次骨髓穿刺。在最后一次穿刺中生命体征恶化，最终离开人世。 一年前，马宇轩还在深圳，会在父母的注视下随着音乐跳舞；一年后，马宇轩在湖南常德老家，安静地躺在婴儿床上，对这个世界再没有回应。改变这一切的是一针疫苗。2012 年 2 月 15 日小宇轩进行了乙脑疫苗的注射，仅仅过了 6 天，突然开始发烧、呕吐甚至抽搐。但是住院三天也没查出病因，情况也越来越糟，之后被送到了深圳市儿童医院 ICU，医院给出的诊断是：乙脑。 梁嘉怡已经 12 岁了，却还是只有一捧大，智力为零。2001 年，梁永立的小女儿梁嘉怡出生，健康可爱。2003 年 8 月，梁永立带小嘉怡到会城卫生院一门诊打第二支乙型脑炎预防针。次日凌晨，小嘉怡发起了高烧，住院治疗，出院确诊为 ‌‌‌‌“重症病毒性脑炎 ‌‌‌‌”。转眼近 10 年过去了，梁嘉怡已经接近植物人的状态，四肢萎缩，只有几十斤重，每日饮食都要靠豆浆机打成汁状喂下去。为了讨说法，父亲梁永立曾历时 35 天骑自行车到北京上访。 易世华在历经几个月的昏迷和几次抢救之后终于活下来，现在郑州一家卫校学习，她说现在的生活就像宿舍楼下的场景一样，一团糟。易世华原本是个聪明伶俐、讨人喜欢的孩子。2006 年 12 月，她和所有同学一样由校医注射了流脑（A+C）疫苗，噩梦从此开始。几天后，她突然变得思维迟钝、胡言乱语，后来还突然昏倒了。到北京治疗时，易世华已经昏迷不醒，生命垂危。最后医院诊断为 ‌‌‌‌“急性播散性脑脊髓炎 ‌‌‌‌”。 余荣辉在打疫苗之前获得过江门市第一届五年级作文大王比赛的一等奖，他写作的题目是《拯救地球》。他最终也没有完成梦想，他甚至连自己都拯救不了，注射疫苗后导致智力低下，喜怒无常，无力面对多舛的世界。 王昭洁已经 7 岁，每日在院子里房子里漫无目的的徘徊。2007 年 4 月 9 日，当时 6 个月大的王昭洁注射了乙肝疫苗的第三针，厄运从此开始。当晚就开始发高烧，很快就发展到惊厥抽搐。从此之后，孩子只要一发烧就抽搐，又过了半年，竟然开始不发烧也抽搐了。智力接近于零，连喝水都要用针管打到嘴里。 李佳欣于 2009 注射了乙脑疫苗，2010 年出现发热和全身抽搐。在当地医院治疗效果不佳后于 1 月 19 日转到大医院就诊，诊断为：‌‌‌‌“急性播散性脑脊髓膜炎 ‌‌‌‌”。住院 22 天后出院，后语言功能和运动功能都受到损害，留下后遗症。西安市预防接种异常反应小组鉴定为与疫苗无关。李尊伟不服，2011 年 1 月 13 日在户县卫生局以死相逼，服下了整瓶的安眠药，经医院抢救才得以脱险。当年，双方达成赔偿协议。 ‌‌‌‌“我祈祷奇迹在儿子身上出现，让一切的痛苦都离我们远去，回到以前的幸福平静的生活中去，让时间倒流到 2010 年 3 月 16 日，把儿子身上的那针药水取回……‌‌‌‌”李宝向在申诉书里这样写道。那一天，他八岁的儿子李致康打完甲流疫苗，表现得没精打采，之后的两三天，孩子一直气息奄奄。辗转多地最终来到北京，在北京儿童医院 ICU，四个月的治疗花去了三十万元，耗尽积蓄，但换来的确是 ‌‌‌‌“植物人 ‌‌‌‌”状态的孩子。 王艺筱已经四岁，连翻身都不会。父母奔忙终日换得一点治疗费用，奶奶做饭的时候，她只能安静地躺在玩具堆里。2010 年 3 月，妈妈史玉凤带王艺筱在临沂市妇幼保健院接种了 A 群流脑疫苗，当晚孩子就发高烧并开始抽搐，被诊断为重症病毒性脑炎。转到临沂市人民医院治疗半年依然无效。当年 9 月，他们去了北京大学妇儿医院，病情才逐渐稳定，但巨额的医疗费用已让这个家庭濒临绝境。 注射强化麻疹疫苗之后，孙舒晴就患上了血小板减少性紫癜，长期大剂量的激素治疗虽然暂时保住了命，但是却让她的身体停止了生长，六岁的孩子还停留在打疫苗前的身高。 卢佳润现在的智力基本为零，母亲带她看院子里早开的樱桃花，她在怀里一动不动，却一直睁着眼睛。卢佳润曾经在七个月大的时候就能挨着墙站，每天早上六点就会醒来，趴在卢卫卫脸上喊爸爸。卢卫卫觉得自己是最幸福的人，但四年前的一针疫苗让这种幸福戛然而止。 郑州北郊的一间狭小的出租屋里，患血小板减少性紫癜，随时会有生命危险的张俊龙已经这样一动不动躺了三年。 注射疫苗之后，这个本来都会爬了的孩子再也没能站起来，年轻的母亲伤心欲绝。高晨翔，一个曾寄托了这个家庭无数希望的名字。‌‌‌‌“现在叫什么都不重要了，孩子已经完全毁了，我们这个家一辈子都只能熬著过冬了 ‌‌‌‌”。此时，高晨翔正在炕上吮吸手指，不停蠕动着发出奇怪的声响。 每天晚饭后，奶奶和妈妈都会带着冀赟去街上走走，算是康复治疗的延续。疾控中心所公布的百万分之一的疫苗不良反应率在统计学上或许微不足道，但对于每一个受害家庭而言却是百分之百的灾难。近日山东非法疫苗案再次刺痛了我们的双眼，悲剧轮番重播，我们只愿今后苦难不再无止境的上演。\n\n- 八孽\n\n第一孽：食品。三聚氰胺、毒大米、地沟油、塑化剂、毒月饼、染色馒头、蛆虫门、致癌门、牛肉膏、毒生姜、瘦肉精、催熟剂、膨大素等这些世界特有的中国名词，无不记载着中国百姓受害的声声血泪史。善良的中国百姓惹不起总躲得起吧，于是逃离本土去海外买。中国那些害人的食品不仅让国人损命，让食品业丢人，让全体的中国大陆百姓蒙羞！更让中国人二个字扣上了悲哀的帽子！官员们吃的是为他们“特供”的食品，从不用担心地沟油苏丹红和添加剂对他们身体的损害和破坏，他们子孙们一生下来就享受到了“非人”的待遇。 第二孽：汽车。1955 年，“新中国”就具备了汽车的制造能力，那时的韩国几乎没有汽车产业。可是，同为 1967 年成立的韩国大宇、韩国现代汽车已现已风靡世界，就连中华人民共和国的首都也在用脸贴上别人的屁股，共享“北京现代”之荣耀。殊不知，北京并没拥有真正的现代，而“现代”却拥有了北京。同样，还有拥有上海的通用、拥有广州的本田、拥有武汉的日产、拥有吉林的大众……如今的中国城市大街上跑的几乎是外国车，而韩国大街上几乎看不到外国车，日本所有城市几乎是本国的本田、丰田、日产、三菱……。这个国家战略资源却让整个汽车行业整得只是为人做嫁衣裳，真是“卖了老婆还帮别人去数钱”，丢人现眼到老祖宗！ 第三孽：电信。远在美国读书的刘翰每次都会掐断父母从国内打来的电话，原因是在国内打到美国每分钟要 8 元以上，即使 IP 电话也要 2.40 元，还不包括市话费。而在美国，往国内打电话每分钟往往小于一美分，比较常见的价格是 10 元人民币 1000 分钟，由此推算中国的电话费竟然高于美国 100 倍呀！要知道中国人的收入只有美国人的十分之一呀。好了，美国太强大了，我们不好比了，阿 Q 就是阿 Q，撑什么阿……。 第四孽：教育。中国孩子已成了高考流水线上的畸形产品。在这凹凸不平、千刀万剐的高考线上，不知扼杀了多少伟人天才，“包养”了多少听话会考的低能废物。如果国家对西部边穷地区考虑尚可理解，可北京上海为何还要剥夺其它省份的入学名额？如果说禁止湖北的孩子以海南户籍参加高考可以理解，为何自称“首善之区”的北京、你却要让生于京、长于京，只是没有所谓“北京户口”的上百万孩子被迫沦为“职业学校”的学生？这种“两手都硬”的政策，促成了北京有的一所中学每年就输入近 200 名学生到北大、清华，几乎相当于几个省的总和。真是有些人出生就有的东西，却是更多人一辈子追求的东西。那么所谓的“北京户口”又是一个“神马”东西？只不过是：他(她)爷爷姥爷们早几年先到了北京那个地方找个“窝棚”住下罢了。因为官员们的孩子都上了国内外最好的学校，想留洋就留洋，想出国就出国，从不用为进个公办幼稚园而通宵达旦去排队。于是，部分人群开始向教育部进行无用但持续的请愿，更多的人开始向国学寻找教育的公平。由于出国留学人群如洪水，让经济不景气的美国加拿大、英国、法国、西班牙等如获救命稻草，纷纷抛起政见，来抢中国的生源了。试想，一些无奈出国的孩子经过西方的流水线的改造后，以后对我们传统教育和封闭不公的决策者而言该是多么的悲哀？ 第五孽：房地产。中国政府的行业政策，没有哪个像房地产政策这样频出，又是“限购”，又是房产税……。可每次政策出台基本又是一个笑柄。其实大家都明白，假如政策制定者和管理者自己没有房子，或远离房地产商与他们没有勾结，或没有利益通吃，假如地方政府不把房地产业当经济核财政支柱，或政绩爬升的资本，政府制定的政策就不可能屡次都成为房价的丢人笑柄与助推器。 第六孽：煤炭石化。有人统计，近三十年非战争非正常死亡人数，中国比全球其他国家合计还多。造成中国死亡的人数原因主要有地震、交通事故和煤炭开采，其中让世界震惊的是煤炭开采为何死这么多人。中国的煤炭行业到底怎么了。 第七孽：医疗卫生。让国人震惊和愤怒的医药事故近些年层出不穷，杀医生事件频繁发生，即使把狼狈为奸的国家药监局原局长郑筱萸们判死刑也难以从根本上解决问题，本来就是社会制度和体制问题，官员们却高喊，找不出什么有效的办法了！ 中国仅有的一点医疗卫生资源，也向干部官员公务员群体过度倾斜，万恶的给药“分级制度”，对参加医疗保险的人群，也耍按照他们的政治地位、社会地位划分等级，级别越高的，得到的医疗服务质量越高，药品供应也耍越好，而老百姓就连基本的医疗都难以保证！“自锯病腿”的悲剧，是生在中国老百姓的真正悲哀！就医难，治病贵，有病不敢医，大病不敢住院依然是中国许多地方、尤其是农村的客观现状。政府们医 改喊了这么多年，老百姓几乎就骂了这么多年，可黑了心的医院,坏了良心的医生,为了骗取患者钱财还在乱下处方胡乱开药。他们内外勾结，为拿回扣，会把药价虚高到 100 倍,放任那么多黑心医生大发黑心财，索要红包明目张胆，不送红包就会缝上你缸门，把纱布留在肚子里！ 市场化医疗下，高级官员们都可住上高干部病房，豪华疗养院，享受的是去全中国各大医院，全额免费医疗，和特供的国产和进口药品的待遇。中国官员们享受的是全额医药免费，对老百姓患了大病无钱医冶跳楼自杀无动于衷，官员特权医疗，黑了心的医生成为杀害病患老百姓的无形屠刀赢利赚钱的黑医生是杀病患老百姓的刽子手！ 第八孽：交通。随着汽车越来越多，城市交通越来越拥挤，我认为最丢人的还是我们大众平日开车的不文明行为：酒驾、闯红灯、向窗外扔杂物、乱停车、超车、不排队、地铁上吃东西……。不仅造成了大量的人员伤亡，也让整个中国人的形象丢尽，尤其是当你如把某些习惯带到国外时，别人对我们同胞行为的眼神其实是整个中国这个国家在丢人…… 谨以此文，纪念那些受伤的孩童 相关链接\n\n# [追忆『疫苗之殇』](https://wentommy.wordpress.com/2018/07/20/%E8%BF%BD%E5%BF%86%E3%80%8E%E7%96%AB%E8%8B%97%E4%B9%8B%E6%AE%87%E3%80%8F/)\n\n# [疫苗之殇痛殴“四个自信”（高新）](https://www.rfa.org/mandarin/zhuanlan/yehuazhongnanhai/gx-07232018112335.html)\n\n# [疫苗之殇](https://botanwang.com/articles/201807/%E7%96%AB%E8%8B%97%E4%B9%8B%E6%AE%87.html)\n","source":"_posts/2018-07-24-黑匣子里到底装了什么.md","raw":"---\ntitle: 黑匣子里到底装了什么\ndate: 2018-07-24 12:47:29\ntags: [人生百态]\ntoc: false\ncategories: 琐碎\n---\n\n> **脏乱不堪的房间里忽然透进来一道微弱的光。多希望有人能一脚把门踹开，让房间里的人都能看到这些“脏乱“。**\n>\n> ---文昭\n>\n> **当民族主义与爱国情怀在中国氤氲蒸腾之时，千疮百孔的食药安全已经成为最为腐朽的短板，它让日益凝聚的共同体显得格外脆弱，撕扯出的每个裂痕都再难修复**\n>\n> --《疫苗事件击穿社会底线 中共构建共同体面临危机 》\n\n**长春长生的狂犬病疫苗造假事件继续发酵。一场关于国产疫苗的信任危机，在民间迅速蔓延。让我们不仅发问，是哪个环节出了问题？会带给人什么影响？是从什么时候开始的？为什么在山东去年九月份就发现了，怎么现在才查出来？为什么长春长生为什么从一个国企，有如何一步一步变成私企的？又是如何后来居上的？总理发话彻查，能否从根治理，以后还还出现类似的事情么？国家又是如何去建设国民对疫苗的自信心的？这样的事情发生后，为什么屡禁不止？为何管理三鹿的人和管理疫苗的人是同一个？为何有的人觉得和自己没关系就可以置若罔闻？为何看到报道少之又少，那些报道都去了哪里？。。。** ![](http://www.jixiaokang.com/wp-content/uploads/2018/07/weibo.jpg) 7 月 21 日，夜晚 22:00 时许，广州天河区的徐丽（化名）临睡前点开小区业主微信群，发现群里的妈妈们都在着急翻看自己孩子的《儿童预防接种证》。她们期待着，曾经注射进孩子体内的白百破疫苗，千万不要是长春长生生产的。 而在 1200 公里外的武汉市，31 岁的妈妈阿琳，则带着自己一岁半的女儿，踏上了前往香港接种肺炎 13 价疫苗的道路。 但是，阿琳不知道的是，她的目的地香港，也正在遭受疫苗断供的危机。来自顺德的珍姐，已经在香港尖沙咀的一家诊所里接种了两针。但自今年 5 月以来，HPV 九价疫苗不仅从 6100 港币三针，涨到了 7800 —9000 港币，还经常缺货。 **一针仅有 0.5 毫升的疫苗，牵动着千家万户的心。**\n\n- **65 万支不合格白百破疫苗 流去了哪里**\n\n[GitHub](https://github.com/fuckcqcs)      这是一个 程序员搜集政府网站上纰漏的疫苗流向，真是个大好人\n\n- **那些被疫苗毒害的人--摘自博谈网**\n\n2009 年 5 月，董梓欣的出生给家人带来了莫大的快乐。同年 12 月，奶奶带孩子去卫生所接种了 A 群流脑疫苗和口服轮状病毒疫苗，结果孩子当天就开始发烧，辗转多家医院后，医院告诉他们：孩子造成的脑损害不可逆转，任何治疗均不再有价值。 从死亡线上被救回来的许译文大脑严重受损，在经过多次干细胞移植之后，唯一的进步就是会在父母的要求下击打几次小鼓。2011 年 2 月，许伟的妻子带女儿许译文接种了百白破的第二针和脊灰的第三剂。5 天之后孩子突然出现发热、抽搐等症状，两天下了四份病危通知书。历经三家医院一个多月的治疗，女儿生命体征才得以稳定下来。但此时孩子已经脑部萎缩，基本处于无意识状态，失去肢体活动能力，市人民医院的诊断为：病毒性脑病。 2012 年 4 月 23 日，龚建的妻子抱着孩子去了社区卫生服务中心接种疫苗，疫苗接种后孩子身体出现异常，在血常规检查的时候发现血小板竟然只剩下 11 个（人体正常值是 100~300），孩子连夜住进了 ICU。医院连下了几次病危通知书，并很快在 5 月 8 日做了第一次骨髓穿刺。在一次次的骨髓穿刺中，这个一岁半的孩子受尽了折磨，妈妈精神也接近崩溃。可最终还是没能停住死神的脚步，2013 年 4 月 22 日凌晨，龚子崇因血小板过低导致的颅内出血去世。 谢俊杰今年 5 岁，本应该是起淘气不消停的年纪，但他大部分的玩耍时间都是在阁楼上独自度过，一刻也不能离开父母的视线。注射疫苗导致的 ‌‌‌‌“血小板减少性紫癜 ‌‌‌‌”，这个拗口的名字如同一个隐身的魔鬼，随时威胁着他的生命。 方灶群陪着小沁怡在楼下的空地玩耍，小家伙将手里的玩具娃娃甩来甩去，稍不满意就大喊大叫，‌‌‌‌“从小就住院，孩子的性格受到很大影响 ‌‌‌‌”。2011 年 3 月，方灶群夫妇带着女儿方沁怡接种卡介苗，5 月底时，作为护士的妻子在一次给孩子洗澡时发现其腋下淋巴肿大，直到 7 月份，孩子的淋巴肿大已经有鸡蛋大小了，还出现溃烂。在不断奔波治疗的同时，方灶群也不断地找疾控中心要求鉴定。最终得到了 ‌‌‌‌“接种卡介苗后淋巴结严重反应 ‌‌‌‌”的结论，并给出了三级丙等的伤残鉴定。 2013 年清明节，夫妻俩回了老家给去世已经三年的孩子的坟头立了块碑，并冲洗了和孩子等大的照片，就像孩子还活着。2009 年，女儿费晶铭正值花季，天生一副好嗓子学美声，梦想考上解放军艺术学院。同年 11 月打了甲流疫苗，之后被诊断为 ‌‌‌‌“急性重症再生障碍性贫血 ‌‌‌‌”。晶晶在入院到去世前，三个月的时间里做了四次骨髓穿刺。在最后一次穿刺中生命体征恶化，最终离开人世。 一年前，马宇轩还在深圳，会在父母的注视下随着音乐跳舞；一年后，马宇轩在湖南常德老家，安静地躺在婴儿床上，对这个世界再没有回应。改变这一切的是一针疫苗。2012 年 2 月 15 日小宇轩进行了乙脑疫苗的注射，仅仅过了 6 天，突然开始发烧、呕吐甚至抽搐。但是住院三天也没查出病因，情况也越来越糟，之后被送到了深圳市儿童医院 ICU，医院给出的诊断是：乙脑。 梁嘉怡已经 12 岁了，却还是只有一捧大，智力为零。2001 年，梁永立的小女儿梁嘉怡出生，健康可爱。2003 年 8 月，梁永立带小嘉怡到会城卫生院一门诊打第二支乙型脑炎预防针。次日凌晨，小嘉怡发起了高烧，住院治疗，出院确诊为 ‌‌‌‌“重症病毒性脑炎 ‌‌‌‌”。转眼近 10 年过去了，梁嘉怡已经接近植物人的状态，四肢萎缩，只有几十斤重，每日饮食都要靠豆浆机打成汁状喂下去。为了讨说法，父亲梁永立曾历时 35 天骑自行车到北京上访。 易世华在历经几个月的昏迷和几次抢救之后终于活下来，现在郑州一家卫校学习，她说现在的生活就像宿舍楼下的场景一样，一团糟。易世华原本是个聪明伶俐、讨人喜欢的孩子。2006 年 12 月，她和所有同学一样由校医注射了流脑（A+C）疫苗，噩梦从此开始。几天后，她突然变得思维迟钝、胡言乱语，后来还突然昏倒了。到北京治疗时，易世华已经昏迷不醒，生命垂危。最后医院诊断为 ‌‌‌‌“急性播散性脑脊髓炎 ‌‌‌‌”。 余荣辉在打疫苗之前获得过江门市第一届五年级作文大王比赛的一等奖，他写作的题目是《拯救地球》。他最终也没有完成梦想，他甚至连自己都拯救不了，注射疫苗后导致智力低下，喜怒无常，无力面对多舛的世界。 王昭洁已经 7 岁，每日在院子里房子里漫无目的的徘徊。2007 年 4 月 9 日，当时 6 个月大的王昭洁注射了乙肝疫苗的第三针，厄运从此开始。当晚就开始发高烧，很快就发展到惊厥抽搐。从此之后，孩子只要一发烧就抽搐，又过了半年，竟然开始不发烧也抽搐了。智力接近于零，连喝水都要用针管打到嘴里。 李佳欣于 2009 注射了乙脑疫苗，2010 年出现发热和全身抽搐。在当地医院治疗效果不佳后于 1 月 19 日转到大医院就诊，诊断为：‌‌‌‌“急性播散性脑脊髓膜炎 ‌‌‌‌”。住院 22 天后出院，后语言功能和运动功能都受到损害，留下后遗症。西安市预防接种异常反应小组鉴定为与疫苗无关。李尊伟不服，2011 年 1 月 13 日在户县卫生局以死相逼，服下了整瓶的安眠药，经医院抢救才得以脱险。当年，双方达成赔偿协议。 ‌‌‌‌“我祈祷奇迹在儿子身上出现，让一切的痛苦都离我们远去，回到以前的幸福平静的生活中去，让时间倒流到 2010 年 3 月 16 日，把儿子身上的那针药水取回……‌‌‌‌”李宝向在申诉书里这样写道。那一天，他八岁的儿子李致康打完甲流疫苗，表现得没精打采，之后的两三天，孩子一直气息奄奄。辗转多地最终来到北京，在北京儿童医院 ICU，四个月的治疗花去了三十万元，耗尽积蓄，但换来的确是 ‌‌‌‌“植物人 ‌‌‌‌”状态的孩子。 王艺筱已经四岁，连翻身都不会。父母奔忙终日换得一点治疗费用，奶奶做饭的时候，她只能安静地躺在玩具堆里。2010 年 3 月，妈妈史玉凤带王艺筱在临沂市妇幼保健院接种了 A 群流脑疫苗，当晚孩子就发高烧并开始抽搐，被诊断为重症病毒性脑炎。转到临沂市人民医院治疗半年依然无效。当年 9 月，他们去了北京大学妇儿医院，病情才逐渐稳定，但巨额的医疗费用已让这个家庭濒临绝境。 注射强化麻疹疫苗之后，孙舒晴就患上了血小板减少性紫癜，长期大剂量的激素治疗虽然暂时保住了命，但是却让她的身体停止了生长，六岁的孩子还停留在打疫苗前的身高。 卢佳润现在的智力基本为零，母亲带她看院子里早开的樱桃花，她在怀里一动不动，却一直睁着眼睛。卢佳润曾经在七个月大的时候就能挨着墙站，每天早上六点就会醒来，趴在卢卫卫脸上喊爸爸。卢卫卫觉得自己是最幸福的人，但四年前的一针疫苗让这种幸福戛然而止。 郑州北郊的一间狭小的出租屋里，患血小板减少性紫癜，随时会有生命危险的张俊龙已经这样一动不动躺了三年。 注射疫苗之后，这个本来都会爬了的孩子再也没能站起来，年轻的母亲伤心欲绝。高晨翔，一个曾寄托了这个家庭无数希望的名字。‌‌‌‌“现在叫什么都不重要了，孩子已经完全毁了，我们这个家一辈子都只能熬著过冬了 ‌‌‌‌”。此时，高晨翔正在炕上吮吸手指，不停蠕动着发出奇怪的声响。 每天晚饭后，奶奶和妈妈都会带着冀赟去街上走走，算是康复治疗的延续。疾控中心所公布的百万分之一的疫苗不良反应率在统计学上或许微不足道，但对于每一个受害家庭而言却是百分之百的灾难。近日山东非法疫苗案再次刺痛了我们的双眼，悲剧轮番重播，我们只愿今后苦难不再无止境的上演。\n\n- 八孽\n\n第一孽：食品。三聚氰胺、毒大米、地沟油、塑化剂、毒月饼、染色馒头、蛆虫门、致癌门、牛肉膏、毒生姜、瘦肉精、催熟剂、膨大素等这些世界特有的中国名词，无不记载着中国百姓受害的声声血泪史。善良的中国百姓惹不起总躲得起吧，于是逃离本土去海外买。中国那些害人的食品不仅让国人损命，让食品业丢人，让全体的中国大陆百姓蒙羞！更让中国人二个字扣上了悲哀的帽子！官员们吃的是为他们“特供”的食品，从不用担心地沟油苏丹红和添加剂对他们身体的损害和破坏，他们子孙们一生下来就享受到了“非人”的待遇。 第二孽：汽车。1955 年，“新中国”就具备了汽车的制造能力，那时的韩国几乎没有汽车产业。可是，同为 1967 年成立的韩国大宇、韩国现代汽车已现已风靡世界，就连中华人民共和国的首都也在用脸贴上别人的屁股，共享“北京现代”之荣耀。殊不知，北京并没拥有真正的现代，而“现代”却拥有了北京。同样，还有拥有上海的通用、拥有广州的本田、拥有武汉的日产、拥有吉林的大众……如今的中国城市大街上跑的几乎是外国车，而韩国大街上几乎看不到外国车，日本所有城市几乎是本国的本田、丰田、日产、三菱……。这个国家战略资源却让整个汽车行业整得只是为人做嫁衣裳，真是“卖了老婆还帮别人去数钱”，丢人现眼到老祖宗！ 第三孽：电信。远在美国读书的刘翰每次都会掐断父母从国内打来的电话，原因是在国内打到美国每分钟要 8 元以上，即使 IP 电话也要 2.40 元，还不包括市话费。而在美国，往国内打电话每分钟往往小于一美分，比较常见的价格是 10 元人民币 1000 分钟，由此推算中国的电话费竟然高于美国 100 倍呀！要知道中国人的收入只有美国人的十分之一呀。好了，美国太强大了，我们不好比了，阿 Q 就是阿 Q，撑什么阿……。 第四孽：教育。中国孩子已成了高考流水线上的畸形产品。在这凹凸不平、千刀万剐的高考线上，不知扼杀了多少伟人天才，“包养”了多少听话会考的低能废物。如果国家对西部边穷地区考虑尚可理解，可北京上海为何还要剥夺其它省份的入学名额？如果说禁止湖北的孩子以海南户籍参加高考可以理解，为何自称“首善之区”的北京、你却要让生于京、长于京，只是没有所谓“北京户口”的上百万孩子被迫沦为“职业学校”的学生？这种“两手都硬”的政策，促成了北京有的一所中学每年就输入近 200 名学生到北大、清华，几乎相当于几个省的总和。真是有些人出生就有的东西，却是更多人一辈子追求的东西。那么所谓的“北京户口”又是一个“神马”东西？只不过是：他(她)爷爷姥爷们早几年先到了北京那个地方找个“窝棚”住下罢了。因为官员们的孩子都上了国内外最好的学校，想留洋就留洋，想出国就出国，从不用为进个公办幼稚园而通宵达旦去排队。于是，部分人群开始向教育部进行无用但持续的请愿，更多的人开始向国学寻找教育的公平。由于出国留学人群如洪水，让经济不景气的美国加拿大、英国、法国、西班牙等如获救命稻草，纷纷抛起政见，来抢中国的生源了。试想，一些无奈出国的孩子经过西方的流水线的改造后，以后对我们传统教育和封闭不公的决策者而言该是多么的悲哀？ 第五孽：房地产。中国政府的行业政策，没有哪个像房地产政策这样频出，又是“限购”，又是房产税……。可每次政策出台基本又是一个笑柄。其实大家都明白，假如政策制定者和管理者自己没有房子，或远离房地产商与他们没有勾结，或没有利益通吃，假如地方政府不把房地产业当经济核财政支柱，或政绩爬升的资本，政府制定的政策就不可能屡次都成为房价的丢人笑柄与助推器。 第六孽：煤炭石化。有人统计，近三十年非战争非正常死亡人数，中国比全球其他国家合计还多。造成中国死亡的人数原因主要有地震、交通事故和煤炭开采，其中让世界震惊的是煤炭开采为何死这么多人。中国的煤炭行业到底怎么了。 第七孽：医疗卫生。让国人震惊和愤怒的医药事故近些年层出不穷，杀医生事件频繁发生，即使把狼狈为奸的国家药监局原局长郑筱萸们判死刑也难以从根本上解决问题，本来就是社会制度和体制问题，官员们却高喊，找不出什么有效的办法了！ 中国仅有的一点医疗卫生资源，也向干部官员公务员群体过度倾斜，万恶的给药“分级制度”，对参加医疗保险的人群，也耍按照他们的政治地位、社会地位划分等级，级别越高的，得到的医疗服务质量越高，药品供应也耍越好，而老百姓就连基本的医疗都难以保证！“自锯病腿”的悲剧，是生在中国老百姓的真正悲哀！就医难，治病贵，有病不敢医，大病不敢住院依然是中国许多地方、尤其是农村的客观现状。政府们医 改喊了这么多年，老百姓几乎就骂了这么多年，可黑了心的医院,坏了良心的医生,为了骗取患者钱财还在乱下处方胡乱开药。他们内外勾结，为拿回扣，会把药价虚高到 100 倍,放任那么多黑心医生大发黑心财，索要红包明目张胆，不送红包就会缝上你缸门，把纱布留在肚子里！ 市场化医疗下，高级官员们都可住上高干部病房，豪华疗养院，享受的是去全中国各大医院，全额免费医疗，和特供的国产和进口药品的待遇。中国官员们享受的是全额医药免费，对老百姓患了大病无钱医冶跳楼自杀无动于衷，官员特权医疗，黑了心的医生成为杀害病患老百姓的无形屠刀赢利赚钱的黑医生是杀病患老百姓的刽子手！ 第八孽：交通。随着汽车越来越多，城市交通越来越拥挤，我认为最丢人的还是我们大众平日开车的不文明行为：酒驾、闯红灯、向窗外扔杂物、乱停车、超车、不排队、地铁上吃东西……。不仅造成了大量的人员伤亡，也让整个中国人的形象丢尽，尤其是当你如把某些习惯带到国外时，别人对我们同胞行为的眼神其实是整个中国这个国家在丢人…… 谨以此文，纪念那些受伤的孩童 相关链接\n\n# [追忆『疫苗之殇』](https://wentommy.wordpress.com/2018/07/20/%E8%BF%BD%E5%BF%86%E3%80%8E%E7%96%AB%E8%8B%97%E4%B9%8B%E6%AE%87%E3%80%8F/)\n\n# [疫苗之殇痛殴“四个自信”（高新）](https://www.rfa.org/mandarin/zhuanlan/yehuazhongnanhai/gx-07232018112335.html)\n\n# [疫苗之殇](https://botanwang.com/articles/201807/%E7%96%AB%E8%8B%97%E4%B9%8B%E6%AE%87.html)\n","slug":"2018-07-24-黑匣子里到底装了什么","published":1,"updated":"2020-03-14T07:09:19.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvnq006d4k8y809r4t3l","content":"<blockquote>\n<p><strong>脏乱不堪的房间里忽然透进来一道微弱的光。多希望有人能一脚把门踹开，让房间里的人都能看到这些“脏乱“。</strong></p>\n<p>—文昭</p>\n<p><strong>当民族主义与爱国情怀在中国氤氲蒸腾之时，千疮百孔的食药安全已经成为最为腐朽的短板，它让日益凝聚的共同体显得格外脆弱，撕扯出的每个裂痕都再难修复</strong></p>\n<p>–《疫苗事件击穿社会底线 中共构建共同体面临危机 》</p>\n</blockquote>\n<p><strong>长春长生的狂犬病疫苗造假事件继续发酵。一场关于国产疫苗的信任危机，在民间迅速蔓延。让我们不仅发问，是哪个环节出了问题？会带给人什么影响？是从什么时候开始的？为什么在山东去年九月份就发现了，怎么现在才查出来？为什么长春长生为什么从一个国企，有如何一步一步变成私企的？又是如何后来居上的？总理发话彻查，能否从根治理，以后还还出现类似的事情么？国家又是如何去建设国民对疫苗的自信心的？这样的事情发生后，为什么屡禁不止？为何管理三鹿的人和管理疫苗的人是同一个？为何有的人觉得和自己没关系就可以置若罔闻？为何看到报道少之又少，那些报道都去了哪里？。。。</strong> <img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/07/weibo.jpg\" alt=\"\"> 7 月 21 日，夜晚 22:00 时许，广州天河区的徐丽（化名）临睡前点开小区业主微信群，发现群里的妈妈们都在着急翻看自己孩子的《儿童预防接种证》。她们期待着，曾经注射进孩子体内的白百破疫苗，千万不要是长春长生生产的。 而在 1200 公里外的武汉市，31 岁的妈妈阿琳，则带着自己一岁半的女儿，踏上了前往香港接种肺炎 13 价疫苗的道路。 但是，阿琳不知道的是，她的目的地香港，也正在遭受疫苗断供的危机。来自顺德的珍姐，已经在香港尖沙咀的一家诊所里接种了两针。但自今年 5 月以来，HPV 九价疫苗不仅从 6100 港币三针，涨到了 7800 —9000 港币，还经常缺货。 <strong>一针仅有 0.5 毫升的疫苗，牵动着千家万户的心。</strong></p>\n<ul>\n<li><strong>65 万支不合格白百破疫苗 流去了哪里</strong></li>\n</ul>\n<p><a href=\"https://github.com/fuckcqcs\" target=\"_blank\" rel=\"noopener\">GitHub</a>      这是一个 程序员搜集政府网站上纰漏的疫苗流向，真是个大好人</p>\n<ul>\n<li><strong>那些被疫苗毒害的人–摘自博谈网</strong></li>\n</ul>\n<p>2009 年 5 月，董梓欣的出生给家人带来了莫大的快乐。同年 12 月，奶奶带孩子去卫生所接种了 A 群流脑疫苗和口服轮状病毒疫苗，结果孩子当天就开始发烧，辗转多家医院后，医院告诉他们：孩子造成的脑损害不可逆转，任何治疗均不再有价值。 从死亡线上被救回来的许译文大脑严重受损，在经过多次干细胞移植之后，唯一的进步就是会在父母的要求下击打几次小鼓。2011 年 2 月，许伟的妻子带女儿许译文接种了百白破的第二针和脊灰的第三剂。5 天之后孩子突然出现发热、抽搐等症状，两天下了四份病危通知书。历经三家医院一个多月的治疗，女儿生命体征才得以稳定下来。但此时孩子已经脑部萎缩，基本处于无意识状态，失去肢体活动能力，市人民医院的诊断为：病毒性脑病。 2012 年 4 月 23 日，龚建的妻子抱着孩子去了社区卫生服务中心接种疫苗，疫苗接种后孩子身体出现异常，在血常规检查的时候发现血小板竟然只剩下 11 个（人体正常值是 100~300），孩子连夜住进了 ICU。医院连下了几次病危通知书，并很快在 5 月 8 日做了第一次骨髓穿刺。在一次次的骨髓穿刺中，这个一岁半的孩子受尽了折磨，妈妈精神也接近崩溃。可最终还是没能停住死神的脚步，2013 年 4 月 22 日凌晨，龚子崇因血小板过低导致的颅内出血去世。 谢俊杰今年 5 岁，本应该是起淘气不消停的年纪，但他大部分的玩耍时间都是在阁楼上独自度过，一刻也不能离开父母的视线。注射疫苗导致的 ‌‌‌‌“血小板减少性紫癜 ‌‌‌‌”，这个拗口的名字如同一个隐身的魔鬼，随时威胁着他的生命。 方灶群陪着小沁怡在楼下的空地玩耍，小家伙将手里的玩具娃娃甩来甩去，稍不满意就大喊大叫，‌‌‌‌“从小就住院，孩子的性格受到很大影响 ‌‌‌‌”。2011 年 3 月，方灶群夫妇带着女儿方沁怡接种卡介苗，5 月底时，作为护士的妻子在一次给孩子洗澡时发现其腋下淋巴肿大，直到 7 月份，孩子的淋巴肿大已经有鸡蛋大小了，还出现溃烂。在不断奔波治疗的同时，方灶群也不断地找疾控中心要求鉴定。最终得到了 ‌‌‌‌“接种卡介苗后淋巴结严重反应 ‌‌‌‌”的结论，并给出了三级丙等的伤残鉴定。 2013 年清明节，夫妻俩回了老家给去世已经三年的孩子的坟头立了块碑，并冲洗了和孩子等大的照片，就像孩子还活着。2009 年，女儿费晶铭正值花季，天生一副好嗓子学美声，梦想考上解放军艺术学院。同年 11 月打了甲流疫苗，之后被诊断为 ‌‌‌‌“急性重症再生障碍性贫血 ‌‌‌‌”。晶晶在入院到去世前，三个月的时间里做了四次骨髓穿刺。在最后一次穿刺中生命体征恶化，最终离开人世。 一年前，马宇轩还在深圳，会在父母的注视下随着音乐跳舞；一年后，马宇轩在湖南常德老家，安静地躺在婴儿床上，对这个世界再没有回应。改变这一切的是一针疫苗。2012 年 2 月 15 日小宇轩进行了乙脑疫苗的注射，仅仅过了 6 天，突然开始发烧、呕吐甚至抽搐。但是住院三天也没查出病因，情况也越来越糟，之后被送到了深圳市儿童医院 ICU，医院给出的诊断是：乙脑。 梁嘉怡已经 12 岁了，却还是只有一捧大，智力为零。2001 年，梁永立的小女儿梁嘉怡出生，健康可爱。2003 年 8 月，梁永立带小嘉怡到会城卫生院一门诊打第二支乙型脑炎预防针。次日凌晨，小嘉怡发起了高烧，住院治疗，出院确诊为 ‌‌‌‌“重症病毒性脑炎 ‌‌‌‌”。转眼近 10 年过去了，梁嘉怡已经接近植物人的状态，四肢萎缩，只有几十斤重，每日饮食都要靠豆浆机打成汁状喂下去。为了讨说法，父亲梁永立曾历时 35 天骑自行车到北京上访。 易世华在历经几个月的昏迷和几次抢救之后终于活下来，现在郑州一家卫校学习，她说现在的生活就像宿舍楼下的场景一样，一团糟。易世华原本是个聪明伶俐、讨人喜欢的孩子。2006 年 12 月，她和所有同学一样由校医注射了流脑（A+C）疫苗，噩梦从此开始。几天后，她突然变得思维迟钝、胡言乱语，后来还突然昏倒了。到北京治疗时，易世华已经昏迷不醒，生命垂危。最后医院诊断为 ‌‌‌‌“急性播散性脑脊髓炎 ‌‌‌‌”。 余荣辉在打疫苗之前获得过江门市第一届五年级作文大王比赛的一等奖，他写作的题目是《拯救地球》。他最终也没有完成梦想，他甚至连自己都拯救不了，注射疫苗后导致智力低下，喜怒无常，无力面对多舛的世界。 王昭洁已经 7 岁，每日在院子里房子里漫无目的的徘徊。2007 年 4 月 9 日，当时 6 个月大的王昭洁注射了乙肝疫苗的第三针，厄运从此开始。当晚就开始发高烧，很快就发展到惊厥抽搐。从此之后，孩子只要一发烧就抽搐，又过了半年，竟然开始不发烧也抽搐了。智力接近于零，连喝水都要用针管打到嘴里。 李佳欣于 2009 注射了乙脑疫苗，2010 年出现发热和全身抽搐。在当地医院治疗效果不佳后于 1 月 19 日转到大医院就诊，诊断为：‌‌‌‌“急性播散性脑脊髓膜炎 ‌‌‌‌”。住院 22 天后出院，后语言功能和运动功能都受到损害，留下后遗症。西安市预防接种异常反应小组鉴定为与疫苗无关。李尊伟不服，2011 年 1 月 13 日在户县卫生局以死相逼，服下了整瓶的安眠药，经医院抢救才得以脱险。当年，双方达成赔偿协议。 ‌‌‌‌“我祈祷奇迹在儿子身上出现，让一切的痛苦都离我们远去，回到以前的幸福平静的生活中去，让时间倒流到 2010 年 3 月 16 日，把儿子身上的那针药水取回……‌‌‌‌”李宝向在申诉书里这样写道。那一天，他八岁的儿子李致康打完甲流疫苗，表现得没精打采，之后的两三天，孩子一直气息奄奄。辗转多地最终来到北京，在北京儿童医院 ICU，四个月的治疗花去了三十万元，耗尽积蓄，但换来的确是 ‌‌‌‌“植物人 ‌‌‌‌”状态的孩子。 王艺筱已经四岁，连翻身都不会。父母奔忙终日换得一点治疗费用，奶奶做饭的时候，她只能安静地躺在玩具堆里。2010 年 3 月，妈妈史玉凤带王艺筱在临沂市妇幼保健院接种了 A 群流脑疫苗，当晚孩子就发高烧并开始抽搐，被诊断为重症病毒性脑炎。转到临沂市人民医院治疗半年依然无效。当年 9 月，他们去了北京大学妇儿医院，病情才逐渐稳定，但巨额的医疗费用已让这个家庭濒临绝境。 注射强化麻疹疫苗之后，孙舒晴就患上了血小板减少性紫癜，长期大剂量的激素治疗虽然暂时保住了命，但是却让她的身体停止了生长，六岁的孩子还停留在打疫苗前的身高。 卢佳润现在的智力基本为零，母亲带她看院子里早开的樱桃花，她在怀里一动不动，却一直睁着眼睛。卢佳润曾经在七个月大的时候就能挨着墙站，每天早上六点就会醒来，趴在卢卫卫脸上喊爸爸。卢卫卫觉得自己是最幸福的人，但四年前的一针疫苗让这种幸福戛然而止。 郑州北郊的一间狭小的出租屋里，患血小板减少性紫癜，随时会有生命危险的张俊龙已经这样一动不动躺了三年。 注射疫苗之后，这个本来都会爬了的孩子再也没能站起来，年轻的母亲伤心欲绝。高晨翔，一个曾寄托了这个家庭无数希望的名字。‌‌‌‌“现在叫什么都不重要了，孩子已经完全毁了，我们这个家一辈子都只能熬著过冬了 ‌‌‌‌”。此时，高晨翔正在炕上吮吸手指，不停蠕动着发出奇怪的声响。 每天晚饭后，奶奶和妈妈都会带着冀赟去街上走走，算是康复治疗的延续。疾控中心所公布的百万分之一的疫苗不良反应率在统计学上或许微不足道，但对于每一个受害家庭而言却是百分之百的灾难。近日山东非法疫苗案再次刺痛了我们的双眼，悲剧轮番重播，我们只愿今后苦难不再无止境的上演。</p>\n<ul>\n<li>八孽</li>\n</ul>\n<p>第一孽：食品。三聚氰胺、毒大米、地沟油、塑化剂、毒月饼、染色馒头、蛆虫门、致癌门、牛肉膏、毒生姜、瘦肉精、催熟剂、膨大素等这些世界特有的中国名词，无不记载着中国百姓受害的声声血泪史。善良的中国百姓惹不起总躲得起吧，于是逃离本土去海外买。中国那些害人的食品不仅让国人损命，让食品业丢人，让全体的中国大陆百姓蒙羞！更让中国人二个字扣上了悲哀的帽子！官员们吃的是为他们“特供”的食品，从不用担心地沟油苏丹红和添加剂对他们身体的损害和破坏，他们子孙们一生下来就享受到了“非人”的待遇。 第二孽：汽车。1955 年，“新中国”就具备了汽车的制造能力，那时的韩国几乎没有汽车产业。可是，同为 1967 年成立的韩国大宇、韩国现代汽车已现已风靡世界，就连中华人民共和国的首都也在用脸贴上别人的屁股，共享“北京现代”之荣耀。殊不知，北京并没拥有真正的现代，而“现代”却拥有了北京。同样，还有拥有上海的通用、拥有广州的本田、拥有武汉的日产、拥有吉林的大众……如今的中国城市大街上跑的几乎是外国车，而韩国大街上几乎看不到外国车，日本所有城市几乎是本国的本田、丰田、日产、三菱……。这个国家战略资源却让整个汽车行业整得只是为人做嫁衣裳，真是“卖了老婆还帮别人去数钱”，丢人现眼到老祖宗！ 第三孽：电信。远在美国读书的刘翰每次都会掐断父母从国内打来的电话，原因是在国内打到美国每分钟要 8 元以上，即使 IP 电话也要 2.40 元，还不包括市话费。而在美国，往国内打电话每分钟往往小于一美分，比较常见的价格是 10 元人民币 1000 分钟，由此推算中国的电话费竟然高于美国 100 倍呀！要知道中国人的收入只有美国人的十分之一呀。好了，美国太强大了，我们不好比了，阿 Q 就是阿 Q，撑什么阿……。 第四孽：教育。中国孩子已成了高考流水线上的畸形产品。在这凹凸不平、千刀万剐的高考线上，不知扼杀了多少伟人天才，“包养”了多少听话会考的低能废物。如果国家对西部边穷地区考虑尚可理解，可北京上海为何还要剥夺其它省份的入学名额？如果说禁止湖北的孩子以海南户籍参加高考可以理解，为何自称“首善之区”的北京、你却要让生于京、长于京，只是没有所谓“北京户口”的上百万孩子被迫沦为“职业学校”的学生？这种“两手都硬”的政策，促成了北京有的一所中学每年就输入近 200 名学生到北大、清华，几乎相当于几个省的总和。真是有些人出生就有的东西，却是更多人一辈子追求的东西。那么所谓的“北京户口”又是一个“神马”东西？只不过是：他(她)爷爷姥爷们早几年先到了北京那个地方找个“窝棚”住下罢了。因为官员们的孩子都上了国内外最好的学校，想留洋就留洋，想出国就出国，从不用为进个公办幼稚园而通宵达旦去排队。于是，部分人群开始向教育部进行无用但持续的请愿，更多的人开始向国学寻找教育的公平。由于出国留学人群如洪水，让经济不景气的美国加拿大、英国、法国、西班牙等如获救命稻草，纷纷抛起政见，来抢中国的生源了。试想，一些无奈出国的孩子经过西方的流水线的改造后，以后对我们传统教育和封闭不公的决策者而言该是多么的悲哀？ 第五孽：房地产。中国政府的行业政策，没有哪个像房地产政策这样频出，又是“限购”，又是房产税……。可每次政策出台基本又是一个笑柄。其实大家都明白，假如政策制定者和管理者自己没有房子，或远离房地产商与他们没有勾结，或没有利益通吃，假如地方政府不把房地产业当经济核财政支柱，或政绩爬升的资本，政府制定的政策就不可能屡次都成为房价的丢人笑柄与助推器。 第六孽：煤炭石化。有人统计，近三十年非战争非正常死亡人数，中国比全球其他国家合计还多。造成中国死亡的人数原因主要有地震、交通事故和煤炭开采，其中让世界震惊的是煤炭开采为何死这么多人。中国的煤炭行业到底怎么了。 第七孽：医疗卫生。让国人震惊和愤怒的医药事故近些年层出不穷，杀医生事件频繁发生，即使把狼狈为奸的国家药监局原局长郑筱萸们判死刑也难以从根本上解决问题，本来就是社会制度和体制问题，官员们却高喊，找不出什么有效的办法了！ 中国仅有的一点医疗卫生资源，也向干部官员公务员群体过度倾斜，万恶的给药“分级制度”，对参加医疗保险的人群，也耍按照他们的政治地位、社会地位划分等级，级别越高的，得到的医疗服务质量越高，药品供应也耍越好，而老百姓就连基本的医疗都难以保证！“自锯病腿”的悲剧，是生在中国老百姓的真正悲哀！就医难，治病贵，有病不敢医，大病不敢住院依然是中国许多地方、尤其是农村的客观现状。政府们医 改喊了这么多年，老百姓几乎就骂了这么多年，可黑了心的医院,坏了良心的医生,为了骗取患者钱财还在乱下处方胡乱开药。他们内外勾结，为拿回扣，会把药价虚高到 100 倍,放任那么多黑心医生大发黑心财，索要红包明目张胆，不送红包就会缝上你缸门，把纱布留在肚子里！ 市场化医疗下，高级官员们都可住上高干部病房，豪华疗养院，享受的是去全中国各大医院，全额免费医疗，和特供的国产和进口药品的待遇。中国官员们享受的是全额医药免费，对老百姓患了大病无钱医冶跳楼自杀无动于衷，官员特权医疗，黑了心的医生成为杀害病患老百姓的无形屠刀赢利赚钱的黑医生是杀病患老百姓的刽子手！ 第八孽：交通。随着汽车越来越多，城市交通越来越拥挤，我认为最丢人的还是我们大众平日开车的不文明行为：酒驾、闯红灯、向窗外扔杂物、乱停车、超车、不排队、地铁上吃东西……。不仅造成了大量的人员伤亡，也让整个中国人的形象丢尽，尤其是当你如把某些习惯带到国外时，别人对我们同胞行为的眼神其实是整个中国这个国家在丢人…… 谨以此文，纪念那些受伤的孩童 相关链接</p>\n<h1 id=\"追忆『疫苗之殇』\"><a href=\"#追忆『疫苗之殇』\" class=\"headerlink\" title=\"追忆『疫苗之殇』\"></a><a href=\"https://wentommy.wordpress.com/2018/07/20/%E8%BF%BD%E5%BF%86%E3%80%8E%E7%96%AB%E8%8B%97%E4%B9%8B%E6%AE%87%E3%80%8F/\" target=\"_blank\" rel=\"noopener\">追忆『疫苗之殇』</a></h1><h1 id=\"疫苗之殇痛殴“四个自信”（高新）\"><a href=\"#疫苗之殇痛殴“四个自信”（高新）\" class=\"headerlink\" title=\"疫苗之殇痛殴“四个自信”（高新）\"></a><a href=\"https://www.rfa.org/mandarin/zhuanlan/yehuazhongnanhai/gx-07232018112335.html\" target=\"_blank\" rel=\"noopener\">疫苗之殇痛殴“四个自信”（高新）</a></h1><h1 id=\"疫苗之殇\"><a href=\"#疫苗之殇\" class=\"headerlink\" title=\"疫苗之殇\"></a><a href=\"https://botanwang.com/articles/201807/%E7%96%AB%E8%8B%97%E4%B9%8B%E6%AE%87.html\" target=\"_blank\" rel=\"noopener\">疫苗之殇</a></h1>","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<blockquote>\n<p><strong>脏乱不堪的房间里忽然透进来一道微弱的光。多希望有人能一脚把门踹开，让房间里的人都能看到这些“脏乱“。</strong></p>\n<p>—文昭</p>\n<p><strong>当民族主义与爱国情怀在中国氤氲蒸腾之时，千疮百孔的食药安全已经成为最为腐朽的短板，它让日益凝聚的共同体显得格外脆弱，撕扯出的每个裂痕都再难修复</strong></p>\n<p>–《疫苗事件击穿社会底线 中共构建共同体面临危机 》</p>\n</blockquote>\n<p><strong>长春长生的狂犬病疫苗造假事件继续发酵。一场关于国产疫苗的信任危机，在民间迅速蔓延。让我们不仅发问，是哪个环节出了问题？会带给人什么影响？是从什么时候开始的？为什么在山东去年九月份就发现了，怎么现在才查出来？为什么长春长生为什么从一个国企，有如何一步一步变成私企的？又是如何后来居上的？总理发话彻查，能否从根治理，以后还还出现类似的事情么？国家又是如何去建设国民对疫苗的自信心的？这样的事情发生后，为什么屡禁不止？为何管理三鹿的人和管理疫苗的人是同一个？为何有的人觉得和自己没关系就可以置若罔闻？为何看到报道少之又少，那些报道都去了哪里？。。。</strong> <img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/07/weibo.jpg\" alt=\"\"> 7 月 21 日，夜晚 22:00 时许，广州天河区的徐丽（化名）临睡前点开小区业主微信群，发现群里的妈妈们都在着急翻看自己孩子的《儿童预防接种证》。她们期待着，曾经注射进孩子体内的白百破疫苗，千万不要是长春长生生产的。 而在 1200 公里外的武汉市，31 岁的妈妈阿琳，则带着自己一岁半的女儿，踏上了前往香港接种肺炎 13 价疫苗的道路。 但是，阿琳不知道的是，她的目的地香港，也正在遭受疫苗断供的危机。来自顺德的珍姐，已经在香港尖沙咀的一家诊所里接种了两针。但自今年 5 月以来，HPV 九价疫苗不仅从 6100 港币三针，涨到了 7800 —9000 港币，还经常缺货。 <strong>一针仅有 0.5 毫升的疫苗，牵动着千家万户的心。</strong></p>\n<ul>\n<li><strong>65 万支不合格白百破疫苗 流去了哪里</strong></li>\n</ul>\n<p><a href=\"https://github.com/fuckcqcs\" target=\"_blank\" rel=\"noopener\">GitHub</a>      这是一个 程序员搜集政府网站上纰漏的疫苗流向，真是个大好人</p>\n<ul>\n<li><strong>那些被疫苗毒害的人–摘自博谈网</strong></li>\n</ul>\n<p>2009 年 5 月，董梓欣的出生给家人带来了莫大的快乐。同年 12 月，奶奶带孩子去卫生所接种了 A 群流脑疫苗和口服轮状病毒疫苗，结果孩子当天就开始发烧，辗转多家医院后，医院告诉他们：孩子造成的脑损害不可逆转，任何治疗均不再有价值。 从死亡线上被救回来的许译文大脑严重受损，在经过多次干细胞移植之后，唯一的进步就是会在父母的要求下击打几次小鼓。2011 年 2 月，许伟的妻子带女儿许译文接种了百白破的第二针和脊灰的第三剂。5 天之后孩子突然出现发热、抽搐等症状，两天下了四份病危通知书。历经三家医院一个多月的治疗，女儿生命体征才得以稳定下来。但此时孩子已经脑部萎缩，基本处于无意识状态，失去肢体活动能力，市人民医院的诊断为：病毒性脑病。 2012 年 4 月 23 日，龚建的妻子抱着孩子去了社区卫生服务中心接种疫苗，疫苗接种后孩子身体出现异常，在血常规检查的时候发现血小板竟然只剩下 11 个（人体正常值是 100~300），孩子连夜住进了 ICU。医院连下了几次病危通知书，并很快在 5 月 8 日做了第一次骨髓穿刺。在一次次的骨髓穿刺中，这个一岁半的孩子受尽了折磨，妈妈精神也接近崩溃。可最终还是没能停住死神的脚步，2013 年 4 月 22 日凌晨，龚子崇因血小板过低导致的颅内出血去世。 谢俊杰今年 5 岁，本应该是起淘气不消停的年纪，但他大部分的玩耍时间都是在阁楼上独自度过，一刻也不能离开父母的视线。注射疫苗导致的 ‌‌‌‌“血小板减少性紫癜 ‌‌‌‌”，这个拗口的名字如同一个隐身的魔鬼，随时威胁着他的生命。 方灶群陪着小沁怡在楼下的空地玩耍，小家伙将手里的玩具娃娃甩来甩去，稍不满意就大喊大叫，‌‌‌‌“从小就住院，孩子的性格受到很大影响 ‌‌‌‌”。2011 年 3 月，方灶群夫妇带着女儿方沁怡接种卡介苗，5 月底时，作为护士的妻子在一次给孩子洗澡时发现其腋下淋巴肿大，直到 7 月份，孩子的淋巴肿大已经有鸡蛋大小了，还出现溃烂。在不断奔波治疗的同时，方灶群也不断地找疾控中心要求鉴定。最终得到了 ‌‌‌‌“接种卡介苗后淋巴结严重反应 ‌‌‌‌”的结论，并给出了三级丙等的伤残鉴定。 2013 年清明节，夫妻俩回了老家给去世已经三年的孩子的坟头立了块碑，并冲洗了和孩子等大的照片，就像孩子还活着。2009 年，女儿费晶铭正值花季，天生一副好嗓子学美声，梦想考上解放军艺术学院。同年 11 月打了甲流疫苗，之后被诊断为 ‌‌‌‌“急性重症再生障碍性贫血 ‌‌‌‌”。晶晶在入院到去世前，三个月的时间里做了四次骨髓穿刺。在最后一次穿刺中生命体征恶化，最终离开人世。 一年前，马宇轩还在深圳，会在父母的注视下随着音乐跳舞；一年后，马宇轩在湖南常德老家，安静地躺在婴儿床上，对这个世界再没有回应。改变这一切的是一针疫苗。2012 年 2 月 15 日小宇轩进行了乙脑疫苗的注射，仅仅过了 6 天，突然开始发烧、呕吐甚至抽搐。但是住院三天也没查出病因，情况也越来越糟，之后被送到了深圳市儿童医院 ICU，医院给出的诊断是：乙脑。 梁嘉怡已经 12 岁了，却还是只有一捧大，智力为零。2001 年，梁永立的小女儿梁嘉怡出生，健康可爱。2003 年 8 月，梁永立带小嘉怡到会城卫生院一门诊打第二支乙型脑炎预防针。次日凌晨，小嘉怡发起了高烧，住院治疗，出院确诊为 ‌‌‌‌“重症病毒性脑炎 ‌‌‌‌”。转眼近 10 年过去了，梁嘉怡已经接近植物人的状态，四肢萎缩，只有几十斤重，每日饮食都要靠豆浆机打成汁状喂下去。为了讨说法，父亲梁永立曾历时 35 天骑自行车到北京上访。 易世华在历经几个月的昏迷和几次抢救之后终于活下来，现在郑州一家卫校学习，她说现在的生活就像宿舍楼下的场景一样，一团糟。易世华原本是个聪明伶俐、讨人喜欢的孩子。2006 年 12 月，她和所有同学一样由校医注射了流脑（A+C）疫苗，噩梦从此开始。几天后，她突然变得思维迟钝、胡言乱语，后来还突然昏倒了。到北京治疗时，易世华已经昏迷不醒，生命垂危。最后医院诊断为 ‌‌‌‌“急性播散性脑脊髓炎 ‌‌‌‌”。 余荣辉在打疫苗之前获得过江门市第一届五年级作文大王比赛的一等奖，他写作的题目是《拯救地球》。他最终也没有完成梦想，他甚至连自己都拯救不了，注射疫苗后导致智力低下，喜怒无常，无力面对多舛的世界。 王昭洁已经 7 岁，每日在院子里房子里漫无目的的徘徊。2007 年 4 月 9 日，当时 6 个月大的王昭洁注射了乙肝疫苗的第三针，厄运从此开始。当晚就开始发高烧，很快就发展到惊厥抽搐。从此之后，孩子只要一发烧就抽搐，又过了半年，竟然开始不发烧也抽搐了。智力接近于零，连喝水都要用针管打到嘴里。 李佳欣于 2009 注射了乙脑疫苗，2010 年出现发热和全身抽搐。在当地医院治疗效果不佳后于 1 月 19 日转到大医院就诊，诊断为：‌‌‌‌“急性播散性脑脊髓膜炎 ‌‌‌‌”。住院 22 天后出院，后语言功能和运动功能都受到损害，留下后遗症。西安市预防接种异常反应小组鉴定为与疫苗无关。李尊伟不服，2011 年 1 月 13 日在户县卫生局以死相逼，服下了整瓶的安眠药，经医院抢救才得以脱险。当年，双方达成赔偿协议。 ‌‌‌‌“我祈祷奇迹在儿子身上出现，让一切的痛苦都离我们远去，回到以前的幸福平静的生活中去，让时间倒流到 2010 年 3 月 16 日，把儿子身上的那针药水取回……‌‌‌‌”李宝向在申诉书里这样写道。那一天，他八岁的儿子李致康打完甲流疫苗，表现得没精打采，之后的两三天，孩子一直气息奄奄。辗转多地最终来到北京，在北京儿童医院 ICU，四个月的治疗花去了三十万元，耗尽积蓄，但换来的确是 ‌‌‌‌“植物人 ‌‌‌‌”状态的孩子。 王艺筱已经四岁，连翻身都不会。父母奔忙终日换得一点治疗费用，奶奶做饭的时候，她只能安静地躺在玩具堆里。2010 年 3 月，妈妈史玉凤带王艺筱在临沂市妇幼保健院接种了 A 群流脑疫苗，当晚孩子就发高烧并开始抽搐，被诊断为重症病毒性脑炎。转到临沂市人民医院治疗半年依然无效。当年 9 月，他们去了北京大学妇儿医院，病情才逐渐稳定，但巨额的医疗费用已让这个家庭濒临绝境。 注射强化麻疹疫苗之后，孙舒晴就患上了血小板减少性紫癜，长期大剂量的激素治疗虽然暂时保住了命，但是却让她的身体停止了生长，六岁的孩子还停留在打疫苗前的身高。 卢佳润现在的智力基本为零，母亲带她看院子里早开的樱桃花，她在怀里一动不动，却一直睁着眼睛。卢佳润曾经在七个月大的时候就能挨着墙站，每天早上六点就会醒来，趴在卢卫卫脸上喊爸爸。卢卫卫觉得自己是最幸福的人，但四年前的一针疫苗让这种幸福戛然而止。 郑州北郊的一间狭小的出租屋里，患血小板减少性紫癜，随时会有生命危险的张俊龙已经这样一动不动躺了三年。 注射疫苗之后，这个本来都会爬了的孩子再也没能站起来，年轻的母亲伤心欲绝。高晨翔，一个曾寄托了这个家庭无数希望的名字。‌‌‌‌“现在叫什么都不重要了，孩子已经完全毁了，我们这个家一辈子都只能熬著过冬了 ‌‌‌‌”。此时，高晨翔正在炕上吮吸手指，不停蠕动着发出奇怪的声响。 每天晚饭后，奶奶和妈妈都会带着冀赟去街上走走，算是康复治疗的延续。疾控中心所公布的百万分之一的疫苗不良反应率在统计学上或许微不足道，但对于每一个受害家庭而言却是百分之百的灾难。近日山东非法疫苗案再次刺痛了我们的双眼，悲剧轮番重播，我们只愿今后苦难不再无止境的上演。</p>\n<ul>\n<li>八孽</li>\n</ul>\n<p>第一孽：食品。三聚氰胺、毒大米、地沟油、塑化剂、毒月饼、染色馒头、蛆虫门、致癌门、牛肉膏、毒生姜、瘦肉精、催熟剂、膨大素等这些世界特有的中国名词，无不记载着中国百姓受害的声声血泪史。善良的中国百姓惹不起总躲得起吧，于是逃离本土去海外买。中国那些害人的食品不仅让国人损命，让食品业丢人，让全体的中国大陆百姓蒙羞！更让中国人二个字扣上了悲哀的帽子！官员们吃的是为他们“特供”的食品，从不用担心地沟油苏丹红和添加剂对他们身体的损害和破坏，他们子孙们一生下来就享受到了“非人”的待遇。 第二孽：汽车。1955 年，“新中国”就具备了汽车的制造能力，那时的韩国几乎没有汽车产业。可是，同为 1967 年成立的韩国大宇、韩国现代汽车已现已风靡世界，就连中华人民共和国的首都也在用脸贴上别人的屁股，共享“北京现代”之荣耀。殊不知，北京并没拥有真正的现代，而“现代”却拥有了北京。同样，还有拥有上海的通用、拥有广州的本田、拥有武汉的日产、拥有吉林的大众……如今的中国城市大街上跑的几乎是外国车，而韩国大街上几乎看不到外国车，日本所有城市几乎是本国的本田、丰田、日产、三菱……。这个国家战略资源却让整个汽车行业整得只是为人做嫁衣裳，真是“卖了老婆还帮别人去数钱”，丢人现眼到老祖宗！ 第三孽：电信。远在美国读书的刘翰每次都会掐断父母从国内打来的电话，原因是在国内打到美国每分钟要 8 元以上，即使 IP 电话也要 2.40 元，还不包括市话费。而在美国，往国内打电话每分钟往往小于一美分，比较常见的价格是 10 元人民币 1000 分钟，由此推算中国的电话费竟然高于美国 100 倍呀！要知道中国人的收入只有美国人的十分之一呀。好了，美国太强大了，我们不好比了，阿 Q 就是阿 Q，撑什么阿……。 第四孽：教育。中国孩子已成了高考流水线上的畸形产品。在这凹凸不平、千刀万剐的高考线上，不知扼杀了多少伟人天才，“包养”了多少听话会考的低能废物。如果国家对西部边穷地区考虑尚可理解，可北京上海为何还要剥夺其它省份的入学名额？如果说禁止湖北的孩子以海南户籍参加高考可以理解，为何自称“首善之区”的北京、你却要让生于京、长于京，只是没有所谓“北京户口”的上百万孩子被迫沦为“职业学校”的学生？这种“两手都硬”的政策，促成了北京有的一所中学每年就输入近 200 名学生到北大、清华，几乎相当于几个省的总和。真是有些人出生就有的东西，却是更多人一辈子追求的东西。那么所谓的“北京户口”又是一个“神马”东西？只不过是：他(她)爷爷姥爷们早几年先到了北京那个地方找个“窝棚”住下罢了。因为官员们的孩子都上了国内外最好的学校，想留洋就留洋，想出国就出国，从不用为进个公办幼稚园而通宵达旦去排队。于是，部分人群开始向教育部进行无用但持续的请愿，更多的人开始向国学寻找教育的公平。由于出国留学人群如洪水，让经济不景气的美国加拿大、英国、法国、西班牙等如获救命稻草，纷纷抛起政见，来抢中国的生源了。试想，一些无奈出国的孩子经过西方的流水线的改造后，以后对我们传统教育和封闭不公的决策者而言该是多么的悲哀？ 第五孽：房地产。中国政府的行业政策，没有哪个像房地产政策这样频出，又是“限购”，又是房产税……。可每次政策出台基本又是一个笑柄。其实大家都明白，假如政策制定者和管理者自己没有房子，或远离房地产商与他们没有勾结，或没有利益通吃，假如地方政府不把房地产业当经济核财政支柱，或政绩爬升的资本，政府制定的政策就不可能屡次都成为房价的丢人笑柄与助推器。 第六孽：煤炭石化。有人统计，近三十年非战争非正常死亡人数，中国比全球其他国家合计还多。造成中国死亡的人数原因主要有地震、交通事故和煤炭开采，其中让世界震惊的是煤炭开采为何死这么多人。中国的煤炭行业到底怎么了。 第七孽：医疗卫生。让国人震惊和愤怒的医药事故近些年层出不穷，杀医生事件频繁发生，即使把狼狈为奸的国家药监局原局长郑筱萸们判死刑也难以从根本上解决问题，本来就是社会制度和体制问题，官员们却高喊，找不出什么有效的办法了！ 中国仅有的一点医疗卫生资源，也向干部官员公务员群体过度倾斜，万恶的给药“分级制度”，对参加医疗保险的人群，也耍按照他们的政治地位、社会地位划分等级，级别越高的，得到的医疗服务质量越高，药品供应也耍越好，而老百姓就连基本的医疗都难以保证！“自锯病腿”的悲剧，是生在中国老百姓的真正悲哀！就医难，治病贵，有病不敢医，大病不敢住院依然是中国许多地方、尤其是农村的客观现状。政府们医 改喊了这么多年，老百姓几乎就骂了这么多年，可黑了心的医院,坏了良心的医生,为了骗取患者钱财还在乱下处方胡乱开药。他们内外勾结，为拿回扣，会把药价虚高到 100 倍,放任那么多黑心医生大发黑心财，索要红包明目张胆，不送红包就会缝上你缸门，把纱布留在肚子里！ 市场化医疗下，高级官员们都可住上高干部病房，豪华疗养院，享受的是去全中国各大医院，全额免费医疗，和特供的国产和进口药品的待遇。中国官员们享受的是全额医药免费，对老百姓患了大病无钱医冶跳楼自杀无动于衷，官员特权医疗，黑了心的医生成为杀害病患老百姓的无形屠刀赢利赚钱的黑医生是杀病患老百姓的刽子手！ 第八孽：交通。随着汽车越来越多，城市交通越来越拥挤，我认为最丢人的还是我们大众平日开车的不文明行为：酒驾、闯红灯、向窗外扔杂物、乱停车、超车、不排队、地铁上吃东西……。不仅造成了大量的人员伤亡，也让整个中国人的形象丢尽，尤其是当你如把某些习惯带到国外时，别人对我们同胞行为的眼神其实是整个中国这个国家在丢人…… 谨以此文，纪念那些受伤的孩童 相关链接</p>\n<h1 id=\"追忆『疫苗之殇』\"><a href=\"#追忆『疫苗之殇』\" class=\"headerlink\" title=\"追忆『疫苗之殇』\"></a><a href=\"https://wentommy.wordpress.com/2018/07/20/%E8%BF%BD%E5%BF%86%E3%80%8E%E7%96%AB%E8%8B%97%E4%B9%8B%E6%AE%87%E3%80%8F/\" target=\"_blank\" rel=\"noopener\">追忆『疫苗之殇』</a></h1><h1 id=\"疫苗之殇痛殴“四个自信”（高新）\"><a href=\"#疫苗之殇痛殴“四个自信”（高新）\" class=\"headerlink\" title=\"疫苗之殇痛殴“四个自信”（高新）\"></a><a href=\"https://www.rfa.org/mandarin/zhuanlan/yehuazhongnanhai/gx-07232018112335.html\" target=\"_blank\" rel=\"noopener\">疫苗之殇痛殴“四个自信”（高新）</a></h1><h1 id=\"疫苗之殇\"><a href=\"#疫苗之殇\" class=\"headerlink\" title=\"疫苗之殇\"></a><a href=\"https://botanwang.com/articles/201807/%E7%96%AB%E8%8B%97%E4%B9%8B%E6%AE%87.html\" target=\"_blank\" rel=\"noopener\">疫苗之殇</a></h1>"},{"title":"Git使用教程及常用命令","date":"2017-08-14T23:35:00.000Z","_content":"\n_**Git\\*\\***基本常用命令如下：\\*\\*_\n\n**   mkdir：         XX (创建一个空目录 XX 指目录名)**\n\n**   pwd：          显示当前目录的路径。**\n\n**   git init          把当前的目录变成可以管理的 git 仓库，生成隐藏.git 文件。**\n\n**   git add XX       把 xx 文件添加到暂存区去。**\n\n**   git commit –m “XX”  提交文件 –m 后面的是注释。**\n\n**   git status        查看仓库状态**\n\n**   git diff  XX      查看 XX 文件修改了那些内容**\n\n**   git log          查看历史记录**\n\n**   git reset  --hard HEAD^ 或者 git reset  --hard HEAD~ 回退到上一个版本**\n\n**                        (如果想回退到 100 个版本，使用 git reset –hard HEAD~100 )**\n\n**   cat XX         查看 XX 文件内容**\n\n**   git reflog       查看历史记录的版本号 id**\n\n**   git checkout -- XX  把 XX 文件在工作区的修改全部撤销。**\n\n**   git rm XX          删除 XX 文件**\n\n**   git remote add origin [https://github.com/xkloveme/vue-resource-demo.git ](https://github.com/xkloveme/vue-resource-demo.git)关联一个远程库**\n\n**   git push –u(第一次要用-u 以后不需要) origin master 把当前 master 分支推送到远程库**\n\n**   git clone [https://github.com/xkloveme/vue-resource-demo.git](https://github.com/xkloveme/vue-resource-demo.git)  从远程库中克隆**\n\n**   git checkout –b dev  创建 dev 分支 并切换到 dev 分支上**\n\n**   git branch  查看当前所有的分支**\n\n**   git checkout master 切换回 master 分支**\n\n**   git merge dev     在当前的分支上合并 dev 分支**\n\n**   git branch –d dev 删除 dev 分支**\n\n**   git branch name  创建分支**\n\n**   git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作**\n\n**   git stash list 查看所有被隐藏的文件列表**\n\n**   git stash apply 恢复被隐藏的文件，但是内容不删除**\n\n**   git stash drop 删除文件**\n\n**   git stash pop 恢复文件的同时 也删除文件**\n\n**   git remote 查看远程库的信息**\n\n**   git remote –v 查看远程库的详细信息**\n\n**   git push origin master  Git 会把 master 分支推送到远程库对应的远程分支上**\n\n**一：Git 是什么？**\n\nGit 是目前世界上最先进的分布式版本控制系统。\n\n**二：SVN 与 Git 的最主要的区别？**\n\nSVN 是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。\n\nGit 是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件 A，其他人也在电脑上改了文件 A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。\n\n**三：在 windows 上如何安装 Git？**\n\nmsysgit 是 windows 版的 Git,如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251338547302114.jpg)\n\n需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 \"Git --> Git Bash\",如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251339315902785.jpg)\n\n会弹出一个类似的命令窗口的东西，就说明 Git 安装成功。如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251340039335704.jpg)\n\n安装完成后，还需要最后一步设置，在命令行输入如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251341575433364.jpg)\n\n因为 Git 是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。\n\n**    注意：**git config  --global 参数，有了这个参数，表示你这台机器上所有的 Git 仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。\n\n**四：如何操作？**\n\n一：创建版本库。\n\n什么是版本库？版本库又名仓库，英文名 repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改，删除，Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。\n\n所以创建一个版本库也非常简单，如下我是 D 盘 –> www 下 目录下新建一个 testgit 版本库。\n\n![](http://images.cnitblog.com/blog/561794/201410/251342369965577.png)\n\npwd 命令是用于显示当前的目录。\n\n1\\. 通过命令 git init 把这个目录变成 git 可以管理的仓库，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251343102774109.png)\n\n这时候你当前 testgit 目录下会多了一个.git 的目录，这个目录是 Git 来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把 git 仓库给破坏了。如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251343384492003.png)\n\n2\\. 把文件添加到版本库中。\n\n首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如 txt 文件，网页，所有程序的代码等，Git 也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从 1kb 变成 2kb，但是到底改了啥，版本控制也不知道。\n\n**     下面先看下\\*\\***demo\\***\\*如下演示：**\n\n我在版本库 testgit 目录下新建一个记事本文件 readme.txt 内容如下：11111111\n\n第一步：使用命令 git add readme.txt 添加到暂存区里面去。如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251344226375669.png)\n\n如果和上面一样，没有任何提示，说明已经添加成功了。\n\n第二步：用命令 git commit 告诉 Git，把文件提交到仓库。\n\n![](http://images.cnitblog.com/blog/561794/201410/251344516834662.png)\n\n现在我们已经提交了一个 readme.txt 文件了，我们下面可以通过命令 git status 来查看是否还有文件未提交，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251345111059561.png)\n\n说明没有任何文件未提交，但是我现在继续来改下 readme.txt 内容，比如我在下面添加一行 2222222222 内容，继续使用 git status 来查看下结果，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251345416525297.png)\n\n上面的命令告诉我们 readme.txt 文件已被修改，但是未被提交的修改。\n\n接下来我想看下 readme.txt 文件到底改了什么内容，如何查看呢？可以使用如下命令：\n\ngit diff readme.txt 如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251346028718381.png)\n\n如上可以看到，readme.txt 文件内容从一行 11111111 改成 二行 添加了一行 22222222 内容。\n\n知道了对 readme.txt 文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的 2 步(第一步是 git add  第二步是：git commit)。\n\n如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251346268403791.png)\n\n二：版本回退：\n\n如上，我们已经学会了修改文件，现在我继续对 readme.txt 文件进行修改，再增加一行\n\n内容为 33333333333333.继续执行命令如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251347200583366.png)\n\n现在我已经对 readme.txt 文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251347438876519.png)\n\ngit log 命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为 333333.上一次是添加内容 222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251348076992146.png)\n\n现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下 2 种命令，第一种是：git reset  --hard HEAD^ 那么如果要回退到上上个版本只需把 HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前 100 个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset  --hard HEAD~100 即可。未回退之前的 readme.txt 内容如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251348307465171.png)\n\n如果想回退到上一个版本的命令如下操作：\n\n![](http://images.cnitblog.com/blog/561794/201410/251348496688157.png)\n\n再来查看下 readme.txt 内容如下：通过命令 cat readme.txt 查看\n\n![](http://images.cnitblog.com/blog/561794/201410/251349052154773.png)\n\n可以看到，内容已经回退到上一个版本了。我们可以继续使用 git log 来查看下历史记录信息，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251349205437091.png)\n\n我们看到 增加 333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有 333333 的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：\n\ngit reset  --hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者 333 内容的版本号我并不知道呢？要如何知道增加 3333 内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog  演示如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251349474491472.png)\n\n通过上面的显示我们可以知道，增加内容 3333 的版本号是 6fcfc89.我们现在可以命令\n\ngit reset  --hard 6fcfc89 来恢复了。演示如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251350096836911.png)\n\n可以看到 目前已经是最新的版本了。\n\n三：理解工作区与暂存区的区别？\n\n**工作区：**就是你在电脑上看到的目录，比如目录下 testgit 里的文件(.git 隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。\n\n**      版本库\\*\\***(Repository)\\***\\*：**工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是 stage(暂存区)，还有 Git 为我们自动创建了第一个分支 master,以及指向 master 的一个指针 HEAD。\n\n我们前面说过使用 Git 提交文件到版本库有两步：\n\n第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。\n\n第二步：使用 git commit 提交更改，实际上就是把暂存区的所有内容提交到当前分支上。\n\n我们继续使用 demo 来演示下：\n\n我们在 readme.txt 再添加一行内容为 4444444，接着在目录下新建一个文件为 test.txt 内容为 test，我们先用命令 git status 来查看下状态，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251350425584501.png)\n\n现在我们先使用 git add 命令把 2 个文件都添加到暂存区中，再使用 git status 来查看下状态，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251351180907145.png)\n\n接着我们可以使用 git commit 一次性提交到分支上，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251351473248082.png)\n\n四：Git 撤销修改和删除文件操作。\n\n**一：撤销修改：**\n\n比如我现在在 readme.txt 文件里面增加一行 内容为 555555555555，我们先通过命令查看如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251352126216220.png)\n\n在我未提交之前，我发现添加 5555555555555 内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：\n\n第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后 add 添加到暂存区，最后 commit 掉。\n\n第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset  --hard HEAD^\n\n但是现在我不想使用上面的 2 种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251352368714545.png)\n\n可以发现，Git 会告诉你，git checkout  -- file 可以丢弃工作区的修改，如下命令：\n\ngit checkout  --  readme.txt,如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251352562464460.png)\n\n命令 git checkout --readme.txt 意思就是，把 readme.txt 文件在工作区做的修改全部撤销，这里有 2 种情况，如下：\n\n1.  readme.txt 自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。\n2.  另外一种是 readme.txt 已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。\n\n对于第二种情况，我想我们继续做 demo 来看下，假如现在我对 readme.txt 添加一行 内容为 6666666666666，我 git add 增加到暂存区后，接着添加内容 7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251353209657240.png)\n\n**注意：**命令 git checkout -- readme.txt 中的 -- 很重要，如果没有 -- 的话，那么命令变成创建分支了。\n\n**二：删除文件。**\n\n假如我现在版本库 testgit 目录添加一个文件 b.txt,然后提交。如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251353539187274.png)\n\n如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上 rm 命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行 commit 命令 提交掉，现在目录是这样的，\n\n![](http://images.cnitblog.com/blog/561794/201410/251354169022085.png)\n\n只要没有 commit 之前，如果我想在版本库中恢复此文件如何操作呢？\n\n可以使用如下命令 git checkout  -- b.txt，如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251354414803609.png)\n\n再来看看我们 testgit 目录，添加了 3 个文件了。如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251355004651109.png)\n\n五：远程仓库。\n\n在了解之前，先注册 github 账号，由于你的本地 Git 仓库和 github 仓库之间的传输是通过 SSH 加密的，所以需要一点设置：\n\n第一步：创建 SSH Key。在用户主目录下，看看有没有.ssh 目录，如果有，再看看这个目录下有没有 id_rsa 和 id_rsa.pub 这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：\n\nssh-keygen  -t rsa –C “youremail@example.com”, 由于我本地此前运行过一次，所以本地有，如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251355342303027.png)\n\nid_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人。\n\n第二步：登录 github,打开” settings”中的 SSH Keys 页面，然后点击“Add SSH Key”,填上任意 title，在 Key 文本框里黏贴 id_rsa.pub 文件的内容。\n\n![](http://images.cnitblog.com/blog/561794/201410/251356274651130.png)\n\n点击 Add Key，你就应该可以看到已经添加的 key。\n\n![](http://images.cnitblog.com/blog/561794/201410/251356499185972.png)\n\n1.  如何添加远程库？\n\n现在的情景是：我们已经在本地创建了一个 Git 仓库后，又想在 github 创建一个 Git 仓库，并且希望这两个仓库进行远程同步，这样 github 的仓库可以作为备份，又可以其他人通过该仓库来协作。\n\n首先，登录 github 上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251357316059068.png)\n\n在 Repository name 填入`testgit`，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的 Git 仓库：\n\n![](http://images.cnitblog.com/blog/561794/201410/251357548716794.png)\n\n目前，在 GitHub 上的这个`testgit`仓库还是空的，GitHub 告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到 GitHub 仓库。\n\n现在，我们根据 GitHub 的提示，在本地的`testgit`仓库下运行命令：\n\ngit remote add origin https://github.com/tugenhua0707/testgit.git\n\n所有的如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251358439027115.png)\n\n把本地库的内容推送到远程，使用 git push 命令，实际上是把当前分支 master 推送到远程。\n\n由于远程库是空的，我们第一次推送 master 分支时，加上了 –u 参数，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在 github 页面中看到远程库的内容已经和本地一模一样了，上面的要输入 github 的用户名和密码如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251359074968040.png)\n\n从现在起，只要本地作了提交，就可以通过如下命令：\n\ngit push origin master\n\n把本地 master 分支的最新修改推送到 github 上了，现在你就拥有了真正的分布式版本库了。\n\n2\\. 如何从远程库克隆？\n\n上面我们了解了先有本地库，后有远程库时候，如何关联远程库。\n\n现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？\n\n首先，登录 github，创建一个新的仓库，名字叫 testgit2.如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251359368403775.png)\n\n如下，我们看到：\n\n![](http://images.cnitblog.com/blog/561794/201410/251359573401245.png)\n\n现在，远程库已经准备好了，下一步是使用命令 git clone 克隆一个本地库了。如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251400190749472.png)\n\n接着在我本地目录下 生成 testgit2 目录了，如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251400431217326.png)\n\n六：创建与合并分支。\n\n在   版本回填退里，你已经知道，每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在 Git 里，这个分支叫主分支，即 master 分支。HEAD 严格来说不是指向提交，而是指向 master，master 才是指向提交的，所以，HEAD 指向的就是当前分支。\n\n首先，我们来创建 dev 分支，然后切换到 dev 分支上。如下操作：\n\n![](http://images.cnitblog.com/blog/561794/201410/251401222624868.png)\n\ngit checkout 命令加上 –b 参数表示创建并切换，相当于如下 2 条命令\n\ngit branch dev\n\ngit checkout dev\n\ngit branch 查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在 dev 分支上继续做 demo，比如我们现在在 readme.txt 再增加一行 7777777777777\n\n首先我们先来查看下 readme.txt 内容，接着添加内容 77777777，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251401471056078.png)\n\n现在 dev 分支工作已完成，现在我们切换到主分支 master 上，继续查看 readme.txt 内容如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251402052152479.png)\n\n现在我们可以把 dev 分支上的内容合并到分支 master 上了，可以在 master 分支上，使用如下命令 git merge dev 如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251402275904876.png)\n\ngit merge 命令用于合并指定分支到当前分支上，合并后，再查看 readme.txt 内容，可以看到，和 dev 分支最新提交的是完全一样的。\n\n注意到上面的*Fast-forward*信息，Git 告诉我们，这次合并是“快进模式”，也就是直接把 master 指向 dev 的当前提交，所以合并速度非常快。\n\n合并完成后，我们可以接着删除 dev 分支了，操作如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251402521216116.png)\n\n总结创建与合并分支命令如下：\n\n查看分支：git branch\n\n创建分支：git branch name\n\n切换分支：git checkout name\n\n创建+切换分支：git checkout –b name\n\n合并某分支到当前分支：git merge name\n\n删除分支：git branch –d name\n\n1.  如何解决冲突？\n\n下面我们还是一步一步来，先新建一个新分支，比如名字叫 fenzhi1，在 readme.txt 添加一行内容 8888888，然后提交，如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251403184188082.png)\n\n同样，我们现在切换到 master 分支上来，也在最后一行添加内容，内容为 99999999，如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251403416053365.png)\n\n现在我们需要在 master 分支上来合并 fenzhi1，如下操作：\n\n![](http://images.cnitblog.com/blog/561794/201410/251404228409533.png)\n\nGit 用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，其中<<>>>>>fenzhi1 是指 fenzhi1 上修改的内容，我们可以修改下如下后保存：\n\n![](http://images.cnitblog.com/blog/561794/201410/251404454024875.png)\n\n如果我想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251405055906673.png)\n\n3.分支管理策略。\n\n通常合并分支时，git 一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff 来禁用”Fast forward”模式。首先我们来做 demo 演示下：\n\n1.  创建一个 dev 分支。\n2.  修改 readme.txt 内容。\n3.  添加到暂存区。\n4.  切换回主分支(master)。\n5.  合并 dev 分支，使用命令 git merge –no-ff  -m “注释” dev\n6.  查看历史记录\n\n截图如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251405434185118.png)\n\n**分支策略：**首先 master 主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的 dev 分支上干活，干完后，比如上要发布，或者说 dev 分支代码稳定后可以合并到主分支 master 上来。\n\n七：bug 分支：\n\n在开发中，会经常碰到 bug 问题，那么有了 bug 就需要修复，在 Git 中，分支是很强大的，每个 bug 都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。\n\n比如我在开发中接到一个 404 bug 时候，我们可以创建一个 404 分支来修复它，但是，当前的 dev 分支上的工作还没有提交。比如如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251407366993876.png)\n\n并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支 bug 要 2 天完成，但是我 issue-404 bug 需要 5 个小时内完成。怎么办呢？还好，Git 还提供了一个 stash 功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251408084493910.png)\n\n所以现在我可以通过创建 issue-404 分支来修复 bug 了。\n\n首先我们要确定在那个分支上修复 bug，比如我现在是在主分支 master 上来修复的，现在我要在 master 分支上创建一个临时分支，演示如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251408333083648.png)\n\n修复完成后，切换到 master 分支上，并完成合并，最后删除 issue-404 分支。演示如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251409016683485.png)\n\n现在，我们回到 dev 分支上干活了。\n\n![](http://images.cnitblog.com/blog/561794/201410/251409307156776.png)\n\n工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list 来查看下。如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251409546688359.png)\n\n工作现场还在，Git 把 stash 内容存在某个地方了，但是需要恢复一下，可以使用如下 2 个方法：\n\n1.  git stash apply 恢复，恢复后，stash 内容并不删除，你需要使用命令 git stash drop 来删除。\n2.  另一种方式是使用 git stash pop,恢复的同时把 stash 内容也删除了。\n\n演示如下\n\n![](http://images.cnitblog.com/blog/561794/201410/251410142934731.png)\n\n八：多人协作。\n\n当你从远程库克隆时候，实际上 Git 自动把本地的 master 分支和远程的 master 分支对应起来了，并且远程库的默认名称是 origin。\n\n1.  要查看远程库的信息 使用 git remote\n2.  要查看远程库的详细信息 使用 git remote –v\n\n如下演示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251410415747295.png)\n\n**一：推送分支：**\n\n推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git 就会把该分支推送到远程库对应的远程分支上：\n\n使用命令 git push origin master\n\n比如我现在的 github 上的 readme.txt 代码如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251411007466738.png)\n\n本地的 readme.txt 代码如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251411277462090.png)\n\n现在我想把本地更新的 readme.txt 代码推送到远程库中，使用命令如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251411458711720.png)\n\n我们可以看到如上，推送成功，我们可以继续来截图 github 上的 readme.txt 内容 如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251412049657718.png)\n\n可以看到 推送成功了，如果我们现在要推送到其他分支，比如 dev 分支上，我们还是那个命令 git push origin dev\n\n那么一般情况下，那些分支要推送呢？\n\n1.  master 分支是主分支，因此要时刻与远程同步。\n2.  一些修复 bug 分支不需要推送到远程去，可以先合并到主分支上，然后把主分支 master 推送到远程去。\n\n**二：抓取分支：**\n\n多人协作时，大家都会往 master 分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把 SSH key 添加到 github 上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫 testgit2\n\n但是我首先要把 dev 分支也要推送到远程去，如下\n\n![](http://images.cnitblog.com/blog/561794/201410/251413370902607.jpg)\n\n接着进入 testgit2 目录，进行克隆远程的库到本地来，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251412375741324.png)\n\n现在目录下生成有如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251414098406468.png)\n\n现在我们的小伙伴要在 dev 分支上做开发，就必须把远程的 origin 的 dev 分支到本地来，于是可以使用命令创建本地 dev 分支：git checkout  –b dev origin/dev\n\n现在小伙伴们就可以在 dev 分支上做开发了，开发完成后把 dev 分支推送到远程库时。\n\n如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251416265903424.png)\n\n小伙伴们已经向 origin/dev 分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251416538082475.png)\n\n由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用 git pull 把最新的提交从 origin/dev 抓下来，然后在本地合并，解决冲突，再推送。\n\n![](http://images.cnitblog.com/blog/561794/201410/251417172467915.png)\n\n*git pull*也失败了，原因是没有指定本地 dev 分支与远程 origin/dev 分支的链接，根据提示，设置 dev 和 origin/dev 的链接：如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251417344188703.png)\n\n这回*git pull*成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再 push：\n\n我们可以先来看看 readme.txt 内容了。\n\n![](http://images.cnitblog.com/blog/561794/201410/251418192937227.png)\n\n现在手动已经解决完了，我接在需要再提交，再 push 到远程库里面去。如下所示：  \n![](http://images.cnitblog.com/blog/561794/201410/251418378872312.png)\n\n因此：多人协作工作模式一般是这样的：\n\n1.  首先，可以试图用 git push origin branch-name 推送自己的修改.\n2.  如果推送失败，则因为远程分支比你的本地更新早，需要先用 git pull 试图合并。\n3.  如果合并有冲突，则需要解决冲突，并在本地提交。再用 git push origin branch-name 推送。\n","source":"_posts/2017-08-15-Git使用教程及常用命令.md","raw":"---\ntitle: Git使用教程及常用命令\ntags:\n  - 技术\n  - git\ndate: 2017-08-15 07:35:00\ncategories: 教程\n---\n\n_**Git\\*\\***基本常用命令如下：\\*\\*_\n\n**   mkdir：         XX (创建一个空目录 XX 指目录名)**\n\n**   pwd：          显示当前目录的路径。**\n\n**   git init          把当前的目录变成可以管理的 git 仓库，生成隐藏.git 文件。**\n\n**   git add XX       把 xx 文件添加到暂存区去。**\n\n**   git commit –m “XX”  提交文件 –m 后面的是注释。**\n\n**   git status        查看仓库状态**\n\n**   git diff  XX      查看 XX 文件修改了那些内容**\n\n**   git log          查看历史记录**\n\n**   git reset  --hard HEAD^ 或者 git reset  --hard HEAD~ 回退到上一个版本**\n\n**                        (如果想回退到 100 个版本，使用 git reset –hard HEAD~100 )**\n\n**   cat XX         查看 XX 文件内容**\n\n**   git reflog       查看历史记录的版本号 id**\n\n**   git checkout -- XX  把 XX 文件在工作区的修改全部撤销。**\n\n**   git rm XX          删除 XX 文件**\n\n**   git remote add origin [https://github.com/xkloveme/vue-resource-demo.git ](https://github.com/xkloveme/vue-resource-demo.git)关联一个远程库**\n\n**   git push –u(第一次要用-u 以后不需要) origin master 把当前 master 分支推送到远程库**\n\n**   git clone [https://github.com/xkloveme/vue-resource-demo.git](https://github.com/xkloveme/vue-resource-demo.git)  从远程库中克隆**\n\n**   git checkout –b dev  创建 dev 分支 并切换到 dev 分支上**\n\n**   git branch  查看当前所有的分支**\n\n**   git checkout master 切换回 master 分支**\n\n**   git merge dev     在当前的分支上合并 dev 分支**\n\n**   git branch –d dev 删除 dev 分支**\n\n**   git branch name  创建分支**\n\n**   git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作**\n\n**   git stash list 查看所有被隐藏的文件列表**\n\n**   git stash apply 恢复被隐藏的文件，但是内容不删除**\n\n**   git stash drop 删除文件**\n\n**   git stash pop 恢复文件的同时 也删除文件**\n\n**   git remote 查看远程库的信息**\n\n**   git remote –v 查看远程库的详细信息**\n\n**   git push origin master  Git 会把 master 分支推送到远程库对应的远程分支上**\n\n**一：Git 是什么？**\n\nGit 是目前世界上最先进的分布式版本控制系统。\n\n**二：SVN 与 Git 的最主要的区别？**\n\nSVN 是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。\n\nGit 是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件 A，其他人也在电脑上改了文件 A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。\n\n**三：在 windows 上如何安装 Git？**\n\nmsysgit 是 windows 版的 Git,如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251338547302114.jpg)\n\n需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 \"Git --> Git Bash\",如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251339315902785.jpg)\n\n会弹出一个类似的命令窗口的东西，就说明 Git 安装成功。如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251340039335704.jpg)\n\n安装完成后，还需要最后一步设置，在命令行输入如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251341575433364.jpg)\n\n因为 Git 是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。\n\n**    注意：**git config  --global 参数，有了这个参数，表示你这台机器上所有的 Git 仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。\n\n**四：如何操作？**\n\n一：创建版本库。\n\n什么是版本库？版本库又名仓库，英文名 repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改，删除，Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。\n\n所以创建一个版本库也非常简单，如下我是 D 盘 –> www 下 目录下新建一个 testgit 版本库。\n\n![](http://images.cnitblog.com/blog/561794/201410/251342369965577.png)\n\npwd 命令是用于显示当前的目录。\n\n1\\. 通过命令 git init 把这个目录变成 git 可以管理的仓库，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251343102774109.png)\n\n这时候你当前 testgit 目录下会多了一个.git 的目录，这个目录是 Git 来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把 git 仓库给破坏了。如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251343384492003.png)\n\n2\\. 把文件添加到版本库中。\n\n首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如 txt 文件，网页，所有程序的代码等，Git 也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从 1kb 变成 2kb，但是到底改了啥，版本控制也不知道。\n\n**     下面先看下\\*\\***demo\\***\\*如下演示：**\n\n我在版本库 testgit 目录下新建一个记事本文件 readme.txt 内容如下：11111111\n\n第一步：使用命令 git add readme.txt 添加到暂存区里面去。如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251344226375669.png)\n\n如果和上面一样，没有任何提示，说明已经添加成功了。\n\n第二步：用命令 git commit 告诉 Git，把文件提交到仓库。\n\n![](http://images.cnitblog.com/blog/561794/201410/251344516834662.png)\n\n现在我们已经提交了一个 readme.txt 文件了，我们下面可以通过命令 git status 来查看是否还有文件未提交，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251345111059561.png)\n\n说明没有任何文件未提交，但是我现在继续来改下 readme.txt 内容，比如我在下面添加一行 2222222222 内容，继续使用 git status 来查看下结果，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251345416525297.png)\n\n上面的命令告诉我们 readme.txt 文件已被修改，但是未被提交的修改。\n\n接下来我想看下 readme.txt 文件到底改了什么内容，如何查看呢？可以使用如下命令：\n\ngit diff readme.txt 如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251346028718381.png)\n\n如上可以看到，readme.txt 文件内容从一行 11111111 改成 二行 添加了一行 22222222 内容。\n\n知道了对 readme.txt 文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的 2 步(第一步是 git add  第二步是：git commit)。\n\n如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251346268403791.png)\n\n二：版本回退：\n\n如上，我们已经学会了修改文件，现在我继续对 readme.txt 文件进行修改，再增加一行\n\n内容为 33333333333333.继续执行命令如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251347200583366.png)\n\n现在我已经对 readme.txt 文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251347438876519.png)\n\ngit log 命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为 333333.上一次是添加内容 222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251348076992146.png)\n\n现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下 2 种命令，第一种是：git reset  --hard HEAD^ 那么如果要回退到上上个版本只需把 HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前 100 个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset  --hard HEAD~100 即可。未回退之前的 readme.txt 内容如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251348307465171.png)\n\n如果想回退到上一个版本的命令如下操作：\n\n![](http://images.cnitblog.com/blog/561794/201410/251348496688157.png)\n\n再来查看下 readme.txt 内容如下：通过命令 cat readme.txt 查看\n\n![](http://images.cnitblog.com/blog/561794/201410/251349052154773.png)\n\n可以看到，内容已经回退到上一个版本了。我们可以继续使用 git log 来查看下历史记录信息，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251349205437091.png)\n\n我们看到 增加 333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有 333333 的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：\n\ngit reset  --hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者 333 内容的版本号我并不知道呢？要如何知道增加 3333 内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog  演示如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251349474491472.png)\n\n通过上面的显示我们可以知道，增加内容 3333 的版本号是 6fcfc89.我们现在可以命令\n\ngit reset  --hard 6fcfc89 来恢复了。演示如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251350096836911.png)\n\n可以看到 目前已经是最新的版本了。\n\n三：理解工作区与暂存区的区别？\n\n**工作区：**就是你在电脑上看到的目录，比如目录下 testgit 里的文件(.git 隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。\n\n**      版本库\\*\\***(Repository)\\***\\*：**工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是 stage(暂存区)，还有 Git 为我们自动创建了第一个分支 master,以及指向 master 的一个指针 HEAD。\n\n我们前面说过使用 Git 提交文件到版本库有两步：\n\n第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。\n\n第二步：使用 git commit 提交更改，实际上就是把暂存区的所有内容提交到当前分支上。\n\n我们继续使用 demo 来演示下：\n\n我们在 readme.txt 再添加一行内容为 4444444，接着在目录下新建一个文件为 test.txt 内容为 test，我们先用命令 git status 来查看下状态，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251350425584501.png)\n\n现在我们先使用 git add 命令把 2 个文件都添加到暂存区中，再使用 git status 来查看下状态，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251351180907145.png)\n\n接着我们可以使用 git commit 一次性提交到分支上，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251351473248082.png)\n\n四：Git 撤销修改和删除文件操作。\n\n**一：撤销修改：**\n\n比如我现在在 readme.txt 文件里面增加一行 内容为 555555555555，我们先通过命令查看如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251352126216220.png)\n\n在我未提交之前，我发现添加 5555555555555 内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：\n\n第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后 add 添加到暂存区，最后 commit 掉。\n\n第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset  --hard HEAD^\n\n但是现在我不想使用上面的 2 种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251352368714545.png)\n\n可以发现，Git 会告诉你，git checkout  -- file 可以丢弃工作区的修改，如下命令：\n\ngit checkout  --  readme.txt,如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251352562464460.png)\n\n命令 git checkout --readme.txt 意思就是，把 readme.txt 文件在工作区做的修改全部撤销，这里有 2 种情况，如下：\n\n1.  readme.txt 自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。\n2.  另外一种是 readme.txt 已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。\n\n对于第二种情况，我想我们继续做 demo 来看下，假如现在我对 readme.txt 添加一行 内容为 6666666666666，我 git add 增加到暂存区后，接着添加内容 7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251353209657240.png)\n\n**注意：**命令 git checkout -- readme.txt 中的 -- 很重要，如果没有 -- 的话，那么命令变成创建分支了。\n\n**二：删除文件。**\n\n假如我现在版本库 testgit 目录添加一个文件 b.txt,然后提交。如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251353539187274.png)\n\n如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上 rm 命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行 commit 命令 提交掉，现在目录是这样的，\n\n![](http://images.cnitblog.com/blog/561794/201410/251354169022085.png)\n\n只要没有 commit 之前，如果我想在版本库中恢复此文件如何操作呢？\n\n可以使用如下命令 git checkout  -- b.txt，如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251354414803609.png)\n\n再来看看我们 testgit 目录，添加了 3 个文件了。如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251355004651109.png)\n\n五：远程仓库。\n\n在了解之前，先注册 github 账号，由于你的本地 Git 仓库和 github 仓库之间的传输是通过 SSH 加密的，所以需要一点设置：\n\n第一步：创建 SSH Key。在用户主目录下，看看有没有.ssh 目录，如果有，再看看这个目录下有没有 id_rsa 和 id_rsa.pub 这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：\n\nssh-keygen  -t rsa –C “youremail@example.com”, 由于我本地此前运行过一次，所以本地有，如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251355342303027.png)\n\nid_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人。\n\n第二步：登录 github,打开” settings”中的 SSH Keys 页面，然后点击“Add SSH Key”,填上任意 title，在 Key 文本框里黏贴 id_rsa.pub 文件的内容。\n\n![](http://images.cnitblog.com/blog/561794/201410/251356274651130.png)\n\n点击 Add Key，你就应该可以看到已经添加的 key。\n\n![](http://images.cnitblog.com/blog/561794/201410/251356499185972.png)\n\n1.  如何添加远程库？\n\n现在的情景是：我们已经在本地创建了一个 Git 仓库后，又想在 github 创建一个 Git 仓库，并且希望这两个仓库进行远程同步，这样 github 的仓库可以作为备份，又可以其他人通过该仓库来协作。\n\n首先，登录 github 上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251357316059068.png)\n\n在 Repository name 填入`testgit`，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的 Git 仓库：\n\n![](http://images.cnitblog.com/blog/561794/201410/251357548716794.png)\n\n目前，在 GitHub 上的这个`testgit`仓库还是空的，GitHub 告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到 GitHub 仓库。\n\n现在，我们根据 GitHub 的提示，在本地的`testgit`仓库下运行命令：\n\ngit remote add origin https://github.com/tugenhua0707/testgit.git\n\n所有的如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251358439027115.png)\n\n把本地库的内容推送到远程，使用 git push 命令，实际上是把当前分支 master 推送到远程。\n\n由于远程库是空的，我们第一次推送 master 分支时，加上了 –u 参数，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在 github 页面中看到远程库的内容已经和本地一模一样了，上面的要输入 github 的用户名和密码如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251359074968040.png)\n\n从现在起，只要本地作了提交，就可以通过如下命令：\n\ngit push origin master\n\n把本地 master 分支的最新修改推送到 github 上了，现在你就拥有了真正的分布式版本库了。\n\n2\\. 如何从远程库克隆？\n\n上面我们了解了先有本地库，后有远程库时候，如何关联远程库。\n\n现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？\n\n首先，登录 github，创建一个新的仓库，名字叫 testgit2.如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251359368403775.png)\n\n如下，我们看到：\n\n![](http://images.cnitblog.com/blog/561794/201410/251359573401245.png)\n\n现在，远程库已经准备好了，下一步是使用命令 git clone 克隆一个本地库了。如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251400190749472.png)\n\n接着在我本地目录下 生成 testgit2 目录了，如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251400431217326.png)\n\n六：创建与合并分支。\n\n在   版本回填退里，你已经知道，每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在 Git 里，这个分支叫主分支，即 master 分支。HEAD 严格来说不是指向提交，而是指向 master，master 才是指向提交的，所以，HEAD 指向的就是当前分支。\n\n首先，我们来创建 dev 分支，然后切换到 dev 分支上。如下操作：\n\n![](http://images.cnitblog.com/blog/561794/201410/251401222624868.png)\n\ngit checkout 命令加上 –b 参数表示创建并切换，相当于如下 2 条命令\n\ngit branch dev\n\ngit checkout dev\n\ngit branch 查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在 dev 分支上继续做 demo，比如我们现在在 readme.txt 再增加一行 7777777777777\n\n首先我们先来查看下 readme.txt 内容，接着添加内容 77777777，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251401471056078.png)\n\n现在 dev 分支工作已完成，现在我们切换到主分支 master 上，继续查看 readme.txt 内容如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251402052152479.png)\n\n现在我们可以把 dev 分支上的内容合并到分支 master 上了，可以在 master 分支上，使用如下命令 git merge dev 如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251402275904876.png)\n\ngit merge 命令用于合并指定分支到当前分支上，合并后，再查看 readme.txt 内容，可以看到，和 dev 分支最新提交的是完全一样的。\n\n注意到上面的*Fast-forward*信息，Git 告诉我们，这次合并是“快进模式”，也就是直接把 master 指向 dev 的当前提交，所以合并速度非常快。\n\n合并完成后，我们可以接着删除 dev 分支了，操作如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251402521216116.png)\n\n总结创建与合并分支命令如下：\n\n查看分支：git branch\n\n创建分支：git branch name\n\n切换分支：git checkout name\n\n创建+切换分支：git checkout –b name\n\n合并某分支到当前分支：git merge name\n\n删除分支：git branch –d name\n\n1.  如何解决冲突？\n\n下面我们还是一步一步来，先新建一个新分支，比如名字叫 fenzhi1，在 readme.txt 添加一行内容 8888888，然后提交，如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251403184188082.png)\n\n同样，我们现在切换到 master 分支上来，也在最后一行添加内容，内容为 99999999，如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251403416053365.png)\n\n现在我们需要在 master 分支上来合并 fenzhi1，如下操作：\n\n![](http://images.cnitblog.com/blog/561794/201410/251404228409533.png)\n\nGit 用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，其中<<>>>>>fenzhi1 是指 fenzhi1 上修改的内容，我们可以修改下如下后保存：\n\n![](http://images.cnitblog.com/blog/561794/201410/251404454024875.png)\n\n如果我想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251405055906673.png)\n\n3.分支管理策略。\n\n通常合并分支时，git 一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff 来禁用”Fast forward”模式。首先我们来做 demo 演示下：\n\n1.  创建一个 dev 分支。\n2.  修改 readme.txt 内容。\n3.  添加到暂存区。\n4.  切换回主分支(master)。\n5.  合并 dev 分支，使用命令 git merge –no-ff  -m “注释” dev\n6.  查看历史记录\n\n截图如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251405434185118.png)\n\n**分支策略：**首先 master 主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的 dev 分支上干活，干完后，比如上要发布，或者说 dev 分支代码稳定后可以合并到主分支 master 上来。\n\n七：bug 分支：\n\n在开发中，会经常碰到 bug 问题，那么有了 bug 就需要修复，在 Git 中，分支是很强大的，每个 bug 都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。\n\n比如我在开发中接到一个 404 bug 时候，我们可以创建一个 404 分支来修复它，但是，当前的 dev 分支上的工作还没有提交。比如如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251407366993876.png)\n\n并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支 bug 要 2 天完成，但是我 issue-404 bug 需要 5 个小时内完成。怎么办呢？还好，Git 还提供了一个 stash 功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251408084493910.png)\n\n所以现在我可以通过创建 issue-404 分支来修复 bug 了。\n\n首先我们要确定在那个分支上修复 bug，比如我现在是在主分支 master 上来修复的，现在我要在 master 分支上创建一个临时分支，演示如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251408333083648.png)\n\n修复完成后，切换到 master 分支上，并完成合并，最后删除 issue-404 分支。演示如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251409016683485.png)\n\n现在，我们回到 dev 分支上干活了。\n\n![](http://images.cnitblog.com/blog/561794/201410/251409307156776.png)\n\n工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list 来查看下。如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251409546688359.png)\n\n工作现场还在，Git 把 stash 内容存在某个地方了，但是需要恢复一下，可以使用如下 2 个方法：\n\n1.  git stash apply 恢复，恢复后，stash 内容并不删除，你需要使用命令 git stash drop 来删除。\n2.  另一种方式是使用 git stash pop,恢复的同时把 stash 内容也删除了。\n\n演示如下\n\n![](http://images.cnitblog.com/blog/561794/201410/251410142934731.png)\n\n八：多人协作。\n\n当你从远程库克隆时候，实际上 Git 自动把本地的 master 分支和远程的 master 分支对应起来了，并且远程库的默认名称是 origin。\n\n1.  要查看远程库的信息 使用 git remote\n2.  要查看远程库的详细信息 使用 git remote –v\n\n如下演示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251410415747295.png)\n\n**一：推送分支：**\n\n推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git 就会把该分支推送到远程库对应的远程分支上：\n\n使用命令 git push origin master\n\n比如我现在的 github 上的 readme.txt 代码如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251411007466738.png)\n\n本地的 readme.txt 代码如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251411277462090.png)\n\n现在我想把本地更新的 readme.txt 代码推送到远程库中，使用命令如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251411458711720.png)\n\n我们可以看到如上，推送成功，我们可以继续来截图 github 上的 readme.txt 内容 如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251412049657718.png)\n\n可以看到 推送成功了，如果我们现在要推送到其他分支，比如 dev 分支上，我们还是那个命令 git push origin dev\n\n那么一般情况下，那些分支要推送呢？\n\n1.  master 分支是主分支，因此要时刻与远程同步。\n2.  一些修复 bug 分支不需要推送到远程去，可以先合并到主分支上，然后把主分支 master 推送到远程去。\n\n**二：抓取分支：**\n\n多人协作时，大家都会往 master 分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把 SSH key 添加到 github 上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫 testgit2\n\n但是我首先要把 dev 分支也要推送到远程去，如下\n\n![](http://images.cnitblog.com/blog/561794/201410/251413370902607.jpg)\n\n接着进入 testgit2 目录，进行克隆远程的库到本地来，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251412375741324.png)\n\n现在目录下生成有如下所示：\n\n![](http://images.cnitblog.com/blog/561794/201410/251414098406468.png)\n\n现在我们的小伙伴要在 dev 分支上做开发，就必须把远程的 origin 的 dev 分支到本地来，于是可以使用命令创建本地 dev 分支：git checkout  –b dev origin/dev\n\n现在小伙伴们就可以在 dev 分支上做开发了，开发完成后把 dev 分支推送到远程库时。\n\n如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251416265903424.png)\n\n小伙伴们已经向 origin/dev 分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251416538082475.png)\n\n由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用 git pull 把最新的提交从 origin/dev 抓下来，然后在本地合并，解决冲突，再推送。\n\n![](http://images.cnitblog.com/blog/561794/201410/251417172467915.png)\n\n*git pull*也失败了，原因是没有指定本地 dev 分支与远程 origin/dev 分支的链接，根据提示，设置 dev 和 origin/dev 的链接：如下：\n\n![](http://images.cnitblog.com/blog/561794/201410/251417344188703.png)\n\n这回*git pull*成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再 push：\n\n我们可以先来看看 readme.txt 内容了。\n\n![](http://images.cnitblog.com/blog/561794/201410/251418192937227.png)\n\n现在手动已经解决完了，我接在需要再提交，再 push 到远程库里面去。如下所示：  \n![](http://images.cnitblog.com/blog/561794/201410/251418378872312.png)\n\n因此：多人协作工作模式一般是这样的：\n\n1.  首先，可以试图用 git push origin branch-name 推送自己的修改.\n2.  如果推送失败，则因为远程分支比你的本地更新早，需要先用 git pull 试图合并。\n3.  如果合并有冲突，则需要解决冲突，并在本地提交。再用 git push origin branch-name 推送。\n","slug":"2017-08-15-Git使用教程及常用命令","published":1,"updated":"2020-03-14T06:45:10.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvny006n4k8y4sjkgnf7","content":"<p><em><strong>Git**</strong>基本常用命令如下：**</em></p>\n<p>**   mkdir：         XX (创建一个空目录 XX 指目录名)**</p>\n<p>**   pwd：          显示当前目录的路径。**</p>\n<p>**   git init          把当前的目录变成可以管理的 git 仓库，生成隐藏.git 文件。**</p>\n<p>**   git add XX       把 xx 文件添加到暂存区去。**</p>\n<p>**   git commit –m “XX”  提交文件 –m 后面的是注释。**</p>\n<p>**   git status        查看仓库状态**</p>\n<p>**   git diff  XX      查看 XX 文件修改了那些内容**</p>\n<p>**   git log          查看历史记录**</p>\n<p>**   git reset  –hard HEAD^ 或者 git reset  –hard HEAD~ 回退到上一个版本**</p>\n<p>**                        (如果想回退到 100 个版本，使用 git reset –hard HEAD~100 )**</p>\n<p>**   cat XX         查看 XX 文件内容**</p>\n<p>**   git reflog       查看历史记录的版本号 id**</p>\n<p>**   git checkout – XX  把 XX 文件在工作区的修改全部撤销。**</p>\n<p>**   git rm XX          删除 XX 文件**</p>\n<p>**   git remote add origin <a href=\"https://github.com/xkloveme/vue-resource-demo.git\" target=\"_blank\" rel=\"noopener\">https://github.com/xkloveme/vue-resource-demo.git </a>关联一个远程库**</p>\n<p>**   git push –u(第一次要用-u 以后不需要) origin master 把当前 master 分支推送到远程库**</p>\n<p>**   git clone <a href=\"https://github.com/xkloveme/vue-resource-demo.git\" target=\"_blank\" rel=\"noopener\">https://github.com/xkloveme/vue-resource-demo.git</a>  从远程库中克隆**</p>\n<p>**   git checkout –b dev  创建 dev 分支 并切换到 dev 分支上**</p>\n<p>**   git branch  查看当前所有的分支**</p>\n<p>**   git checkout master 切换回 master 分支**</p>\n<p>**   git merge dev     在当前的分支上合并 dev 分支**</p>\n<p>**   git branch –d dev 删除 dev 分支**</p>\n<p>**   git branch name  创建分支**</p>\n<p>**   git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作**</p>\n<p>**   git stash list 查看所有被隐藏的文件列表**</p>\n<p>**   git stash apply 恢复被隐藏的文件，但是内容不删除**</p>\n<p>**   git stash drop 删除文件**</p>\n<p>**   git stash pop 恢复文件的同时 也删除文件**</p>\n<p>**   git remote 查看远程库的信息**</p>\n<p>**   git remote –v 查看远程库的详细信息**</p>\n<p>**   git push origin master  Git 会把 master 分支推送到远程库对应的远程分支上**</p>\n<p><strong>一：Git 是什么？</strong></p>\n<p>Git 是目前世界上最先进的分布式版本控制系统。</p>\n<p><strong>二：SVN 与 Git 的最主要的区别？</strong></p>\n<p>SVN 是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p>\n<p>Git 是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件 A，其他人也在电脑上改了文件 A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>\n<p><strong>三：在 windows 上如何安装 Git？</strong></p>\n<p>msysgit 是 windows 版的 Git,如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251338547302114.jpg\" alt=\"\"></p>\n<p>需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 “Git –&gt; Git Bash”,如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251339315902785.jpg\" alt=\"\"></p>\n<p>会弹出一个类似的命令窗口的东西，就说明 Git 安装成功。如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251340039335704.jpg\" alt=\"\"></p>\n<p>安装完成后，还需要最后一步设置，在命令行输入如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251341575433364.jpg\" alt=\"\"></p>\n<p>因为 Git 是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。</p>\n<p>**    注意：**git config  –global 参数，有了这个参数，表示你这台机器上所有的 Git 仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。</p>\n<p><strong>四：如何操作？</strong></p>\n<p>一：创建版本库。</p>\n<p>什么是版本库？版本库又名仓库，英文名 repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改，删除，Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。</p>\n<p>所以创建一个版本库也非常简单，如下我是 D 盘 –&gt; www 下 目录下新建一个 testgit 版本库。</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251342369965577.png\" alt=\"\"></p>\n<p>pwd 命令是用于显示当前的目录。</p>\n<p>1. 通过命令 git init 把这个目录变成 git 可以管理的仓库，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251343102774109.png\" alt=\"\"></p>\n<p>这时候你当前 testgit 目录下会多了一个.git 的目录，这个目录是 Git 来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把 git 仓库给破坏了。如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251343384492003.png\" alt=\"\"></p>\n<p>2. 把文件添加到版本库中。</p>\n<p>首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如 txt 文件，网页，所有程序的代码等，Git 也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从 1kb 变成 2kb，但是到底改了啥，版本控制也不知道。</p>\n<p>**     下面先看下**<strong>demo*</strong>*如下演示：**</p>\n<p>我在版本库 testgit 目录下新建一个记事本文件 readme.txt 内容如下：11111111</p>\n<p>第一步：使用命令 git add readme.txt 添加到暂存区里面去。如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251344226375669.png\" alt=\"\"></p>\n<p>如果和上面一样，没有任何提示，说明已经添加成功了。</p>\n<p>第二步：用命令 git commit 告诉 Git，把文件提交到仓库。</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251344516834662.png\" alt=\"\"></p>\n<p>现在我们已经提交了一个 readme.txt 文件了，我们下面可以通过命令 git status 来查看是否还有文件未提交，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251345111059561.png\" alt=\"\"></p>\n<p>说明没有任何文件未提交，但是我现在继续来改下 readme.txt 内容，比如我在下面添加一行 2222222222 内容，继续使用 git status 来查看下结果，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251345416525297.png\" alt=\"\"></p>\n<p>上面的命令告诉我们 readme.txt 文件已被修改，但是未被提交的修改。</p>\n<p>接下来我想看下 readme.txt 文件到底改了什么内容，如何查看呢？可以使用如下命令：</p>\n<p>git diff readme.txt 如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251346028718381.png\" alt=\"\"></p>\n<p>如上可以看到，readme.txt 文件内容从一行 11111111 改成 二行 添加了一行 22222222 内容。</p>\n<p>知道了对 readme.txt 文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的 2 步(第一步是 git add  第二步是：git commit)。</p>\n<p>如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251346268403791.png\" alt=\"\"></p>\n<p>二：版本回退：</p>\n<p>如上，我们已经学会了修改文件，现在我继续对 readme.txt 文件进行修改，再增加一行</p>\n<p>内容为 33333333333333.继续执行命令如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251347200583366.png\" alt=\"\"></p>\n<p>现在我已经对 readme.txt 文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251347438876519.png\" alt=\"\"></p>\n<p>git log 命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为 333333.上一次是添加内容 222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251348076992146.png\" alt=\"\"></p>\n<p>现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下 2 种命令，第一种是：git reset  –hard HEAD^ 那么如果要回退到上上个版本只需把 HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前 100 个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset  –hard HEAD~100 即可。未回退之前的 readme.txt 内容如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251348307465171.png\" alt=\"\"></p>\n<p>如果想回退到上一个版本的命令如下操作：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251348496688157.png\" alt=\"\"></p>\n<p>再来查看下 readme.txt 内容如下：通过命令 cat readme.txt 查看</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251349052154773.png\" alt=\"\"></p>\n<p>可以看到，内容已经回退到上一个版本了。我们可以继续使用 git log 来查看下历史记录信息，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251349205437091.png\" alt=\"\"></p>\n<p>我们看到 增加 333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有 333333 的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：</p>\n<p>git reset  –hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者 333 内容的版本号我并不知道呢？要如何知道增加 3333 内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog  演示如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251349474491472.png\" alt=\"\"></p>\n<p>通过上面的显示我们可以知道，增加内容 3333 的版本号是 6fcfc89.我们现在可以命令</p>\n<p>git reset  –hard 6fcfc89 来恢复了。演示如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251350096836911.png\" alt=\"\"></p>\n<p>可以看到 目前已经是最新的版本了。</p>\n<p>三：理解工作区与暂存区的区别？</p>\n<p><strong>工作区：</strong>就是你在电脑上看到的目录，比如目录下 testgit 里的文件(.git 隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。</p>\n<p>**      版本库**<strong>(Repository)*</strong>*：**工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是 stage(暂存区)，还有 Git 为我们自动创建了第一个分支 master,以及指向 master 的一个指针 HEAD。</p>\n<p>我们前面说过使用 Git 提交文件到版本库有两步：</p>\n<p>第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。</p>\n<p>第二步：使用 git commit 提交更改，实际上就是把暂存区的所有内容提交到当前分支上。</p>\n<p>我们继续使用 demo 来演示下：</p>\n<p>我们在 readme.txt 再添加一行内容为 4444444，接着在目录下新建一个文件为 test.txt 内容为 test，我们先用命令 git status 来查看下状态，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251350425584501.png\" alt=\"\"></p>\n<p>现在我们先使用 git add 命令把 2 个文件都添加到暂存区中，再使用 git status 来查看下状态，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251351180907145.png\" alt=\"\"></p>\n<p>接着我们可以使用 git commit 一次性提交到分支上，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251351473248082.png\" alt=\"\"></p>\n<p>四：Git 撤销修改和删除文件操作。</p>\n<p><strong>一：撤销修改：</strong></p>\n<p>比如我现在在 readme.txt 文件里面增加一行 内容为 555555555555，我们先通过命令查看如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251352126216220.png\" alt=\"\"></p>\n<p>在我未提交之前，我发现添加 5555555555555 内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：</p>\n<p>第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后 add 添加到暂存区，最后 commit 掉。</p>\n<p>第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset  –hard HEAD^</p>\n<p>但是现在我不想使用上面的 2 种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251352368714545.png\" alt=\"\"></p>\n<p>可以发现，Git 会告诉你，git checkout  – file 可以丢弃工作区的修改，如下命令：</p>\n<p>git checkout  –  readme.txt,如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251352562464460.png\" alt=\"\"></p>\n<p>命令 git checkout –readme.txt 意思就是，把 readme.txt 文件在工作区做的修改全部撤销，这里有 2 种情况，如下：</p>\n<ol>\n<li>readme.txt 自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。</li>\n<li>另外一种是 readme.txt 已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。</li>\n</ol>\n<p>对于第二种情况，我想我们继续做 demo 来看下，假如现在我对 readme.txt 添加一行 内容为 6666666666666，我 git add 增加到暂存区后，接着添加内容 7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251353209657240.png\" alt=\"\"></p>\n<p><strong>注意：</strong>命令 git checkout – readme.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了。</p>\n<p><strong>二：删除文件。</strong></p>\n<p>假如我现在版本库 testgit 目录添加一个文件 b.txt,然后提交。如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251353539187274.png\" alt=\"\"></p>\n<p>如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上 rm 命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行 commit 命令 提交掉，现在目录是这样的，</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251354169022085.png\" alt=\"\"></p>\n<p>只要没有 commit 之前，如果我想在版本库中恢复此文件如何操作呢？</p>\n<p>可以使用如下命令 git checkout  – b.txt，如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251354414803609.png\" alt=\"\"></p>\n<p>再来看看我们 testgit 目录，添加了 3 个文件了。如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251355004651109.png\" alt=\"\"></p>\n<p>五：远程仓库。</p>\n<p>在了解之前，先注册 github 账号，由于你的本地 Git 仓库和 github 仓库之间的传输是通过 SSH 加密的，所以需要一点设置：</p>\n<p>第一步：创建 SSH Key。在用户主目录下，看看有没有.ssh 目录，如果有，再看看这个目录下有没有 id_rsa 和 id_rsa.pub 这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：</p>\n<p>ssh-keygen  -t rsa –C “<a href=\"mailto:youremail@example.com\">youremail@example.com</a>”, 由于我本地此前运行过一次，所以本地有，如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251355342303027.png\" alt=\"\"></p>\n<p>id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人。</p>\n<p>第二步：登录 github,打开” settings”中的 SSH Keys 页面，然后点击“Add SSH Key”,填上任意 title，在 Key 文本框里黏贴 id_rsa.pub 文件的内容。</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251356274651130.png\" alt=\"\"></p>\n<p>点击 Add Key，你就应该可以看到已经添加的 key。</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251356499185972.png\" alt=\"\"></p>\n<ol>\n<li>如何添加远程库？</li>\n</ol>\n<p>现在的情景是：我们已经在本地创建了一个 Git 仓库后，又想在 github 创建一个 Git 仓库，并且希望这两个仓库进行远程同步，这样 github 的仓库可以作为备份，又可以其他人通过该仓库来协作。</p>\n<p>首先，登录 github 上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251357316059068.png\" alt=\"\"></p>\n<p>在 Repository name 填入<code>testgit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的 Git 仓库：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251357548716794.png\" alt=\"\"></p>\n<p>目前，在 GitHub 上的这个<code>testgit</code>仓库还是空的，GitHub 告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到 GitHub 仓库。</p>\n<p>现在，我们根据 GitHub 的提示，在本地的<code>testgit</code>仓库下运行命令：</p>\n<p>git remote add origin <a href=\"https://github.com/tugenhua0707/testgit.git\" target=\"_blank\" rel=\"noopener\">https://github.com/tugenhua0707/testgit.git</a></p>\n<p>所有的如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251358439027115.png\" alt=\"\"></p>\n<p>把本地库的内容推送到远程，使用 git push 命令，实际上是把当前分支 master 推送到远程。</p>\n<p>由于远程库是空的，我们第一次推送 master 分支时，加上了 –u 参数，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在 github 页面中看到远程库的内容已经和本地一模一样了，上面的要输入 github 的用户名和密码如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251359074968040.png\" alt=\"\"></p>\n<p>从现在起，只要本地作了提交，就可以通过如下命令：</p>\n<p>git push origin master</p>\n<p>把本地 master 分支的最新修改推送到 github 上了，现在你就拥有了真正的分布式版本库了。</p>\n<p>2. 如何从远程库克隆？</p>\n<p>上面我们了解了先有本地库，后有远程库时候，如何关联远程库。</p>\n<p>现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？</p>\n<p>首先，登录 github，创建一个新的仓库，名字叫 testgit2.如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251359368403775.png\" alt=\"\"></p>\n<p>如下，我们看到：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251359573401245.png\" alt=\"\"></p>\n<p>现在，远程库已经准备好了，下一步是使用命令 git clone 克隆一个本地库了。如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251400190749472.png\" alt=\"\"></p>\n<p>接着在我本地目录下 生成 testgit2 目录了，如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251400431217326.png\" alt=\"\"></p>\n<p>六：创建与合并分支。</p>\n<p>在   版本回填退里，你已经知道，每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在 Git 里，这个分支叫主分支，即 master 分支。HEAD 严格来说不是指向提交，而是指向 master，master 才是指向提交的，所以，HEAD 指向的就是当前分支。</p>\n<p>首先，我们来创建 dev 分支，然后切换到 dev 分支上。如下操作：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251401222624868.png\" alt=\"\"></p>\n<p>git checkout 命令加上 –b 参数表示创建并切换，相当于如下 2 条命令</p>\n<p>git branch dev</p>\n<p>git checkout dev</p>\n<p>git branch 查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在 dev 分支上继续做 demo，比如我们现在在 readme.txt 再增加一行 7777777777777</p>\n<p>首先我们先来查看下 readme.txt 内容，接着添加内容 77777777，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251401471056078.png\" alt=\"\"></p>\n<p>现在 dev 分支工作已完成，现在我们切换到主分支 master 上，继续查看 readme.txt 内容如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251402052152479.png\" alt=\"\"></p>\n<p>现在我们可以把 dev 分支上的内容合并到分支 master 上了，可以在 master 分支上，使用如下命令 git merge dev 如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251402275904876.png\" alt=\"\"></p>\n<p>git merge 命令用于合并指定分支到当前分支上，合并后，再查看 readme.txt 内容，可以看到，和 dev 分支最新提交的是完全一样的。</p>\n<p>注意到上面的<em>Fast-forward</em>信息，Git 告诉我们，这次合并是“快进模式”，也就是直接把 master 指向 dev 的当前提交，所以合并速度非常快。</p>\n<p>合并完成后，我们可以接着删除 dev 分支了，操作如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251402521216116.png\" alt=\"\"></p>\n<p>总结创建与合并分支命令如下：</p>\n<p>查看分支：git branch</p>\n<p>创建分支：git branch name</p>\n<p>切换分支：git checkout name</p>\n<p>创建+切换分支：git checkout –b name</p>\n<p>合并某分支到当前分支：git merge name</p>\n<p>删除分支：git branch –d name</p>\n<ol>\n<li>如何解决冲突？</li>\n</ol>\n<p>下面我们还是一步一步来，先新建一个新分支，比如名字叫 fenzhi1，在 readme.txt 添加一行内容 8888888，然后提交，如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251403184188082.png\" alt=\"\"></p>\n<p>同样，我们现在切换到 master 分支上来，也在最后一行添加内容，内容为 99999999，如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251403416053365.png\" alt=\"\"></p>\n<p>现在我们需要在 master 分支上来合并 fenzhi1，如下操作：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251404228409533.png\" alt=\"\"></p>\n<p>Git 用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&gt;&gt;&gt;&gt;&gt;fenzhi1 是指 fenzhi1 上修改的内容，我们可以修改下如下后保存：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251404454024875.png\" alt=\"\"></p>\n<p>如果我想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251405055906673.png\" alt=\"\"></p>\n<p>3.分支管理策略。</p>\n<p>通常合并分支时，git 一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff 来禁用”Fast forward”模式。首先我们来做 demo 演示下：</p>\n<ol>\n<li>创建一个 dev 分支。</li>\n<li>修改 readme.txt 内容。</li>\n<li>添加到暂存区。</li>\n<li>切换回主分支(master)。</li>\n<li>合并 dev 分支，使用命令 git merge –no-ff  -m “注释” dev</li>\n<li>查看历史记录</li>\n</ol>\n<p>截图如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251405434185118.png\" alt=\"\"></p>\n<p><strong>分支策略：</strong>首先 master 主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的 dev 分支上干活，干完后，比如上要发布，或者说 dev 分支代码稳定后可以合并到主分支 master 上来。</p>\n<p>七：bug 分支：</p>\n<p>在开发中，会经常碰到 bug 问题，那么有了 bug 就需要修复，在 Git 中，分支是很强大的，每个 bug 都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p>\n<p>比如我在开发中接到一个 404 bug 时候，我们可以创建一个 404 分支来修复它，但是，当前的 dev 分支上的工作还没有提交。比如如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251407366993876.png\" alt=\"\"></p>\n<p>并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支 bug 要 2 天完成，但是我 issue-404 bug 需要 5 个小时内完成。怎么办呢？还好，Git 还提供了一个 stash 功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251408084493910.png\" alt=\"\"></p>\n<p>所以现在我可以通过创建 issue-404 分支来修复 bug 了。</p>\n<p>首先我们要确定在那个分支上修复 bug，比如我现在是在主分支 master 上来修复的，现在我要在 master 分支上创建一个临时分支，演示如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251408333083648.png\" alt=\"\"></p>\n<p>修复完成后，切换到 master 分支上，并完成合并，最后删除 issue-404 分支。演示如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251409016683485.png\" alt=\"\"></p>\n<p>现在，我们回到 dev 分支上干活了。</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251409307156776.png\" alt=\"\"></p>\n<p>工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list 来查看下。如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251409546688359.png\" alt=\"\"></p>\n<p>工作现场还在，Git 把 stash 内容存在某个地方了，但是需要恢复一下，可以使用如下 2 个方法：</p>\n<ol>\n<li>git stash apply 恢复，恢复后，stash 内容并不删除，你需要使用命令 git stash drop 来删除。</li>\n<li>另一种方式是使用 git stash pop,恢复的同时把 stash 内容也删除了。</li>\n</ol>\n<p>演示如下</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251410142934731.png\" alt=\"\"></p>\n<p>八：多人协作。</p>\n<p>当你从远程库克隆时候，实际上 Git 自动把本地的 master 分支和远程的 master 分支对应起来了，并且远程库的默认名称是 origin。</p>\n<ol>\n<li>要查看远程库的信息 使用 git remote</li>\n<li>要查看远程库的详细信息 使用 git remote –v</li>\n</ol>\n<p>如下演示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251410415747295.png\" alt=\"\"></p>\n<p><strong>一：推送分支：</strong></p>\n<p>推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git 就会把该分支推送到远程库对应的远程分支上：</p>\n<p>使用命令 git push origin master</p>\n<p>比如我现在的 github 上的 readme.txt 代码如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251411007466738.png\" alt=\"\"></p>\n<p>本地的 readme.txt 代码如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251411277462090.png\" alt=\"\"></p>\n<p>现在我想把本地更新的 readme.txt 代码推送到远程库中，使用命令如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251411458711720.png\" alt=\"\"></p>\n<p>我们可以看到如上，推送成功，我们可以继续来截图 github 上的 readme.txt 内容 如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251412049657718.png\" alt=\"\"></p>\n<p>可以看到 推送成功了，如果我们现在要推送到其他分支，比如 dev 分支上，我们还是那个命令 git push origin dev</p>\n<p>那么一般情况下，那些分支要推送呢？</p>\n<ol>\n<li>master 分支是主分支，因此要时刻与远程同步。</li>\n<li>一些修复 bug 分支不需要推送到远程去，可以先合并到主分支上，然后把主分支 master 推送到远程去。</li>\n</ol>\n<p><strong>二：抓取分支：</strong></p>\n<p>多人协作时，大家都会往 master 分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把 SSH key 添加到 github 上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫 testgit2</p>\n<p>但是我首先要把 dev 分支也要推送到远程去，如下</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251413370902607.jpg\" alt=\"\"></p>\n<p>接着进入 testgit2 目录，进行克隆远程的库到本地来，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251412375741324.png\" alt=\"\"></p>\n<p>现在目录下生成有如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251414098406468.png\" alt=\"\"></p>\n<p>现在我们的小伙伴要在 dev 分支上做开发，就必须把远程的 origin 的 dev 分支到本地来，于是可以使用命令创建本地 dev 分支：git checkout  –b dev origin/dev</p>\n<p>现在小伙伴们就可以在 dev 分支上做开发了，开发完成后把 dev 分支推送到远程库时。</p>\n<p>如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251416265903424.png\" alt=\"\"></p>\n<p>小伙伴们已经向 origin/dev 分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251416538082475.png\" alt=\"\"></p>\n<p>由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用 git pull 把最新的提交从 origin/dev 抓下来，然后在本地合并，解决冲突，再推送。</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251417172467915.png\" alt=\"\"></p>\n<p><em>git pull</em>也失败了，原因是没有指定本地 dev 分支与远程 origin/dev 分支的链接，根据提示，设置 dev 和 origin/dev 的链接：如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251417344188703.png\" alt=\"\"></p>\n<p>这回<em>git pull</em>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再 push：</p>\n<p>我们可以先来看看 readme.txt 内容了。</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251418192937227.png\" alt=\"\"></p>\n<p>现在手动已经解决完了，我接在需要再提交，再 push 到远程库里面去。如下所示：<br><img src=\"http://images.cnitblog.com/blog/561794/201410/251418378872312.png\" alt=\"\"></p>\n<p>因此：多人协作工作模式一般是这样的：</p>\n<ol>\n<li>首先，可以试图用 git push origin branch-name 推送自己的修改.</li>\n<li>如果推送失败，则因为远程分支比你的本地更新早，需要先用 git pull 试图合并。</li>\n<li>如果合并有冲突，则需要解决冲突，并在本地提交。再用 git push origin branch-name 推送。</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p><em><strong>Git**</strong>基本常用命令如下：**</em></p>\n<p>**   mkdir：         XX (创建一个空目录 XX 指目录名)**</p>\n<p>**   pwd：          显示当前目录的路径。**</p>\n<p>**   git init          把当前的目录变成可以管理的 git 仓库，生成隐藏.git 文件。**</p>\n<p>**   git add XX       把 xx 文件添加到暂存区去。**</p>\n<p>**   git commit –m “XX”  提交文件 –m 后面的是注释。**</p>\n<p>**   git status        查看仓库状态**</p>\n<p>**   git diff  XX      查看 XX 文件修改了那些内容**</p>\n<p>**   git log          查看历史记录**</p>\n<p>**   git reset  –hard HEAD^ 或者 git reset  –hard HEAD~ 回退到上一个版本**</p>\n<p>**                        (如果想回退到 100 个版本，使用 git reset –hard HEAD~100 )**</p>\n<p>**   cat XX         查看 XX 文件内容**</p>\n<p>**   git reflog       查看历史记录的版本号 id**</p>\n<p>**   git checkout – XX  把 XX 文件在工作区的修改全部撤销。**</p>\n<p>**   git rm XX          删除 XX 文件**</p>\n<p>**   git remote add origin <a href=\"https://github.com/xkloveme/vue-resource-demo.git\" target=\"_blank\" rel=\"noopener\">https://github.com/xkloveme/vue-resource-demo.git </a>关联一个远程库**</p>\n<p>**   git push –u(第一次要用-u 以后不需要) origin master 把当前 master 分支推送到远程库**</p>\n<p>**   git clone <a href=\"https://github.com/xkloveme/vue-resource-demo.git\" target=\"_blank\" rel=\"noopener\">https://github.com/xkloveme/vue-resource-demo.git</a>  从远程库中克隆**</p>\n<p>**   git checkout –b dev  创建 dev 分支 并切换到 dev 分支上**</p>\n<p>**   git branch  查看当前所有的分支**</p>\n<p>**   git checkout master 切换回 master 分支**</p>\n<p>**   git merge dev     在当前的分支上合并 dev 分支**</p>\n<p>**   git branch –d dev 删除 dev 分支**</p>\n<p>**   git branch name  创建分支**</p>\n<p>**   git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作**</p>\n<p>**   git stash list 查看所有被隐藏的文件列表**</p>\n<p>**   git stash apply 恢复被隐藏的文件，但是内容不删除**</p>\n<p>**   git stash drop 删除文件**</p>\n<p>**   git stash pop 恢复文件的同时 也删除文件**</p>\n<p>**   git remote 查看远程库的信息**</p>\n<p>**   git remote –v 查看远程库的详细信息**</p>\n<p>**   git push origin master  Git 会把 master 分支推送到远程库对应的远程分支上**</p>\n<p><strong>一：Git 是什么？</strong></p>\n<p>Git 是目前世界上最先进的分布式版本控制系统。</p>\n<p><strong>二：SVN 与 Git 的最主要的区别？</strong></p>\n<p>SVN 是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p>\n<p>Git 是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件 A，其他人也在电脑上改了文件 A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>\n<p><strong>三：在 windows 上如何安装 Git？</strong></p>\n<p>msysgit 是 windows 版的 Git,如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251338547302114.jpg\" alt=\"\"></p>\n<p>需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 “Git –&gt; Git Bash”,如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251339315902785.jpg\" alt=\"\"></p>\n<p>会弹出一个类似的命令窗口的东西，就说明 Git 安装成功。如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251340039335704.jpg\" alt=\"\"></p>\n<p>安装完成后，还需要最后一步设置，在命令行输入如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251341575433364.jpg\" alt=\"\"></p>\n<p>因为 Git 是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。</p>\n<p>**    注意：**git config  –global 参数，有了这个参数，表示你这台机器上所有的 Git 仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。</p>\n<p><strong>四：如何操作？</strong></p>\n<p>一：创建版本库。</p>\n<p>什么是版本库？版本库又名仓库，英文名 repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改，删除，Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。</p>\n<p>所以创建一个版本库也非常简单，如下我是 D 盘 –&gt; www 下 目录下新建一个 testgit 版本库。</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251342369965577.png\" alt=\"\"></p>\n<p>pwd 命令是用于显示当前的目录。</p>\n<p>1. 通过命令 git init 把这个目录变成 git 可以管理的仓库，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251343102774109.png\" alt=\"\"></p>\n<p>这时候你当前 testgit 目录下会多了一个.git 的目录，这个目录是 Git 来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把 git 仓库给破坏了。如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251343384492003.png\" alt=\"\"></p>\n<p>2. 把文件添加到版本库中。</p>\n<p>首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如 txt 文件，网页，所有程序的代码等，Git 也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从 1kb 变成 2kb，但是到底改了啥，版本控制也不知道。</p>\n<p>**     下面先看下**<strong>demo*</strong>*如下演示：**</p>\n<p>我在版本库 testgit 目录下新建一个记事本文件 readme.txt 内容如下：11111111</p>\n<p>第一步：使用命令 git add readme.txt 添加到暂存区里面去。如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251344226375669.png\" alt=\"\"></p>\n<p>如果和上面一样，没有任何提示，说明已经添加成功了。</p>\n<p>第二步：用命令 git commit 告诉 Git，把文件提交到仓库。</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251344516834662.png\" alt=\"\"></p>\n<p>现在我们已经提交了一个 readme.txt 文件了，我们下面可以通过命令 git status 来查看是否还有文件未提交，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251345111059561.png\" alt=\"\"></p>\n<p>说明没有任何文件未提交，但是我现在继续来改下 readme.txt 内容，比如我在下面添加一行 2222222222 内容，继续使用 git status 来查看下结果，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251345416525297.png\" alt=\"\"></p>\n<p>上面的命令告诉我们 readme.txt 文件已被修改，但是未被提交的修改。</p>\n<p>接下来我想看下 readme.txt 文件到底改了什么内容，如何查看呢？可以使用如下命令：</p>\n<p>git diff readme.txt 如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251346028718381.png\" alt=\"\"></p>\n<p>如上可以看到，readme.txt 文件内容从一行 11111111 改成 二行 添加了一行 22222222 内容。</p>\n<p>知道了对 readme.txt 文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的 2 步(第一步是 git add  第二步是：git commit)。</p>\n<p>如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251346268403791.png\" alt=\"\"></p>\n<p>二：版本回退：</p>\n<p>如上，我们已经学会了修改文件，现在我继续对 readme.txt 文件进行修改，再增加一行</p>\n<p>内容为 33333333333333.继续执行命令如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251347200583366.png\" alt=\"\"></p>\n<p>现在我已经对 readme.txt 文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251347438876519.png\" alt=\"\"></p>\n<p>git log 命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为 333333.上一次是添加内容 222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251348076992146.png\" alt=\"\"></p>\n<p>现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下 2 种命令，第一种是：git reset  –hard HEAD^ 那么如果要回退到上上个版本只需把 HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前 100 个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset  –hard HEAD~100 即可。未回退之前的 readme.txt 内容如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251348307465171.png\" alt=\"\"></p>\n<p>如果想回退到上一个版本的命令如下操作：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251348496688157.png\" alt=\"\"></p>\n<p>再来查看下 readme.txt 内容如下：通过命令 cat readme.txt 查看</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251349052154773.png\" alt=\"\"></p>\n<p>可以看到，内容已经回退到上一个版本了。我们可以继续使用 git log 来查看下历史记录信息，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251349205437091.png\" alt=\"\"></p>\n<p>我们看到 增加 333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有 333333 的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：</p>\n<p>git reset  –hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者 333 内容的版本号我并不知道呢？要如何知道增加 3333 内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog  演示如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251349474491472.png\" alt=\"\"></p>\n<p>通过上面的显示我们可以知道，增加内容 3333 的版本号是 6fcfc89.我们现在可以命令</p>\n<p>git reset  –hard 6fcfc89 来恢复了。演示如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251350096836911.png\" alt=\"\"></p>\n<p>可以看到 目前已经是最新的版本了。</p>\n<p>三：理解工作区与暂存区的区别？</p>\n<p><strong>工作区：</strong>就是你在电脑上看到的目录，比如目录下 testgit 里的文件(.git 隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。</p>\n<p>**      版本库**<strong>(Repository)*</strong>*：**工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是 stage(暂存区)，还有 Git 为我们自动创建了第一个分支 master,以及指向 master 的一个指针 HEAD。</p>\n<p>我们前面说过使用 Git 提交文件到版本库有两步：</p>\n<p>第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。</p>\n<p>第二步：使用 git commit 提交更改，实际上就是把暂存区的所有内容提交到当前分支上。</p>\n<p>我们继续使用 demo 来演示下：</p>\n<p>我们在 readme.txt 再添加一行内容为 4444444，接着在目录下新建一个文件为 test.txt 内容为 test，我们先用命令 git status 来查看下状态，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251350425584501.png\" alt=\"\"></p>\n<p>现在我们先使用 git add 命令把 2 个文件都添加到暂存区中，再使用 git status 来查看下状态，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251351180907145.png\" alt=\"\"></p>\n<p>接着我们可以使用 git commit 一次性提交到分支上，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251351473248082.png\" alt=\"\"></p>\n<p>四：Git 撤销修改和删除文件操作。</p>\n<p><strong>一：撤销修改：</strong></p>\n<p>比如我现在在 readme.txt 文件里面增加一行 内容为 555555555555，我们先通过命令查看如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251352126216220.png\" alt=\"\"></p>\n<p>在我未提交之前，我发现添加 5555555555555 内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：</p>\n<p>第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后 add 添加到暂存区，最后 commit 掉。</p>\n<p>第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset  –hard HEAD^</p>\n<p>但是现在我不想使用上面的 2 种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251352368714545.png\" alt=\"\"></p>\n<p>可以发现，Git 会告诉你，git checkout  – file 可以丢弃工作区的修改，如下命令：</p>\n<p>git checkout  –  readme.txt,如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251352562464460.png\" alt=\"\"></p>\n<p>命令 git checkout –readme.txt 意思就是，把 readme.txt 文件在工作区做的修改全部撤销，这里有 2 种情况，如下：</p>\n<ol>\n<li>readme.txt 自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。</li>\n<li>另外一种是 readme.txt 已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。</li>\n</ol>\n<p>对于第二种情况，我想我们继续做 demo 来看下，假如现在我对 readme.txt 添加一行 内容为 6666666666666，我 git add 增加到暂存区后，接着添加内容 7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251353209657240.png\" alt=\"\"></p>\n<p><strong>注意：</strong>命令 git checkout – readme.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了。</p>\n<p><strong>二：删除文件。</strong></p>\n<p>假如我现在版本库 testgit 目录添加一个文件 b.txt,然后提交。如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251353539187274.png\" alt=\"\"></p>\n<p>如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上 rm 命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行 commit 命令 提交掉，现在目录是这样的，</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251354169022085.png\" alt=\"\"></p>\n<p>只要没有 commit 之前，如果我想在版本库中恢复此文件如何操作呢？</p>\n<p>可以使用如下命令 git checkout  – b.txt，如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251354414803609.png\" alt=\"\"></p>\n<p>再来看看我们 testgit 目录，添加了 3 个文件了。如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251355004651109.png\" alt=\"\"></p>\n<p>五：远程仓库。</p>\n<p>在了解之前，先注册 github 账号，由于你的本地 Git 仓库和 github 仓库之间的传输是通过 SSH 加密的，所以需要一点设置：</p>\n<p>第一步：创建 SSH Key。在用户主目录下，看看有没有.ssh 目录，如果有，再看看这个目录下有没有 id_rsa 和 id_rsa.pub 这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：</p>\n<p>ssh-keygen  -t rsa –C “<a href=\"mailto:youremail@example.com\">youremail@example.com</a>”, 由于我本地此前运行过一次，所以本地有，如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251355342303027.png\" alt=\"\"></p>\n<p>id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人。</p>\n<p>第二步：登录 github,打开” settings”中的 SSH Keys 页面，然后点击“Add SSH Key”,填上任意 title，在 Key 文本框里黏贴 id_rsa.pub 文件的内容。</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251356274651130.png\" alt=\"\"></p>\n<p>点击 Add Key，你就应该可以看到已经添加的 key。</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251356499185972.png\" alt=\"\"></p>\n<ol>\n<li>如何添加远程库？</li>\n</ol>\n<p>现在的情景是：我们已经在本地创建了一个 Git 仓库后，又想在 github 创建一个 Git 仓库，并且希望这两个仓库进行远程同步，这样 github 的仓库可以作为备份，又可以其他人通过该仓库来协作。</p>\n<p>首先，登录 github 上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251357316059068.png\" alt=\"\"></p>\n<p>在 Repository name 填入<code>testgit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的 Git 仓库：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251357548716794.png\" alt=\"\"></p>\n<p>目前，在 GitHub 上的这个<code>testgit</code>仓库还是空的，GitHub 告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到 GitHub 仓库。</p>\n<p>现在，我们根据 GitHub 的提示，在本地的<code>testgit</code>仓库下运行命令：</p>\n<p>git remote add origin <a href=\"https://github.com/tugenhua0707/testgit.git\" target=\"_blank\" rel=\"noopener\">https://github.com/tugenhua0707/testgit.git</a></p>\n<p>所有的如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251358439027115.png\" alt=\"\"></p>\n<p>把本地库的内容推送到远程，使用 git push 命令，实际上是把当前分支 master 推送到远程。</p>\n<p>由于远程库是空的，我们第一次推送 master 分支时，加上了 –u 参数，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在 github 页面中看到远程库的内容已经和本地一模一样了，上面的要输入 github 的用户名和密码如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251359074968040.png\" alt=\"\"></p>\n<p>从现在起，只要本地作了提交，就可以通过如下命令：</p>\n<p>git push origin master</p>\n<p>把本地 master 分支的最新修改推送到 github 上了，现在你就拥有了真正的分布式版本库了。</p>\n<p>2. 如何从远程库克隆？</p>\n<p>上面我们了解了先有本地库，后有远程库时候，如何关联远程库。</p>\n<p>现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？</p>\n<p>首先，登录 github，创建一个新的仓库，名字叫 testgit2.如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251359368403775.png\" alt=\"\"></p>\n<p>如下，我们看到：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251359573401245.png\" alt=\"\"></p>\n<p>现在，远程库已经准备好了，下一步是使用命令 git clone 克隆一个本地库了。如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251400190749472.png\" alt=\"\"></p>\n<p>接着在我本地目录下 生成 testgit2 目录了，如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251400431217326.png\" alt=\"\"></p>\n<p>六：创建与合并分支。</p>\n<p>在   版本回填退里，你已经知道，每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在 Git 里，这个分支叫主分支，即 master 分支。HEAD 严格来说不是指向提交，而是指向 master，master 才是指向提交的，所以，HEAD 指向的就是当前分支。</p>\n<p>首先，我们来创建 dev 分支，然后切换到 dev 分支上。如下操作：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251401222624868.png\" alt=\"\"></p>\n<p>git checkout 命令加上 –b 参数表示创建并切换，相当于如下 2 条命令</p>\n<p>git branch dev</p>\n<p>git checkout dev</p>\n<p>git branch 查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在 dev 分支上继续做 demo，比如我们现在在 readme.txt 再增加一行 7777777777777</p>\n<p>首先我们先来查看下 readme.txt 内容，接着添加内容 77777777，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251401471056078.png\" alt=\"\"></p>\n<p>现在 dev 分支工作已完成，现在我们切换到主分支 master 上，继续查看 readme.txt 内容如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251402052152479.png\" alt=\"\"></p>\n<p>现在我们可以把 dev 分支上的内容合并到分支 master 上了，可以在 master 分支上，使用如下命令 git merge dev 如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251402275904876.png\" alt=\"\"></p>\n<p>git merge 命令用于合并指定分支到当前分支上，合并后，再查看 readme.txt 内容，可以看到，和 dev 分支最新提交的是完全一样的。</p>\n<p>注意到上面的<em>Fast-forward</em>信息，Git 告诉我们，这次合并是“快进模式”，也就是直接把 master 指向 dev 的当前提交，所以合并速度非常快。</p>\n<p>合并完成后，我们可以接着删除 dev 分支了，操作如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251402521216116.png\" alt=\"\"></p>\n<p>总结创建与合并分支命令如下：</p>\n<p>查看分支：git branch</p>\n<p>创建分支：git branch name</p>\n<p>切换分支：git checkout name</p>\n<p>创建+切换分支：git checkout –b name</p>\n<p>合并某分支到当前分支：git merge name</p>\n<p>删除分支：git branch –d name</p>\n<ol>\n<li>如何解决冲突？</li>\n</ol>\n<p>下面我们还是一步一步来，先新建一个新分支，比如名字叫 fenzhi1，在 readme.txt 添加一行内容 8888888，然后提交，如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251403184188082.png\" alt=\"\"></p>\n<p>同样，我们现在切换到 master 分支上来，也在最后一行添加内容，内容为 99999999，如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251403416053365.png\" alt=\"\"></p>\n<p>现在我们需要在 master 分支上来合并 fenzhi1，如下操作：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251404228409533.png\" alt=\"\"></p>\n<p>Git 用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&gt;&gt;&gt;&gt;&gt;fenzhi1 是指 fenzhi1 上修改的内容，我们可以修改下如下后保存：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251404454024875.png\" alt=\"\"></p>\n<p>如果我想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251405055906673.png\" alt=\"\"></p>\n<p>3.分支管理策略。</p>\n<p>通常合并分支时，git 一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff 来禁用”Fast forward”模式。首先我们来做 demo 演示下：</p>\n<ol>\n<li>创建一个 dev 分支。</li>\n<li>修改 readme.txt 内容。</li>\n<li>添加到暂存区。</li>\n<li>切换回主分支(master)。</li>\n<li>合并 dev 分支，使用命令 git merge –no-ff  -m “注释” dev</li>\n<li>查看历史记录</li>\n</ol>\n<p>截图如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251405434185118.png\" alt=\"\"></p>\n<p><strong>分支策略：</strong>首先 master 主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的 dev 分支上干活，干完后，比如上要发布，或者说 dev 分支代码稳定后可以合并到主分支 master 上来。</p>\n<p>七：bug 分支：</p>\n<p>在开发中，会经常碰到 bug 问题，那么有了 bug 就需要修复，在 Git 中，分支是很强大的，每个 bug 都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p>\n<p>比如我在开发中接到一个 404 bug 时候，我们可以创建一个 404 分支来修复它，但是，当前的 dev 分支上的工作还没有提交。比如如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251407366993876.png\" alt=\"\"></p>\n<p>并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支 bug 要 2 天完成，但是我 issue-404 bug 需要 5 个小时内完成。怎么办呢？还好，Git 还提供了一个 stash 功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251408084493910.png\" alt=\"\"></p>\n<p>所以现在我可以通过创建 issue-404 分支来修复 bug 了。</p>\n<p>首先我们要确定在那个分支上修复 bug，比如我现在是在主分支 master 上来修复的，现在我要在 master 分支上创建一个临时分支，演示如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251408333083648.png\" alt=\"\"></p>\n<p>修复完成后，切换到 master 分支上，并完成合并，最后删除 issue-404 分支。演示如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251409016683485.png\" alt=\"\"></p>\n<p>现在，我们回到 dev 分支上干活了。</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251409307156776.png\" alt=\"\"></p>\n<p>工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list 来查看下。如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251409546688359.png\" alt=\"\"></p>\n<p>工作现场还在，Git 把 stash 内容存在某个地方了，但是需要恢复一下，可以使用如下 2 个方法：</p>\n<ol>\n<li>git stash apply 恢复，恢复后，stash 内容并不删除，你需要使用命令 git stash drop 来删除。</li>\n<li>另一种方式是使用 git stash pop,恢复的同时把 stash 内容也删除了。</li>\n</ol>\n<p>演示如下</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251410142934731.png\" alt=\"\"></p>\n<p>八：多人协作。</p>\n<p>当你从远程库克隆时候，实际上 Git 自动把本地的 master 分支和远程的 master 分支对应起来了，并且远程库的默认名称是 origin。</p>\n<ol>\n<li>要查看远程库的信息 使用 git remote</li>\n<li>要查看远程库的详细信息 使用 git remote –v</li>\n</ol>\n<p>如下演示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251410415747295.png\" alt=\"\"></p>\n<p><strong>一：推送分支：</strong></p>\n<p>推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git 就会把该分支推送到远程库对应的远程分支上：</p>\n<p>使用命令 git push origin master</p>\n<p>比如我现在的 github 上的 readme.txt 代码如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251411007466738.png\" alt=\"\"></p>\n<p>本地的 readme.txt 代码如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251411277462090.png\" alt=\"\"></p>\n<p>现在我想把本地更新的 readme.txt 代码推送到远程库中，使用命令如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251411458711720.png\" alt=\"\"></p>\n<p>我们可以看到如上，推送成功，我们可以继续来截图 github 上的 readme.txt 内容 如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251412049657718.png\" alt=\"\"></p>\n<p>可以看到 推送成功了，如果我们现在要推送到其他分支，比如 dev 分支上，我们还是那个命令 git push origin dev</p>\n<p>那么一般情况下，那些分支要推送呢？</p>\n<ol>\n<li>master 分支是主分支，因此要时刻与远程同步。</li>\n<li>一些修复 bug 分支不需要推送到远程去，可以先合并到主分支上，然后把主分支 master 推送到远程去。</li>\n</ol>\n<p><strong>二：抓取分支：</strong></p>\n<p>多人协作时，大家都会往 master 分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把 SSH key 添加到 github 上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫 testgit2</p>\n<p>但是我首先要把 dev 分支也要推送到远程去，如下</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251413370902607.jpg\" alt=\"\"></p>\n<p>接着进入 testgit2 目录，进行克隆远程的库到本地来，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251412375741324.png\" alt=\"\"></p>\n<p>现在目录下生成有如下所示：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251414098406468.png\" alt=\"\"></p>\n<p>现在我们的小伙伴要在 dev 分支上做开发，就必须把远程的 origin 的 dev 分支到本地来，于是可以使用命令创建本地 dev 分支：git checkout  –b dev origin/dev</p>\n<p>现在小伙伴们就可以在 dev 分支上做开发了，开发完成后把 dev 分支推送到远程库时。</p>\n<p>如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251416265903424.png\" alt=\"\"></p>\n<p>小伙伴们已经向 origin/dev 分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251416538082475.png\" alt=\"\"></p>\n<p>由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用 git pull 把最新的提交从 origin/dev 抓下来，然后在本地合并，解决冲突，再推送。</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251417172467915.png\" alt=\"\"></p>\n<p><em>git pull</em>也失败了，原因是没有指定本地 dev 分支与远程 origin/dev 分支的链接，根据提示，设置 dev 和 origin/dev 的链接：如下：</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251417344188703.png\" alt=\"\"></p>\n<p>这回<em>git pull</em>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再 push：</p>\n<p>我们可以先来看看 readme.txt 内容了。</p>\n<p><img src=\"http://images.cnitblog.com/blog/561794/201410/251418192937227.png\" alt=\"\"></p>\n<p>现在手动已经解决完了，我接在需要再提交，再 push 到远程库里面去。如下所示：<br><img src=\"http://images.cnitblog.com/blog/561794/201410/251418378872312.png\" alt=\"\"></p>\n<p>因此：多人协作工作模式一般是这样的：</p>\n<ol>\n<li>首先，可以试图用 git push origin branch-name 推送自己的修改.</li>\n<li>如果推送失败，则因为远程分支比你的本地更新早，需要先用 git pull 试图合并。</li>\n<li>如果合并有冲突，则需要解决冲突，并在本地提交。再用 git push origin branch-name 推送。</li>\n</ol>\n"},{"title":"前端性能优化最佳实践","date":"2017-08-26T23:43:00.000Z","_content":"\n本文主要考量客户端性能、服务器端和网络性能，内容框架来自  [Yahoo Developer Network](https://developer.yahoo.com/performance/rules.html)，包含 7 个类别共 35 条前端性能优化最佳实践，在此基础上补充了一些相关或者更符合主流技术的内容。\n\n同时，建议关注及时更新的  [Google 性能优化指南](https://developers.google.com/web/fundamentals/performance/?hl=en)。\n\n目录：\n\n- [页面内容](https://csspod.com/frontend-performance-best-practices/#content)\n  - [减少 HTTP 请求数](https://csspod.com/frontend-performance-best-practices/#content-http)\n  - [减少 DNS 查询](https://csspod.com/frontend-performance-best-practices/#content-dns)\n  - [避免重定向](https://csspod.com/frontend-performance-best-practices/#content-redirect)\n  - [缓存 Ajax 请求](https://csspod.com/frontend-performance-best-practices/#content-ajax-cache)\n  - [延迟加载](https://csspod.com/frontend-performance-best-practices/#content-postload)\n  - [预先加载](https://csspod.com/frontend-performance-best-practices/#content-preload)\n  - [减少 DOM 元素数量](https://csspod.com/frontend-performance-best-practices/#content-dom)\n  - [划分内容到不同域名](https://csspod.com/frontend-performance-best-practices/#content-domains)\n  - [尽量减少 iframe 使用](https://csspod.com/frontend-performance-best-practices/#content-iframe)\n  - [避免 404 错误](https://csspod.com/frontend-performance-best-practices/#content-404)\n- [服务器](https://csspod.com/frontend-performance-best-practices/#server)\n  - [使用 CDN](https://csspod.com/frontend-performance-best-practices/#server-cdn)\n  - [添加 Expires 或 Cache-Control 响应头](https://csspod.com/frontend-performance-best-practices/#server-cache)\n  - [启用 Gzip](https://csspod.com/frontend-performance-best-practices/#server-gzip)\n  - [配置 Etag](https://csspod.com/frontend-performance-best-practices/#server-etag)\n  - [尽早输出缓冲](https://csspod.com/frontend-performance-best-practices/#server-flush)\n  - [Ajax 请求使用 GET 方法](https://csspod.com/frontend-performance-best-practices/#server-ajax-get)\n  - [避免图片 src 为空](https://csspod.com/frontend-performance-best-practices/#server-src)\n- [Cookie](https://csspod.com/frontend-performance-best-practices/#cookie)\n  - [减少 Cookie 大小](https://csspod.com/frontend-performance-best-practices/#cookie-size)\n  - [静态资源使用无 Cookie 域名](https://csspod.com/frontend-performance-best-practices/#cookie-free)\n- [CSS](https://csspod.com/frontend-performance-best-practices/#css)\n  - [把样式表放在    中](https://csspod.com/frontend-performance-best-practices/#css-head)\n  - [不要使用 CSS 表达式](https://csspod.com/frontend-performance-best-practices/#css-expression)\n  - [使用    替代  `@import`](https://csspod.com/frontend-performance-best-practices/#css-link)\n  - [不要使用 filter](https://csspod.com/frontend-performance-best-practices/#css-filter)\n- [JavaScript](https://csspod.com/frontend-performance-best-practices/#javascript)\n  - [把脚本放在页面底部](https://csspod.com/frontend-performance-best-practices/#javascript-bottom)\n  - [使用外部 JavaScript 和 CSS](https://csspod.com/frontend-performance-best-practices/#javascript-extenal)\n  - [压缩 JavaScript 和 CSS](https://csspod.com/frontend-performance-best-practices/#javascript-minify)\n  - [移除重复脚本](https://csspod.com/frontend-performance-best-practices/#javascript-duplicate)\n  - [减少 DOM 操作](https://csspod.com/frontend-performance-best-practices/#javascript-dom)\n  - [使用高效的事件处理](https://csspod.com/frontend-performance-best-practices/#javascript-event)\n- [图片](https://csspod.com/frontend-performance-best-practices/#image)\n  - [优化图片](https://csspod.com/frontend-performance-best-practices/#image-optimize)\n  - [优化 CSS Sprite](https://csspod.com/frontend-performance-best-practices/#image-sprite)\n  - [不要在 HTML 中缩放图片](https://csspod.com/frontend-performance-best-practices/#image-scale)\n  - [使用体积小、可缓存的 favicon.ico](https://csspod.com/frontend-performance-best-practices/#image-favicon)\n- [移动端](https://csspod.com/frontend-performance-best-practices/#mobile)\n  - [保持单个文件小于 25 KB](https://csspod.com/frontend-performance-best-practices/#mobile-25kb)\n  - [打包内容为分段（multipart）文档](https://csspod.com/frontend-performance-best-practices/#mobile-multipart)\n\n前端性能的一个重要指标是页面加载时间，不仅事关用户体验，也是搜索引擎排名考虑的一个因素。\n\n> - 来自 Google 的数据表明，一个有 10 条数据 0.4 秒能加载完的页面，变成 30 条数据 0.9 秒加载完之后，流量和广告收入下降 90%。\n> - Google Map 首页文件大小从 100KB 减小到 70-80KB 后，流量在第一周涨了 10%，接下来的三周涨了 25%。\n> - 亚马逊的数据表明：加载时间增加 100 毫秒，销量就下降 1%。\n\n以上数据更说明「加载时间就是金钱」，前端优化主要围绕提高加载速度进行。\n\n## 页面内容\n\n### 减少 HTTP 请求数\n\nWeb 前端 80% 的响应时间花在图片、样式、脚本等资源下载上。浏览器对每个域名的连接数是有限制的，减少请求次数是缩短响应时间的关键。\n\n通过简洁的设计减少页面所需资源，进而减少 HTTP 请求，这是最直接的方式，前提是你的 Boss、设计师同事不打死你。所以，还是另辟蹊径吧：\n\n- 合并 JavaScript、CSS 等文件；\n\n  - 服务器端（CDN）自动合并\n  - 基于 Node.js 的文件合并工具一抓一大把\n\n- 使用[CSS Sprite](http://alistapart.com/articles/sprites)：将背景图片合并成一个文件，通过`background-image`  和  `background-position`  控制显示；\n\n  - [Sprite Cow](http://www.spritecow.com/)\n  - [Spritebox](http://www.spritebox.net/)\n\n  > 逐步被 Icon Font 和 SVG Sprite 取代。\n\n- [Image Map](http://www.w3.org/TR/html401/struct/objects.html#h-13.6)：合并图片，然后使用坐标映射不同的区域（[演示](<https://en.wikipedia.org/wiki/The_Club_(dining_club)>)）。\n\n  > 缺点：仅适用于相连的图片；设置坐标过程乏味且易出错；可访性问题。不推荐使用这种过时的技术。\n\n- Inline Assets：使用  [Data URI scheme](https://en.wikipedia.org/wiki/Data_URI_scheme)  将图片嵌入 HTML 或者 CSS 中；或者将 CSS、JS、图片直接嵌入 HTML 中。\n\n  > 会增加文件大小，也可能产生浏览器兼容及其他性能问题（有待整理补充）。\n\n  未来的趋势是使用内嵌 SVG。\n\n- [内容分片](https://csspod.com/frontend-performance-best-practices/#content-domains)，将请求划分到不同的域名上。\n\n> HTTP/2 通过多路复用大幅降低了多个请求的开销。通过数据分帧层，客户端和服务器之间只需要建立一个 TCP 连接，即可同时收发多个文件，而且，该连接在相当长的时间周期内保持打开（持久化），以便复用。\n>\n> HTTP/2 的新特性意味着上述优化实践不再适用，但考虑到客户端对 HTTP/2 的支持覆盖程度，还需根据实际数据权衡。\n\n### 减少 DNS 查询\n\n用户输入 URL 以后，浏览器首先要查询域名（hostname）对应服务器的 IP 地址，一般需要耗费  20-120 毫秒   时间。DNS 查询完成之前，浏览器无法从服务器下载任何数据。\n\n基于性能考虑，ISP、局域网、操作系统、浏览器都会有相应的 DNS 缓存机制。\n\n- IE 缓存 30 分钟，可以通过注册表中  `DnsCacheTimeout`  项设置；\n- Firefox 混存 1 分钟，通过  `network.dnsCacheExpiration`  配置；\n- （TODO：补充其他浏览器缓存信息）\n\n首次访问、没有相应的 DNS 缓存时，域名越多，查询时间越长。所以应尽量减少域名数量。但基于并行下载考虑，把资源分布到 2 个域名上（最多不超过 4 个）。这是减少 DNS 查询同时保证并行下载的折衷方案。\n\n### 避免重定向\n\nHTTP 重定向通过  `301`/`302`  状态码实现。\n\n    HTTP/1.1 301 Moved Permanently\n    Location: http://example.com/newuri\n    Content-Type: text/html\n\n客户端收到服务器的重定向响应后，会根据响应头中  `Location`  的地址再次发送请求。重定向会影响用户体验，尤其是多次重定向时，用户在一段时间内看不到任何内容，只看到浏览器进度条一直在刷新。\n\n有时重定向无法避免，在糟糕也比抛出 404 好。虽然通过  [HTML meta refresh](https://en.wikipedia.org/wiki/Meta_refresh)  和 JavaScript 也能实现，但首选 HTTP `3xx`  跳转，以保证浏览器「后退」功能正常工作（也利于 SEO）。\n\n- 最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加  `/`  但未添加。比如，访问  `http://astrology.yahoo.com/astrology`  将被 301 重定向到  `http://astrology.yahoo.com/astrology/`（注意末尾的  `/`）。如果使用 Apache，可以通过  `Alias`  或  `mod_rewrite`  或  `DirectorySlash`  解决这个问题。\n- 网站域名变更：CNAME 结合  `Alias`  或  `mod_rewrite`  或者其他服务器类似功能实现跳转。\n\n### 缓存 Ajax 请求\n\nAjax 可以提高用户体验。但「异步」不意味着「及时」，优化 Ajax 响应速度提高性能仍是需要关注的主题。\n\n最重要的的优化方式是缓存响应结果，详见  [添加 Expires 或 Cache-Control 响应头](https://csspod.com/frontend-performance-best-practices/#server-cache)。\n\n以下规则也关乎 Ajax 响应速度：\n\n- [启用 Gzip](https://csspod.com/frontend-performance-best-practices/#server-gzip)\n- [减少 DNS 查询](https://csspod.com/frontend-performance-best-practices/#content-dns)\n- [压缩 JavaScript 和 CSS](https://csspod.com/frontend-performance-best-practices/#javascript-minify)\n- [避免重定向](https://csspod.com/frontend-performance-best-practices/#content-redirect)\n- [配置 Etag](https://csspod.com/frontend-performance-best-practices/#server-etag)\n\n### 延迟加载\n\n页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如：\n\n- 非首屏使用的数据、样式、脚本、图片等；\n- 用户交互时才会显示的内容。\n\n遵循「渐进增强」理念开发的网站：JavaScript 用于增强用用户体验，但没有（不支持） JavaScript 也能正常工作，完全可以延迟加载 JavaScript。\n\n> 延迟渲染\n>\n> 将首屏以外的 HTML 放在不渲染的元素中，如隐藏的  `</code>，或者 <code>type</code> 属性为非执行脚本的 <code><script></code>标签中，减少初始渲染的 DOM 元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。</p> </blockquote> <p><a name=\"content-preload\"></a></p> <h3 id=\"\">预先加载</h3> <p>预先加载利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应。</p> <ul> <li> <p>无条件预先加载：页面加载完成（<code>load</code>）后，马上获取其他资源。以 <a href=\"http://google.com/\">google.com</a> 为例，首页加载完成后会立即下载一个 Sprite 图片，此图首页不需要，但是搜索结果页要用到。</p> </li> <li> <p>有条件预先加载：根据用户行为预判用户去向，预载相关资源。比如 <a href=\"http://search.yahoo.com/\">search.yahoo.com</a> 开始输入时会有额外的资源加载。</p> <blockquote> <p>Chrome 等浏览器的地址栏也有类似的机制。</p> </blockquote> </li> <li> <p>有「阴谋」的预先加载：页面即将上线新版前预先加载新版内容。网站改版后由于缓存、使用习惯等原因，会有旧版的网站更快更流畅的反馈。为缓解这一问题，在新版上线之前，旧版可以利用空闲提前加载一些新版的资源缓存到客户端，以便新版正式上线后更快的载入（好一个「心机猿」:scream:）。</p> <blockquote> <p>「双十一」、「黑五」这类促销日来临之前，也可以预先下载一些相关资源到客户端（浏览器、App 等），有效利用浏览器缓存和本地存储，降低活动当日请求压力，提高用户体验。</p> </blockquote> </li> </ul> <blockquote> <p>TODO: Prefetch 相关细节</p> </blockquote> <ul> <li><a href=\"https://www.w3.org/TR/resource-hints/\">Resource Hints Spec</a></li> </ul> <p><a name=\"content-dom\"></a></p> <h3 id=\"dom\">减少 DOM 元素数量</h3> <p>复杂的页面不仅下载的字节更多，JavaScript DOM 操作也更慢。例如，同是添加一个事件处理器，500 个元素和 5000 个元素的页面速度上会有很大区别。</p> <p>从以下几个角度考虑移除不必要的标记：</p> <ul> <li>是否还在使用表格布局？</li> <li>塞进去更多的 <code><div></code> 仅为了处理布局问题？也许有更好、更语义化的标记。</li> <li>能通过伪元素实现的功能，就没必要添加额外元素，如清除浮动。</li> </ul> <p>浏览器控制台中输入以下代码可以计算出页面中有多少 DOM 元素：</p> <pre><code class=\"language-javascript\">document.getElementsByTagName('*').length; </code></pre> <p>对比标记良好的的网站，看看差距是多少。</p> <blockquote> <p>为什么不使用表格布局？</p> <ul> <li>更多的标签，增加文件大小；</li> <li>不易维护，无法适应响应式设计；</li> <li>性能考量，默认的表格布局算法会产生大量重绘（参见<a href=\"https://csspod.com/table-width-algorithms/\">表格布局算法</a>）。</li> </ul> </blockquote> <p><a name=\"content-domains\"></a></p> <h3 id=\"\">划分内容到不同域名</h3> <p>浏览器一般会限制每个域的并行线程（一般为 6 个，甚至更少），使用不同的域名可以最大化下载线程，但注意保持在 2-4 个域名内，以避免 DNS 查询损耗。</p> <p>例如，动态内容放在 <code>csspod.com</code> 上，静态资源放在 <code>static.csspod.com</code>上。这样还可以禁用静态资源域下的 Cookie，减少数据传输，详见 <a href=\"https://csspod.com/frontend-performance-best-practices/#cookie-free\">Cookie 优化</a>。</p> <p>更多信息参考 <a href=\"http://yuiblog.com/blog/2007/04/11/performance-research-part-4/\">Maximizing Parallel Downloads in the Carpool Lane</a></p> <p><a name=\"content-iframe\"></a></p> <h3 id=\"iframe\">尽量减少 iframe 使用</h3> <p>使用 iframe 可以在页面中嵌入 HTML 文档，但有利有弊。</p> <p><code><iframe></code> 优点：</p> <ul> <li>可以用来加载速度较慢的第三方资源，如广告、徽章；</li> <li>可用作<a href=\"http://www.html5rocks.com/en/tutorials/security/sandboxed-iframes/\">安全沙箱</a>；</li> <li>可以并行下载脚本。</li> </ul> <p><code><iframe> 缺点</code>：</p> <ul> <li> <p>加载代价昂贵，即使是空的页面；</p> </li> <li> <p>阻塞页面 <code>load</code> 事件触发；</p> <blockquote> <p>Iframe 完全加载以后，父页面才会触发 <code>load</code> 事件。 Safari、Chrome 中通过 JavaScript 动态设置 iframe <code>src</code> 可以避免这个问题。</p> </blockquote> </li> <li> <p>缺乏语义。</p> </li> </ul> <p><a name=\"content-404\"></a></p> <h3 id=\"404\">避免 404 错误</h3> <p>HTTP 请求很昂贵，返回无效的响应（如 404 未找到）完全没必要，降低用户体验而且毫无益处。</p> <p>一些网站设计很酷炫、有提示信息的 404 页面，有助于提高用户体验，但还是浪费服务器资源。尤其糟糕的是外部脚本返回 404，不仅阻塞其他资源下载，浏览器还会尝试把 404 页面内容当作 JavaScript 解析，消耗更多资源。</p> <h3 id=\"\">补充规则：</h3> <ul> <li>定义字符集，并放在 <code><head></code> 顶部。大多数浏览器会暂停页面渲染，直到找到字符集定义。</li> </ul> <p><a name=\"server\"></a></p> <h2 id=\"\">服务器</h2> <p>服务器相关优化设置可参考 H5BP 相关项目：</p> <ul> <li><a href=\"https://github.com/h5bp/server-configs-nginx\">Nginx HTTP server boilerplate configs</a></li> <li><a href=\"https://github.com/h5bp/server-configs-apache\">Apache HTTP server boilerplate configs</a></li> <li><a href=\"https://github.com/h5bp/server-configs-iis\">IIS Web.Config Boilerplates</a></li> </ul> <p><a name=\"server-cdn\"></a></p> <h3 id=\"cdn\">使用 CDN</h3> <p>网站 80-90% 响应时间消耗在资源下载上，减少资源下载时间是性能优化的黄金发则。</p> <p>相比分布式架构的复杂和巨大投入，静态内容分发网络（CDN）可以以较低的投入，获得加载速度有效提升。</p> <p><a name=\"server-cache\"></a></p> <h3 id=\"expirescachecontrol\">添加 Expires 或 Cache-Control 响应头</h3> <ul> <li>静态内容：将 <code>Expires</code> 响应头设置为将来很远的时间，实现「永不过期」策略；</li> <li>动态内容：设置合适的 <code>Cache-Control</code> 响应头，让浏览器有条件地发起请求。</li> </ul> <blockquote> <p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control\">Cache-Control</a> 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires、Pragma）。当前的所有浏览器都支持 Cache-Control，因此，使用它就够了。</p> </blockquote> <blockquote> <p>鉴于静态内容和动态内容不同的缓存策略，实践中一般会把二者部署在不同的服务器（域名）以方便管理。</p> </blockquote> <p>参考链接：</p> <ul> <li><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\">HTTP 缓存 | Web Fundamentals - Google Developers</a></li> <li><a href=\"https://github.com/h5bp/server-configs\">H5BP - Server Configs</a></li> </ul> <p><a name=\"server-gzip\"></a></p> <h3 id=\"gzip\">启用 Gzip</h3> <p>Gzip 压缩通常可以减少 70% 的响应大小，对某些文件更可能高达 90%，比 Deflate 更高效。主流 Web 服务器都有相应模块，而且绝大多数浏览器支持 gzip 解码。所以，应该对 HTML、CSS、JS、XML、JSON 等文本类型的内容启用压缩。</p> <p>注意，图片和 PDF 文件不要使用 gzip。它们本身已经压缩过，再使用 gzip 压缩不仅浪费 CPU 资源，而且还可能增加文件体积。</p> <p>对于不支持的 Gzip 的用户代理，通过设置 Vary 响应头，返回<s>为</s>未压缩的数据：</p> <pre><code>Vary: * </code></pre> <p><a name=\"server-etag\"></a></p> <h3 id=\"etag\">配置 Etag</h3> <p>Etag 通过文件版本标识，方便服务器判断请求的内容是否有更新，如果没有就响应 <code>304</code>，避免重新下载。</p> <p>当然，启用 Etag 可能会导致其他问题，还需要根据具体情况做判断。（TODO：补充相关内容）</p> <p><a name=\"server-flush\"></a></p> <h3 id=\"flush\">尽早输出（flush）缓冲</h3> <p>用户请求页面时，服务器通常需要花费 200 ~ 500 毫秒来组合 HTML 页面。在此期间，浏览器处于空闲、等待数据状态。使用PHP 中的 <a href=\"http://php.net/flush\">flush()</a> 函数，可以发送部分已经准备好的 HTML 到浏览器，以便服务器还在忙于处理剩余页面时，浏览器可以提前开始获取资源。</p> <p>可以考虑在 <code></head></code> 之后输出一次缓冲，HTML head 一般比较容易生成，先发送以便浏览器开始获取 <code><head></code> 里引用的 CSS 等资源。</p> <p>Example:</p> <pre><code class=\"language-html\"><!-- css, js --> </head> <?php flush(); ?> <body> <!-- content --> </code></pre> <p><a name=\"server-ajax-get\"></a></p> <h3 id=\"ajaxget\">Ajax 请求使用 GET 方法</h3> <p>浏览器执行 XMLHttpRequest POST 请求时分成两步，先发送 Header，再发送数据。而 GET 只使用一个 TCP 数据包发送数据，所以首选 GET 方法。</p> <p>根据 <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html\">HTTP 规范</a>，GET 用于获取数据，POST 则用于向服务器发送数据，所以 Ajax 请求数据时使用 GET 更符合规范（<a href=\"http://www.w3schools.com/tags/ref_httpmethods.asp\">GET 和 POST 对比</a>）。</p> <p>IE 中最大 URL 长度为 2K，如果超出 2K，则需要考虑使用 POST 方法。</p> <p><a name=\"server-src\"></a></p> <h3 id=\"src\">避免图片 src 为空</h3> <p>图片 <code>src</code> 属性值为空字符串可能以下面两种形式出现：</p> <p>HTML:</p> <pre><code class=\"language-html\"><img src=\"\" /> </code></pre> <p>JavaScript：</p> <pre><code class=\"language-javascript\">var img = new Image(); img.src = \"\"; </code></pre> <p>虽然 <code>src</code> 属性为空字符串，但浏览器仍然会向服务器发起一个 HTTP 请求：</p> <ul> <li>IE 向页面所在的目录发送请求；</li> <li>Safari、Chrome、Firefox 向页面本身发送请求；</li> <li>Opera 不执行任何操作。</li> </ul> <blockquote> <p>以上数据较老，当下主流版本可能会有改变。</p> </blockquote> <p>空 <code>src</code> 产生请求的后果不容小觑：</p> <ul> <li>给服务器造成意外的流量负担，尤其时日 PV 较大时；</li> <li>浪费服务器计算资源；</li> <li>可能产生报错。</li> </ul> <p>当然，浏览器如此实现也是根据 <a href=\"https://www.ietf.org/rfc/rfc3986.txt\">RFC 3986 - Uniform Resource Identifiers</a>，当空字符串作为 URI 出现时，被当成相对 URI，具体算法参见规范 5.2 节。</p> <p>参考链接：</p> <ul> <li><a href=\"https://www.nczonline.net/blog/2009/11/30/empty-image-src-can-destroy-your-site/\">Empty image src can destroy your site</a></li> </ul> <blockquote> <p>空的 <code>href</code> 属性也存在类似问题。用户点击空链接时，浏览器也会向服务器发送 HTTP 请求，可以通过 JavaScript 阻止空链接的默认的行为。</p> </blockquote> <p><a name=\"cookie\"></a></p> <h2 id=\"cookie\">Cookie</h2> <p><a name=\"cookie-size\"></a></p> <h3 id=\"cookie\">减少 Cookie 大小</h3> <p>Cookie 被用于身份认证、个性化设置等诸多用途。Cookie 通过 HTTP 头在服务器和浏览器间来回传送，减少 Cookie 大小可以降低其对响应速度的影响。</p> <ul> <li>去除不必要的 Cookie；</li> <li>尽量压缩 Cookie 大小；</li> <li>注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；</li> <li>设置合适的过期时间。</li> </ul> <p>更多细节参考 <a href=\"http://yuiblog.com/blog/2007/03/01/performance-research-part-3/\">When the Cookie Crumbles</a>。</p> <blockquote> <p>HTTP/2 首部压缩在客户端和服务器端使用「首部表」来跟踪和存储之前发送的键值对，对于相同的数据，不再随每次请求和响应发送。</p> </blockquote> <p><a name=\"cookie-free\"></a></p> <h3 id=\"cookie\">静态资源使用无 Cookie 域名</h3> <p>静态资源一般无需使用 Cookie，可以把它们放在使用二级域名或者专门域名的无 Cookie 服务器上，降低 Cookie 传送的造成的流量浪费，提高响应速度。</p> <p><a name=\"css\"></a></p> <h2 id=\"css\">CSS</h2> <p><a name=\"css-head\"></a></p> <h3 id=\"head\">把样式表放在 <code><head></code> 中</h3> <p>把样式表放在 <code><head></code> 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉。</p> <p>这对内容比较多的页面尤为重要，用户可以先查看已经下载渲染的内容，而不是盯着白屏等待。</p> <p>如果把样式表放在页面底部，一些浏览器为减少重绘，会在 CSS 加载完成以后才渲染页面，用户只能对着白屏干瞪眼，用户体验极差。</p> <p><a name=\"css-expression\"></a></p> <h3 id=\"css\">不要使用 CSS 表达式</h3> <p>CSS 表达式可以在 CSS 里执行 JavaScript，仅 IE5-IE7 支持，IE8 标准模式已经废弃。</p> <p>CSS 表达式超出预期的频繁执行，页面滚动、鼠标移动时都会不断执行，带来很大的性能损耗。</p> <blockquote> <p>IE7 及更低版本的浏览器已经逐渐成为历史，忘记它吧。</p> </blockquote> <p><a name=\"css-link\"></a></p> <h3 id=\"linkimport\">使用 <code><link></code> 替代 <code>@import</code></h3> <p>对于 IE 某些版本，<code>@import</code> 的行为和 <code><link></code> 放在页面底部一样。所以，不要用它。</p> <p><a name=\"css-filter\"></a></p> <h3 id=\"filter\">不要使用 filter</h3> <p><code>AlphaImageLoader</code> 为 IE5.5-IE8 专有的技术，和 CSS 表达式一样，放进博物馆吧。</p> <blockquote> <p>注意：</p> <p>这里所说的不是 <a href=\"https://www.w3.org/TR/filter-effects-1/\">CSS3 Filter</a>，参考文章 <a href=\"http://www.html5rocks.com/en/tutorials/filters/understanding-css/\">Understanding CSS Filter Effects</a></p> </blockquote> <p><a name=\"javascript\"></a></p> <h2 id=\"javascript\">JavaScript</h2> <p><a name=\"javascript-bottom\"></a></p> <h3 id=\"\">把脚本放在页面底部</h3> <p>浏览器下载脚本时，会阻塞其他资源并行下载，即使是来自不同域名的资源。因此，最好将脚本放在底部，以提高页面加载速度。</p> <p>一些特殊场景无法将脚本放到页面底部的，可以考虑 <code><script></code> 的以下属性：</p> <ul> <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement#defer_property\"><code>defer</code> 属性</a>；</li> <li>HTML5 新增的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement#async_property\"><code>async</code> 属性</a>。</li> </ul> <p><a name=\"javascript-extenal\"></a></p> <h3 id=\"javascriptcss\">使用外部 JavaScript 和 CSS</h3> <p>外部 JavaScript 和 CSS 文件可以被浏览器缓存，在不同页面间重用，也能降低页面大小。</p> <p>当然，实际中也需要考虑代码的重用程度。如果仅仅是某个页面使用到的代码，可以考虑内嵌在页面中，减少 HTTP 请求数。另外，可以在首页加载完成以后，预先加载子页面的资源。</p> <p><a name=\"javascript-minify\"></a></p> <h3 id=\"javascriptcss\">压缩 JavaScript 和 CSS</h3> <p>压缩代码可以移除非功能性的字符（注释、空格、空行等），减少文件大小，提高载入速度。</p> <blockquote> <p>得益于 Node.js 的流行，开源社区涌现出许多高效、易用的前端优化工具，JavaScript 和 CSS 压缩类的，不敢说多如牛毛，多入鸡毛倒是一点不夸张，如 [UglifyJS 2] (<a href=\"https://github.com/mishoo/UglifyJS2\">https://github.com/mishoo/UglifyJS2</a>)、<a href=\"https://www.npmjs.com/package/csso\">csso</a>、<a href=\"https://www.npmjs.com/package/cssnano\">cssnano</a> 等。</p> <p>对于内嵌的 CSS 和 JavaScript，也可以通过 <a href=\"https://www.npmjs.com/package/htmlmin\">htmlmin</a> 等工具压缩。</p> <p>这些项目都有 Gulp、Webpack 等流行构建工具的配套版本。</p> </blockquote> <p><a name=\"javascript-duplicate\"></a></p> <h3 id=\"\">移除重复脚本</h3> <p>重复的脚本不仅产生不必要的 HTTP 请求，而且重复解析执行浪费时间和计算资源。</p> <p><a name=\"javascript-dom\"></a></p> <h3 id=\"dom\">减少 DOM 操作</h3> <p>JavaScript 操作 DOM 很慢，尤其是 DOM 节点很多时。</p> <p>使用时应该注意：</p> <ul> <li>缓存已经访问过的元素；</li> <li>使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/createDocumentFragment\">DocumentFragment</a> 暂存 DOM，整理好以后再插入 DOM 树；</li> <li>操作 className，而不是多次读写 <code>style</code>；</li> <li>避免使用 JavaScript 修复布局。</li> </ul> <p><a name=\"javascript-event\"></a></p> <h3 id=\"\">使用高效的事件处理</h3> <ul> <li>减少绑定事件监听的节点，如通过事件委托；</li> <li>尽早处理事件，在 <code>DOMContentLoaded</code> 即可进行，不用等到 <code>load</code>以后。</li> </ul> <blockquote> <p>对于 <code>resize</code>、<code>scroll</code> 等触发频率极高的事件，应该通过 debounce 等机制降低处理程序执行频率。</p> <p>TODO: 补充相关内容 <a href=\"http://demo.nimius.net/debounce_throttle/\">http://demo.nimius.net/debounce_throttle/</a></p> </blockquote> <p><a name=\"image\"></a></p> <h2 id=\"\">图片</h2> <p><a name=\"image-optimize\"></a></p> <h3 id=\"\">优化图片</h3> <blockquote> <p>YDN <a href=\"https://developer.yahoo.com/performance/rules.html#opt_images\">列出的相关工具</a> 缺乏易用性，建议参考以下工具。</p> </blockquote> <ul> <li><a href=\"https://github.com/imagemin/imagemin\">imagemin</a></li> <li><a href=\"https://imageoptim.com/mac\">ImageOptim</a></li> </ul> <blockquote> <p>TODO:</p> <ul> <li>PNG 终极优化；</li> <li>Webp 相关内容；</li> <li>SVG 相关内容。</li> </ul> </blockquote> <p>PNG 终极优化：</p> <ul> <li><a href=\"http://www.queness.com/post/2507/most-effective-method-to-reduce-and-optimize-png-images\">Most Effective Method to Reduce and Optimize PNG Images</a></li> <li><a href=\"https://www.smashingmagazine.com/2009/07/clever-png-optimization-techniques/\">Clever PNG Optimization Techniques</a></li> </ul> <p><a name=\"image-sprite\"></a></p> <h3 id=\"csssprite\">优化 CSS Sprite</h3> <ul> <li>水平排列 Sprite 中的图片，垂直排列会增加图片大小；</li> <li>Spirite 中把颜色较近的组合在一起可以降低颜色数，理想状况是低于 256 色以适用 PNG8 格式；</li> <li>不要在 Spirite 的图像中间留有较大空隙。减少空隙虽然不太影响文件大小，但可以降低用户代理把图片解压为像素图的内存消耗，对移动设备更友好。</li> </ul> <p><a name=\"image-scale\"></a></p> <h3 id=\"html\">不要在 HTML 中缩放图片</h3> <p>不要使用 <code><img></code> 的 <code>width</code>、<code>height</code> 缩放图片，如果用到小图片，就使用相应大小的图片。</p> <blockquote> <p>很多 CMS 和 CDN 都提供图片裁切功能。</p> </blockquote> <p><a name=\"image-favicon\"></a></p> <h3 id=\"faviconico\">使用体积小、可缓存的 favicon.ico</h3> <p>Favicon.ico 一般存放在网站根目录下，无论是否在页面中设置，浏览器都会尝试请求这个文件。</p> <p>所以确保这个图标：</p> <ul> <li>存在（避免 404）；</li> <li>尽量小，最好小于 1K；</li> <li>设置较长的过期时间。</li> </ul> <blockquote> <p>对于较新的浏览器，可以使用 PNG 格式的 favicon。</p> </blockquote> <p>参考链接：</p> <ul> <li><a href=\"https://css-tricks.com/favicon-quiz/\">Favicons, Touch Icons, Tile Icons, etc. Which Do You Need?</a></li> </ul> <h3 id=\"\">图片相关补充</h3> <blockquote> <p>设置图片的宽和高，以免浏览器按照「猜」的宽高给图片保留的区域和实际宽高差异，产生重绘。</p> </blockquote> <p><a name=\"mobile\"></a></p> <h2 id=\"\">移动端</h2> <blockquote> <p>移动端优化相关内容有待进一步整理补充。</p> </blockquote> <p><a name=\"mobile-25k\"></a></p> <h3 id=\"25kb\"><a href=\"https://developer.yahoo.com/performance/rules.html#under25\">保持单个文件小于 25 KB</a></h3> <p><a name=\"mobile-multipart\"></a></p> <h3 id=\"multipart\"><a href=\"https://developer.yahoo.com/performance/rules.html#multipart\">打包内容为分段（multipart）文档</a></h3> <h2 id=\"\">参考链接</h2> <ul> <li><a href=\"http://www.websiteoptimization.com/speed/tweak/psychology-web-performance/\">The Psychology of Web Performance</a></li> </ul></x-turndown>`\n","source":"_posts/2017-08-27-前端性能优化最佳实践.md","raw":"---\ntitle: 前端性能优化最佳实践\ntags:\n  - 优化\ndate: 2017-08-27 07:43:00\ncategories: 前端\n---\n\n本文主要考量客户端性能、服务器端和网络性能，内容框架来自  [Yahoo Developer Network](https://developer.yahoo.com/performance/rules.html)，包含 7 个类别共 35 条前端性能优化最佳实践，在此基础上补充了一些相关或者更符合主流技术的内容。\n\n同时，建议关注及时更新的  [Google 性能优化指南](https://developers.google.com/web/fundamentals/performance/?hl=en)。\n\n目录：\n\n- [页面内容](https://csspod.com/frontend-performance-best-practices/#content)\n  - [减少 HTTP 请求数](https://csspod.com/frontend-performance-best-practices/#content-http)\n  - [减少 DNS 查询](https://csspod.com/frontend-performance-best-practices/#content-dns)\n  - [避免重定向](https://csspod.com/frontend-performance-best-practices/#content-redirect)\n  - [缓存 Ajax 请求](https://csspod.com/frontend-performance-best-practices/#content-ajax-cache)\n  - [延迟加载](https://csspod.com/frontend-performance-best-practices/#content-postload)\n  - [预先加载](https://csspod.com/frontend-performance-best-practices/#content-preload)\n  - [减少 DOM 元素数量](https://csspod.com/frontend-performance-best-practices/#content-dom)\n  - [划分内容到不同域名](https://csspod.com/frontend-performance-best-practices/#content-domains)\n  - [尽量减少 iframe 使用](https://csspod.com/frontend-performance-best-practices/#content-iframe)\n  - [避免 404 错误](https://csspod.com/frontend-performance-best-practices/#content-404)\n- [服务器](https://csspod.com/frontend-performance-best-practices/#server)\n  - [使用 CDN](https://csspod.com/frontend-performance-best-practices/#server-cdn)\n  - [添加 Expires 或 Cache-Control 响应头](https://csspod.com/frontend-performance-best-practices/#server-cache)\n  - [启用 Gzip](https://csspod.com/frontend-performance-best-practices/#server-gzip)\n  - [配置 Etag](https://csspod.com/frontend-performance-best-practices/#server-etag)\n  - [尽早输出缓冲](https://csspod.com/frontend-performance-best-practices/#server-flush)\n  - [Ajax 请求使用 GET 方法](https://csspod.com/frontend-performance-best-practices/#server-ajax-get)\n  - [避免图片 src 为空](https://csspod.com/frontend-performance-best-practices/#server-src)\n- [Cookie](https://csspod.com/frontend-performance-best-practices/#cookie)\n  - [减少 Cookie 大小](https://csspod.com/frontend-performance-best-practices/#cookie-size)\n  - [静态资源使用无 Cookie 域名](https://csspod.com/frontend-performance-best-practices/#cookie-free)\n- [CSS](https://csspod.com/frontend-performance-best-practices/#css)\n  - [把样式表放在    中](https://csspod.com/frontend-performance-best-practices/#css-head)\n  - [不要使用 CSS 表达式](https://csspod.com/frontend-performance-best-practices/#css-expression)\n  - [使用    替代  `@import`](https://csspod.com/frontend-performance-best-practices/#css-link)\n  - [不要使用 filter](https://csspod.com/frontend-performance-best-practices/#css-filter)\n- [JavaScript](https://csspod.com/frontend-performance-best-practices/#javascript)\n  - [把脚本放在页面底部](https://csspod.com/frontend-performance-best-practices/#javascript-bottom)\n  - [使用外部 JavaScript 和 CSS](https://csspod.com/frontend-performance-best-practices/#javascript-extenal)\n  - [压缩 JavaScript 和 CSS](https://csspod.com/frontend-performance-best-practices/#javascript-minify)\n  - [移除重复脚本](https://csspod.com/frontend-performance-best-practices/#javascript-duplicate)\n  - [减少 DOM 操作](https://csspod.com/frontend-performance-best-practices/#javascript-dom)\n  - [使用高效的事件处理](https://csspod.com/frontend-performance-best-practices/#javascript-event)\n- [图片](https://csspod.com/frontend-performance-best-practices/#image)\n  - [优化图片](https://csspod.com/frontend-performance-best-practices/#image-optimize)\n  - [优化 CSS Sprite](https://csspod.com/frontend-performance-best-practices/#image-sprite)\n  - [不要在 HTML 中缩放图片](https://csspod.com/frontend-performance-best-practices/#image-scale)\n  - [使用体积小、可缓存的 favicon.ico](https://csspod.com/frontend-performance-best-practices/#image-favicon)\n- [移动端](https://csspod.com/frontend-performance-best-practices/#mobile)\n  - [保持单个文件小于 25 KB](https://csspod.com/frontend-performance-best-practices/#mobile-25kb)\n  - [打包内容为分段（multipart）文档](https://csspod.com/frontend-performance-best-practices/#mobile-multipart)\n\n前端性能的一个重要指标是页面加载时间，不仅事关用户体验，也是搜索引擎排名考虑的一个因素。\n\n> - 来自 Google 的数据表明，一个有 10 条数据 0.4 秒能加载完的页面，变成 30 条数据 0.9 秒加载完之后，流量和广告收入下降 90%。\n> - Google Map 首页文件大小从 100KB 减小到 70-80KB 后，流量在第一周涨了 10%，接下来的三周涨了 25%。\n> - 亚马逊的数据表明：加载时间增加 100 毫秒，销量就下降 1%。\n\n以上数据更说明「加载时间就是金钱」，前端优化主要围绕提高加载速度进行。\n\n## 页面内容\n\n### 减少 HTTP 请求数\n\nWeb 前端 80% 的响应时间花在图片、样式、脚本等资源下载上。浏览器对每个域名的连接数是有限制的，减少请求次数是缩短响应时间的关键。\n\n通过简洁的设计减少页面所需资源，进而减少 HTTP 请求，这是最直接的方式，前提是你的 Boss、设计师同事不打死你。所以，还是另辟蹊径吧：\n\n- 合并 JavaScript、CSS 等文件；\n\n  - 服务器端（CDN）自动合并\n  - 基于 Node.js 的文件合并工具一抓一大把\n\n- 使用[CSS Sprite](http://alistapart.com/articles/sprites)：将背景图片合并成一个文件，通过`background-image`  和  `background-position`  控制显示；\n\n  - [Sprite Cow](http://www.spritecow.com/)\n  - [Spritebox](http://www.spritebox.net/)\n\n  > 逐步被 Icon Font 和 SVG Sprite 取代。\n\n- [Image Map](http://www.w3.org/TR/html401/struct/objects.html#h-13.6)：合并图片，然后使用坐标映射不同的区域（[演示](<https://en.wikipedia.org/wiki/The_Club_(dining_club)>)）。\n\n  > 缺点：仅适用于相连的图片；设置坐标过程乏味且易出错；可访性问题。不推荐使用这种过时的技术。\n\n- Inline Assets：使用  [Data URI scheme](https://en.wikipedia.org/wiki/Data_URI_scheme)  将图片嵌入 HTML 或者 CSS 中；或者将 CSS、JS、图片直接嵌入 HTML 中。\n\n  > 会增加文件大小，也可能产生浏览器兼容及其他性能问题（有待整理补充）。\n\n  未来的趋势是使用内嵌 SVG。\n\n- [内容分片](https://csspod.com/frontend-performance-best-practices/#content-domains)，将请求划分到不同的域名上。\n\n> HTTP/2 通过多路复用大幅降低了多个请求的开销。通过数据分帧层，客户端和服务器之间只需要建立一个 TCP 连接，即可同时收发多个文件，而且，该连接在相当长的时间周期内保持打开（持久化），以便复用。\n>\n> HTTP/2 的新特性意味着上述优化实践不再适用，但考虑到客户端对 HTTP/2 的支持覆盖程度，还需根据实际数据权衡。\n\n### 减少 DNS 查询\n\n用户输入 URL 以后，浏览器首先要查询域名（hostname）对应服务器的 IP 地址，一般需要耗费  20-120 毫秒   时间。DNS 查询完成之前，浏览器无法从服务器下载任何数据。\n\n基于性能考虑，ISP、局域网、操作系统、浏览器都会有相应的 DNS 缓存机制。\n\n- IE 缓存 30 分钟，可以通过注册表中  `DnsCacheTimeout`  项设置；\n- Firefox 混存 1 分钟，通过  `network.dnsCacheExpiration`  配置；\n- （TODO：补充其他浏览器缓存信息）\n\n首次访问、没有相应的 DNS 缓存时，域名越多，查询时间越长。所以应尽量减少域名数量。但基于并行下载考虑，把资源分布到 2 个域名上（最多不超过 4 个）。这是减少 DNS 查询同时保证并行下载的折衷方案。\n\n### 避免重定向\n\nHTTP 重定向通过  `301`/`302`  状态码实现。\n\n    HTTP/1.1 301 Moved Permanently\n    Location: http://example.com/newuri\n    Content-Type: text/html\n\n客户端收到服务器的重定向响应后，会根据响应头中  `Location`  的地址再次发送请求。重定向会影响用户体验，尤其是多次重定向时，用户在一段时间内看不到任何内容，只看到浏览器进度条一直在刷新。\n\n有时重定向无法避免，在糟糕也比抛出 404 好。虽然通过  [HTML meta refresh](https://en.wikipedia.org/wiki/Meta_refresh)  和 JavaScript 也能实现，但首选 HTTP `3xx`  跳转，以保证浏览器「后退」功能正常工作（也利于 SEO）。\n\n- 最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加  `/`  但未添加。比如，访问  `http://astrology.yahoo.com/astrology`  将被 301 重定向到  `http://astrology.yahoo.com/astrology/`（注意末尾的  `/`）。如果使用 Apache，可以通过  `Alias`  或  `mod_rewrite`  或  `DirectorySlash`  解决这个问题。\n- 网站域名变更：CNAME 结合  `Alias`  或  `mod_rewrite`  或者其他服务器类似功能实现跳转。\n\n### 缓存 Ajax 请求\n\nAjax 可以提高用户体验。但「异步」不意味着「及时」，优化 Ajax 响应速度提高性能仍是需要关注的主题。\n\n最重要的的优化方式是缓存响应结果，详见  [添加 Expires 或 Cache-Control 响应头](https://csspod.com/frontend-performance-best-practices/#server-cache)。\n\n以下规则也关乎 Ajax 响应速度：\n\n- [启用 Gzip](https://csspod.com/frontend-performance-best-practices/#server-gzip)\n- [减少 DNS 查询](https://csspod.com/frontend-performance-best-practices/#content-dns)\n- [压缩 JavaScript 和 CSS](https://csspod.com/frontend-performance-best-practices/#javascript-minify)\n- [避免重定向](https://csspod.com/frontend-performance-best-practices/#content-redirect)\n- [配置 Etag](https://csspod.com/frontend-performance-best-practices/#server-etag)\n\n### 延迟加载\n\n页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如：\n\n- 非首屏使用的数据、样式、脚本、图片等；\n- 用户交互时才会显示的内容。\n\n遵循「渐进增强」理念开发的网站：JavaScript 用于增强用用户体验，但没有（不支持） JavaScript 也能正常工作，完全可以延迟加载 JavaScript。\n\n> 延迟渲染\n>\n> 将首屏以外的 HTML 放在不渲染的元素中，如隐藏的  `</code>，或者 <code>type</code> 属性为非执行脚本的 <code><script></code>标签中，减少初始渲染的 DOM 元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。</p> </blockquote> <p><a name=\"content-preload\"></a></p> <h3 id=\"\">预先加载</h3> <p>预先加载利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应。</p> <ul> <li> <p>无条件预先加载：页面加载完成（<code>load</code>）后，马上获取其他资源。以 <a href=\"http://google.com/\">google.com</a> 为例，首页加载完成后会立即下载一个 Sprite 图片，此图首页不需要，但是搜索结果页要用到。</p> </li> <li> <p>有条件预先加载：根据用户行为预判用户去向，预载相关资源。比如 <a href=\"http://search.yahoo.com/\">search.yahoo.com</a> 开始输入时会有额外的资源加载。</p> <blockquote> <p>Chrome 等浏览器的地址栏也有类似的机制。</p> </blockquote> </li> <li> <p>有「阴谋」的预先加载：页面即将上线新版前预先加载新版内容。网站改版后由于缓存、使用习惯等原因，会有旧版的网站更快更流畅的反馈。为缓解这一问题，在新版上线之前，旧版可以利用空闲提前加载一些新版的资源缓存到客户端，以便新版正式上线后更快的载入（好一个「心机猿」:scream:）。</p> <blockquote> <p>「双十一」、「黑五」这类促销日来临之前，也可以预先下载一些相关资源到客户端（浏览器、App 等），有效利用浏览器缓存和本地存储，降低活动当日请求压力，提高用户体验。</p> </blockquote> </li> </ul> <blockquote> <p>TODO: Prefetch 相关细节</p> </blockquote> <ul> <li><a href=\"https://www.w3.org/TR/resource-hints/\">Resource Hints Spec</a></li> </ul> <p><a name=\"content-dom\"></a></p> <h3 id=\"dom\">减少 DOM 元素数量</h3> <p>复杂的页面不仅下载的字节更多，JavaScript DOM 操作也更慢。例如，同是添加一个事件处理器，500 个元素和 5000 个元素的页面速度上会有很大区别。</p> <p>从以下几个角度考虑移除不必要的标记：</p> <ul> <li>是否还在使用表格布局？</li> <li>塞进去更多的 <code><div></code> 仅为了处理布局问题？也许有更好、更语义化的标记。</li> <li>能通过伪元素实现的功能，就没必要添加额外元素，如清除浮动。</li> </ul> <p>浏览器控制台中输入以下代码可以计算出页面中有多少 DOM 元素：</p> <pre><code class=\"language-javascript\">document.getElementsByTagName('*').length; </code></pre> <p>对比标记良好的的网站，看看差距是多少。</p> <blockquote> <p>为什么不使用表格布局？</p> <ul> <li>更多的标签，增加文件大小；</li> <li>不易维护，无法适应响应式设计；</li> <li>性能考量，默认的表格布局算法会产生大量重绘（参见<a href=\"https://csspod.com/table-width-algorithms/\">表格布局算法</a>）。</li> </ul> </blockquote> <p><a name=\"content-domains\"></a></p> <h3 id=\"\">划分内容到不同域名</h3> <p>浏览器一般会限制每个域的并行线程（一般为 6 个，甚至更少），使用不同的域名可以最大化下载线程，但注意保持在 2-4 个域名内，以避免 DNS 查询损耗。</p> <p>例如，动态内容放在 <code>csspod.com</code> 上，静态资源放在 <code>static.csspod.com</code>上。这样还可以禁用静态资源域下的 Cookie，减少数据传输，详见 <a href=\"https://csspod.com/frontend-performance-best-practices/#cookie-free\">Cookie 优化</a>。</p> <p>更多信息参考 <a href=\"http://yuiblog.com/blog/2007/04/11/performance-research-part-4/\">Maximizing Parallel Downloads in the Carpool Lane</a></p> <p><a name=\"content-iframe\"></a></p> <h3 id=\"iframe\">尽量减少 iframe 使用</h3> <p>使用 iframe 可以在页面中嵌入 HTML 文档，但有利有弊。</p> <p><code><iframe></code> 优点：</p> <ul> <li>可以用来加载速度较慢的第三方资源，如广告、徽章；</li> <li>可用作<a href=\"http://www.html5rocks.com/en/tutorials/security/sandboxed-iframes/\">安全沙箱</a>；</li> <li>可以并行下载脚本。</li> </ul> <p><code><iframe> 缺点</code>：</p> <ul> <li> <p>加载代价昂贵，即使是空的页面；</p> </li> <li> <p>阻塞页面 <code>load</code> 事件触发；</p> <blockquote> <p>Iframe 完全加载以后，父页面才会触发 <code>load</code> 事件。 Safari、Chrome 中通过 JavaScript 动态设置 iframe <code>src</code> 可以避免这个问题。</p> </blockquote> </li> <li> <p>缺乏语义。</p> </li> </ul> <p><a name=\"content-404\"></a></p> <h3 id=\"404\">避免 404 错误</h3> <p>HTTP 请求很昂贵，返回无效的响应（如 404 未找到）完全没必要，降低用户体验而且毫无益处。</p> <p>一些网站设计很酷炫、有提示信息的 404 页面，有助于提高用户体验，但还是浪费服务器资源。尤其糟糕的是外部脚本返回 404，不仅阻塞其他资源下载，浏览器还会尝试把 404 页面内容当作 JavaScript 解析，消耗更多资源。</p> <h3 id=\"\">补充规则：</h3> <ul> <li>定义字符集，并放在 <code><head></code> 顶部。大多数浏览器会暂停页面渲染，直到找到字符集定义。</li> </ul> <p><a name=\"server\"></a></p> <h2 id=\"\">服务器</h2> <p>服务器相关优化设置可参考 H5BP 相关项目：</p> <ul> <li><a href=\"https://github.com/h5bp/server-configs-nginx\">Nginx HTTP server boilerplate configs</a></li> <li><a href=\"https://github.com/h5bp/server-configs-apache\">Apache HTTP server boilerplate configs</a></li> <li><a href=\"https://github.com/h5bp/server-configs-iis\">IIS Web.Config Boilerplates</a></li> </ul> <p><a name=\"server-cdn\"></a></p> <h3 id=\"cdn\">使用 CDN</h3> <p>网站 80-90% 响应时间消耗在资源下载上，减少资源下载时间是性能优化的黄金发则。</p> <p>相比分布式架构的复杂和巨大投入，静态内容分发网络（CDN）可以以较低的投入，获得加载速度有效提升。</p> <p><a name=\"server-cache\"></a></p> <h3 id=\"expirescachecontrol\">添加 Expires 或 Cache-Control 响应头</h3> <ul> <li>静态内容：将 <code>Expires</code> 响应头设置为将来很远的时间，实现「永不过期」策略；</li> <li>动态内容：设置合适的 <code>Cache-Control</code> 响应头，让浏览器有条件地发起请求。</li> </ul> <blockquote> <p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control\">Cache-Control</a> 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires、Pragma）。当前的所有浏览器都支持 Cache-Control，因此，使用它就够了。</p> </blockquote> <blockquote> <p>鉴于静态内容和动态内容不同的缓存策略，实践中一般会把二者部署在不同的服务器（域名）以方便管理。</p> </blockquote> <p>参考链接：</p> <ul> <li><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn\">HTTP 缓存 | Web Fundamentals - Google Developers</a></li> <li><a href=\"https://github.com/h5bp/server-configs\">H5BP - Server Configs</a></li> </ul> <p><a name=\"server-gzip\"></a></p> <h3 id=\"gzip\">启用 Gzip</h3> <p>Gzip 压缩通常可以减少 70% 的响应大小，对某些文件更可能高达 90%，比 Deflate 更高效。主流 Web 服务器都有相应模块，而且绝大多数浏览器支持 gzip 解码。所以，应该对 HTML、CSS、JS、XML、JSON 等文本类型的内容启用压缩。</p> <p>注意，图片和 PDF 文件不要使用 gzip。它们本身已经压缩过，再使用 gzip 压缩不仅浪费 CPU 资源，而且还可能增加文件体积。</p> <p>对于不支持的 Gzip 的用户代理，通过设置 Vary 响应头，返回<s>为</s>未压缩的数据：</p> <pre><code>Vary: * </code></pre> <p><a name=\"server-etag\"></a></p> <h3 id=\"etag\">配置 Etag</h3> <p>Etag 通过文件版本标识，方便服务器判断请求的内容是否有更新，如果没有就响应 <code>304</code>，避免重新下载。</p> <p>当然，启用 Etag 可能会导致其他问题，还需要根据具体情况做判断。（TODO：补充相关内容）</p> <p><a name=\"server-flush\"></a></p> <h3 id=\"flush\">尽早输出（flush）缓冲</h3> <p>用户请求页面时，服务器通常需要花费 200 ~ 500 毫秒来组合 HTML 页面。在此期间，浏览器处于空闲、等待数据状态。使用PHP 中的 <a href=\"http://php.net/flush\">flush()</a> 函数，可以发送部分已经准备好的 HTML 到浏览器，以便服务器还在忙于处理剩余页面时，浏览器可以提前开始获取资源。</p> <p>可以考虑在 <code></head></code> 之后输出一次缓冲，HTML head 一般比较容易生成，先发送以便浏览器开始获取 <code><head></code> 里引用的 CSS 等资源。</p> <p>Example:</p> <pre><code class=\"language-html\"><!-- css, js --> </head> <?php flush(); ?> <body> <!-- content --> </code></pre> <p><a name=\"server-ajax-get\"></a></p> <h3 id=\"ajaxget\">Ajax 请求使用 GET 方法</h3> <p>浏览器执行 XMLHttpRequest POST 请求时分成两步，先发送 Header，再发送数据。而 GET 只使用一个 TCP 数据包发送数据，所以首选 GET 方法。</p> <p>根据 <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html\">HTTP 规范</a>，GET 用于获取数据，POST 则用于向服务器发送数据，所以 Ajax 请求数据时使用 GET 更符合规范（<a href=\"http://www.w3schools.com/tags/ref_httpmethods.asp\">GET 和 POST 对比</a>）。</p> <p>IE 中最大 URL 长度为 2K，如果超出 2K，则需要考虑使用 POST 方法。</p> <p><a name=\"server-src\"></a></p> <h3 id=\"src\">避免图片 src 为空</h3> <p>图片 <code>src</code> 属性值为空字符串可能以下面两种形式出现：</p> <p>HTML:</p> <pre><code class=\"language-html\"><img src=\"\" /> </code></pre> <p>JavaScript：</p> <pre><code class=\"language-javascript\">var img = new Image(); img.src = \"\"; </code></pre> <p>虽然 <code>src</code> 属性为空字符串，但浏览器仍然会向服务器发起一个 HTTP 请求：</p> <ul> <li>IE 向页面所在的目录发送请求；</li> <li>Safari、Chrome、Firefox 向页面本身发送请求；</li> <li>Opera 不执行任何操作。</li> </ul> <blockquote> <p>以上数据较老，当下主流版本可能会有改变。</p> </blockquote> <p>空 <code>src</code> 产生请求的后果不容小觑：</p> <ul> <li>给服务器造成意外的流量负担，尤其时日 PV 较大时；</li> <li>浪费服务器计算资源；</li> <li>可能产生报错。</li> </ul> <p>当然，浏览器如此实现也是根据 <a href=\"https://www.ietf.org/rfc/rfc3986.txt\">RFC 3986 - Uniform Resource Identifiers</a>，当空字符串作为 URI 出现时，被当成相对 URI，具体算法参见规范 5.2 节。</p> <p>参考链接：</p> <ul> <li><a href=\"https://www.nczonline.net/blog/2009/11/30/empty-image-src-can-destroy-your-site/\">Empty image src can destroy your site</a></li> </ul> <blockquote> <p>空的 <code>href</code> 属性也存在类似问题。用户点击空链接时，浏览器也会向服务器发送 HTTP 请求，可以通过 JavaScript 阻止空链接的默认的行为。</p> </blockquote> <p><a name=\"cookie\"></a></p> <h2 id=\"cookie\">Cookie</h2> <p><a name=\"cookie-size\"></a></p> <h3 id=\"cookie\">减少 Cookie 大小</h3> <p>Cookie 被用于身份认证、个性化设置等诸多用途。Cookie 通过 HTTP 头在服务器和浏览器间来回传送，减少 Cookie 大小可以降低其对响应速度的影响。</p> <ul> <li>去除不必要的 Cookie；</li> <li>尽量压缩 Cookie 大小；</li> <li>注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；</li> <li>设置合适的过期时间。</li> </ul> <p>更多细节参考 <a href=\"http://yuiblog.com/blog/2007/03/01/performance-research-part-3/\">When the Cookie Crumbles</a>。</p> <blockquote> <p>HTTP/2 首部压缩在客户端和服务器端使用「首部表」来跟踪和存储之前发送的键值对，对于相同的数据，不再随每次请求和响应发送。</p> </blockquote> <p><a name=\"cookie-free\"></a></p> <h3 id=\"cookie\">静态资源使用无 Cookie 域名</h3> <p>静态资源一般无需使用 Cookie，可以把它们放在使用二级域名或者专门域名的无 Cookie 服务器上，降低 Cookie 传送的造成的流量浪费，提高响应速度。</p> <p><a name=\"css\"></a></p> <h2 id=\"css\">CSS</h2> <p><a name=\"css-head\"></a></p> <h3 id=\"head\">把样式表放在 <code><head></code> 中</h3> <p>把样式表放在 <code><head></code> 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉。</p> <p>这对内容比较多的页面尤为重要，用户可以先查看已经下载渲染的内容，而不是盯着白屏等待。</p> <p>如果把样式表放在页面底部，一些浏览器为减少重绘，会在 CSS 加载完成以后才渲染页面，用户只能对着白屏干瞪眼，用户体验极差。</p> <p><a name=\"css-expression\"></a></p> <h3 id=\"css\">不要使用 CSS 表达式</h3> <p>CSS 表达式可以在 CSS 里执行 JavaScript，仅 IE5-IE7 支持，IE8 标准模式已经废弃。</p> <p>CSS 表达式超出预期的频繁执行，页面滚动、鼠标移动时都会不断执行，带来很大的性能损耗。</p> <blockquote> <p>IE7 及更低版本的浏览器已经逐渐成为历史，忘记它吧。</p> </blockquote> <p><a name=\"css-link\"></a></p> <h3 id=\"linkimport\">使用 <code><link></code> 替代 <code>@import</code></h3> <p>对于 IE 某些版本，<code>@import</code> 的行为和 <code><link></code> 放在页面底部一样。所以，不要用它。</p> <p><a name=\"css-filter\"></a></p> <h3 id=\"filter\">不要使用 filter</h3> <p><code>AlphaImageLoader</code> 为 IE5.5-IE8 专有的技术，和 CSS 表达式一样，放进博物馆吧。</p> <blockquote> <p>注意：</p> <p>这里所说的不是 <a href=\"https://www.w3.org/TR/filter-effects-1/\">CSS3 Filter</a>，参考文章 <a href=\"http://www.html5rocks.com/en/tutorials/filters/understanding-css/\">Understanding CSS Filter Effects</a></p> </blockquote> <p><a name=\"javascript\"></a></p> <h2 id=\"javascript\">JavaScript</h2> <p><a name=\"javascript-bottom\"></a></p> <h3 id=\"\">把脚本放在页面底部</h3> <p>浏览器下载脚本时，会阻塞其他资源并行下载，即使是来自不同域名的资源。因此，最好将脚本放在底部，以提高页面加载速度。</p> <p>一些特殊场景无法将脚本放到页面底部的，可以考虑 <code><script></code> 的以下属性：</p> <ul> <li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement#defer_property\"><code>defer</code> 属性</a>；</li> <li>HTML5 新增的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement#async_property\"><code>async</code> 属性</a>。</li> </ul> <p><a name=\"javascript-extenal\"></a></p> <h3 id=\"javascriptcss\">使用外部 JavaScript 和 CSS</h3> <p>外部 JavaScript 和 CSS 文件可以被浏览器缓存，在不同页面间重用，也能降低页面大小。</p> <p>当然，实际中也需要考虑代码的重用程度。如果仅仅是某个页面使用到的代码，可以考虑内嵌在页面中，减少 HTTP 请求数。另外，可以在首页加载完成以后，预先加载子页面的资源。</p> <p><a name=\"javascript-minify\"></a></p> <h3 id=\"javascriptcss\">压缩 JavaScript 和 CSS</h3> <p>压缩代码可以移除非功能性的字符（注释、空格、空行等），减少文件大小，提高载入速度。</p> <blockquote> <p>得益于 Node.js 的流行，开源社区涌现出许多高效、易用的前端优化工具，JavaScript 和 CSS 压缩类的，不敢说多如牛毛，多入鸡毛倒是一点不夸张，如 [UglifyJS 2] (<a href=\"https://github.com/mishoo/UglifyJS2\">https://github.com/mishoo/UglifyJS2</a>)、<a href=\"https://www.npmjs.com/package/csso\">csso</a>、<a href=\"https://www.npmjs.com/package/cssnano\">cssnano</a> 等。</p> <p>对于内嵌的 CSS 和 JavaScript，也可以通过 <a href=\"https://www.npmjs.com/package/htmlmin\">htmlmin</a> 等工具压缩。</p> <p>这些项目都有 Gulp、Webpack 等流行构建工具的配套版本。</p> </blockquote> <p><a name=\"javascript-duplicate\"></a></p> <h3 id=\"\">移除重复脚本</h3> <p>重复的脚本不仅产生不必要的 HTTP 请求，而且重复解析执行浪费时间和计算资源。</p> <p><a name=\"javascript-dom\"></a></p> <h3 id=\"dom\">减少 DOM 操作</h3> <p>JavaScript 操作 DOM 很慢，尤其是 DOM 节点很多时。</p> <p>使用时应该注意：</p> <ul> <li>缓存已经访问过的元素；</li> <li>使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/createDocumentFragment\">DocumentFragment</a> 暂存 DOM，整理好以后再插入 DOM 树；</li> <li>操作 className，而不是多次读写 <code>style</code>；</li> <li>避免使用 JavaScript 修复布局。</li> </ul> <p><a name=\"javascript-event\"></a></p> <h3 id=\"\">使用高效的事件处理</h3> <ul> <li>减少绑定事件监听的节点，如通过事件委托；</li> <li>尽早处理事件，在 <code>DOMContentLoaded</code> 即可进行，不用等到 <code>load</code>以后。</li> </ul> <blockquote> <p>对于 <code>resize</code>、<code>scroll</code> 等触发频率极高的事件，应该通过 debounce 等机制降低处理程序执行频率。</p> <p>TODO: 补充相关内容 <a href=\"http://demo.nimius.net/debounce_throttle/\">http://demo.nimius.net/debounce_throttle/</a></p> </blockquote> <p><a name=\"image\"></a></p> <h2 id=\"\">图片</h2> <p><a name=\"image-optimize\"></a></p> <h3 id=\"\">优化图片</h3> <blockquote> <p>YDN <a href=\"https://developer.yahoo.com/performance/rules.html#opt_images\">列出的相关工具</a> 缺乏易用性，建议参考以下工具。</p> </blockquote> <ul> <li><a href=\"https://github.com/imagemin/imagemin\">imagemin</a></li> <li><a href=\"https://imageoptim.com/mac\">ImageOptim</a></li> </ul> <blockquote> <p>TODO:</p> <ul> <li>PNG 终极优化；</li> <li>Webp 相关内容；</li> <li>SVG 相关内容。</li> </ul> </blockquote> <p>PNG 终极优化：</p> <ul> <li><a href=\"http://www.queness.com/post/2507/most-effective-method-to-reduce-and-optimize-png-images\">Most Effective Method to Reduce and Optimize PNG Images</a></li> <li><a href=\"https://www.smashingmagazine.com/2009/07/clever-png-optimization-techniques/\">Clever PNG Optimization Techniques</a></li> </ul> <p><a name=\"image-sprite\"></a></p> <h3 id=\"csssprite\">优化 CSS Sprite</h3> <ul> <li>水平排列 Sprite 中的图片，垂直排列会增加图片大小；</li> <li>Spirite 中把颜色较近的组合在一起可以降低颜色数，理想状况是低于 256 色以适用 PNG8 格式；</li> <li>不要在 Spirite 的图像中间留有较大空隙。减少空隙虽然不太影响文件大小，但可以降低用户代理把图片解压为像素图的内存消耗，对移动设备更友好。</li> </ul> <p><a name=\"image-scale\"></a></p> <h3 id=\"html\">不要在 HTML 中缩放图片</h3> <p>不要使用 <code><img></code> 的 <code>width</code>、<code>height</code> 缩放图片，如果用到小图片，就使用相应大小的图片。</p> <blockquote> <p>很多 CMS 和 CDN 都提供图片裁切功能。</p> </blockquote> <p><a name=\"image-favicon\"></a></p> <h3 id=\"faviconico\">使用体积小、可缓存的 favicon.ico</h3> <p>Favicon.ico 一般存放在网站根目录下，无论是否在页面中设置，浏览器都会尝试请求这个文件。</p> <p>所以确保这个图标：</p> <ul> <li>存在（避免 404）；</li> <li>尽量小，最好小于 1K；</li> <li>设置较长的过期时间。</li> </ul> <blockquote> <p>对于较新的浏览器，可以使用 PNG 格式的 favicon。</p> </blockquote> <p>参考链接：</p> <ul> <li><a href=\"https://css-tricks.com/favicon-quiz/\">Favicons, Touch Icons, Tile Icons, etc. Which Do You Need?</a></li> </ul> <h3 id=\"\">图片相关补充</h3> <blockquote> <p>设置图片的宽和高，以免浏览器按照「猜」的宽高给图片保留的区域和实际宽高差异，产生重绘。</p> </blockquote> <p><a name=\"mobile\"></a></p> <h2 id=\"\">移动端</h2> <blockquote> <p>移动端优化相关内容有待进一步整理补充。</p> </blockquote> <p><a name=\"mobile-25k\"></a></p> <h3 id=\"25kb\"><a href=\"https://developer.yahoo.com/performance/rules.html#under25\">保持单个文件小于 25 KB</a></h3> <p><a name=\"mobile-multipart\"></a></p> <h3 id=\"multipart\"><a href=\"https://developer.yahoo.com/performance/rules.html#multipart\">打包内容为分段（multipart）文档</a></h3> <h2 id=\"\">参考链接</h2> <ul> <li><a href=\"http://www.websiteoptimization.com/speed/tweak/psychology-web-performance/\">The Psychology of Web Performance</a></li> </ul></x-turndown>`\n","slug":"2017-08-27-前端性能优化最佳实践","published":1,"updated":"2020-03-14T06:46:47.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvnz006o4k8yge7s2gsi","content":"<p>本文主要考量客户端性能、服务器端和网络性能，内容框架来自  <a href=\"https://developer.yahoo.com/performance/rules.html\" target=\"_blank\" rel=\"noopener\">Yahoo Developer Network</a>，包含 7 个类别共 35 条前端性能优化最佳实践，在此基础上补充了一些相关或者更符合主流技术的内容。</p>\n<p>同时，建议关注及时更新的  <a href=\"https://developers.google.com/web/fundamentals/performance/?hl=en\" target=\"_blank\" rel=\"noopener\">Google 性能优化指南</a>。</p>\n<p>目录：</p>\n<ul>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content\" target=\"_blank\" rel=\"noopener\">页面内容</a><ul>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-http\" target=\"_blank\" rel=\"noopener\">减少 HTTP 请求数</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-dns\" target=\"_blank\" rel=\"noopener\">减少 DNS 查询</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-redirect\" target=\"_blank\" rel=\"noopener\">避免重定向</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-ajax-cache\" target=\"_blank\" rel=\"noopener\">缓存 Ajax 请求</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-postload\" target=\"_blank\" rel=\"noopener\">延迟加载</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-preload\" target=\"_blank\" rel=\"noopener\">预先加载</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-dom\" target=\"_blank\" rel=\"noopener\">减少 DOM 元素数量</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-domains\" target=\"_blank\" rel=\"noopener\">划分内容到不同域名</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-iframe\" target=\"_blank\" rel=\"noopener\">尽量减少 iframe 使用</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-404\" target=\"_blank\" rel=\"noopener\">避免 404 错误</a></li>\n</ul>\n</li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server\" target=\"_blank\" rel=\"noopener\">服务器</a><ul>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server-cdn\" target=\"_blank\" rel=\"noopener\">使用 CDN</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server-cache\" target=\"_blank\" rel=\"noopener\">添加 Expires 或 Cache-Control 响应头</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server-gzip\" target=\"_blank\" rel=\"noopener\">启用 Gzip</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server-etag\" target=\"_blank\" rel=\"noopener\">配置 Etag</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server-flush\" target=\"_blank\" rel=\"noopener\">尽早输出缓冲</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server-ajax-get\" target=\"_blank\" rel=\"noopener\">Ajax 请求使用 GET 方法</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server-src\" target=\"_blank\" rel=\"noopener\">避免图片 src 为空</a></li>\n</ul>\n</li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#cookie\" target=\"_blank\" rel=\"noopener\">Cookie</a><ul>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#cookie-size\" target=\"_blank\" rel=\"noopener\">减少 Cookie 大小</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#cookie-free\" target=\"_blank\" rel=\"noopener\">静态资源使用无 Cookie 域名</a></li>\n</ul>\n</li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#css\" target=\"_blank\" rel=\"noopener\">CSS</a><ul>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#css-head\" target=\"_blank\" rel=\"noopener\">把样式表放在    中</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#css-expression\" target=\"_blank\" rel=\"noopener\">不要使用 CSS 表达式</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#css-link\" target=\"_blank\" rel=\"noopener\">使用    替代  <code>@import</code></a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#css-filter\" target=\"_blank\" rel=\"noopener\">不要使用 filter</a></li>\n</ul>\n</li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#javascript\" target=\"_blank\" rel=\"noopener\">JavaScript</a><ul>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#javascript-bottom\" target=\"_blank\" rel=\"noopener\">把脚本放在页面底部</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#javascript-extenal\" target=\"_blank\" rel=\"noopener\">使用外部 JavaScript 和 CSS</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#javascript-minify\" target=\"_blank\" rel=\"noopener\">压缩 JavaScript 和 CSS</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#javascript-duplicate\" target=\"_blank\" rel=\"noopener\">移除重复脚本</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#javascript-dom\" target=\"_blank\" rel=\"noopener\">减少 DOM 操作</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#javascript-event\" target=\"_blank\" rel=\"noopener\">使用高效的事件处理</a></li>\n</ul>\n</li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#image\" target=\"_blank\" rel=\"noopener\">图片</a><ul>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#image-optimize\" target=\"_blank\" rel=\"noopener\">优化图片</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#image-sprite\" target=\"_blank\" rel=\"noopener\">优化 CSS Sprite</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#image-scale\" target=\"_blank\" rel=\"noopener\">不要在 HTML 中缩放图片</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#image-favicon\" target=\"_blank\" rel=\"noopener\">使用体积小、可缓存的 favicon.ico</a></li>\n</ul>\n</li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#mobile\" target=\"_blank\" rel=\"noopener\">移动端</a><ul>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#mobile-25kb\" target=\"_blank\" rel=\"noopener\">保持单个文件小于 25 KB</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#mobile-multipart\" target=\"_blank\" rel=\"noopener\">打包内容为分段（multipart）文档</a></li>\n</ul>\n</li>\n</ul>\n<p>前端性能的一个重要指标是页面加载时间，不仅事关用户体验，也是搜索引擎排名考虑的一个因素。</p>\n<blockquote>\n<ul>\n<li>来自 Google 的数据表明，一个有 10 条数据 0.4 秒能加载完的页面，变成 30 条数据 0.9 秒加载完之后，流量和广告收入下降 90%。</li>\n<li>Google Map 首页文件大小从 100KB 减小到 70-80KB 后，流量在第一周涨了 10%，接下来的三周涨了 25%。</li>\n<li>亚马逊的数据表明：加载时间增加 100 毫秒，销量就下降 1%。</li>\n</ul>\n</blockquote>\n<p>以上数据更说明「加载时间就是金钱」，前端优化主要围绕提高加载速度进行。</p>\n<h2 id=\"页面内容\"><a href=\"#页面内容\" class=\"headerlink\" title=\"页面内容\"></a>页面内容</h2><h3 id=\"减少-HTTP-请求数\"><a href=\"#减少-HTTP-请求数\" class=\"headerlink\" title=\"减少 HTTP 请求数\"></a>减少 HTTP 请求数</h3><p>Web 前端 80% 的响应时间花在图片、样式、脚本等资源下载上。浏览器对每个域名的连接数是有限制的，减少请求次数是缩短响应时间的关键。</p>\n<p>通过简洁的设计减少页面所需资源，进而减少 HTTP 请求，这是最直接的方式，前提是你的 Boss、设计师同事不打死你。所以，还是另辟蹊径吧：</p>\n<ul>\n<li><p>合并 JavaScript、CSS 等文件；</p>\n<ul>\n<li>服务器端（CDN）自动合并</li>\n<li>基于 Node.js 的文件合并工具一抓一大把</li>\n</ul>\n</li>\n<li><p>使用<a href=\"http://alistapart.com/articles/sprites\" target=\"_blank\" rel=\"noopener\">CSS Sprite</a>：将背景图片合并成一个文件，通过<code>background-image</code>  和  <code>background-position</code>  控制显示；</p>\n<ul>\n<li><a href=\"http://www.spritecow.com/\" target=\"_blank\" rel=\"noopener\">Sprite Cow</a></li>\n<li><a href=\"http://www.spritebox.net/\" target=\"_blank\" rel=\"noopener\">Spritebox</a></li>\n</ul>\n<blockquote>\n<p>逐步被 Icon Font 和 SVG Sprite 取代。</p>\n</blockquote>\n</li>\n<li><p><a href=\"http://www.w3.org/TR/html401/struct/objects.html#h-13.6\" target=\"_blank\" rel=\"noopener\">Image Map</a>：合并图片，然后使用坐标映射不同的区域（<a href=\"https://en.wikipedia.org/wiki/The_Club_(dining_club)\" target=\"_blank\" rel=\"noopener\">演示</a>）。</p>\n<blockquote>\n<p>缺点：仅适用于相连的图片；设置坐标过程乏味且易出错；可访性问题。不推荐使用这种过时的技术。</p>\n</blockquote>\n</li>\n<li><p>Inline Assets：使用  <a href=\"https://en.wikipedia.org/wiki/Data_URI_scheme\" target=\"_blank\" rel=\"noopener\">Data URI scheme</a>  将图片嵌入 HTML 或者 CSS 中；或者将 CSS、JS、图片直接嵌入 HTML 中。</p>\n<blockquote>\n<p>会增加文件大小，也可能产生浏览器兼容及其他性能问题（有待整理补充）。</p>\n</blockquote>\n<p>未来的趋势是使用内嵌 SVG。</p>\n</li>\n<li><p><a href=\"https://csspod.com/frontend-performance-best-practices/#content-domains\" target=\"_blank\" rel=\"noopener\">内容分片</a>，将请求划分到不同的域名上。</p>\n</li>\n</ul>\n<blockquote>\n<p>HTTP/2 通过多路复用大幅降低了多个请求的开销。通过数据分帧层，客户端和服务器之间只需要建立一个 TCP 连接，即可同时收发多个文件，而且，该连接在相当长的时间周期内保持打开（持久化），以便复用。</p>\n<p>HTTP/2 的新特性意味着上述优化实践不再适用，但考虑到客户端对 HTTP/2 的支持覆盖程度，还需根据实际数据权衡。</p>\n</blockquote>\n<h3 id=\"减少-DNS-查询\"><a href=\"#减少-DNS-查询\" class=\"headerlink\" title=\"减少 DNS 查询\"></a>减少 DNS 查询</h3><p>用户输入 URL 以后，浏览器首先要查询域名（hostname）对应服务器的 IP 地址，一般需要耗费  20-120 毫秒   时间。DNS 查询完成之前，浏览器无法从服务器下载任何数据。</p>\n<p>基于性能考虑，ISP、局域网、操作系统、浏览器都会有相应的 DNS 缓存机制。</p>\n<ul>\n<li>IE 缓存 30 分钟，可以通过注册表中  <code>DnsCacheTimeout</code>  项设置；</li>\n<li>Firefox 混存 1 分钟，通过  <code>network.dnsCacheExpiration</code>  配置；</li>\n<li>（TODO：补充其他浏览器缓存信息）</li>\n</ul>\n<p>首次访问、没有相应的 DNS 缓存时，域名越多，查询时间越长。所以应尽量减少域名数量。但基于并行下载考虑，把资源分布到 2 个域名上（最多不超过 4 个）。这是减少 DNS 查询同时保证并行下载的折衷方案。</p>\n<h3 id=\"避免重定向\"><a href=\"#避免重定向\" class=\"headerlink\" title=\"避免重定向\"></a>避免重定向</h3><p>HTTP 重定向通过  <code>301</code>/<code>302</code>  状态码实现。</p>\n<pre><code>HTTP/1.1 301 Moved Permanently\nLocation: http://example.com/newuri\nContent-Type: text/html</code></pre><p>客户端收到服务器的重定向响应后，会根据响应头中  <code>Location</code>  的地址再次发送请求。重定向会影响用户体验，尤其是多次重定向时，用户在一段时间内看不到任何内容，只看到浏览器进度条一直在刷新。</p>\n<p>有时重定向无法避免，在糟糕也比抛出 404 好。虽然通过  <a href=\"https://en.wikipedia.org/wiki/Meta_refresh\" target=\"_blank\" rel=\"noopener\">HTML meta refresh</a>  和 JavaScript 也能实现，但首选 HTTP <code>3xx</code>  跳转，以保证浏览器「后退」功能正常工作（也利于 SEO）。</p>\n<ul>\n<li>最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加  <code>/</code>  但未添加。比如，访问  <code>http://astrology.yahoo.com/astrology</code>  将被 301 重定向到  <code>http://astrology.yahoo.com/astrology/</code>（注意末尾的  <code>/</code>）。如果使用 Apache，可以通过  <code>Alias</code>  或  <code>mod_rewrite</code>  或  <code>DirectorySlash</code>  解决这个问题。</li>\n<li>网站域名变更：CNAME 结合  <code>Alias</code>  或  <code>mod_rewrite</code>  或者其他服务器类似功能实现跳转。</li>\n</ul>\n<h3 id=\"缓存-Ajax-请求\"><a href=\"#缓存-Ajax-请求\" class=\"headerlink\" title=\"缓存 Ajax 请求\"></a>缓存 Ajax 请求</h3><p>Ajax 可以提高用户体验。但「异步」不意味着「及时」，优化 Ajax 响应速度提高性能仍是需要关注的主题。</p>\n<p>最重要的的优化方式是缓存响应结果，详见  <a href=\"https://csspod.com/frontend-performance-best-practices/#server-cache\" target=\"_blank\" rel=\"noopener\">添加 Expires 或 Cache-Control 响应头</a>。</p>\n<p>以下规则也关乎 Ajax 响应速度：</p>\n<ul>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server-gzip\" target=\"_blank\" rel=\"noopener\">启用 Gzip</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-dns\" target=\"_blank\" rel=\"noopener\">减少 DNS 查询</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#javascript-minify\" target=\"_blank\" rel=\"noopener\">压缩 JavaScript 和 CSS</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-redirect\" target=\"_blank\" rel=\"noopener\">避免重定向</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server-etag\" target=\"_blank\" rel=\"noopener\">配置 Etag</a></li>\n</ul>\n<h3 id=\"延迟加载\"><a href=\"#延迟加载\" class=\"headerlink\" title=\"延迟加载\"></a>延迟加载</h3><p>页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如：</p>\n<ul>\n<li>非首屏使用的数据、样式、脚本、图片等；</li>\n<li>用户交互时才会显示的内容。</li>\n</ul>\n<p>遵循「渐进增强」理念开发的网站：JavaScript 用于增强用用户体验，但没有（不支持） JavaScript 也能正常工作，完全可以延迟加载 JavaScript。</p>\n<blockquote>\n<p>延迟渲染</p>\n<p>将首屏以外的 HTML 放在不渲染的元素中，如隐藏的  <code>&lt;/code&gt;，或者 &lt;code&gt;type&lt;/code&gt; 属性为非执行脚本的 &lt;code&gt;&lt;script&gt;&lt;/code&gt;标签中，减少初始渲染的 DOM 元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;content-preload&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;&quot;&gt;预先加载&lt;/h3&gt; &lt;p&gt;预先加载利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应。&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;无条件预先加载：页面加载完成（&lt;code&gt;load&lt;/code&gt;）后，马上获取其他资源。以 &lt;a href=&quot;http://google.com/&quot;&gt;google.com&lt;/a&gt; 为例，首页加载完成后会立即下载一个 Sprite 图片，此图首页不需要，但是搜索结果页要用到。&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;有条件预先加载：根据用户行为预判用户去向，预载相关资源。比如 &lt;a href=&quot;http://search.yahoo.com/&quot;&gt;search.yahoo.com&lt;/a&gt; 开始输入时会有额外的资源加载。&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Chrome 等浏览器的地址栏也有类似的机制。&lt;/p&gt; &lt;/blockquote&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;有「阴谋」的预先加载：页面即将上线新版前预先加载新版内容。网站改版后由于缓存、使用习惯等原因，会有旧版的网站更快更流畅的反馈。为缓解这一问题，在新版上线之前，旧版可以利用空闲提前加载一些新版的资源缓存到客户端，以便新版正式上线后更快的载入（好一个「心机猿」:scream:）。&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;「双十一」、「黑五」这类促销日来临之前，也可以预先下载一些相关资源到客户端（浏览器、App 等），有效利用浏览器缓存和本地存储，降低活动当日请求压力，提高用户体验。&lt;/p&gt; &lt;/blockquote&gt; &lt;/li&gt; &lt;/ul&gt; &lt;blockquote&gt; &lt;p&gt;TODO: Prefetch 相关细节&lt;/p&gt; &lt;/blockquote&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://www.w3.org/TR/resource-hints/&quot;&gt;Resource Hints Spec&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;a name=&quot;content-dom&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;dom&quot;&gt;减少 DOM 元素数量&lt;/h3&gt; &lt;p&gt;复杂的页面不仅下载的字节更多，JavaScript DOM 操作也更慢。例如，同是添加一个事件处理器，500 个元素和 5000 个元素的页面速度上会有很大区别。&lt;/p&gt; &lt;p&gt;从以下几个角度考虑移除不必要的标记：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;是否还在使用表格布局？&lt;/li&gt; &lt;li&gt;塞进去更多的 &lt;code&gt;&lt;div&gt;&lt;/code&gt; 仅为了处理布局问题？也许有更好、更语义化的标记。&lt;/li&gt; &lt;li&gt;能通过伪元素实现的功能，就没必要添加额外元素，如清除浮动。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;浏览器控制台中输入以下代码可以计算出页面中有多少 DOM 元素：&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;document.getElementsByTagName(&#39;*&#39;).length; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;对比标记良好的的网站，看看差距是多少。&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;为什么不使用表格布局？&lt;/p&gt; &lt;ul&gt; &lt;li&gt;更多的标签，增加文件大小；&lt;/li&gt; &lt;li&gt;不易维护，无法适应响应式设计；&lt;/li&gt; &lt;li&gt;性能考量，默认的表格布局算法会产生大量重绘（参见&lt;a href=&quot;https://csspod.com/table-width-algorithms/&quot;&gt;表格布局算法&lt;/a&gt;）。&lt;/li&gt; &lt;/ul&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;content-domains&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;&quot;&gt;划分内容到不同域名&lt;/h3&gt; &lt;p&gt;浏览器一般会限制每个域的并行线程（一般为 6 个，甚至更少），使用不同的域名可以最大化下载线程，但注意保持在 2-4 个域名内，以避免 DNS 查询损耗。&lt;/p&gt; &lt;p&gt;例如，动态内容放在 &lt;code&gt;csspod.com&lt;/code&gt; 上，静态资源放在 &lt;code&gt;static.csspod.com&lt;/code&gt;上。这样还可以禁用静态资源域下的 Cookie，减少数据传输，详见 &lt;a href=&quot;https://csspod.com/frontend-performance-best-practices/#cookie-free&quot;&gt;Cookie 优化&lt;/a&gt;。&lt;/p&gt; &lt;p&gt;更多信息参考 &lt;a href=&quot;http://yuiblog.com/blog/2007/04/11/performance-research-part-4/&quot;&gt;Maximizing Parallel Downloads in the Carpool Lane&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a name=&quot;content-iframe&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;iframe&quot;&gt;尽量减少 iframe 使用&lt;/h3&gt; &lt;p&gt;使用 iframe 可以在页面中嵌入 HTML 文档，但有利有弊。&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;iframe&gt;&lt;/code&gt; 优点：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;可以用来加载速度较慢的第三方资源，如广告、徽章；&lt;/li&gt; &lt;li&gt;可用作&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/security/sandboxed-iframes/&quot;&gt;安全沙箱&lt;/a&gt;；&lt;/li&gt; &lt;li&gt;可以并行下载脚本。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;code&gt;&lt;iframe&gt; 缺点&lt;/code&gt;：&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;加载代价昂贵，即使是空的页面；&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;阻塞页面 &lt;code&gt;load&lt;/code&gt; 事件触发；&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Iframe 完全加载以后，父页面才会触发 &lt;code&gt;load&lt;/code&gt; 事件。 Safari、Chrome 中通过 JavaScript 动态设置 iframe &lt;code&gt;src&lt;/code&gt; 可以避免这个问题。&lt;/p&gt; &lt;/blockquote&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;缺乏语义。&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;a name=&quot;content-404&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;404&quot;&gt;避免 404 错误&lt;/h3&gt; &lt;p&gt;HTTP 请求很昂贵，返回无效的响应（如 404 未找到）完全没必要，降低用户体验而且毫无益处。&lt;/p&gt; &lt;p&gt;一些网站设计很酷炫、有提示信息的 404 页面，有助于提高用户体验，但还是浪费服务器资源。尤其糟糕的是外部脚本返回 404，不仅阻塞其他资源下载，浏览器还会尝试把 404 页面内容当作 JavaScript 解析，消耗更多资源。&lt;/p&gt; &lt;h3 id=&quot;&quot;&gt;补充规则：&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;定义字符集，并放在 &lt;code&gt;&lt;head&gt;&lt;/code&gt; 顶部。大多数浏览器会暂停页面渲染，直到找到字符集定义。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;a name=&quot;server&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h2 id=&quot;&quot;&gt;服务器&lt;/h2&gt; &lt;p&gt;服务器相关优化设置可参考 H5BP 相关项目：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://github.com/h5bp/server-configs-nginx&quot;&gt;Nginx HTTP server boilerplate configs&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://github.com/h5bp/server-configs-apache&quot;&gt;Apache HTTP server boilerplate configs&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://github.com/h5bp/server-configs-iis&quot;&gt;IIS Web.Config Boilerplates&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;a name=&quot;server-cdn&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;cdn&quot;&gt;使用 CDN&lt;/h3&gt; &lt;p&gt;网站 80-90% 响应时间消耗在资源下载上，减少资源下载时间是性能优化的黄金发则。&lt;/p&gt; &lt;p&gt;相比分布式架构的复杂和巨大投入，静态内容分发网络（CDN）可以以较低的投入，获得加载速度有效提升。&lt;/p&gt; &lt;p&gt;&lt;a name=&quot;server-cache&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;expirescachecontrol&quot;&gt;添加 Expires 或 Cache-Control 响应头&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;静态内容：将 &lt;code&gt;Expires&lt;/code&gt; 响应头设置为将来很远的时间，实现「永不过期」策略；&lt;/li&gt; &lt;li&gt;动态内容：设置合适的 &lt;code&gt;Cache-Control&lt;/code&gt; 响应头，让浏览器有条件地发起请求。&lt;/li&gt; &lt;/ul&gt; &lt;blockquote&gt; &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control&quot;&gt;Cache-Control&lt;/a&gt; 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires、Pragma）。当前的所有浏览器都支持 Cache-Control，因此，使用它就够了。&lt;/p&gt; &lt;/blockquote&gt; &lt;blockquote&gt; &lt;p&gt;鉴于静态内容和动态内容不同的缓存策略，实践中一般会把二者部署在不同的服务器（域名）以方便管理。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;参考链接：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn&quot;&gt;HTTP 缓存 | Web Fundamentals - Google Developers&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://github.com/h5bp/server-configs&quot;&gt;H5BP - Server Configs&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;a name=&quot;server-gzip&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;gzip&quot;&gt;启用 Gzip&lt;/h3&gt; &lt;p&gt;Gzip 压缩通常可以减少 70% 的响应大小，对某些文件更可能高达 90%，比 Deflate 更高效。主流 Web 服务器都有相应模块，而且绝大多数浏览器支持 gzip 解码。所以，应该对 HTML、CSS、JS、XML、JSON 等文本类型的内容启用压缩。&lt;/p&gt; &lt;p&gt;注意，图片和 PDF 文件不要使用 gzip。它们本身已经压缩过，再使用 gzip 压缩不仅浪费 CPU 资源，而且还可能增加文件体积。&lt;/p&gt; &lt;p&gt;对于不支持的 Gzip 的用户代理，通过设置 Vary 响应头，返回&lt;s&gt;为&lt;/s&gt;未压缩的数据：&lt;/p&gt; &lt;pre&gt;&lt;code&gt;Vary: * &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;a name=&quot;server-etag&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;etag&quot;&gt;配置 Etag&lt;/h3&gt; &lt;p&gt;Etag 通过文件版本标识，方便服务器判断请求的内容是否有更新，如果没有就响应 &lt;code&gt;304&lt;/code&gt;，避免重新下载。&lt;/p&gt; &lt;p&gt;当然，启用 Etag 可能会导致其他问题，还需要根据具体情况做判断。（TODO：补充相关内容）&lt;/p&gt; &lt;p&gt;&lt;a name=&quot;server-flush&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;flush&quot;&gt;尽早输出（flush）缓冲&lt;/h3&gt; &lt;p&gt;用户请求页面时，服务器通常需要花费 200 ~ 500 毫秒来组合 HTML 页面。在此期间，浏览器处于空闲、等待数据状态。使用PHP 中的 &lt;a href=&quot;http://php.net/flush&quot;&gt;flush()&lt;/a&gt; 函数，可以发送部分已经准备好的 HTML 到浏览器，以便服务器还在忙于处理剩余页面时，浏览器可以提前开始获取资源。&lt;/p&gt; &lt;p&gt;可以考虑在 &lt;code&gt;&lt;/head&gt;&lt;/code&gt; 之后输出一次缓冲，HTML head 一般比较容易生成，先发送以便浏览器开始获取 &lt;code&gt;&lt;head&gt;&lt;/code&gt; 里引用的 CSS 等资源。&lt;/p&gt; &lt;p&gt;Example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;!-- css, js --&gt; &lt;/head&gt; &lt;?php flush(); ?&gt; &lt;body&gt; &lt;!-- content --&gt; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;a name=&quot;server-ajax-get&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;ajaxget&quot;&gt;Ajax 请求使用 GET 方法&lt;/h3&gt; &lt;p&gt;浏览器执行 XMLHttpRequest POST 请求时分成两步，先发送 Header，再发送数据。而 GET 只使用一个 TCP 数据包发送数据，所以首选 GET 方法。&lt;/p&gt; &lt;p&gt;根据 &lt;a href=&quot;https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&quot;&gt;HTTP 规范&lt;/a&gt;，GET 用于获取数据，POST 则用于向服务器发送数据，所以 Ajax 请求数据时使用 GET 更符合规范（&lt;a href=&quot;http://www.w3schools.com/tags/ref_httpmethods.asp&quot;&gt;GET 和 POST 对比&lt;/a&gt;）。&lt;/p&gt; &lt;p&gt;IE 中最大 URL 长度为 2K，如果超出 2K，则需要考虑使用 POST 方法。&lt;/p&gt; &lt;p&gt;&lt;a name=&quot;server-src&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;src&quot;&gt;避免图片 src 为空&lt;/h3&gt; &lt;p&gt;图片 &lt;code&gt;src&lt;/code&gt; 属性值为空字符串可能以下面两种形式出现：&lt;/p&gt; &lt;p&gt;HTML:&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;img src=&quot;&quot; /&gt; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;JavaScript：&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var img = new Image(); img.src = &quot;&quot;; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;虽然 &lt;code&gt;src&lt;/code&gt; 属性为空字符串，但浏览器仍然会向服务器发起一个 HTTP 请求：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;IE 向页面所在的目录发送请求；&lt;/li&gt; &lt;li&gt;Safari、Chrome、Firefox 向页面本身发送请求；&lt;/li&gt; &lt;li&gt;Opera 不执行任何操作。&lt;/li&gt; &lt;/ul&gt; &lt;blockquote&gt; &lt;p&gt;以上数据较老，当下主流版本可能会有改变。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;空 &lt;code&gt;src&lt;/code&gt; 产生请求的后果不容小觑：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;给服务器造成意外的流量负担，尤其时日 PV 较大时；&lt;/li&gt; &lt;li&gt;浪费服务器计算资源；&lt;/li&gt; &lt;li&gt;可能产生报错。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;当然，浏览器如此实现也是根据 &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986 - Uniform Resource Identifiers&lt;/a&gt;，当空字符串作为 URI 出现时，被当成相对 URI，具体算法参见规范 5.2 节。&lt;/p&gt; &lt;p&gt;参考链接：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://www.nczonline.net/blog/2009/11/30/empty-image-src-can-destroy-your-site/&quot;&gt;Empty image src can destroy your site&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;blockquote&gt; &lt;p&gt;空的 &lt;code&gt;href&lt;/code&gt; 属性也存在类似问题。用户点击空链接时，浏览器也会向服务器发送 HTTP 请求，可以通过 JavaScript 阻止空链接的默认的行为。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;cookie&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h2 id=&quot;cookie&quot;&gt;Cookie&lt;/h2&gt; &lt;p&gt;&lt;a name=&quot;cookie-size&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;cookie&quot;&gt;减少 Cookie 大小&lt;/h3&gt; &lt;p&gt;Cookie 被用于身份认证、个性化设置等诸多用途。Cookie 通过 HTTP 头在服务器和浏览器间来回传送，减少 Cookie 大小可以降低其对响应速度的影响。&lt;/p&gt; &lt;ul&gt; &lt;li&gt;去除不必要的 Cookie；&lt;/li&gt; &lt;li&gt;尽量压缩 Cookie 大小；&lt;/li&gt; &lt;li&gt;注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；&lt;/li&gt; &lt;li&gt;设置合适的过期时间。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;更多细节参考 &lt;a href=&quot;http://yuiblog.com/blog/2007/03/01/performance-research-part-3/&quot;&gt;When the Cookie Crumbles&lt;/a&gt;。&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;HTTP/2 首部压缩在客户端和服务器端使用「首部表」来跟踪和存储之前发送的键值对，对于相同的数据，不再随每次请求和响应发送。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;cookie-free&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;cookie&quot;&gt;静态资源使用无 Cookie 域名&lt;/h3&gt; &lt;p&gt;静态资源一般无需使用 Cookie，可以把它们放在使用二级域名或者专门域名的无 Cookie 服务器上，降低 Cookie 传送的造成的流量浪费，提高响应速度。&lt;/p&gt; &lt;p&gt;&lt;a name=&quot;css&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h2 id=&quot;css&quot;&gt;CSS&lt;/h2&gt; &lt;p&gt;&lt;a name=&quot;css-head&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;head&quot;&gt;把样式表放在 &lt;code&gt;&lt;head&gt;&lt;/code&gt; 中&lt;/h3&gt; &lt;p&gt;把样式表放在 &lt;code&gt;&lt;head&gt;&lt;/code&gt; 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉。&lt;/p&gt; &lt;p&gt;这对内容比较多的页面尤为重要，用户可以先查看已经下载渲染的内容，而不是盯着白屏等待。&lt;/p&gt; &lt;p&gt;如果把样式表放在页面底部，一些浏览器为减少重绘，会在 CSS 加载完成以后才渲染页面，用户只能对着白屏干瞪眼，用户体验极差。&lt;/p&gt; &lt;p&gt;&lt;a name=&quot;css-expression&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;css&quot;&gt;不要使用 CSS 表达式&lt;/h3&gt; &lt;p&gt;CSS 表达式可以在 CSS 里执行 JavaScript，仅 IE5-IE7 支持，IE8 标准模式已经废弃。&lt;/p&gt; &lt;p&gt;CSS 表达式超出预期的频繁执行，页面滚动、鼠标移动时都会不断执行，带来很大的性能损耗。&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;IE7 及更低版本的浏览器已经逐渐成为历史，忘记它吧。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;css-link&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;linkimport&quot;&gt;使用 &lt;code&gt;&lt;link&gt;&lt;/code&gt; 替代 &lt;code&gt;@import&lt;/code&gt;&lt;/h3&gt; &lt;p&gt;对于 IE 某些版本，&lt;code&gt;@import&lt;/code&gt; 的行为和 &lt;code&gt;&lt;link&gt;&lt;/code&gt; 放在页面底部一样。所以，不要用它。&lt;/p&gt; &lt;p&gt;&lt;a name=&quot;css-filter&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;filter&quot;&gt;不要使用 filter&lt;/h3&gt; &lt;p&gt;&lt;code&gt;AlphaImageLoader&lt;/code&gt; 为 IE5.5-IE8 专有的技术，和 CSS 表达式一样，放进博物馆吧。&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;注意：&lt;/p&gt; &lt;p&gt;这里所说的不是 &lt;a href=&quot;https://www.w3.org/TR/filter-effects-1/&quot;&gt;CSS3 Filter&lt;/a&gt;，参考文章 &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/filters/understanding-css/&quot;&gt;Understanding CSS Filter Effects&lt;/a&gt;&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;javascript&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h2 id=&quot;javascript&quot;&gt;JavaScript&lt;/h2&gt; &lt;p&gt;&lt;a name=&quot;javascript-bottom&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;&quot;&gt;把脚本放在页面底部&lt;/h3&gt; &lt;p&gt;浏览器下载脚本时，会阻塞其他资源并行下载，即使是来自不同域名的资源。因此，最好将脚本放在底部，以提高页面加载速度。&lt;/p&gt; &lt;p&gt;一些特殊场景无法将脚本放到页面底部的，可以考虑 &lt;code&gt;&lt;script&gt;&lt;/code&gt; 的以下属性：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement#defer_property&quot;&gt;&lt;code&gt;defer&lt;/code&gt; 属性&lt;/a&gt;；&lt;/li&gt; &lt;li&gt;HTML5 新增的 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement#async_property&quot;&gt;&lt;code&gt;async&lt;/code&gt; 属性&lt;/a&gt;。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;a name=&quot;javascript-extenal&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;javascriptcss&quot;&gt;使用外部 JavaScript 和 CSS&lt;/h3&gt; &lt;p&gt;外部 JavaScript 和 CSS 文件可以被浏览器缓存，在不同页面间重用，也能降低页面大小。&lt;/p&gt; &lt;p&gt;当然，实际中也需要考虑代码的重用程度。如果仅仅是某个页面使用到的代码，可以考虑内嵌在页面中，减少 HTTP 请求数。另外，可以在首页加载完成以后，预先加载子页面的资源。&lt;/p&gt; &lt;p&gt;&lt;a name=&quot;javascript-minify&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;javascriptcss&quot;&gt;压缩 JavaScript 和 CSS&lt;/h3&gt; &lt;p&gt;压缩代码可以移除非功能性的字符（注释、空格、空行等），减少文件大小，提高载入速度。&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;得益于 Node.js 的流行，开源社区涌现出许多高效、易用的前端优化工具，JavaScript 和 CSS 压缩类的，不敢说多如牛毛，多入鸡毛倒是一点不夸张，如 [UglifyJS 2] (&lt;a href=&quot;https://github.com/mishoo/UglifyJS2&quot;&gt;https://github.com/mishoo/UglifyJS2&lt;/a&gt;)、&lt;a href=&quot;https://www.npmjs.com/package/csso&quot;&gt;csso&lt;/a&gt;、&lt;a href=&quot;https://www.npmjs.com/package/cssnano&quot;&gt;cssnano&lt;/a&gt; 等。&lt;/p&gt; &lt;p&gt;对于内嵌的 CSS 和 JavaScript，也可以通过 &lt;a href=&quot;https://www.npmjs.com/package/htmlmin&quot;&gt;htmlmin&lt;/a&gt; 等工具压缩。&lt;/p&gt; &lt;p&gt;这些项目都有 Gulp、Webpack 等流行构建工具的配套版本。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;javascript-duplicate&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;&quot;&gt;移除重复脚本&lt;/h3&gt; &lt;p&gt;重复的脚本不仅产生不必要的 HTTP 请求，而且重复解析执行浪费时间和计算资源。&lt;/p&gt; &lt;p&gt;&lt;a name=&quot;javascript-dom&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;dom&quot;&gt;减少 DOM 操作&lt;/h3&gt; &lt;p&gt;JavaScript 操作 DOM 很慢，尤其是 DOM 节点很多时。&lt;/p&gt; &lt;p&gt;使用时应该注意：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;缓存已经访问过的元素；&lt;/li&gt; &lt;li&gt;使用 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/createDocumentFragment&quot;&gt;DocumentFragment&lt;/a&gt; 暂存 DOM，整理好以后再插入 DOM 树；&lt;/li&gt; &lt;li&gt;操作 className，而不是多次读写 &lt;code&gt;style&lt;/code&gt;；&lt;/li&gt; &lt;li&gt;避免使用 JavaScript 修复布局。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;a name=&quot;javascript-event&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;&quot;&gt;使用高效的事件处理&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;减少绑定事件监听的节点，如通过事件委托；&lt;/li&gt; &lt;li&gt;尽早处理事件，在 &lt;code&gt;DOMContentLoaded&lt;/code&gt; 即可进行，不用等到 &lt;code&gt;load&lt;/code&gt;以后。&lt;/li&gt; &lt;/ul&gt; &lt;blockquote&gt; &lt;p&gt;对于 &lt;code&gt;resize&lt;/code&gt;、&lt;code&gt;scroll&lt;/code&gt; 等触发频率极高的事件，应该通过 debounce 等机制降低处理程序执行频率。&lt;/p&gt; &lt;p&gt;TODO: 补充相关内容 &lt;a href=&quot;http://demo.nimius.net/debounce_throttle/&quot;&gt;http://demo.nimius.net/debounce_throttle/&lt;/a&gt;&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;image&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h2 id=&quot;&quot;&gt;图片&lt;/h2&gt; &lt;p&gt;&lt;a name=&quot;image-optimize&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;&quot;&gt;优化图片&lt;/h3&gt; &lt;blockquote&gt; &lt;p&gt;YDN &lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#opt_images&quot;&gt;列出的相关工具&lt;/a&gt; 缺乏易用性，建议参考以下工具。&lt;/p&gt; &lt;/blockquote&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://github.com/imagemin/imagemin&quot;&gt;imagemin&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://imageoptim.com/mac&quot;&gt;ImageOptim&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;blockquote&gt; &lt;p&gt;TODO:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;PNG 终极优化；&lt;/li&gt; &lt;li&gt;Webp 相关内容；&lt;/li&gt; &lt;li&gt;SVG 相关内容。&lt;/li&gt; &lt;/ul&gt; &lt;/blockquote&gt; &lt;p&gt;PNG 终极优化：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;http://www.queness.com/post/2507/most-effective-method-to-reduce-and-optimize-png-images&quot;&gt;Most Effective Method to Reduce and Optimize PNG Images&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.smashingmagazine.com/2009/07/clever-png-optimization-techniques/&quot;&gt;Clever PNG Optimization Techniques&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;a name=&quot;image-sprite&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;csssprite&quot;&gt;优化 CSS Sprite&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;水平排列 Sprite 中的图片，垂直排列会增加图片大小；&lt;/li&gt; &lt;li&gt;Spirite 中把颜色较近的组合在一起可以降低颜色数，理想状况是低于 256 色以适用 PNG8 格式；&lt;/li&gt; &lt;li&gt;不要在 Spirite 的图像中间留有较大空隙。减少空隙虽然不太影响文件大小，但可以降低用户代理把图片解压为像素图的内存消耗，对移动设备更友好。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;a name=&quot;image-scale&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;html&quot;&gt;不要在 HTML 中缩放图片&lt;/h3&gt; &lt;p&gt;不要使用 &lt;code&gt;&lt;img&gt;&lt;/code&gt; 的 &lt;code&gt;width&lt;/code&gt;、&lt;code&gt;height&lt;/code&gt; 缩放图片，如果用到小图片，就使用相应大小的图片。&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;很多 CMS 和 CDN 都提供图片裁切功能。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;image-favicon&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;faviconico&quot;&gt;使用体积小、可缓存的 favicon.ico&lt;/h3&gt; &lt;p&gt;Favicon.ico 一般存放在网站根目录下，无论是否在页面中设置，浏览器都会尝试请求这个文件。&lt;/p&gt; &lt;p&gt;所以确保这个图标：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;存在（避免 404）；&lt;/li&gt; &lt;li&gt;尽量小，最好小于 1K；&lt;/li&gt; &lt;li&gt;设置较长的过期时间。&lt;/li&gt; &lt;/ul&gt; &lt;blockquote&gt; &lt;p&gt;对于较新的浏览器，可以使用 PNG 格式的 favicon。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;参考链接：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://css-tricks.com/favicon-quiz/&quot;&gt;Favicons, Touch Icons, Tile Icons, etc. Which Do You Need?&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h3 id=&quot;&quot;&gt;图片相关补充&lt;/h3&gt; &lt;blockquote&gt; &lt;p&gt;设置图片的宽和高，以免浏览器按照「猜」的宽高给图片保留的区域和实际宽高差异，产生重绘。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;mobile&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h2 id=&quot;&quot;&gt;移动端&lt;/h2&gt; &lt;blockquote&gt; &lt;p&gt;移动端优化相关内容有待进一步整理补充。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;mobile-25k&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;25kb&quot;&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#under25&quot;&gt;保持单个文件小于 25 KB&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;&lt;a name=&quot;mobile-multipart&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;multipart&quot;&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#multipart&quot;&gt;打包内容为分段（multipart）文档&lt;/a&gt;&lt;/h3&gt; &lt;h2 id=&quot;&quot;&gt;参考链接&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;http://www.websiteoptimization.com/speed/tweak/psychology-web-performance/&quot;&gt;The Psychology of Web Performance&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/x-turndown&gt;</code></p>\n</blockquote>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>本文主要考量客户端性能、服务器端和网络性能，内容框架来自  <a href=\"https://developer.yahoo.com/performance/rules.html\" target=\"_blank\" rel=\"noopener\">Yahoo Developer Network</a>，包含 7 个类别共 35 条前端性能优化最佳实践，在此基础上补充了一些相关或者更符合主流技术的内容。</p>\n<p>同时，建议关注及时更新的  <a href=\"https://developers.google.com/web/fundamentals/performance/?hl=en\" target=\"_blank\" rel=\"noopener\">Google 性能优化指南</a>。</p>\n<p>目录：</p>\n<ul>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content\" target=\"_blank\" rel=\"noopener\">页面内容</a><ul>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-http\" target=\"_blank\" rel=\"noopener\">减少 HTTP 请求数</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-dns\" target=\"_blank\" rel=\"noopener\">减少 DNS 查询</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-redirect\" target=\"_blank\" rel=\"noopener\">避免重定向</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-ajax-cache\" target=\"_blank\" rel=\"noopener\">缓存 Ajax 请求</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-postload\" target=\"_blank\" rel=\"noopener\">延迟加载</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-preload\" target=\"_blank\" rel=\"noopener\">预先加载</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-dom\" target=\"_blank\" rel=\"noopener\">减少 DOM 元素数量</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-domains\" target=\"_blank\" rel=\"noopener\">划分内容到不同域名</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-iframe\" target=\"_blank\" rel=\"noopener\">尽量减少 iframe 使用</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-404\" target=\"_blank\" rel=\"noopener\">避免 404 错误</a></li>\n</ul>\n</li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server\" target=\"_blank\" rel=\"noopener\">服务器</a><ul>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server-cdn\" target=\"_blank\" rel=\"noopener\">使用 CDN</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server-cache\" target=\"_blank\" rel=\"noopener\">添加 Expires 或 Cache-Control 响应头</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server-gzip\" target=\"_blank\" rel=\"noopener\">启用 Gzip</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server-etag\" target=\"_blank\" rel=\"noopener\">配置 Etag</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server-flush\" target=\"_blank\" rel=\"noopener\">尽早输出缓冲</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server-ajax-get\" target=\"_blank\" rel=\"noopener\">Ajax 请求使用 GET 方法</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server-src\" target=\"_blank\" rel=\"noopener\">避免图片 src 为空</a></li>\n</ul>\n</li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#cookie\" target=\"_blank\" rel=\"noopener\">Cookie</a><ul>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#cookie-size\" target=\"_blank\" rel=\"noopener\">减少 Cookie 大小</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#cookie-free\" target=\"_blank\" rel=\"noopener\">静态资源使用无 Cookie 域名</a></li>\n</ul>\n</li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#css\" target=\"_blank\" rel=\"noopener\">CSS</a><ul>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#css-head\" target=\"_blank\" rel=\"noopener\">把样式表放在    中</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#css-expression\" target=\"_blank\" rel=\"noopener\">不要使用 CSS 表达式</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#css-link\" target=\"_blank\" rel=\"noopener\">使用    替代  <code>@import</code></a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#css-filter\" target=\"_blank\" rel=\"noopener\">不要使用 filter</a></li>\n</ul>\n</li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#javascript\" target=\"_blank\" rel=\"noopener\">JavaScript</a><ul>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#javascript-bottom\" target=\"_blank\" rel=\"noopener\">把脚本放在页面底部</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#javascript-extenal\" target=\"_blank\" rel=\"noopener\">使用外部 JavaScript 和 CSS</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#javascript-minify\" target=\"_blank\" rel=\"noopener\">压缩 JavaScript 和 CSS</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#javascript-duplicate\" target=\"_blank\" rel=\"noopener\">移除重复脚本</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#javascript-dom\" target=\"_blank\" rel=\"noopener\">减少 DOM 操作</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#javascript-event\" target=\"_blank\" rel=\"noopener\">使用高效的事件处理</a></li>\n</ul>\n</li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#image\" target=\"_blank\" rel=\"noopener\">图片</a><ul>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#image-optimize\" target=\"_blank\" rel=\"noopener\">优化图片</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#image-sprite\" target=\"_blank\" rel=\"noopener\">优化 CSS Sprite</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#image-scale\" target=\"_blank\" rel=\"noopener\">不要在 HTML 中缩放图片</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#image-favicon\" target=\"_blank\" rel=\"noopener\">使用体积小、可缓存的 favicon.ico</a></li>\n</ul>\n</li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#mobile\" target=\"_blank\" rel=\"noopener\">移动端</a><ul>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#mobile-25kb\" target=\"_blank\" rel=\"noopener\">保持单个文件小于 25 KB</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#mobile-multipart\" target=\"_blank\" rel=\"noopener\">打包内容为分段（multipart）文档</a></li>\n</ul>\n</li>\n</ul>\n<p>前端性能的一个重要指标是页面加载时间，不仅事关用户体验，也是搜索引擎排名考虑的一个因素。</p>\n<blockquote>\n<ul>\n<li>来自 Google 的数据表明，一个有 10 条数据 0.4 秒能加载完的页面，变成 30 条数据 0.9 秒加载完之后，流量和广告收入下降 90%。</li>\n<li>Google Map 首页文件大小从 100KB 减小到 70-80KB 后，流量在第一周涨了 10%，接下来的三周涨了 25%。</li>\n<li>亚马逊的数据表明：加载时间增加 100 毫秒，销量就下降 1%。</li>\n</ul>\n</blockquote>\n<p>以上数据更说明「加载时间就是金钱」，前端优化主要围绕提高加载速度进行。</p>\n<h2 id=\"页面内容\"><a href=\"#页面内容\" class=\"headerlink\" title=\"页面内容\"></a>页面内容</h2><h3 id=\"减少-HTTP-请求数\"><a href=\"#减少-HTTP-请求数\" class=\"headerlink\" title=\"减少 HTTP 请求数\"></a>减少 HTTP 请求数</h3><p>Web 前端 80% 的响应时间花在图片、样式、脚本等资源下载上。浏览器对每个域名的连接数是有限制的，减少请求次数是缩短响应时间的关键。</p>\n<p>通过简洁的设计减少页面所需资源，进而减少 HTTP 请求，这是最直接的方式，前提是你的 Boss、设计师同事不打死你。所以，还是另辟蹊径吧：</p>\n<ul>\n<li><p>合并 JavaScript、CSS 等文件；</p>\n<ul>\n<li>服务器端（CDN）自动合并</li>\n<li>基于 Node.js 的文件合并工具一抓一大把</li>\n</ul>\n</li>\n<li><p>使用<a href=\"http://alistapart.com/articles/sprites\" target=\"_blank\" rel=\"noopener\">CSS Sprite</a>：将背景图片合并成一个文件，通过<code>background-image</code>  和  <code>background-position</code>  控制显示；</p>\n<ul>\n<li><a href=\"http://www.spritecow.com/\" target=\"_blank\" rel=\"noopener\">Sprite Cow</a></li>\n<li><a href=\"http://www.spritebox.net/\" target=\"_blank\" rel=\"noopener\">Spritebox</a></li>\n</ul>\n<blockquote>\n<p>逐步被 Icon Font 和 SVG Sprite 取代。</p>\n</blockquote>\n</li>\n<li><p><a href=\"http://www.w3.org/TR/html401/struct/objects.html#h-13.6\" target=\"_blank\" rel=\"noopener\">Image Map</a>：合并图片，然后使用坐标映射不同的区域（<a href=\"https://en.wikipedia.org/wiki/The_Club_(dining_club)\" target=\"_blank\" rel=\"noopener\">演示</a>）。</p>\n<blockquote>\n<p>缺点：仅适用于相连的图片；设置坐标过程乏味且易出错；可访性问题。不推荐使用这种过时的技术。</p>\n</blockquote>\n</li>\n<li><p>Inline Assets：使用  <a href=\"https://en.wikipedia.org/wiki/Data_URI_scheme\" target=\"_blank\" rel=\"noopener\">Data URI scheme</a>  将图片嵌入 HTML 或者 CSS 中；或者将 CSS、JS、图片直接嵌入 HTML 中。</p>\n<blockquote>\n<p>会增加文件大小，也可能产生浏览器兼容及其他性能问题（有待整理补充）。</p>\n</blockquote>\n<p>未来的趋势是使用内嵌 SVG。</p>\n</li>\n<li><p><a href=\"https://csspod.com/frontend-performance-best-practices/#content-domains\" target=\"_blank\" rel=\"noopener\">内容分片</a>，将请求划分到不同的域名上。</p>\n</li>\n</ul>\n<blockquote>\n<p>HTTP/2 通过多路复用大幅降低了多个请求的开销。通过数据分帧层，客户端和服务器之间只需要建立一个 TCP 连接，即可同时收发多个文件，而且，该连接在相当长的时间周期内保持打开（持久化），以便复用。</p>\n<p>HTTP/2 的新特性意味着上述优化实践不再适用，但考虑到客户端对 HTTP/2 的支持覆盖程度，还需根据实际数据权衡。</p>\n</blockquote>\n<h3 id=\"减少-DNS-查询\"><a href=\"#减少-DNS-查询\" class=\"headerlink\" title=\"减少 DNS 查询\"></a>减少 DNS 查询</h3><p>用户输入 URL 以后，浏览器首先要查询域名（hostname）对应服务器的 IP 地址，一般需要耗费  20-120 毫秒   时间。DNS 查询完成之前，浏览器无法从服务器下载任何数据。</p>\n<p>基于性能考虑，ISP、局域网、操作系统、浏览器都会有相应的 DNS 缓存机制。</p>\n<ul>\n<li>IE 缓存 30 分钟，可以通过注册表中  <code>DnsCacheTimeout</code>  项设置；</li>\n<li>Firefox 混存 1 分钟，通过  <code>network.dnsCacheExpiration</code>  配置；</li>\n<li>（TODO：补充其他浏览器缓存信息）</li>\n</ul>\n<p>首次访问、没有相应的 DNS 缓存时，域名越多，查询时间越长。所以应尽量减少域名数量。但基于并行下载考虑，把资源分布到 2 个域名上（最多不超过 4 个）。这是减少 DNS 查询同时保证并行下载的折衷方案。</p>\n<h3 id=\"避免重定向\"><a href=\"#避免重定向\" class=\"headerlink\" title=\"避免重定向\"></a>避免重定向</h3><p>HTTP 重定向通过  <code>301</code>/<code>302</code>  状态码实现。</p>\n<pre><code>HTTP/1.1 301 Moved Permanently\nLocation: http://example.com/newuri\nContent-Type: text/html</code></pre><p>客户端收到服务器的重定向响应后，会根据响应头中  <code>Location</code>  的地址再次发送请求。重定向会影响用户体验，尤其是多次重定向时，用户在一段时间内看不到任何内容，只看到浏览器进度条一直在刷新。</p>\n<p>有时重定向无法避免，在糟糕也比抛出 404 好。虽然通过  <a href=\"https://en.wikipedia.org/wiki/Meta_refresh\" target=\"_blank\" rel=\"noopener\">HTML meta refresh</a>  和 JavaScript 也能实现，但首选 HTTP <code>3xx</code>  跳转，以保证浏览器「后退」功能正常工作（也利于 SEO）。</p>\n<ul>\n<li>最浪费的重定向经常发生、而且很容易被忽略：URL 末尾应该添加  <code>/</code>  但未添加。比如，访问  <code>http://astrology.yahoo.com/astrology</code>  将被 301 重定向到  <code>http://astrology.yahoo.com/astrology/</code>（注意末尾的  <code>/</code>）。如果使用 Apache，可以通过  <code>Alias</code>  或  <code>mod_rewrite</code>  或  <code>DirectorySlash</code>  解决这个问题。</li>\n<li>网站域名变更：CNAME 结合  <code>Alias</code>  或  <code>mod_rewrite</code>  或者其他服务器类似功能实现跳转。</li>\n</ul>\n<h3 id=\"缓存-Ajax-请求\"><a href=\"#缓存-Ajax-请求\" class=\"headerlink\" title=\"缓存 Ajax 请求\"></a>缓存 Ajax 请求</h3><p>Ajax 可以提高用户体验。但「异步」不意味着「及时」，优化 Ajax 响应速度提高性能仍是需要关注的主题。</p>\n<p>最重要的的优化方式是缓存响应结果，详见  <a href=\"https://csspod.com/frontend-performance-best-practices/#server-cache\" target=\"_blank\" rel=\"noopener\">添加 Expires 或 Cache-Control 响应头</a>。</p>\n<p>以下规则也关乎 Ajax 响应速度：</p>\n<ul>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server-gzip\" target=\"_blank\" rel=\"noopener\">启用 Gzip</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-dns\" target=\"_blank\" rel=\"noopener\">减少 DNS 查询</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#javascript-minify\" target=\"_blank\" rel=\"noopener\">压缩 JavaScript 和 CSS</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#content-redirect\" target=\"_blank\" rel=\"noopener\">避免重定向</a></li>\n<li><a href=\"https://csspod.com/frontend-performance-best-practices/#server-etag\" target=\"_blank\" rel=\"noopener\">配置 Etag</a></li>\n</ul>\n<h3 id=\"延迟加载\"><a href=\"#延迟加载\" class=\"headerlink\" title=\"延迟加载\"></a>延迟加载</h3><p>页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如：</p>\n<ul>\n<li>非首屏使用的数据、样式、脚本、图片等；</li>\n<li>用户交互时才会显示的内容。</li>\n</ul>\n<p>遵循「渐进增强」理念开发的网站：JavaScript 用于增强用用户体验，但没有（不支持） JavaScript 也能正常工作，完全可以延迟加载 JavaScript。</p>\n<blockquote>\n<p>延迟渲染</p>\n<p>将首屏以外的 HTML 放在不渲染的元素中，如隐藏的  <code>&lt;/code&gt;，或者 &lt;code&gt;type&lt;/code&gt; 属性为非执行脚本的 &lt;code&gt;&lt;script&gt;&lt;/code&gt;标签中，减少初始渲染的 DOM 元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;content-preload&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;&quot;&gt;预先加载&lt;/h3&gt; &lt;p&gt;预先加载利用浏览器空闲时间请求将来要使用的资源，以便用户访问下一页面时更快地响应。&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;无条件预先加载：页面加载完成（&lt;code&gt;load&lt;/code&gt;）后，马上获取其他资源。以 &lt;a href=&quot;http://google.com/&quot;&gt;google.com&lt;/a&gt; 为例，首页加载完成后会立即下载一个 Sprite 图片，此图首页不需要，但是搜索结果页要用到。&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;有条件预先加载：根据用户行为预判用户去向，预载相关资源。比如 &lt;a href=&quot;http://search.yahoo.com/&quot;&gt;search.yahoo.com&lt;/a&gt; 开始输入时会有额外的资源加载。&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Chrome 等浏览器的地址栏也有类似的机制。&lt;/p&gt; &lt;/blockquote&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;有「阴谋」的预先加载：页面即将上线新版前预先加载新版内容。网站改版后由于缓存、使用习惯等原因，会有旧版的网站更快更流畅的反馈。为缓解这一问题，在新版上线之前，旧版可以利用空闲提前加载一些新版的资源缓存到客户端，以便新版正式上线后更快的载入（好一个「心机猿」:scream:）。&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;「双十一」、「黑五」这类促销日来临之前，也可以预先下载一些相关资源到客户端（浏览器、App 等），有效利用浏览器缓存和本地存储，降低活动当日请求压力，提高用户体验。&lt;/p&gt; &lt;/blockquote&gt; &lt;/li&gt; &lt;/ul&gt; &lt;blockquote&gt; &lt;p&gt;TODO: Prefetch 相关细节&lt;/p&gt; &lt;/blockquote&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://www.w3.org/TR/resource-hints/&quot;&gt;Resource Hints Spec&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;a name=&quot;content-dom&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;dom&quot;&gt;减少 DOM 元素数量&lt;/h3&gt; &lt;p&gt;复杂的页面不仅下载的字节更多，JavaScript DOM 操作也更慢。例如，同是添加一个事件处理器，500 个元素和 5000 个元素的页面速度上会有很大区别。&lt;/p&gt; &lt;p&gt;从以下几个角度考虑移除不必要的标记：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;是否还在使用表格布局？&lt;/li&gt; &lt;li&gt;塞进去更多的 &lt;code&gt;&lt;div&gt;&lt;/code&gt; 仅为了处理布局问题？也许有更好、更语义化的标记。&lt;/li&gt; &lt;li&gt;能通过伪元素实现的功能，就没必要添加额外元素，如清除浮动。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;浏览器控制台中输入以下代码可以计算出页面中有多少 DOM 元素：&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;document.getElementsByTagName(&#39;*&#39;).length; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;对比标记良好的的网站，看看差距是多少。&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;为什么不使用表格布局？&lt;/p&gt; &lt;ul&gt; &lt;li&gt;更多的标签，增加文件大小；&lt;/li&gt; &lt;li&gt;不易维护，无法适应响应式设计；&lt;/li&gt; &lt;li&gt;性能考量，默认的表格布局算法会产生大量重绘（参见&lt;a href=&quot;https://csspod.com/table-width-algorithms/&quot;&gt;表格布局算法&lt;/a&gt;）。&lt;/li&gt; &lt;/ul&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;content-domains&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;&quot;&gt;划分内容到不同域名&lt;/h3&gt; &lt;p&gt;浏览器一般会限制每个域的并行线程（一般为 6 个，甚至更少），使用不同的域名可以最大化下载线程，但注意保持在 2-4 个域名内，以避免 DNS 查询损耗。&lt;/p&gt; &lt;p&gt;例如，动态内容放在 &lt;code&gt;csspod.com&lt;/code&gt; 上，静态资源放在 &lt;code&gt;static.csspod.com&lt;/code&gt;上。这样还可以禁用静态资源域下的 Cookie，减少数据传输，详见 &lt;a href=&quot;https://csspod.com/frontend-performance-best-practices/#cookie-free&quot;&gt;Cookie 优化&lt;/a&gt;。&lt;/p&gt; &lt;p&gt;更多信息参考 &lt;a href=&quot;http://yuiblog.com/blog/2007/04/11/performance-research-part-4/&quot;&gt;Maximizing Parallel Downloads in the Carpool Lane&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a name=&quot;content-iframe&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;iframe&quot;&gt;尽量减少 iframe 使用&lt;/h3&gt; &lt;p&gt;使用 iframe 可以在页面中嵌入 HTML 文档，但有利有弊。&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;iframe&gt;&lt;/code&gt; 优点：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;可以用来加载速度较慢的第三方资源，如广告、徽章；&lt;/li&gt; &lt;li&gt;可用作&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/security/sandboxed-iframes/&quot;&gt;安全沙箱&lt;/a&gt;；&lt;/li&gt; &lt;li&gt;可以并行下载脚本。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;code&gt;&lt;iframe&gt; 缺点&lt;/code&gt;：&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;加载代价昂贵，即使是空的页面；&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;阻塞页面 &lt;code&gt;load&lt;/code&gt; 事件触发；&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Iframe 完全加载以后，父页面才会触发 &lt;code&gt;load&lt;/code&gt; 事件。 Safari、Chrome 中通过 JavaScript 动态设置 iframe &lt;code&gt;src&lt;/code&gt; 可以避免这个问题。&lt;/p&gt; &lt;/blockquote&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;缺乏语义。&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;a name=&quot;content-404&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;404&quot;&gt;避免 404 错误&lt;/h3&gt; &lt;p&gt;HTTP 请求很昂贵，返回无效的响应（如 404 未找到）完全没必要，降低用户体验而且毫无益处。&lt;/p&gt; &lt;p&gt;一些网站设计很酷炫、有提示信息的 404 页面，有助于提高用户体验，但还是浪费服务器资源。尤其糟糕的是外部脚本返回 404，不仅阻塞其他资源下载，浏览器还会尝试把 404 页面内容当作 JavaScript 解析，消耗更多资源。&lt;/p&gt; &lt;h3 id=&quot;&quot;&gt;补充规则：&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;定义字符集，并放在 &lt;code&gt;&lt;head&gt;&lt;/code&gt; 顶部。大多数浏览器会暂停页面渲染，直到找到字符集定义。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;a name=&quot;server&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h2 id=&quot;&quot;&gt;服务器&lt;/h2&gt; &lt;p&gt;服务器相关优化设置可参考 H5BP 相关项目：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://github.com/h5bp/server-configs-nginx&quot;&gt;Nginx HTTP server boilerplate configs&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://github.com/h5bp/server-configs-apache&quot;&gt;Apache HTTP server boilerplate configs&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://github.com/h5bp/server-configs-iis&quot;&gt;IIS Web.Config Boilerplates&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;a name=&quot;server-cdn&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;cdn&quot;&gt;使用 CDN&lt;/h3&gt; &lt;p&gt;网站 80-90% 响应时间消耗在资源下载上，减少资源下载时间是性能优化的黄金发则。&lt;/p&gt; &lt;p&gt;相比分布式架构的复杂和巨大投入，静态内容分发网络（CDN）可以以较低的投入，获得加载速度有效提升。&lt;/p&gt; &lt;p&gt;&lt;a name=&quot;server-cache&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;expirescachecontrol&quot;&gt;添加 Expires 或 Cache-Control 响应头&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;静态内容：将 &lt;code&gt;Expires&lt;/code&gt; 响应头设置为将来很远的时间，实现「永不过期」策略；&lt;/li&gt; &lt;li&gt;动态内容：设置合适的 &lt;code&gt;Cache-Control&lt;/code&gt; 响应头，让浏览器有条件地发起请求。&lt;/li&gt; &lt;/ul&gt; &lt;blockquote&gt; &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control&quot;&gt;Cache-Control&lt;/a&gt; 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires、Pragma）。当前的所有浏览器都支持 Cache-Control，因此，使用它就够了。&lt;/p&gt; &lt;/blockquote&gt; &lt;blockquote&gt; &lt;p&gt;鉴于静态内容和动态内容不同的缓存策略，实践中一般会把二者部署在不同的服务器（域名）以方便管理。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;参考链接：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn&quot;&gt;HTTP 缓存 | Web Fundamentals - Google Developers&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://github.com/h5bp/server-configs&quot;&gt;H5BP - Server Configs&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;a name=&quot;server-gzip&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;gzip&quot;&gt;启用 Gzip&lt;/h3&gt; &lt;p&gt;Gzip 压缩通常可以减少 70% 的响应大小，对某些文件更可能高达 90%，比 Deflate 更高效。主流 Web 服务器都有相应模块，而且绝大多数浏览器支持 gzip 解码。所以，应该对 HTML、CSS、JS、XML、JSON 等文本类型的内容启用压缩。&lt;/p&gt; &lt;p&gt;注意，图片和 PDF 文件不要使用 gzip。它们本身已经压缩过，再使用 gzip 压缩不仅浪费 CPU 资源，而且还可能增加文件体积。&lt;/p&gt; &lt;p&gt;对于不支持的 Gzip 的用户代理，通过设置 Vary 响应头，返回&lt;s&gt;为&lt;/s&gt;未压缩的数据：&lt;/p&gt; &lt;pre&gt;&lt;code&gt;Vary: * &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;a name=&quot;server-etag&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;etag&quot;&gt;配置 Etag&lt;/h3&gt; &lt;p&gt;Etag 通过文件版本标识，方便服务器判断请求的内容是否有更新，如果没有就响应 &lt;code&gt;304&lt;/code&gt;，避免重新下载。&lt;/p&gt; &lt;p&gt;当然，启用 Etag 可能会导致其他问题，还需要根据具体情况做判断。（TODO：补充相关内容）&lt;/p&gt; &lt;p&gt;&lt;a name=&quot;server-flush&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;flush&quot;&gt;尽早输出（flush）缓冲&lt;/h3&gt; &lt;p&gt;用户请求页面时，服务器通常需要花费 200 ~ 500 毫秒来组合 HTML 页面。在此期间，浏览器处于空闲、等待数据状态。使用PHP 中的 &lt;a href=&quot;http://php.net/flush&quot;&gt;flush()&lt;/a&gt; 函数，可以发送部分已经准备好的 HTML 到浏览器，以便服务器还在忙于处理剩余页面时，浏览器可以提前开始获取资源。&lt;/p&gt; &lt;p&gt;可以考虑在 &lt;code&gt;&lt;/head&gt;&lt;/code&gt; 之后输出一次缓冲，HTML head 一般比较容易生成，先发送以便浏览器开始获取 &lt;code&gt;&lt;head&gt;&lt;/code&gt; 里引用的 CSS 等资源。&lt;/p&gt; &lt;p&gt;Example:&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;!-- css, js --&gt; &lt;/head&gt; &lt;?php flush(); ?&gt; &lt;body&gt; &lt;!-- content --&gt; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;a name=&quot;server-ajax-get&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;ajaxget&quot;&gt;Ajax 请求使用 GET 方法&lt;/h3&gt; &lt;p&gt;浏览器执行 XMLHttpRequest POST 请求时分成两步，先发送 Header，再发送数据。而 GET 只使用一个 TCP 数据包发送数据，所以首选 GET 方法。&lt;/p&gt; &lt;p&gt;根据 &lt;a href=&quot;https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&quot;&gt;HTTP 规范&lt;/a&gt;，GET 用于获取数据，POST 则用于向服务器发送数据，所以 Ajax 请求数据时使用 GET 更符合规范（&lt;a href=&quot;http://www.w3schools.com/tags/ref_httpmethods.asp&quot;&gt;GET 和 POST 对比&lt;/a&gt;）。&lt;/p&gt; &lt;p&gt;IE 中最大 URL 长度为 2K，如果超出 2K，则需要考虑使用 POST 方法。&lt;/p&gt; &lt;p&gt;&lt;a name=&quot;server-src&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;src&quot;&gt;避免图片 src 为空&lt;/h3&gt; &lt;p&gt;图片 &lt;code&gt;src&lt;/code&gt; 属性值为空字符串可能以下面两种形式出现：&lt;/p&gt; &lt;p&gt;HTML:&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;img src=&quot;&quot; /&gt; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;JavaScript：&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var img = new Image(); img.src = &quot;&quot;; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;虽然 &lt;code&gt;src&lt;/code&gt; 属性为空字符串，但浏览器仍然会向服务器发起一个 HTTP 请求：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;IE 向页面所在的目录发送请求；&lt;/li&gt; &lt;li&gt;Safari、Chrome、Firefox 向页面本身发送请求；&lt;/li&gt; &lt;li&gt;Opera 不执行任何操作。&lt;/li&gt; &lt;/ul&gt; &lt;blockquote&gt; &lt;p&gt;以上数据较老，当下主流版本可能会有改变。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;空 &lt;code&gt;src&lt;/code&gt; 产生请求的后果不容小觑：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;给服务器造成意外的流量负担，尤其时日 PV 较大时；&lt;/li&gt; &lt;li&gt;浪费服务器计算资源；&lt;/li&gt; &lt;li&gt;可能产生报错。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;当然，浏览器如此实现也是根据 &lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986 - Uniform Resource Identifiers&lt;/a&gt;，当空字符串作为 URI 出现时，被当成相对 URI，具体算法参见规范 5.2 节。&lt;/p&gt; &lt;p&gt;参考链接：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://www.nczonline.net/blog/2009/11/30/empty-image-src-can-destroy-your-site/&quot;&gt;Empty image src can destroy your site&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;blockquote&gt; &lt;p&gt;空的 &lt;code&gt;href&lt;/code&gt; 属性也存在类似问题。用户点击空链接时，浏览器也会向服务器发送 HTTP 请求，可以通过 JavaScript 阻止空链接的默认的行为。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;cookie&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h2 id=&quot;cookie&quot;&gt;Cookie&lt;/h2&gt; &lt;p&gt;&lt;a name=&quot;cookie-size&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;cookie&quot;&gt;减少 Cookie 大小&lt;/h3&gt; &lt;p&gt;Cookie 被用于身份认证、个性化设置等诸多用途。Cookie 通过 HTTP 头在服务器和浏览器间来回传送，减少 Cookie 大小可以降低其对响应速度的影响。&lt;/p&gt; &lt;ul&gt; &lt;li&gt;去除不必要的 Cookie；&lt;/li&gt; &lt;li&gt;尽量压缩 Cookie 大小；&lt;/li&gt; &lt;li&gt;注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；&lt;/li&gt; &lt;li&gt;设置合适的过期时间。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;更多细节参考 &lt;a href=&quot;http://yuiblog.com/blog/2007/03/01/performance-research-part-3/&quot;&gt;When the Cookie Crumbles&lt;/a&gt;。&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;HTTP/2 首部压缩在客户端和服务器端使用「首部表」来跟踪和存储之前发送的键值对，对于相同的数据，不再随每次请求和响应发送。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;cookie-free&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;cookie&quot;&gt;静态资源使用无 Cookie 域名&lt;/h3&gt; &lt;p&gt;静态资源一般无需使用 Cookie，可以把它们放在使用二级域名或者专门域名的无 Cookie 服务器上，降低 Cookie 传送的造成的流量浪费，提高响应速度。&lt;/p&gt; &lt;p&gt;&lt;a name=&quot;css&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h2 id=&quot;css&quot;&gt;CSS&lt;/h2&gt; &lt;p&gt;&lt;a name=&quot;css-head&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;head&quot;&gt;把样式表放在 &lt;code&gt;&lt;head&gt;&lt;/code&gt; 中&lt;/h3&gt; &lt;p&gt;把样式表放在 &lt;code&gt;&lt;head&gt;&lt;/code&gt; 中可以让页面渐进渲染，尽早呈现视觉反馈，给用户加载速度很快的感觉。&lt;/p&gt; &lt;p&gt;这对内容比较多的页面尤为重要，用户可以先查看已经下载渲染的内容，而不是盯着白屏等待。&lt;/p&gt; &lt;p&gt;如果把样式表放在页面底部，一些浏览器为减少重绘，会在 CSS 加载完成以后才渲染页面，用户只能对着白屏干瞪眼，用户体验极差。&lt;/p&gt; &lt;p&gt;&lt;a name=&quot;css-expression&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;css&quot;&gt;不要使用 CSS 表达式&lt;/h3&gt; &lt;p&gt;CSS 表达式可以在 CSS 里执行 JavaScript，仅 IE5-IE7 支持，IE8 标准模式已经废弃。&lt;/p&gt; &lt;p&gt;CSS 表达式超出预期的频繁执行，页面滚动、鼠标移动时都会不断执行，带来很大的性能损耗。&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;IE7 及更低版本的浏览器已经逐渐成为历史，忘记它吧。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;css-link&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;linkimport&quot;&gt;使用 &lt;code&gt;&lt;link&gt;&lt;/code&gt; 替代 &lt;code&gt;@import&lt;/code&gt;&lt;/h3&gt; &lt;p&gt;对于 IE 某些版本，&lt;code&gt;@import&lt;/code&gt; 的行为和 &lt;code&gt;&lt;link&gt;&lt;/code&gt; 放在页面底部一样。所以，不要用它。&lt;/p&gt; &lt;p&gt;&lt;a name=&quot;css-filter&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;filter&quot;&gt;不要使用 filter&lt;/h3&gt; &lt;p&gt;&lt;code&gt;AlphaImageLoader&lt;/code&gt; 为 IE5.5-IE8 专有的技术，和 CSS 表达式一样，放进博物馆吧。&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;注意：&lt;/p&gt; &lt;p&gt;这里所说的不是 &lt;a href=&quot;https://www.w3.org/TR/filter-effects-1/&quot;&gt;CSS3 Filter&lt;/a&gt;，参考文章 &lt;a href=&quot;http://www.html5rocks.com/en/tutorials/filters/understanding-css/&quot;&gt;Understanding CSS Filter Effects&lt;/a&gt;&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;javascript&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h2 id=&quot;javascript&quot;&gt;JavaScript&lt;/h2&gt; &lt;p&gt;&lt;a name=&quot;javascript-bottom&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;&quot;&gt;把脚本放在页面底部&lt;/h3&gt; &lt;p&gt;浏览器下载脚本时，会阻塞其他资源并行下载，即使是来自不同域名的资源。因此，最好将脚本放在底部，以提高页面加载速度。&lt;/p&gt; &lt;p&gt;一些特殊场景无法将脚本放到页面底部的，可以考虑 &lt;code&gt;&lt;script&gt;&lt;/code&gt; 的以下属性：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement#defer_property&quot;&gt;&lt;code&gt;defer&lt;/code&gt; 属性&lt;/a&gt;；&lt;/li&gt; &lt;li&gt;HTML5 新增的 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement#async_property&quot;&gt;&lt;code&gt;async&lt;/code&gt; 属性&lt;/a&gt;。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;a name=&quot;javascript-extenal&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;javascriptcss&quot;&gt;使用外部 JavaScript 和 CSS&lt;/h3&gt; &lt;p&gt;外部 JavaScript 和 CSS 文件可以被浏览器缓存，在不同页面间重用，也能降低页面大小。&lt;/p&gt; &lt;p&gt;当然，实际中也需要考虑代码的重用程度。如果仅仅是某个页面使用到的代码，可以考虑内嵌在页面中，减少 HTTP 请求数。另外，可以在首页加载完成以后，预先加载子页面的资源。&lt;/p&gt; &lt;p&gt;&lt;a name=&quot;javascript-minify&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;javascriptcss&quot;&gt;压缩 JavaScript 和 CSS&lt;/h3&gt; &lt;p&gt;压缩代码可以移除非功能性的字符（注释、空格、空行等），减少文件大小，提高载入速度。&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;得益于 Node.js 的流行，开源社区涌现出许多高效、易用的前端优化工具，JavaScript 和 CSS 压缩类的，不敢说多如牛毛，多入鸡毛倒是一点不夸张，如 [UglifyJS 2] (&lt;a href=&quot;https://github.com/mishoo/UglifyJS2&quot;&gt;https://github.com/mishoo/UglifyJS2&lt;/a&gt;)、&lt;a href=&quot;https://www.npmjs.com/package/csso&quot;&gt;csso&lt;/a&gt;、&lt;a href=&quot;https://www.npmjs.com/package/cssnano&quot;&gt;cssnano&lt;/a&gt; 等。&lt;/p&gt; &lt;p&gt;对于内嵌的 CSS 和 JavaScript，也可以通过 &lt;a href=&quot;https://www.npmjs.com/package/htmlmin&quot;&gt;htmlmin&lt;/a&gt; 等工具压缩。&lt;/p&gt; &lt;p&gt;这些项目都有 Gulp、Webpack 等流行构建工具的配套版本。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;javascript-duplicate&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;&quot;&gt;移除重复脚本&lt;/h3&gt; &lt;p&gt;重复的脚本不仅产生不必要的 HTTP 请求，而且重复解析执行浪费时间和计算资源。&lt;/p&gt; &lt;p&gt;&lt;a name=&quot;javascript-dom&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;dom&quot;&gt;减少 DOM 操作&lt;/h3&gt; &lt;p&gt;JavaScript 操作 DOM 很慢，尤其是 DOM 节点很多时。&lt;/p&gt; &lt;p&gt;使用时应该注意：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;缓存已经访问过的元素；&lt;/li&gt; &lt;li&gt;使用 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/createDocumentFragment&quot;&gt;DocumentFragment&lt;/a&gt; 暂存 DOM，整理好以后再插入 DOM 树；&lt;/li&gt; &lt;li&gt;操作 className，而不是多次读写 &lt;code&gt;style&lt;/code&gt;；&lt;/li&gt; &lt;li&gt;避免使用 JavaScript 修复布局。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;a name=&quot;javascript-event&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;&quot;&gt;使用高效的事件处理&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;减少绑定事件监听的节点，如通过事件委托；&lt;/li&gt; &lt;li&gt;尽早处理事件，在 &lt;code&gt;DOMContentLoaded&lt;/code&gt; 即可进行，不用等到 &lt;code&gt;load&lt;/code&gt;以后。&lt;/li&gt; &lt;/ul&gt; &lt;blockquote&gt; &lt;p&gt;对于 &lt;code&gt;resize&lt;/code&gt;、&lt;code&gt;scroll&lt;/code&gt; 等触发频率极高的事件，应该通过 debounce 等机制降低处理程序执行频率。&lt;/p&gt; &lt;p&gt;TODO: 补充相关内容 &lt;a href=&quot;http://demo.nimius.net/debounce_throttle/&quot;&gt;http://demo.nimius.net/debounce_throttle/&lt;/a&gt;&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;image&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h2 id=&quot;&quot;&gt;图片&lt;/h2&gt; &lt;p&gt;&lt;a name=&quot;image-optimize&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;&quot;&gt;优化图片&lt;/h3&gt; &lt;blockquote&gt; &lt;p&gt;YDN &lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#opt_images&quot;&gt;列出的相关工具&lt;/a&gt; 缺乏易用性，建议参考以下工具。&lt;/p&gt; &lt;/blockquote&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://github.com/imagemin/imagemin&quot;&gt;imagemin&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://imageoptim.com/mac&quot;&gt;ImageOptim&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;blockquote&gt; &lt;p&gt;TODO:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;PNG 终极优化；&lt;/li&gt; &lt;li&gt;Webp 相关内容；&lt;/li&gt; &lt;li&gt;SVG 相关内容。&lt;/li&gt; &lt;/ul&gt; &lt;/blockquote&gt; &lt;p&gt;PNG 终极优化：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;http://www.queness.com/post/2507/most-effective-method-to-reduce-and-optimize-png-images&quot;&gt;Most Effective Method to Reduce and Optimize PNG Images&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.smashingmagazine.com/2009/07/clever-png-optimization-techniques/&quot;&gt;Clever PNG Optimization Techniques&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;a name=&quot;image-sprite&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;csssprite&quot;&gt;优化 CSS Sprite&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;水平排列 Sprite 中的图片，垂直排列会增加图片大小；&lt;/li&gt; &lt;li&gt;Spirite 中把颜色较近的组合在一起可以降低颜色数，理想状况是低于 256 色以适用 PNG8 格式；&lt;/li&gt; &lt;li&gt;不要在 Spirite 的图像中间留有较大空隙。减少空隙虽然不太影响文件大小，但可以降低用户代理把图片解压为像素图的内存消耗，对移动设备更友好。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;a name=&quot;image-scale&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;html&quot;&gt;不要在 HTML 中缩放图片&lt;/h3&gt; &lt;p&gt;不要使用 &lt;code&gt;&lt;img&gt;&lt;/code&gt; 的 &lt;code&gt;width&lt;/code&gt;、&lt;code&gt;height&lt;/code&gt; 缩放图片，如果用到小图片，就使用相应大小的图片。&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;很多 CMS 和 CDN 都提供图片裁切功能。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;image-favicon&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;faviconico&quot;&gt;使用体积小、可缓存的 favicon.ico&lt;/h3&gt; &lt;p&gt;Favicon.ico 一般存放在网站根目录下，无论是否在页面中设置，浏览器都会尝试请求这个文件。&lt;/p&gt; &lt;p&gt;所以确保这个图标：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;存在（避免 404）；&lt;/li&gt; &lt;li&gt;尽量小，最好小于 1K；&lt;/li&gt; &lt;li&gt;设置较长的过期时间。&lt;/li&gt; &lt;/ul&gt; &lt;blockquote&gt; &lt;p&gt;对于较新的浏览器，可以使用 PNG 格式的 favicon。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;参考链接：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://css-tricks.com/favicon-quiz/&quot;&gt;Favicons, Touch Icons, Tile Icons, etc. Which Do You Need?&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;h3 id=&quot;&quot;&gt;图片相关补充&lt;/h3&gt; &lt;blockquote&gt; &lt;p&gt;设置图片的宽和高，以免浏览器按照「猜」的宽高给图片保留的区域和实际宽高差异，产生重绘。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;mobile&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h2 id=&quot;&quot;&gt;移动端&lt;/h2&gt; &lt;blockquote&gt; &lt;p&gt;移动端优化相关内容有待进一步整理补充。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;a name=&quot;mobile-25k&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;25kb&quot;&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#under25&quot;&gt;保持单个文件小于 25 KB&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;&lt;a name=&quot;mobile-multipart&quot;&gt;&lt;/a&gt;&lt;/p&gt; &lt;h3 id=&quot;multipart&quot;&gt;&lt;a href=&quot;https://developer.yahoo.com/performance/rules.html#multipart&quot;&gt;打包内容为分段（multipart）文档&lt;/a&gt;&lt;/h3&gt; &lt;h2 id=&quot;&quot;&gt;参考链接&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;http://www.websiteoptimization.com/speed/tweak/psychology-web-performance/&quot;&gt;The Psychology of Web Performance&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/x-turndown&gt;</code></p>\n</blockquote>\n"},{"title":"Awesome Chrome 插件集锦","toc":false,"date":"2017-09-09T07:19:00.000Z","_content":"\n子曾曰：“工欲善其事，必先利其器。居是邦也。”——语出《论语·卫灵公》；其后一百多年，荀子也在其《劝学》中倡言道：“吾尝终日而思矣，不如须臾之所学也；吾尝跂而望矣，不如登高之博见也。登高而招，臂非加长也，而见者远；顺风而呼，声非加疾也，而闻者彰。假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也”。远从石器时代开始，先贤无不据此而行；时至今日，已将具器的职能，发挥到淋漓尽致之境界：倘若离开它的存在，人类已无法正常生活；斯可云鉴？\n\n[![Chrmme-500px](http://www.jixiaokang.com/wp-content/uploads/2018/05/nice-chrome.jpg)](http://www.jixiaokang.com/wp-content/uploads/2018/05/nice-chrome.jpg \"Chrmme-500px\")Chrmme-500px\n\n话说此篇不过是记载些，居家必备的  Chrome  插件而已；为何要这么一段缀为前言？缘由是，这其中蕴涵了一个劝解的倡导。著名财经作家吴晓波先生，有次谈及到亚当·格兰特写的一本书`《离经叛道》`；书中指出：离经叛道不是天生的特质，而是一种有意识的选择。为此作者讲了个有趣的小故事来证明这一点。\n\n> 经济学家迈克尔·豪斯曼主持了一个项目，研究为什么有些员工在工作岗位上的时间比其他人更久。在寻找线索的过程中，他发现：使用 Firefox 或 Chrome 浏览器的员工坚守在某一岗位上的时间，要比那些使用 IE 浏览器或 Safari 浏览器的员工长 15％，同时他们拥有更低的缺勤率和明显更高的销售额！\n\n几乎 2/3 的员工使用的是默认浏览器(Window 下 IE，Mac 下 Safari，国内小白选 360？)，从来没有质疑过是否存在一个更好的浏览器可以使用。主动选择浏览器的人，往往会在日常生活中寻找更好的选择，虽然这一行为并不显眼；但成功就属于拥有这极尽追求的一拨人。\n\n如若，你常用一项工具，然而你都未去全然了解它，以此推演之，又如何能在其他事情上获取成功呢？`够用就好`的心态，只会让你止于平庸，难以卓越。而这种心态，也会阻碍社会的进步，话说在国内，Windows 系统的 xp 版本 s 使用率，一度跟 win8 持平，而即便今时今日，Win10 都发布很久了，可是实用最多的却还是 Win7，😂；如果你愿意去追求品味与效率，你会发现，你该用 Mac，不是么？\n\n此篇主旨不在于去说教；但也不全然只是介绍些超好用的 Chrome 插件：毕竟 Chrome 上好用的插件，实在是多不胜数；如果你愿意，你也可不怎么费力的写一款。谈及以上那么多有的没的，也是想说明，当遇到问题，不妨思考下，当你遇到了，别人想必早已遇到并解决，你只需找到他们方案、并吸收为己用就好；站在巨人肩膀上前行，总比自己闭门挖坑来得要高明。见识得多了，用得熟了，思维变得宽阔了，有一天遇到未被解决得问题，想必那时也能如巨人一般，造它一个，享与他人；何乐不为？\n\n到此，废话暂时告一段落；进入正题，介绍些个人觉得超棒的工具，享与捧场的你。当然，你知道世事与人，皆在进步，我也不会例外。倘若很多神器，未曾提及，多半是见识的还不够多，还请在留言出不吝分享，先行谢过。\n\n## 高效篇\n\n### Vimium\n\n作为一款黑客级别的 Chrome 插件，对她的存在真是喜之不尽。为此，一年多以前特为她写了篇：[Vimium~让您的 Chrome 起飞](http://www.jeffjade.com/2015/10/19/2015-10-18-chrome-vimium/?jeffjade)。工欲善其事，必先利其器的理念，被此款插件体现的淋漓尽致：拥有她，从此脱离鼠标操纵 Chrome，且便捷数倍不止。`f`、`gg`、`G`、`gg`、`r`、`yy`、`yt`、`x`、`t`、`j`、`k`、`J`、`K`、`B`  等快捷键，皆是非常有用且常用的存在(也有同款名曰  *Vimium + Visual mode* )。当年有感叹到：“熟能生巧，至巧了，即可夺天之工”。高效必备，`Vimium`你值得拥有（★★★★★ ＋）[Vimium 链接直达](https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb)。\n\n[![Chrome-Vimium｜Form 500px](http://www.jixiaokang.com/wp-content/uploads/2018/05/558479-20170122200957410-312549711.jpg)](http://www.jixiaokang.com/wp-content/uploads/2018/05/558479-20170122200957410-312549711.jpg \"Chrome-Vimium｜Form 500px\")Chrome-Vimium ｜ Form 500px\n\n这里需要补充一款  `cVim`  插件，五星级插件，好评如潮；其功能与  `Vimium`  类似，而其功能目测要比她尤胜一筹(强化了搜索，Visual mode，以及文本选择等等)；如果志向于如极客一般操控你的 Chrome，那么不妨一试，兴许这  `cVim`  会为你打开一个全新的大门，祝好；(而我，已先迷恋  `Vimium`，短时间内不会移情别恋)； （★★★★★++）[cVim 链接直达](https://chrome.google.com/webstore/detail/cvim/ihlenndgcmojhcghmfjfneahoeklbjjh/reviews)。\n\n### Tampermonkey\n\n据悉，`Tampermonkey`，她是一款强大的难以想象的浏览器插件，俗称“油猴子”；据说，她是高手必备的 Chrome 扩展，毕竟只有高手中的高手，才能领略到 Tampermonkey 的优美；据坊间传言，就算 Chrome 没有其他扩展，只有 Tampermonkey，Chrome 依然能吸引到一大群死忠 … 其官方描述只一句  The world’s most popular userscript manager，但她的话题却是无尽的去延展；这是一款伟大的插件，各路高手对她的赞美，已然到无以复加的地步；个人品级不够，难叙她的强大，看管须自行探索；唯一句：略经初探，她的存在，就好如 Mac 系统下的第一神器  Alfred  一般，强于不强，不仅在软件本身，同时也取决于使用者的功夫，此路美景纵横，祝君好运(update @2017-01-24)。\n\n[Tampermonkey 链接直达](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo)\n\n### crxMouse Chrome Gestures\n\n方便,快捷,充分发掘鼠标的所有操作，功能包括：鼠标手势、超级拖曳、滚轮手势、摇杆手势、平滑滚动、标签页列表等。在用`Vimium`之前，这真是挺常用的利器；当然如果你喜欢用鼠标，这款与你来讲，再好没有；你可讲常用的操作，定制鼠标手势；比如前进、后退、在新的标签页打开(默认，点击该链接一拖即可)等等（★★★★）\n\n[![|Chrmme鼠标手势-jeffjade.com](http://www.jixiaokang.com/wp-content/uploads/2018/05/558479-20170122200310254-2024804592.jpg)](http://www.jixiaokang.com/wp-content/uploads/2018/05/558479-20170122200310254-2024804592.jpg \"|Chrmme鼠标手势-jeffjade.com\")|Chrmme 鼠标手势-jeffjade.com\n\n[链接直达](https://chrome.google.com/webstore/detail/crxmouse-chrome-gestures/jlgkpaicikihijadgifklkbpdajbkhjo)\n\n> *题外话：*  你知道工作之余，写篇博文颇为不易；然而，国内聚合网站可谓多不胜数，而某度搜索，很多时候，对`聚合`的亲睐竟远胜于原创，唉。为满足下那小小虚荣，不得不在此插播一则说明，此篇整理悉数出自[晚晴幽草轩](https://jeffjade.com/2017/01/23/118-chrome_awesome_plug-in/www.jeffjade.com)，欲转载以享之，烦请注明出处 (_^_^\\_)。\n\n## 利器篇\n\n### OneTab\n\n了不得，这款插件我也是异常喜欢。当你发现自己有太多的标签页时，单击 OneTab 图标，将所有标签页转换成一个列表。当你需要再次访问这些标签页时，可以单独或全部恢复它们（★★★★★）。\n\n[链接直达](https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall?hl=zh-CN)\n\n### The Great Suspender\n\n这是一款 Chrome 下的多标签页管理应用，用来临时休眠掉不使用的标签页，从而释放出更多的内存和资源，让你做更重要的事情；在需要的时候点一下就能恢复。这跟  `OneTab`  还是有些区别的。\n\n[链接直达](https://chrome.google.com/webstore/detail/the-great-suspender/klbibkeccnjlkjkiokjodocebajanakg?hl=zh-CN)\n\n### LastPass\n\n密码管理软件。可将你所有的密码信息保存起来，你再也无需记住复杂繁多的密码了，只需登录到 lastpass，然后保存你的密码，lastpass 会自动帮你完成登录，不需要输入密码。它还允许你从任何主流的密码存储器导入和导出密码，捕获其它管理器无法捕获的密码包括很多 AJAX 表单。也可轻松地创建强大的密码。敏感信息在上传之前已在本地计算机上加密，因此就算是 LastPass 的员工也无法得到密码信息。更妙 de 在于，lastpass 支持的不仅仅是 Chrome，还有 Firefox、opera，甚至 IE;当然如果你有一套完善便捷的密码方案，可忽略之（★★★★）。\n\n[链接直达](https://chrome.google.com/webstore/detail/lastpass/hdokiejnpimakedhajhdlcegeplioahd?hl=zh-CN)\n\n### Infinity 新标签页\n\nInfinity 新标签页，基于 Chrome 的云应用服务，让你更优雅、轻松地使用 Chrome：她不仅让你的 Chrome`新标签页`，变得很唯美(风景美图背景)，且能十分实用——你可添加多个应用入口，且可随性自定义；虽然这功能跟`Vimium`的`B`有些重叠，却也蛮喜欢她的存在（★★★★★）。\n\n[![Infinity新标签页|jeffjade.com](http://www.jixiaokang.com/wp-content/uploads/2018/05/InfinityE696B0E6A087E7ADBEE9A1B5.jpg)](http://www.jixiaokang.com/wp-content/uploads/2018/05/InfinityE696B0E6A087E7ADBEE9A1B5.jpg \"Infinity新标签页|jeffjade.com\")Infinity 新标签页|jeffjade.com\n\n### Momentum\n\n一款清新的新标签页插件，具有待办、天气、搜索功能，最最重要的是，插件的大背景，非常具有创意和艺术气息，每天更换；这跟`Infinity`同为美好的存在，如你更在意简洁文艺，不妨用此款(话说我司上下班打卡提示，就是此风)。  \ns  \n[链接直达](https://chrome.google.com/webstore/detail/momentum/laookkfknpbbblfpciffpaejjkokdgca)\n\n### 网页截图:注释&批注\n\n五星评级插件；她，可以捕获整个页面或任何部分(包括桌面窗口)，矩形，圆形，箭头，线条和文字，模糊敏感信息，一键上传，分享注释(也可以选择本地图片)。支持 PNG 和链接；实在是很有用的存在，值得拥有。\n\n[链接直达](https://chrome.google.com/webstore/detail/awesome-screenshot-screen/nlipoenfbbikpbjkfpfillcgkoblgpmj?hl=zh-CN)\n\n### Joxi Full Page Screen Capture\n\n`Joxi Full Page Screen Capture`  是一款可以帮助用户全屏截图的谷歌浏览器插件；用户在打开网页，需要截图的时候，不管该网页有没有滚动条，她都能完美地把整个网页进行截图。当然，也可以选取网页中的一部分进行截图，在选取了截图范围以后，用户还可以对截图进行简单的编辑。同类型的还有`Blipshot`（网页全屏、滚动截图）。\n\n[链接直达](https://chrome.google.com/webstore/detail/joxi-full-page-screen-cap/jhcdlkgjiehgpnpolkbnmpffjodigbkb?hl=zh-CN)\n\n### Print Friendly & PDF\n\n一款可以帮助用户自定义打印内容，以及打印格式的谷歌浏览器插件，同时支持 PDF 的格式打印。Chrome 自带打印功能(command p 或者右键)，但不能满足复杂点的需求；而这款插件的存在，就解决了很多人的刚需：1. 可以滤掉一些不想打印的内容(去除打印页面中的所有图片、删除网页中的广告、删除多余的文字等方便的自定义打印的功能)；2. 对打印的格式重新进行调整(比如调节打印的字体大小)；还支持查看打印历史等等，如此贴心，值得拥有。\n\n[链接直达](https://chrome.google.com/webstore/detail/print-friendly-pdf/ohlencieiipommannpdfcmfdpjjmeolj/related?hl=zh-CN)\n\n### 二维码(QR 码)生成器\n\n可以生成当前页面二维码，手机直接扫二维码就可以访问当前页面；虽不是很常用，但需要时候确实是挺有用。\n\n[链接直达](https://chrome.google.com/webstore/detail/%E4%BA%8C%E7%BB%B4%E7%A0%81qr%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/pflgjjogbmmcmfhfcnlohagkablhbpmg)\n\n### 花瓣网页收藏工具\n\n图片爱好者的福音。此款插件的作用在于，在网页上出现的图片，都可以直接点击收藏到花瓣，提供画板作为分类进行收集，以后找图片素材或者欣赏之前看到过的好的图片时很方便；个人也是一直将其常开着。\n\n[链接直达](https://chrome.google.com/webstore/detail/%E8%8A%B1%E7%93%A3%E7%BD%91%E9%A1%B5%E6%94%B6%E8%97%8F%E5%B7%A5%E5%85%B7/imamemhokkdleoelohnmkimbmpfglcil)\n\n## 清静篇\n\n### Adblock Plus\n\n免费的广告拦截器，可阻止所有烦人的广告及恶意软件和跟踪。享受没有恼人广告的网络世界，网冲必备。\n\n> 这里有必要补充一下，对此，有网友提出  `ADM`,`Adguard`，以及  `广告终结者`  等过滤广告的插件，且呼声蛮高。然而，在得知这些讯息后，我并没有想立即去体验；缘由是，够用就好   那懒的魔咒发作了；而据说，这`广告终结者`可以屏蔽掉视频中的广告，Look，当止于懒的时候，很可能就失掉了些美好，不是么？\n\n[![Chrome|Adblock Plus](http://www.jixiaokang.com/wp-content/uploads/2018/05/dsfdsfgdsg.png)](http://www.jixiaokang.com/wp-content/uploads/2018/05/dsfdsfgdsg.png \"Chrome|Adblock Plus\")Chrome|Adblock Plus\n\n[链接直达](https://chrome.google.com/webstore/detail/adblock-plus/cfhdojbkjhnklbpkdaibdccddilifddb)\n\n### [Stylish](https://userstyles.org/)\n\nRestyle the web with Stylish（为任意网站自定义主题） !  其官方描述为：利用用户样式管理器 Stylish 来重新编辑网站的样式。您可利用 Stylish 为许多网站安装主题和皮肤，也可创建自己的主题和皮肤。@少数派 有一篇文章[不喜欢某个网站的样子？用 Stylish 给它一键「换肤」](http://sspai.com/34508?from=jeffjade.com)，蛮详细的介绍了如何使用她，给常用网站换肤；譬  [Weibo-v6](https://userstyles.org/styles/106272/weibo-v6)，[flat-zhihu](https://userstyles.org/styles/108011/flat-zhihu-v2-4-12)  等，感觉还是蛮好的。当然，还可以使用 Stylish 自定义网页字体、实现去除广告、补全浏览器部分功能等等，这都属于进阶部分，需要额外去探索；坚信，主动去折腾，会让生活更多彩多姿（★★★★★）。Update@2017-02-03\n\n[链接直达](https://chrome.google.com/webstore/detail/stylish-custom-themes-for/fjnbnpbmkenffdnngjfgmeleoegfcffe?hl=zh-CN)\n\n### 阅读模式\n\n当你想用心去品味一篇文章时候，你会发现她的存在是多么的美好：她提供与 Safari 阅读模式功能一致的插件，浏览文章页时候可进入友好的阅读模式，并自定义阅读功能。同比之下，也体验下了`愉阅`，iReader，等等，效果都不如`阅读模式`来的简约和优美；[Fokus](https://chrome.google.com/webstore/detail/fokus/flkkpmjbbpijiedjdgnhkcgopgnflehe/related)，这个 喜欢鼠标覆盖一段文字阅读，把其它地方阴影，以此来聚集注意力，想法虽妙，却需要额外手动触发，得失之间，看个人取舍了！\n\n[![阅读模式-jeffjade.com](http://www.jixiaokang.com/wp-content/uploads/2018/05/E99885E8AFBBE6A8A1E5BC8F.jpg)](http://www.jixiaokang.com/wp-content/uploads/2018/05/E99885E8AFBBE6A8A1E5BC8F.jpg \"阅读模式-jeffjade.com\")阅读模式-jeffjade.com\n\n[链接直达](https://chrome.google.com/webstore/detail/reader-view/iibolhpkjjmoepndefdmdlmbpfhlgjpl/related?utm_source=chrome-app-launcher-info-dialog)\n\n### 一键管理所有扩展\n\n此插件为以前的一键禁用所有扩展-加强版。当你安装了蛮多好用插件之后，这款插件就显得很有作用了；要知道，很有用的插件，并不是都很常用，那些常驻内存，多少会导致浏览器会占用更多的消耗；而手动去在扩展中打开，用印度语讲，”亚克”！有这插件的存在，就好如男孩裤子有了拉链，Up 与 Down 之间就解决了两方面需求，值得拥有，If you Have More （★★★★★）。\n\n[![一键管理所有扩展插件-jeffjade.com](http://www.jixiaokang.com/wp-content/uploads/2018/05/E4B880E994AEE7AEA1E79086E68980E69C89E689A9E5B195.jpg)](http://www.jixiaokang.com/wp-content/uploads/2018/05/E4B880E994AEE7AEA1E79086E68980E69C89E689A9E5B195.jpg \"一键管理所有扩展插件-jeffjade.com\")一键管理所有扩展插件-jeffjade.com\n\n[链接直达](https://chrome.google.com/webstore/detail/%E4%B8%80%E9%94%AE%E7%AE%A1%E7%90%86%E6%89%80%E6%9C%89%E6%89%A9%E5%B1%95/niemebbfnfbjfojajlmnbiikmcpjkkja)\n\n### 眼不见心不烦\n\n此乃微博党的福音！在浏览器端，自己通过这个插件进行设置，可以将热门微博、会员推广等等内容窗口都给屏蔽了！还我们一个干净、舒服的微博环境！然而，在当下这手机端横行的年代，这款插件的辉煌，也就那样了(可微博客户端自行设置，据悉满多隐藏的功能)。\n\n## 开发篇\n\n作为程序开发者，遇到好多“程序员”，非常不熟悉所用的 Editor。对于那些漠视(或无视)工具的 Coder，多少有些劝导（虽然，这看起来有点像我悟到出家了，也欲劝他们也剃度似的）。可是，这里倒的确有番说辞的是，程序语言也好、内功心法也罢，还是这 Chrome，那 Sublime 等等，归其根都是工具的范畴，有什么好漠视的？反倒是，对编辑器，PS，Sketch 等工具的熟悉，当是早于那些语言的；毕竟，你应该明白，编程的时候，不能被输出给限制太多不是？再者，既有的工具不用，反倒是以步代车，是何道理？(以步代车，还能借机会锻炼下身子呢，那么有 Tools 不用的你呢？)。\n\n### Json-Handle\n\n她可以帮助你在浏览器中查看 JSON 数据，并以优美的树视图姿势，展示出对应数据；如果你愿意，还可以配置快捷键，所需之时，一键呼出。在同类型插件中，这款是所见过最靓丽多姿的，并且功能完善；开发调试、手写 JSON，常备良品 （★★★★★）。\n\n[链接直达](https://chrome.google.com/webstore/detail/json-handle/iahnhfdhidomcpggpaimmmahffihkfnj?hl=zh-CN)\n\n### Postman\n\n口碑极好的一款接口调试工具；不管是从事前端，还是移动端开发，这都是一款必备神器；如若还未用它嗨起来，想必多少会加点儿班来嗨了(当然，这是一句玩笑话；毕竟即便不用，很多时候加点班都是少不了的) （★★★★★）。\n\n[链接直达](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop)\n\n### Vue React AngularJS Devtools\n\nVue 调试工具。如果你如今从事前端开发，大行其道的 MVVM 框架，决计是绕不过去的存在。那么以下是三大流行框架 Devtools，如需自取。  \n[Vue.js devtools](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd)\n\n[AngularJS Batarang](https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk)\n\n[React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)\n\n### Octotree\n\nCode tree for GitHub and GitLab；作为五星好评的存在，大有相见恨晚的感觉，值得拥有；当你翻别人源码的时候，是否很苦恼，特别是你的网络不给力的时候，简直很抓狂，有否？而 Octotree 的存在，就是帮助你整理出来项目文件列表，立于侧边，好如编辑器一般；正如网友评论道： Can’t love it MORE （★★★★★）。\n\n[链接直达](https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc/reviews)\n\n### Allow-Control-Allow-Origin: \\*\n\nJS 同源策略保障我们的页面安全；但是开发期间，大家并不想看到这烦人的家伙；尤其是如今前后端分离的时代，你总是需要些办法以解决跨域，比如`代理`、`JSONP`、`改Host`等等；而使用  `Allow-Control-Allow-Origin: *`插件轻松解决这个问题。\n\n[链接直达](https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi)\n\n### WEB 前端助手(FeHelper)\n\nFE 助手：包括字符串编解码、图片 base64 编码、代码压缩、美化、JSON 格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、栅格检测、JS 运行效率分析等。\n\n[链接直达](https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad)\n\n### CSSViewer\n\nCSSViewer 是一个简单的 CSS 属性查看器。它有一个浮动面板，指明鼠标所在处信息，提供其字体、文本、颜色、背景、框、定位和效果属性的说明。 CSSViewer 可以快速提供需要的基本 CSS 信息。\n\n[链接直达](https://chrome.google.com/webstore/detail/cssviewer/ggfgijbpiheegefliciemofobhmofgce)\n\n### [Wappalyzer](https://wappalyzer.com/?from=jeffjade.com)\n\nIdentifies software on the web；`Wappalyzer`  是一个浏览器扩展，义译为 Web 应用指纹识别，它能够揭示某网站上使用的技术。它可以检测内容管理系统，电子商务平台，Web 服务器，JavaScript 框架，分析工具等等；浏览 Wappalyzer 能够检测到的应用的完整列表：[https://wappalyzer.com/applications](https://wappalyzer.com/applications) 。据悉为渗透工程师必备，同比之下还有  `HackBar`、`Tamper Data`等等；倘若，你想知道一个网站，使用什么技术，用此插件就对了。\n\n[链接直达](https://chrome.google.com/webstore/detail/wappalyzer/gppongmhjkpfnbhagpmjfkannfbllamg?hl=zh-CN)\n\n## 其他篇\n\n- [SwitchyOmega](https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif/reviews?hl=zh-CN)  五星级好评的存在(可以感受到，我朝爱自由上网的渴望与热忱)；她，轻松快捷地管理和切换多个代理设置，据悉常与`shadowsocks`互相配合，来完成科学上网的美好愿景。\n\n- [v2ex-plus](https://chrome.google.com/webstore/detail/v2ex-plus/daeclijmnojoemooblcbfeeceopnkolo/related): 如果你常去  `V2ex`  跟程序员们一起聊聊天，吹吹水，涨涨姿势，发发帖子，可用之。\n\n- [掘金](https://chrome.google.com/webstore/detail/%E6%8E%98%E9%87%91/lecdifefmmfjnjjinhaennhdlmcaeeeb)  是一款技术分享社区，前端后端，设计产品都有涵盖，质量还好；这款插件即可一键打开之（备注，它默认当你打开新标签页就是打开它，虽可设置，但和 Infinity 目测有水火不容的冲突，然后就没然后了）爱学习如你，倒可以 Install 一下试试 (这不是广告，至少没钱拿)。\n\n## 写在最后\n\n工欲善其事，必先利其器，人们总是低估工具对自己心智模式的影响，请记住，好工具是好思想的容器；好工具也会蕴含好知识；如果你能学会善假于物也，自然界间，互联网里，包罗万象，任君所学；何须如今那些 “Teacher” 来猥亵了你的创造力？求知欲和热情的坚持，才是最好的师傅。闲言暂住，回到 Chrome 插件话题；Chrome 插件多不能数，非一篇能全之，那么你有什么好用的插件呢？期待共享。\n\n> 微注：  个人的见识总是有限的，所以有在 @V2EX 发帖  [那些你觉得堪称神兵利器的 Chrome 插件](https://www.v2ex.com/t/336428?from=jeffjade.com)，在猴鸡交替之际，引发了网友热议，收获颇丰；文章中不少插件的推荐，就来源此处；如需增长见闻，不妨细观；另外，也有在 @黑客派 发帖[谈谈你觉得堪称神兵利器的 Chrome 插件](https://hacpai.com/article/1485149167264?from=jeffjade.com)。\n\n值此将新年之际，大家都在忙着支付宝`积福`，或 QQ`红包`，或者享受回家团圆之乐，我则终将这篇文章整理了出来(后续漫加)；如果觉得有用，不妨考虑打赏一杯咖啡？好让在那些偶尔闲暇的夜里，可以有精神去敲敲打打，产出些有所用的文字。谨在此恭祝我朝人民：天天开心，事事顺心；新春快乐，阖家欢乐。\n","source":"_posts/2017-09-09-chrome插件.md","raw":"---\ntitle: Awesome Chrome 插件集锦\ntags:\n  - 工具\ntoc: false\ndate: 2017-09-09 15:19:00\ncategories: 工具\n---\n\n子曾曰：“工欲善其事，必先利其器。居是邦也。”——语出《论语·卫灵公》；其后一百多年，荀子也在其《劝学》中倡言道：“吾尝终日而思矣，不如须臾之所学也；吾尝跂而望矣，不如登高之博见也。登高而招，臂非加长也，而见者远；顺风而呼，声非加疾也，而闻者彰。假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也”。远从石器时代开始，先贤无不据此而行；时至今日，已将具器的职能，发挥到淋漓尽致之境界：倘若离开它的存在，人类已无法正常生活；斯可云鉴？\n\n[![Chrmme-500px](http://www.jixiaokang.com/wp-content/uploads/2018/05/nice-chrome.jpg)](http://www.jixiaokang.com/wp-content/uploads/2018/05/nice-chrome.jpg \"Chrmme-500px\")Chrmme-500px\n\n话说此篇不过是记载些，居家必备的  Chrome  插件而已；为何要这么一段缀为前言？缘由是，这其中蕴涵了一个劝解的倡导。著名财经作家吴晓波先生，有次谈及到亚当·格兰特写的一本书`《离经叛道》`；书中指出：离经叛道不是天生的特质，而是一种有意识的选择。为此作者讲了个有趣的小故事来证明这一点。\n\n> 经济学家迈克尔·豪斯曼主持了一个项目，研究为什么有些员工在工作岗位上的时间比其他人更久。在寻找线索的过程中，他发现：使用 Firefox 或 Chrome 浏览器的员工坚守在某一岗位上的时间，要比那些使用 IE 浏览器或 Safari 浏览器的员工长 15％，同时他们拥有更低的缺勤率和明显更高的销售额！\n\n几乎 2/3 的员工使用的是默认浏览器(Window 下 IE，Mac 下 Safari，国内小白选 360？)，从来没有质疑过是否存在一个更好的浏览器可以使用。主动选择浏览器的人，往往会在日常生活中寻找更好的选择，虽然这一行为并不显眼；但成功就属于拥有这极尽追求的一拨人。\n\n如若，你常用一项工具，然而你都未去全然了解它，以此推演之，又如何能在其他事情上获取成功呢？`够用就好`的心态，只会让你止于平庸，难以卓越。而这种心态，也会阻碍社会的进步，话说在国内，Windows 系统的 xp 版本 s 使用率，一度跟 win8 持平，而即便今时今日，Win10 都发布很久了，可是实用最多的却还是 Win7，😂；如果你愿意去追求品味与效率，你会发现，你该用 Mac，不是么？\n\n此篇主旨不在于去说教；但也不全然只是介绍些超好用的 Chrome 插件：毕竟 Chrome 上好用的插件，实在是多不胜数；如果你愿意，你也可不怎么费力的写一款。谈及以上那么多有的没的，也是想说明，当遇到问题，不妨思考下，当你遇到了，别人想必早已遇到并解决，你只需找到他们方案、并吸收为己用就好；站在巨人肩膀上前行，总比自己闭门挖坑来得要高明。见识得多了，用得熟了，思维变得宽阔了，有一天遇到未被解决得问题，想必那时也能如巨人一般，造它一个，享与他人；何乐不为？\n\n到此，废话暂时告一段落；进入正题，介绍些个人觉得超棒的工具，享与捧场的你。当然，你知道世事与人，皆在进步，我也不会例外。倘若很多神器，未曾提及，多半是见识的还不够多，还请在留言出不吝分享，先行谢过。\n\n## 高效篇\n\n### Vimium\n\n作为一款黑客级别的 Chrome 插件，对她的存在真是喜之不尽。为此，一年多以前特为她写了篇：[Vimium~让您的 Chrome 起飞](http://www.jeffjade.com/2015/10/19/2015-10-18-chrome-vimium/?jeffjade)。工欲善其事，必先利其器的理念，被此款插件体现的淋漓尽致：拥有她，从此脱离鼠标操纵 Chrome，且便捷数倍不止。`f`、`gg`、`G`、`gg`、`r`、`yy`、`yt`、`x`、`t`、`j`、`k`、`J`、`K`、`B`  等快捷键，皆是非常有用且常用的存在(也有同款名曰  *Vimium + Visual mode* )。当年有感叹到：“熟能生巧，至巧了，即可夺天之工”。高效必备，`Vimium`你值得拥有（★★★★★ ＋）[Vimium 链接直达](https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb)。\n\n[![Chrome-Vimium｜Form 500px](http://www.jixiaokang.com/wp-content/uploads/2018/05/558479-20170122200957410-312549711.jpg)](http://www.jixiaokang.com/wp-content/uploads/2018/05/558479-20170122200957410-312549711.jpg \"Chrome-Vimium｜Form 500px\")Chrome-Vimium ｜ Form 500px\n\n这里需要补充一款  `cVim`  插件，五星级插件，好评如潮；其功能与  `Vimium`  类似，而其功能目测要比她尤胜一筹(强化了搜索，Visual mode，以及文本选择等等)；如果志向于如极客一般操控你的 Chrome，那么不妨一试，兴许这  `cVim`  会为你打开一个全新的大门，祝好；(而我，已先迷恋  `Vimium`，短时间内不会移情别恋)； （★★★★★++）[cVim 链接直达](https://chrome.google.com/webstore/detail/cvim/ihlenndgcmojhcghmfjfneahoeklbjjh/reviews)。\n\n### Tampermonkey\n\n据悉，`Tampermonkey`，她是一款强大的难以想象的浏览器插件，俗称“油猴子”；据说，她是高手必备的 Chrome 扩展，毕竟只有高手中的高手，才能领略到 Tampermonkey 的优美；据坊间传言，就算 Chrome 没有其他扩展，只有 Tampermonkey，Chrome 依然能吸引到一大群死忠 … 其官方描述只一句  The world’s most popular userscript manager，但她的话题却是无尽的去延展；这是一款伟大的插件，各路高手对她的赞美，已然到无以复加的地步；个人品级不够，难叙她的强大，看管须自行探索；唯一句：略经初探，她的存在，就好如 Mac 系统下的第一神器  Alfred  一般，强于不强，不仅在软件本身，同时也取决于使用者的功夫，此路美景纵横，祝君好运(update @2017-01-24)。\n\n[Tampermonkey 链接直达](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo)\n\n### crxMouse Chrome Gestures\n\n方便,快捷,充分发掘鼠标的所有操作，功能包括：鼠标手势、超级拖曳、滚轮手势、摇杆手势、平滑滚动、标签页列表等。在用`Vimium`之前，这真是挺常用的利器；当然如果你喜欢用鼠标，这款与你来讲，再好没有；你可讲常用的操作，定制鼠标手势；比如前进、后退、在新的标签页打开(默认，点击该链接一拖即可)等等（★★★★）\n\n[![|Chrmme鼠标手势-jeffjade.com](http://www.jixiaokang.com/wp-content/uploads/2018/05/558479-20170122200310254-2024804592.jpg)](http://www.jixiaokang.com/wp-content/uploads/2018/05/558479-20170122200310254-2024804592.jpg \"|Chrmme鼠标手势-jeffjade.com\")|Chrmme 鼠标手势-jeffjade.com\n\n[链接直达](https://chrome.google.com/webstore/detail/crxmouse-chrome-gestures/jlgkpaicikihijadgifklkbpdajbkhjo)\n\n> *题外话：*  你知道工作之余，写篇博文颇为不易；然而，国内聚合网站可谓多不胜数，而某度搜索，很多时候，对`聚合`的亲睐竟远胜于原创，唉。为满足下那小小虚荣，不得不在此插播一则说明，此篇整理悉数出自[晚晴幽草轩](https://jeffjade.com/2017/01/23/118-chrome_awesome_plug-in/www.jeffjade.com)，欲转载以享之，烦请注明出处 (_^_^\\_)。\n\n## 利器篇\n\n### OneTab\n\n了不得，这款插件我也是异常喜欢。当你发现自己有太多的标签页时，单击 OneTab 图标，将所有标签页转换成一个列表。当你需要再次访问这些标签页时，可以单独或全部恢复它们（★★★★★）。\n\n[链接直达](https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall?hl=zh-CN)\n\n### The Great Suspender\n\n这是一款 Chrome 下的多标签页管理应用，用来临时休眠掉不使用的标签页，从而释放出更多的内存和资源，让你做更重要的事情；在需要的时候点一下就能恢复。这跟  `OneTab`  还是有些区别的。\n\n[链接直达](https://chrome.google.com/webstore/detail/the-great-suspender/klbibkeccnjlkjkiokjodocebajanakg?hl=zh-CN)\n\n### LastPass\n\n密码管理软件。可将你所有的密码信息保存起来，你再也无需记住复杂繁多的密码了，只需登录到 lastpass，然后保存你的密码，lastpass 会自动帮你完成登录，不需要输入密码。它还允许你从任何主流的密码存储器导入和导出密码，捕获其它管理器无法捕获的密码包括很多 AJAX 表单。也可轻松地创建强大的密码。敏感信息在上传之前已在本地计算机上加密，因此就算是 LastPass 的员工也无法得到密码信息。更妙 de 在于，lastpass 支持的不仅仅是 Chrome，还有 Firefox、opera，甚至 IE;当然如果你有一套完善便捷的密码方案，可忽略之（★★★★）。\n\n[链接直达](https://chrome.google.com/webstore/detail/lastpass/hdokiejnpimakedhajhdlcegeplioahd?hl=zh-CN)\n\n### Infinity 新标签页\n\nInfinity 新标签页，基于 Chrome 的云应用服务，让你更优雅、轻松地使用 Chrome：她不仅让你的 Chrome`新标签页`，变得很唯美(风景美图背景)，且能十分实用——你可添加多个应用入口，且可随性自定义；虽然这功能跟`Vimium`的`B`有些重叠，却也蛮喜欢她的存在（★★★★★）。\n\n[![Infinity新标签页|jeffjade.com](http://www.jixiaokang.com/wp-content/uploads/2018/05/InfinityE696B0E6A087E7ADBEE9A1B5.jpg)](http://www.jixiaokang.com/wp-content/uploads/2018/05/InfinityE696B0E6A087E7ADBEE9A1B5.jpg \"Infinity新标签页|jeffjade.com\")Infinity 新标签页|jeffjade.com\n\n### Momentum\n\n一款清新的新标签页插件，具有待办、天气、搜索功能，最最重要的是，插件的大背景，非常具有创意和艺术气息，每天更换；这跟`Infinity`同为美好的存在，如你更在意简洁文艺，不妨用此款(话说我司上下班打卡提示，就是此风)。  \ns  \n[链接直达](https://chrome.google.com/webstore/detail/momentum/laookkfknpbbblfpciffpaejjkokdgca)\n\n### 网页截图:注释&批注\n\n五星评级插件；她，可以捕获整个页面或任何部分(包括桌面窗口)，矩形，圆形，箭头，线条和文字，模糊敏感信息，一键上传，分享注释(也可以选择本地图片)。支持 PNG 和链接；实在是很有用的存在，值得拥有。\n\n[链接直达](https://chrome.google.com/webstore/detail/awesome-screenshot-screen/nlipoenfbbikpbjkfpfillcgkoblgpmj?hl=zh-CN)\n\n### Joxi Full Page Screen Capture\n\n`Joxi Full Page Screen Capture`  是一款可以帮助用户全屏截图的谷歌浏览器插件；用户在打开网页，需要截图的时候，不管该网页有没有滚动条，她都能完美地把整个网页进行截图。当然，也可以选取网页中的一部分进行截图，在选取了截图范围以后，用户还可以对截图进行简单的编辑。同类型的还有`Blipshot`（网页全屏、滚动截图）。\n\n[链接直达](https://chrome.google.com/webstore/detail/joxi-full-page-screen-cap/jhcdlkgjiehgpnpolkbnmpffjodigbkb?hl=zh-CN)\n\n### Print Friendly & PDF\n\n一款可以帮助用户自定义打印内容，以及打印格式的谷歌浏览器插件，同时支持 PDF 的格式打印。Chrome 自带打印功能(command p 或者右键)，但不能满足复杂点的需求；而这款插件的存在，就解决了很多人的刚需：1. 可以滤掉一些不想打印的内容(去除打印页面中的所有图片、删除网页中的广告、删除多余的文字等方便的自定义打印的功能)；2. 对打印的格式重新进行调整(比如调节打印的字体大小)；还支持查看打印历史等等，如此贴心，值得拥有。\n\n[链接直达](https://chrome.google.com/webstore/detail/print-friendly-pdf/ohlencieiipommannpdfcmfdpjjmeolj/related?hl=zh-CN)\n\n### 二维码(QR 码)生成器\n\n可以生成当前页面二维码，手机直接扫二维码就可以访问当前页面；虽不是很常用，但需要时候确实是挺有用。\n\n[链接直达](https://chrome.google.com/webstore/detail/%E4%BA%8C%E7%BB%B4%E7%A0%81qr%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/pflgjjogbmmcmfhfcnlohagkablhbpmg)\n\n### 花瓣网页收藏工具\n\n图片爱好者的福音。此款插件的作用在于，在网页上出现的图片，都可以直接点击收藏到花瓣，提供画板作为分类进行收集，以后找图片素材或者欣赏之前看到过的好的图片时很方便；个人也是一直将其常开着。\n\n[链接直达](https://chrome.google.com/webstore/detail/%E8%8A%B1%E7%93%A3%E7%BD%91%E9%A1%B5%E6%94%B6%E8%97%8F%E5%B7%A5%E5%85%B7/imamemhokkdleoelohnmkimbmpfglcil)\n\n## 清静篇\n\n### Adblock Plus\n\n免费的广告拦截器，可阻止所有烦人的广告及恶意软件和跟踪。享受没有恼人广告的网络世界，网冲必备。\n\n> 这里有必要补充一下，对此，有网友提出  `ADM`,`Adguard`，以及  `广告终结者`  等过滤广告的插件，且呼声蛮高。然而，在得知这些讯息后，我并没有想立即去体验；缘由是，够用就好   那懒的魔咒发作了；而据说，这`广告终结者`可以屏蔽掉视频中的广告，Look，当止于懒的时候，很可能就失掉了些美好，不是么？\n\n[![Chrome|Adblock Plus](http://www.jixiaokang.com/wp-content/uploads/2018/05/dsfdsfgdsg.png)](http://www.jixiaokang.com/wp-content/uploads/2018/05/dsfdsfgdsg.png \"Chrome|Adblock Plus\")Chrome|Adblock Plus\n\n[链接直达](https://chrome.google.com/webstore/detail/adblock-plus/cfhdojbkjhnklbpkdaibdccddilifddb)\n\n### [Stylish](https://userstyles.org/)\n\nRestyle the web with Stylish（为任意网站自定义主题） !  其官方描述为：利用用户样式管理器 Stylish 来重新编辑网站的样式。您可利用 Stylish 为许多网站安装主题和皮肤，也可创建自己的主题和皮肤。@少数派 有一篇文章[不喜欢某个网站的样子？用 Stylish 给它一键「换肤」](http://sspai.com/34508?from=jeffjade.com)，蛮详细的介绍了如何使用她，给常用网站换肤；譬  [Weibo-v6](https://userstyles.org/styles/106272/weibo-v6)，[flat-zhihu](https://userstyles.org/styles/108011/flat-zhihu-v2-4-12)  等，感觉还是蛮好的。当然，还可以使用 Stylish 自定义网页字体、实现去除广告、补全浏览器部分功能等等，这都属于进阶部分，需要额外去探索；坚信，主动去折腾，会让生活更多彩多姿（★★★★★）。Update@2017-02-03\n\n[链接直达](https://chrome.google.com/webstore/detail/stylish-custom-themes-for/fjnbnpbmkenffdnngjfgmeleoegfcffe?hl=zh-CN)\n\n### 阅读模式\n\n当你想用心去品味一篇文章时候，你会发现她的存在是多么的美好：她提供与 Safari 阅读模式功能一致的插件，浏览文章页时候可进入友好的阅读模式，并自定义阅读功能。同比之下，也体验下了`愉阅`，iReader，等等，效果都不如`阅读模式`来的简约和优美；[Fokus](https://chrome.google.com/webstore/detail/fokus/flkkpmjbbpijiedjdgnhkcgopgnflehe/related)，这个 喜欢鼠标覆盖一段文字阅读，把其它地方阴影，以此来聚集注意力，想法虽妙，却需要额外手动触发，得失之间，看个人取舍了！\n\n[![阅读模式-jeffjade.com](http://www.jixiaokang.com/wp-content/uploads/2018/05/E99885E8AFBBE6A8A1E5BC8F.jpg)](http://www.jixiaokang.com/wp-content/uploads/2018/05/E99885E8AFBBE6A8A1E5BC8F.jpg \"阅读模式-jeffjade.com\")阅读模式-jeffjade.com\n\n[链接直达](https://chrome.google.com/webstore/detail/reader-view/iibolhpkjjmoepndefdmdlmbpfhlgjpl/related?utm_source=chrome-app-launcher-info-dialog)\n\n### 一键管理所有扩展\n\n此插件为以前的一键禁用所有扩展-加强版。当你安装了蛮多好用插件之后，这款插件就显得很有作用了；要知道，很有用的插件，并不是都很常用，那些常驻内存，多少会导致浏览器会占用更多的消耗；而手动去在扩展中打开，用印度语讲，”亚克”！有这插件的存在，就好如男孩裤子有了拉链，Up 与 Down 之间就解决了两方面需求，值得拥有，If you Have More （★★★★★）。\n\n[![一键管理所有扩展插件-jeffjade.com](http://www.jixiaokang.com/wp-content/uploads/2018/05/E4B880E994AEE7AEA1E79086E68980E69C89E689A9E5B195.jpg)](http://www.jixiaokang.com/wp-content/uploads/2018/05/E4B880E994AEE7AEA1E79086E68980E69C89E689A9E5B195.jpg \"一键管理所有扩展插件-jeffjade.com\")一键管理所有扩展插件-jeffjade.com\n\n[链接直达](https://chrome.google.com/webstore/detail/%E4%B8%80%E9%94%AE%E7%AE%A1%E7%90%86%E6%89%80%E6%9C%89%E6%89%A9%E5%B1%95/niemebbfnfbjfojajlmnbiikmcpjkkja)\n\n### 眼不见心不烦\n\n此乃微博党的福音！在浏览器端，自己通过这个插件进行设置，可以将热门微博、会员推广等等内容窗口都给屏蔽了！还我们一个干净、舒服的微博环境！然而，在当下这手机端横行的年代，这款插件的辉煌，也就那样了(可微博客户端自行设置，据悉满多隐藏的功能)。\n\n## 开发篇\n\n作为程序开发者，遇到好多“程序员”，非常不熟悉所用的 Editor。对于那些漠视(或无视)工具的 Coder，多少有些劝导（虽然，这看起来有点像我悟到出家了，也欲劝他们也剃度似的）。可是，这里倒的确有番说辞的是，程序语言也好、内功心法也罢，还是这 Chrome，那 Sublime 等等，归其根都是工具的范畴，有什么好漠视的？反倒是，对编辑器，PS，Sketch 等工具的熟悉，当是早于那些语言的；毕竟，你应该明白，编程的时候，不能被输出给限制太多不是？再者，既有的工具不用，反倒是以步代车，是何道理？(以步代车，还能借机会锻炼下身子呢，那么有 Tools 不用的你呢？)。\n\n### Json-Handle\n\n她可以帮助你在浏览器中查看 JSON 数据，并以优美的树视图姿势，展示出对应数据；如果你愿意，还可以配置快捷键，所需之时，一键呼出。在同类型插件中，这款是所见过最靓丽多姿的，并且功能完善；开发调试、手写 JSON，常备良品 （★★★★★）。\n\n[链接直达](https://chrome.google.com/webstore/detail/json-handle/iahnhfdhidomcpggpaimmmahffihkfnj?hl=zh-CN)\n\n### Postman\n\n口碑极好的一款接口调试工具；不管是从事前端，还是移动端开发，这都是一款必备神器；如若还未用它嗨起来，想必多少会加点儿班来嗨了(当然，这是一句玩笑话；毕竟即便不用，很多时候加点班都是少不了的) （★★★★★）。\n\n[链接直达](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop)\n\n### Vue React AngularJS Devtools\n\nVue 调试工具。如果你如今从事前端开发，大行其道的 MVVM 框架，决计是绕不过去的存在。那么以下是三大流行框架 Devtools，如需自取。  \n[Vue.js devtools](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd)\n\n[AngularJS Batarang](https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk)\n\n[React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)\n\n### Octotree\n\nCode tree for GitHub and GitLab；作为五星好评的存在，大有相见恨晚的感觉，值得拥有；当你翻别人源码的时候，是否很苦恼，特别是你的网络不给力的时候，简直很抓狂，有否？而 Octotree 的存在，就是帮助你整理出来项目文件列表，立于侧边，好如编辑器一般；正如网友评论道： Can’t love it MORE （★★★★★）。\n\n[链接直达](https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc/reviews)\n\n### Allow-Control-Allow-Origin: \\*\n\nJS 同源策略保障我们的页面安全；但是开发期间，大家并不想看到这烦人的家伙；尤其是如今前后端分离的时代，你总是需要些办法以解决跨域，比如`代理`、`JSONP`、`改Host`等等；而使用  `Allow-Control-Allow-Origin: *`插件轻松解决这个问题。\n\n[链接直达](https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi)\n\n### WEB 前端助手(FeHelper)\n\nFE 助手：包括字符串编解码、图片 base64 编码、代码压缩、美化、JSON 格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、栅格检测、JS 运行效率分析等。\n\n[链接直达](https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad)\n\n### CSSViewer\n\nCSSViewer 是一个简单的 CSS 属性查看器。它有一个浮动面板，指明鼠标所在处信息，提供其字体、文本、颜色、背景、框、定位和效果属性的说明。 CSSViewer 可以快速提供需要的基本 CSS 信息。\n\n[链接直达](https://chrome.google.com/webstore/detail/cssviewer/ggfgijbpiheegefliciemofobhmofgce)\n\n### [Wappalyzer](https://wappalyzer.com/?from=jeffjade.com)\n\nIdentifies software on the web；`Wappalyzer`  是一个浏览器扩展，义译为 Web 应用指纹识别，它能够揭示某网站上使用的技术。它可以检测内容管理系统，电子商务平台，Web 服务器，JavaScript 框架，分析工具等等；浏览 Wappalyzer 能够检测到的应用的完整列表：[https://wappalyzer.com/applications](https://wappalyzer.com/applications) 。据悉为渗透工程师必备，同比之下还有  `HackBar`、`Tamper Data`等等；倘若，你想知道一个网站，使用什么技术，用此插件就对了。\n\n[链接直达](https://chrome.google.com/webstore/detail/wappalyzer/gppongmhjkpfnbhagpmjfkannfbllamg?hl=zh-CN)\n\n## 其他篇\n\n- [SwitchyOmega](https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif/reviews?hl=zh-CN)  五星级好评的存在(可以感受到，我朝爱自由上网的渴望与热忱)；她，轻松快捷地管理和切换多个代理设置，据悉常与`shadowsocks`互相配合，来完成科学上网的美好愿景。\n\n- [v2ex-plus](https://chrome.google.com/webstore/detail/v2ex-plus/daeclijmnojoemooblcbfeeceopnkolo/related): 如果你常去  `V2ex`  跟程序员们一起聊聊天，吹吹水，涨涨姿势，发发帖子，可用之。\n\n- [掘金](https://chrome.google.com/webstore/detail/%E6%8E%98%E9%87%91/lecdifefmmfjnjjinhaennhdlmcaeeeb)  是一款技术分享社区，前端后端，设计产品都有涵盖，质量还好；这款插件即可一键打开之（备注，它默认当你打开新标签页就是打开它，虽可设置，但和 Infinity 目测有水火不容的冲突，然后就没然后了）爱学习如你，倒可以 Install 一下试试 (这不是广告，至少没钱拿)。\n\n## 写在最后\n\n工欲善其事，必先利其器，人们总是低估工具对自己心智模式的影响，请记住，好工具是好思想的容器；好工具也会蕴含好知识；如果你能学会善假于物也，自然界间，互联网里，包罗万象，任君所学；何须如今那些 “Teacher” 来猥亵了你的创造力？求知欲和热情的坚持，才是最好的师傅。闲言暂住，回到 Chrome 插件话题；Chrome 插件多不能数，非一篇能全之，那么你有什么好用的插件呢？期待共享。\n\n> 微注：  个人的见识总是有限的，所以有在 @V2EX 发帖  [那些你觉得堪称神兵利器的 Chrome 插件](https://www.v2ex.com/t/336428?from=jeffjade.com)，在猴鸡交替之际，引发了网友热议，收获颇丰；文章中不少插件的推荐，就来源此处；如需增长见闻，不妨细观；另外，也有在 @黑客派 发帖[谈谈你觉得堪称神兵利器的 Chrome 插件](https://hacpai.com/article/1485149167264?from=jeffjade.com)。\n\n值此将新年之际，大家都在忙着支付宝`积福`，或 QQ`红包`，或者享受回家团圆之乐，我则终将这篇文章整理了出来(后续漫加)；如果觉得有用，不妨考虑打赏一杯咖啡？好让在那些偶尔闲暇的夜里，可以有精神去敲敲打打，产出些有所用的文字。谨在此恭祝我朝人民：天天开心，事事顺心；新春快乐，阖家欢乐。\n","slug":"2017-09-09-chrome插件","published":1,"updated":"2020-03-14T06:47:35.163Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvnz006q4k8yh8bn1izl","content":"<p>子曾曰：“工欲善其事，必先利其器。居是邦也。”——语出《论语·卫灵公》；其后一百多年，荀子也在其《劝学》中倡言道：“吾尝终日而思矣，不如须臾之所学也；吾尝跂而望矣，不如登高之博见也。登高而招，臂非加长也，而见者远；顺风而呼，声非加疾也，而闻者彰。假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也”。远从石器时代开始，先贤无不据此而行；时至今日，已将具器的职能，发挥到淋漓尽致之境界：倘若离开它的存在，人类已无法正常生活；斯可云鉴？</p>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/nice-chrome.jpg\" target=\"_blank\" rel=\"noopener\" title=\"Chrmme-500px\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/nice-chrome.jpg\" alt=\"Chrmme-500px\"></a>Chrmme-500px</p>\n<p>话说此篇不过是记载些，居家必备的  Chrome  插件而已；为何要这么一段缀为前言？缘由是，这其中蕴涵了一个劝解的倡导。著名财经作家吴晓波先生，有次谈及到亚当·格兰特写的一本书<code>《离经叛道》</code>；书中指出：离经叛道不是天生的特质，而是一种有意识的选择。为此作者讲了个有趣的小故事来证明这一点。</p>\n<blockquote>\n<p>经济学家迈克尔·豪斯曼主持了一个项目，研究为什么有些员工在工作岗位上的时间比其他人更久。在寻找线索的过程中，他发现：使用 Firefox 或 Chrome 浏览器的员工坚守在某一岗位上的时间，要比那些使用 IE 浏览器或 Safari 浏览器的员工长 15％，同时他们拥有更低的缺勤率和明显更高的销售额！</p>\n</blockquote>\n<p>几乎 2/3 的员工使用的是默认浏览器(Window 下 IE，Mac 下 Safari，国内小白选 360？)，从来没有质疑过是否存在一个更好的浏览器可以使用。主动选择浏览器的人，往往会在日常生活中寻找更好的选择，虽然这一行为并不显眼；但成功就属于拥有这极尽追求的一拨人。</p>\n<p>如若，你常用一项工具，然而你都未去全然了解它，以此推演之，又如何能在其他事情上获取成功呢？<code>够用就好</code>的心态，只会让你止于平庸，难以卓越。而这种心态，也会阻碍社会的进步，话说在国内，Windows 系统的 xp 版本 s 使用率，一度跟 win8 持平，而即便今时今日，Win10 都发布很久了，可是实用最多的却还是 Win7，😂；如果你愿意去追求品味与效率，你会发现，你该用 Mac，不是么？</p>\n<p>此篇主旨不在于去说教；但也不全然只是介绍些超好用的 Chrome 插件：毕竟 Chrome 上好用的插件，实在是多不胜数；如果你愿意，你也可不怎么费力的写一款。谈及以上那么多有的没的，也是想说明，当遇到问题，不妨思考下，当你遇到了，别人想必早已遇到并解决，你只需找到他们方案、并吸收为己用就好；站在巨人肩膀上前行，总比自己闭门挖坑来得要高明。见识得多了，用得熟了，思维变得宽阔了，有一天遇到未被解决得问题，想必那时也能如巨人一般，造它一个，享与他人；何乐不为？</p>\n<p>到此，废话暂时告一段落；进入正题，介绍些个人觉得超棒的工具，享与捧场的你。当然，你知道世事与人，皆在进步，我也不会例外。倘若很多神器，未曾提及，多半是见识的还不够多，还请在留言出不吝分享，先行谢过。</p>\n<h2 id=\"高效篇\"><a href=\"#高效篇\" class=\"headerlink\" title=\"高效篇\"></a>高效篇</h2><h3 id=\"Vimium\"><a href=\"#Vimium\" class=\"headerlink\" title=\"Vimium\"></a>Vimium</h3><p>作为一款黑客级别的 Chrome 插件，对她的存在真是喜之不尽。为此，一年多以前特为她写了篇：<a href=\"http://www.jeffjade.com/2015/10/19/2015-10-18-chrome-vimium/?jeffjade\" target=\"_blank\" rel=\"noopener\">Vimium~让您的 Chrome 起飞</a>。工欲善其事，必先利其器的理念，被此款插件体现的淋漓尽致：拥有她，从此脱离鼠标操纵 Chrome，且便捷数倍不止。<code>f</code>、<code>gg</code>、<code>G</code>、<code>gg</code>、<code>r</code>、<code>yy</code>、<code>yt</code>、<code>x</code>、<code>t</code>、<code>j</code>、<code>k</code>、<code>J</code>、<code>K</code>、<code>B</code>  等快捷键，皆是非常有用且常用的存在(也有同款名曰  <em>Vimium + Visual mode</em> )。当年有感叹到：“熟能生巧，至巧了，即可夺天之工”。高效必备，<code>Vimium</code>你值得拥有（★★★★★ ＋）<a href=\"https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb\" target=\"_blank\" rel=\"noopener\">Vimium 链接直达</a>。</p>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/558479-20170122200957410-312549711.jpg\" target=\"_blank\" rel=\"noopener\" title=\"Chrome-Vimium｜Form 500px\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/558479-20170122200957410-312549711.jpg\" alt=\"Chrome-Vimium｜Form 500px\"></a>Chrome-Vimium ｜ Form 500px</p>\n<p>这里需要补充一款  <code>cVim</code>  插件，五星级插件，好评如潮；其功能与  <code>Vimium</code>  类似，而其功能目测要比她尤胜一筹(强化了搜索，Visual mode，以及文本选择等等)；如果志向于如极客一般操控你的 Chrome，那么不妨一试，兴许这  <code>cVim</code>  会为你打开一个全新的大门，祝好；(而我，已先迷恋  <code>Vimium</code>，短时间内不会移情别恋)； （★★★★★++）<a href=\"https://chrome.google.com/webstore/detail/cvim/ihlenndgcmojhcghmfjfneahoeklbjjh/reviews\" target=\"_blank\" rel=\"noopener\">cVim 链接直达</a>。</p>\n<h3 id=\"Tampermonkey\"><a href=\"#Tampermonkey\" class=\"headerlink\" title=\"Tampermonkey\"></a>Tampermonkey</h3><p>据悉，<code>Tampermonkey</code>，她是一款强大的难以想象的浏览器插件，俗称“油猴子”；据说，她是高手必备的 Chrome 扩展，毕竟只有高手中的高手，才能领略到 Tampermonkey 的优美；据坊间传言，就算 Chrome 没有其他扩展，只有 Tampermonkey，Chrome 依然能吸引到一大群死忠 … 其官方描述只一句  The world’s most popular userscript manager，但她的话题却是无尽的去延展；这是一款伟大的插件，各路高手对她的赞美，已然到无以复加的地步；个人品级不够，难叙她的强大，看管须自行探索；唯一句：略经初探，她的存在，就好如 Mac 系统下的第一神器  Alfred  一般，强于不强，不仅在软件本身，同时也取决于使用者的功夫，此路美景纵横，祝君好运(update @2017-01-24)。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo\" target=\"_blank\" rel=\"noopener\">Tampermonkey 链接直达</a></p>\n<h3 id=\"crxMouse-Chrome-Gestures\"><a href=\"#crxMouse-Chrome-Gestures\" class=\"headerlink\" title=\"crxMouse Chrome Gestures\"></a>crxMouse Chrome Gestures</h3><p>方便,快捷,充分发掘鼠标的所有操作，功能包括：鼠标手势、超级拖曳、滚轮手势、摇杆手势、平滑滚动、标签页列表等。在用<code>Vimium</code>之前，这真是挺常用的利器；当然如果你喜欢用鼠标，这款与你来讲，再好没有；你可讲常用的操作，定制鼠标手势；比如前进、后退、在新的标签页打开(默认，点击该链接一拖即可)等等（★★★★）</p>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/558479-20170122200310254-2024804592.jpg\" target=\"_blank\" rel=\"noopener\" title=\"|Chrmme鼠标手势-jeffjade.com\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/558479-20170122200310254-2024804592.jpg\" alt=\"|Chrmme鼠标手势-jeffjade.com\"></a>|Chrmme 鼠标手势-jeffjade.com</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/crxmouse-chrome-gestures/jlgkpaicikihijadgifklkbpdajbkhjo\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<blockquote>\n<p><em>题外话：</em>  你知道工作之余，写篇博文颇为不易；然而，国内聚合网站可谓多不胜数，而某度搜索，很多时候，对<code>聚合</code>的亲睐竟远胜于原创，唉。为满足下那小小虚荣，不得不在此插播一则说明，此篇整理悉数出自<a href=\"https://jeffjade.com/2017/01/23/118-chrome_awesome_plug-in/www.jeffjade.com\" target=\"_blank\" rel=\"noopener\">晚晴幽草轩</a>，欲转载以享之，烦请注明出处 (<em>^</em>^_)。</p>\n</blockquote>\n<h2 id=\"利器篇\"><a href=\"#利器篇\" class=\"headerlink\" title=\"利器篇\"></a>利器篇</h2><h3 id=\"OneTab\"><a href=\"#OneTab\" class=\"headerlink\" title=\"OneTab\"></a>OneTab</h3><p>了不得，这款插件我也是异常喜欢。当你发现自己有太多的标签页时，单击 OneTab 图标，将所有标签页转换成一个列表。当你需要再次访问这些标签页时，可以单独或全部恢复它们（★★★★★）。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"The-Great-Suspender\"><a href=\"#The-Great-Suspender\" class=\"headerlink\" title=\"The Great Suspender\"></a>The Great Suspender</h3><p>这是一款 Chrome 下的多标签页管理应用，用来临时休眠掉不使用的标签页，从而释放出更多的内存和资源，让你做更重要的事情；在需要的时候点一下就能恢复。这跟  <code>OneTab</code>  还是有些区别的。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/the-great-suspender/klbibkeccnjlkjkiokjodocebajanakg?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"LastPass\"><a href=\"#LastPass\" class=\"headerlink\" title=\"LastPass\"></a>LastPass</h3><p>密码管理软件。可将你所有的密码信息保存起来，你再也无需记住复杂繁多的密码了，只需登录到 lastpass，然后保存你的密码，lastpass 会自动帮你完成登录，不需要输入密码。它还允许你从任何主流的密码存储器导入和导出密码，捕获其它管理器无法捕获的密码包括很多 AJAX 表单。也可轻松地创建强大的密码。敏感信息在上传之前已在本地计算机上加密，因此就算是 LastPass 的员工也无法得到密码信息。更妙 de 在于，lastpass 支持的不仅仅是 Chrome，还有 Firefox、opera，甚至 IE;当然如果你有一套完善便捷的密码方案，可忽略之（★★★★）。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/lastpass/hdokiejnpimakedhajhdlcegeplioahd?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"Infinity-新标签页\"><a href=\"#Infinity-新标签页\" class=\"headerlink\" title=\"Infinity 新标签页\"></a>Infinity 新标签页</h3><p>Infinity 新标签页，基于 Chrome 的云应用服务，让你更优雅、轻松地使用 Chrome：她不仅让你的 Chrome<code>新标签页</code>，变得很唯美(风景美图背景)，且能十分实用——你可添加多个应用入口，且可随性自定义；虽然这功能跟<code>Vimium</code>的<code>B</code>有些重叠，却也蛮喜欢她的存在（★★★★★）。</p>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/InfinityE696B0E6A087E7ADBEE9A1B5.jpg\" target=\"_blank\" rel=\"noopener\" title=\"Infinity新标签页|jeffjade.com\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/InfinityE696B0E6A087E7ADBEE9A1B5.jpg\" alt=\"Infinity新标签页|jeffjade.com\"></a>Infinity 新标签页|jeffjade.com</p>\n<h3 id=\"Momentum\"><a href=\"#Momentum\" class=\"headerlink\" title=\"Momentum\"></a>Momentum</h3><p>一款清新的新标签页插件，具有待办、天气、搜索功能，最最重要的是，插件的大背景，非常具有创意和艺术气息，每天更换；这跟<code>Infinity</code>同为美好的存在，如你更在意简洁文艺，不妨用此款(话说我司上下班打卡提示，就是此风)。<br>s<br><a href=\"https://chrome.google.com/webstore/detail/momentum/laookkfknpbbblfpciffpaejjkokdgca\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"网页截图-注释-amp-批注\"><a href=\"#网页截图-注释-amp-批注\" class=\"headerlink\" title=\"网页截图:注释&amp;批注\"></a>网页截图:注释&amp;批注</h3><p>五星评级插件；她，可以捕获整个页面或任何部分(包括桌面窗口)，矩形，圆形，箭头，线条和文字，模糊敏感信息，一键上传，分享注释(也可以选择本地图片)。支持 PNG 和链接；实在是很有用的存在，值得拥有。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/awesome-screenshot-screen/nlipoenfbbikpbjkfpfillcgkoblgpmj?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"Joxi-Full-Page-Screen-Capture\"><a href=\"#Joxi-Full-Page-Screen-Capture\" class=\"headerlink\" title=\"Joxi Full Page Screen Capture\"></a>Joxi Full Page Screen Capture</h3><p><code>Joxi Full Page Screen Capture</code>  是一款可以帮助用户全屏截图的谷歌浏览器插件；用户在打开网页，需要截图的时候，不管该网页有没有滚动条，她都能完美地把整个网页进行截图。当然，也可以选取网页中的一部分进行截图，在选取了截图范围以后，用户还可以对截图进行简单的编辑。同类型的还有<code>Blipshot</code>（网页全屏、滚动截图）。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/joxi-full-page-screen-cap/jhcdlkgjiehgpnpolkbnmpffjodigbkb?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"Print-Friendly-amp-PDF\"><a href=\"#Print-Friendly-amp-PDF\" class=\"headerlink\" title=\"Print Friendly &amp; PDF\"></a>Print Friendly &amp; PDF</h3><p>一款可以帮助用户自定义打印内容，以及打印格式的谷歌浏览器插件，同时支持 PDF 的格式打印。Chrome 自带打印功能(command p 或者右键)，但不能满足复杂点的需求；而这款插件的存在，就解决了很多人的刚需：1. 可以滤掉一些不想打印的内容(去除打印页面中的所有图片、删除网页中的广告、删除多余的文字等方便的自定义打印的功能)；2. 对打印的格式重新进行调整(比如调节打印的字体大小)；还支持查看打印历史等等，如此贴心，值得拥有。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/print-friendly-pdf/ohlencieiipommannpdfcmfdpjjmeolj/related?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"二维码-QR-码-生成器\"><a href=\"#二维码-QR-码-生成器\" class=\"headerlink\" title=\"二维码(QR 码)生成器\"></a>二维码(QR 码)生成器</h3><p>可以生成当前页面二维码，手机直接扫二维码就可以访问当前页面；虽不是很常用，但需要时候确实是挺有用。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/%E4%BA%8C%E7%BB%B4%E7%A0%81qr%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/pflgjjogbmmcmfhfcnlohagkablhbpmg\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"花瓣网页收藏工具\"><a href=\"#花瓣网页收藏工具\" class=\"headerlink\" title=\"花瓣网页收藏工具\"></a>花瓣网页收藏工具</h3><p>图片爱好者的福音。此款插件的作用在于，在网页上出现的图片，都可以直接点击收藏到花瓣，提供画板作为分类进行收集，以后找图片素材或者欣赏之前看到过的好的图片时很方便；个人也是一直将其常开着。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/%E8%8A%B1%E7%93%A3%E7%BD%91%E9%A1%B5%E6%94%B6%E8%97%8F%E5%B7%A5%E5%85%B7/imamemhokkdleoelohnmkimbmpfglcil\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h2 id=\"清静篇\"><a href=\"#清静篇\" class=\"headerlink\" title=\"清静篇\"></a>清静篇</h2><h3 id=\"Adblock-Plus\"><a href=\"#Adblock-Plus\" class=\"headerlink\" title=\"Adblock Plus\"></a>Adblock Plus</h3><p>免费的广告拦截器，可阻止所有烦人的广告及恶意软件和跟踪。享受没有恼人广告的网络世界，网冲必备。</p>\n<blockquote>\n<p>这里有必要补充一下，对此，有网友提出  <code>ADM</code>,<code>Adguard</code>，以及  <code>广告终结者</code>  等过滤广告的插件，且呼声蛮高。然而，在得知这些讯息后，我并没有想立即去体验；缘由是，够用就好   那懒的魔咒发作了；而据说，这<code>广告终结者</code>可以屏蔽掉视频中的广告，Look，当止于懒的时候，很可能就失掉了些美好，不是么？</p>\n</blockquote>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/dsfdsfgdsg.png\" target=\"_blank\" rel=\"noopener\" title=\"Chrome|Adblock Plus\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/dsfdsfgdsg.png\" alt=\"Chrome|Adblock Plus\"></a>Chrome|Adblock Plus</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/adblock-plus/cfhdojbkjhnklbpkdaibdccddilifddb\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"Stylish\"><a href=\"#Stylish\" class=\"headerlink\" title=\"Stylish\"></a><a href=\"https://userstyles.org/\" target=\"_blank\" rel=\"noopener\">Stylish</a></h3><p>Restyle the web with Stylish（为任意网站自定义主题） !  其官方描述为：利用用户样式管理器 Stylish 来重新编辑网站的样式。您可利用 Stylish 为许多网站安装主题和皮肤，也可创建自己的主题和皮肤。@少数派 有一篇文章<a href=\"http://sspai.com/34508?from=jeffjade.com\" target=\"_blank\" rel=\"noopener\">不喜欢某个网站的样子？用 Stylish 给它一键「换肤」</a>，蛮详细的介绍了如何使用她，给常用网站换肤；譬  <a href=\"https://userstyles.org/styles/106272/weibo-v6\" target=\"_blank\" rel=\"noopener\">Weibo-v6</a>，<a href=\"https://userstyles.org/styles/108011/flat-zhihu-v2-4-12\" target=\"_blank\" rel=\"noopener\">flat-zhihu</a>  等，感觉还是蛮好的。当然，还可以使用 Stylish 自定义网页字体、实现去除广告、补全浏览器部分功能等等，这都属于进阶部分，需要额外去探索；坚信，主动去折腾，会让生活更多彩多姿（★★★★★）。Update@2017-02-03</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/stylish-custom-themes-for/fjnbnpbmkenffdnngjfgmeleoegfcffe?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"阅读模式\"><a href=\"#阅读模式\" class=\"headerlink\" title=\"阅读模式\"></a>阅读模式</h3><p>当你想用心去品味一篇文章时候，你会发现她的存在是多么的美好：她提供与 Safari 阅读模式功能一致的插件，浏览文章页时候可进入友好的阅读模式，并自定义阅读功能。同比之下，也体验下了<code>愉阅</code>，iReader，等等，效果都不如<code>阅读模式</code>来的简约和优美；<a href=\"https://chrome.google.com/webstore/detail/fokus/flkkpmjbbpijiedjdgnhkcgopgnflehe/related\" target=\"_blank\" rel=\"noopener\">Fokus</a>，这个 喜欢鼠标覆盖一段文字阅读，把其它地方阴影，以此来聚集注意力，想法虽妙，却需要额外手动触发，得失之间，看个人取舍了！</p>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/E99885E8AFBBE6A8A1E5BC8F.jpg\" target=\"_blank\" rel=\"noopener\" title=\"阅读模式-jeffjade.com\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/E99885E8AFBBE6A8A1E5BC8F.jpg\" alt=\"阅读模式-jeffjade.com\"></a>阅读模式-jeffjade.com</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/reader-view/iibolhpkjjmoepndefdmdlmbpfhlgjpl/related?utm_source=chrome-app-launcher-info-dialog\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"一键管理所有扩展\"><a href=\"#一键管理所有扩展\" class=\"headerlink\" title=\"一键管理所有扩展\"></a>一键管理所有扩展</h3><p>此插件为以前的一键禁用所有扩展-加强版。当你安装了蛮多好用插件之后，这款插件就显得很有作用了；要知道，很有用的插件，并不是都很常用，那些常驻内存，多少会导致浏览器会占用更多的消耗；而手动去在扩展中打开，用印度语讲，”亚克”！有这插件的存在，就好如男孩裤子有了拉链，Up 与 Down 之间就解决了两方面需求，值得拥有，If you Have More （★★★★★）。</p>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/E4B880E994AEE7AEA1E79086E68980E69C89E689A9E5B195.jpg\" target=\"_blank\" rel=\"noopener\" title=\"一键管理所有扩展插件-jeffjade.com\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/E4B880E994AEE7AEA1E79086E68980E69C89E689A9E5B195.jpg\" alt=\"一键管理所有扩展插件-jeffjade.com\"></a>一键管理所有扩展插件-jeffjade.com</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/%E4%B8%80%E9%94%AE%E7%AE%A1%E7%90%86%E6%89%80%E6%9C%89%E6%89%A9%E5%B1%95/niemebbfnfbjfojajlmnbiikmcpjkkja\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"眼不见心不烦\"><a href=\"#眼不见心不烦\" class=\"headerlink\" title=\"眼不见心不烦\"></a>眼不见心不烦</h3><p>此乃微博党的福音！在浏览器端，自己通过这个插件进行设置，可以将热门微博、会员推广等等内容窗口都给屏蔽了！还我们一个干净、舒服的微博环境！然而，在当下这手机端横行的年代，这款插件的辉煌，也就那样了(可微博客户端自行设置，据悉满多隐藏的功能)。</p>\n<h2 id=\"开发篇\"><a href=\"#开发篇\" class=\"headerlink\" title=\"开发篇\"></a>开发篇</h2><p>作为程序开发者，遇到好多“程序员”，非常不熟悉所用的 Editor。对于那些漠视(或无视)工具的 Coder，多少有些劝导（虽然，这看起来有点像我悟到出家了，也欲劝他们也剃度似的）。可是，这里倒的确有番说辞的是，程序语言也好、内功心法也罢，还是这 Chrome，那 Sublime 等等，归其根都是工具的范畴，有什么好漠视的？反倒是，对编辑器，PS，Sketch 等工具的熟悉，当是早于那些语言的；毕竟，你应该明白，编程的时候，不能被输出给限制太多不是？再者，既有的工具不用，反倒是以步代车，是何道理？(以步代车，还能借机会锻炼下身子呢，那么有 Tools 不用的你呢？)。</p>\n<h3 id=\"Json-Handle\"><a href=\"#Json-Handle\" class=\"headerlink\" title=\"Json-Handle\"></a>Json-Handle</h3><p>她可以帮助你在浏览器中查看 JSON 数据，并以优美的树视图姿势，展示出对应数据；如果你愿意，还可以配置快捷键，所需之时，一键呼出。在同类型插件中，这款是所见过最靓丽多姿的，并且功能完善；开发调试、手写 JSON，常备良品 （★★★★★）。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/json-handle/iahnhfdhidomcpggpaimmmahffihkfnj?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"Postman\"><a href=\"#Postman\" class=\"headerlink\" title=\"Postman\"></a>Postman</h3><p>口碑极好的一款接口调试工具；不管是从事前端，还是移动端开发，这都是一款必备神器；如若还未用它嗨起来，想必多少会加点儿班来嗨了(当然，这是一句玩笑话；毕竟即便不用，很多时候加点班都是少不了的) （★★★★★）。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"Vue-React-AngularJS-Devtools\"><a href=\"#Vue-React-AngularJS-Devtools\" class=\"headerlink\" title=\"Vue React AngularJS Devtools\"></a>Vue React AngularJS Devtools</h3><p>Vue 调试工具。如果你如今从事前端开发，大行其道的 MVVM 框架，决计是绕不过去的存在。那么以下是三大流行框架 Devtools，如需自取。<br><a href=\"https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd\" target=\"_blank\" rel=\"noopener\">Vue.js devtools</a></p>\n<p><a href=\"https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk\" target=\"_blank\" rel=\"noopener\">AngularJS Batarang</a></p>\n<p><a href=\"https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi\" target=\"_blank\" rel=\"noopener\">React Developer Tools</a></p>\n<h3 id=\"Octotree\"><a href=\"#Octotree\" class=\"headerlink\" title=\"Octotree\"></a>Octotree</h3><p>Code tree for GitHub and GitLab；作为五星好评的存在，大有相见恨晚的感觉，值得拥有；当你翻别人源码的时候，是否很苦恼，特别是你的网络不给力的时候，简直很抓狂，有否？而 Octotree 的存在，就是帮助你整理出来项目文件列表，立于侧边，好如编辑器一般；正如网友评论道： Can’t love it MORE （★★★★★）。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc/reviews\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"Allow-Control-Allow-Origin\"><a href=\"#Allow-Control-Allow-Origin\" class=\"headerlink\" title=\"Allow-Control-Allow-Origin: *\"></a>Allow-Control-Allow-Origin: *</h3><p>JS 同源策略保障我们的页面安全；但是开发期间，大家并不想看到这烦人的家伙；尤其是如今前后端分离的时代，你总是需要些办法以解决跨域，比如<code>代理</code>、<code>JSONP</code>、<code>改Host</code>等等；而使用  <code>Allow-Control-Allow-Origin: *</code>插件轻松解决这个问题。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"WEB-前端助手-FeHelper\"><a href=\"#WEB-前端助手-FeHelper\" class=\"headerlink\" title=\"WEB 前端助手(FeHelper)\"></a>WEB 前端助手(FeHelper)</h3><p>FE 助手：包括字符串编解码、图片 base64 编码、代码压缩、美化、JSON 格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、栅格检测、JS 运行效率分析等。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"CSSViewer\"><a href=\"#CSSViewer\" class=\"headerlink\" title=\"CSSViewer\"></a>CSSViewer</h3><p>CSSViewer 是一个简单的 CSS 属性查看器。它有一个浮动面板，指明鼠标所在处信息，提供其字体、文本、颜色、背景、框、定位和效果属性的说明。 CSSViewer 可以快速提供需要的基本 CSS 信息。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/cssviewer/ggfgijbpiheegefliciemofobhmofgce\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"Wappalyzer\"><a href=\"#Wappalyzer\" class=\"headerlink\" title=\"Wappalyzer\"></a><a href=\"https://wappalyzer.com/?from=jeffjade.com\" target=\"_blank\" rel=\"noopener\">Wappalyzer</a></h3><p>Identifies software on the web；<code>Wappalyzer</code>  是一个浏览器扩展，义译为 Web 应用指纹识别，它能够揭示某网站上使用的技术。它可以检测内容管理系统，电子商务平台，Web 服务器，JavaScript 框架，分析工具等等；浏览 Wappalyzer 能够检测到的应用的完整列表：<a href=\"https://wappalyzer.com/applications\" target=\"_blank\" rel=\"noopener\">https://wappalyzer.com/applications</a> 。据悉为渗透工程师必备，同比之下还有  <code>HackBar</code>、<code>Tamper Data</code>等等；倘若，你想知道一个网站，使用什么技术，用此插件就对了。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/wappalyzer/gppongmhjkpfnbhagpmjfkannfbllamg?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h2 id=\"其他篇\"><a href=\"#其他篇\" class=\"headerlink\" title=\"其他篇\"></a>其他篇</h2><ul>\n<li><p><a href=\"https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif/reviews?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">SwitchyOmega</a>  五星级好评的存在(可以感受到，我朝爱自由上网的渴望与热忱)；她，轻松快捷地管理和切换多个代理设置，据悉常与<code>shadowsocks</code>互相配合，来完成科学上网的美好愿景。</p>\n</li>\n<li><p><a href=\"https://chrome.google.com/webstore/detail/v2ex-plus/daeclijmnojoemooblcbfeeceopnkolo/related\" target=\"_blank\" rel=\"noopener\">v2ex-plus</a>: 如果你常去  <code>V2ex</code>  跟程序员们一起聊聊天，吹吹水，涨涨姿势，发发帖子，可用之。</p>\n</li>\n<li><p><a href=\"https://chrome.google.com/webstore/detail/%E6%8E%98%E9%87%91/lecdifefmmfjnjjinhaennhdlmcaeeeb\" target=\"_blank\" rel=\"noopener\">掘金</a>  是一款技术分享社区，前端后端，设计产品都有涵盖，质量还好；这款插件即可一键打开之（备注，它默认当你打开新标签页就是打开它，虽可设置，但和 Infinity 目测有水火不容的冲突，然后就没然后了）爱学习如你，倒可以 Install 一下试试 (这不是广告，至少没钱拿)。</p>\n</li>\n</ul>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>工欲善其事，必先利其器，人们总是低估工具对自己心智模式的影响，请记住，好工具是好思想的容器；好工具也会蕴含好知识；如果你能学会善假于物也，自然界间，互联网里，包罗万象，任君所学；何须如今那些 “Teacher” 来猥亵了你的创造力？求知欲和热情的坚持，才是最好的师傅。闲言暂住，回到 Chrome 插件话题；Chrome 插件多不能数，非一篇能全之，那么你有什么好用的插件呢？期待共享。</p>\n<blockquote>\n<p>微注：  个人的见识总是有限的，所以有在 @V2EX 发帖  <a href=\"https://www.v2ex.com/t/336428?from=jeffjade.com\" target=\"_blank\" rel=\"noopener\">那些你觉得堪称神兵利器的 Chrome 插件</a>，在猴鸡交替之际，引发了网友热议，收获颇丰；文章中不少插件的推荐，就来源此处；如需增长见闻，不妨细观；另外，也有在 @黑客派 发帖<a href=\"https://hacpai.com/article/1485149167264?from=jeffjade.com\" target=\"_blank\" rel=\"noopener\">谈谈你觉得堪称神兵利器的 Chrome 插件</a>。</p>\n</blockquote>\n<p>值此将新年之际，大家都在忙着支付宝<code>积福</code>，或 QQ<code>红包</code>，或者享受回家团圆之乐，我则终将这篇文章整理了出来(后续漫加)；如果觉得有用，不妨考虑打赏一杯咖啡？好让在那些偶尔闲暇的夜里，可以有精神去敲敲打打，产出些有所用的文字。谨在此恭祝我朝人民：天天开心，事事顺心；新春快乐，阖家欢乐。</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>子曾曰：“工欲善其事，必先利其器。居是邦也。”——语出《论语·卫灵公》；其后一百多年，荀子也在其《劝学》中倡言道：“吾尝终日而思矣，不如须臾之所学也；吾尝跂而望矣，不如登高之博见也。登高而招，臂非加长也，而见者远；顺风而呼，声非加疾也，而闻者彰。假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也”。远从石器时代开始，先贤无不据此而行；时至今日，已将具器的职能，发挥到淋漓尽致之境界：倘若离开它的存在，人类已无法正常生活；斯可云鉴？</p>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/nice-chrome.jpg\" target=\"_blank\" rel=\"noopener\" title=\"Chrmme-500px\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/nice-chrome.jpg\" alt=\"Chrmme-500px\"></a>Chrmme-500px</p>\n<p>话说此篇不过是记载些，居家必备的  Chrome  插件而已；为何要这么一段缀为前言？缘由是，这其中蕴涵了一个劝解的倡导。著名财经作家吴晓波先生，有次谈及到亚当·格兰特写的一本书<code>《离经叛道》</code>；书中指出：离经叛道不是天生的特质，而是一种有意识的选择。为此作者讲了个有趣的小故事来证明这一点。</p>\n<blockquote>\n<p>经济学家迈克尔·豪斯曼主持了一个项目，研究为什么有些员工在工作岗位上的时间比其他人更久。在寻找线索的过程中，他发现：使用 Firefox 或 Chrome 浏览器的员工坚守在某一岗位上的时间，要比那些使用 IE 浏览器或 Safari 浏览器的员工长 15％，同时他们拥有更低的缺勤率和明显更高的销售额！</p>\n</blockquote>\n<p>几乎 2/3 的员工使用的是默认浏览器(Window 下 IE，Mac 下 Safari，国内小白选 360？)，从来没有质疑过是否存在一个更好的浏览器可以使用。主动选择浏览器的人，往往会在日常生活中寻找更好的选择，虽然这一行为并不显眼；但成功就属于拥有这极尽追求的一拨人。</p>\n<p>如若，你常用一项工具，然而你都未去全然了解它，以此推演之，又如何能在其他事情上获取成功呢？<code>够用就好</code>的心态，只会让你止于平庸，难以卓越。而这种心态，也会阻碍社会的进步，话说在国内，Windows 系统的 xp 版本 s 使用率，一度跟 win8 持平，而即便今时今日，Win10 都发布很久了，可是实用最多的却还是 Win7，😂；如果你愿意去追求品味与效率，你会发现，你该用 Mac，不是么？</p>\n<p>此篇主旨不在于去说教；但也不全然只是介绍些超好用的 Chrome 插件：毕竟 Chrome 上好用的插件，实在是多不胜数；如果你愿意，你也可不怎么费力的写一款。谈及以上那么多有的没的，也是想说明，当遇到问题，不妨思考下，当你遇到了，别人想必早已遇到并解决，你只需找到他们方案、并吸收为己用就好；站在巨人肩膀上前行，总比自己闭门挖坑来得要高明。见识得多了，用得熟了，思维变得宽阔了，有一天遇到未被解决得问题，想必那时也能如巨人一般，造它一个，享与他人；何乐不为？</p>\n<p>到此，废话暂时告一段落；进入正题，介绍些个人觉得超棒的工具，享与捧场的你。当然，你知道世事与人，皆在进步，我也不会例外。倘若很多神器，未曾提及，多半是见识的还不够多，还请在留言出不吝分享，先行谢过。</p>\n<h2 id=\"高效篇\"><a href=\"#高效篇\" class=\"headerlink\" title=\"高效篇\"></a>高效篇</h2><h3 id=\"Vimium\"><a href=\"#Vimium\" class=\"headerlink\" title=\"Vimium\"></a>Vimium</h3><p>作为一款黑客级别的 Chrome 插件，对她的存在真是喜之不尽。为此，一年多以前特为她写了篇：<a href=\"http://www.jeffjade.com/2015/10/19/2015-10-18-chrome-vimium/?jeffjade\" target=\"_blank\" rel=\"noopener\">Vimium~让您的 Chrome 起飞</a>。工欲善其事，必先利其器的理念，被此款插件体现的淋漓尽致：拥有她，从此脱离鼠标操纵 Chrome，且便捷数倍不止。<code>f</code>、<code>gg</code>、<code>G</code>、<code>gg</code>、<code>r</code>、<code>yy</code>、<code>yt</code>、<code>x</code>、<code>t</code>、<code>j</code>、<code>k</code>、<code>J</code>、<code>K</code>、<code>B</code>  等快捷键，皆是非常有用且常用的存在(也有同款名曰  <em>Vimium + Visual mode</em> )。当年有感叹到：“熟能生巧，至巧了，即可夺天之工”。高效必备，<code>Vimium</code>你值得拥有（★★★★★ ＋）<a href=\"https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb\" target=\"_blank\" rel=\"noopener\">Vimium 链接直达</a>。</p>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/558479-20170122200957410-312549711.jpg\" target=\"_blank\" rel=\"noopener\" title=\"Chrome-Vimium｜Form 500px\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/558479-20170122200957410-312549711.jpg\" alt=\"Chrome-Vimium｜Form 500px\"></a>Chrome-Vimium ｜ Form 500px</p>\n<p>这里需要补充一款  <code>cVim</code>  插件，五星级插件，好评如潮；其功能与  <code>Vimium</code>  类似，而其功能目测要比她尤胜一筹(强化了搜索，Visual mode，以及文本选择等等)；如果志向于如极客一般操控你的 Chrome，那么不妨一试，兴许这  <code>cVim</code>  会为你打开一个全新的大门，祝好；(而我，已先迷恋  <code>Vimium</code>，短时间内不会移情别恋)； （★★★★★++）<a href=\"https://chrome.google.com/webstore/detail/cvim/ihlenndgcmojhcghmfjfneahoeklbjjh/reviews\" target=\"_blank\" rel=\"noopener\">cVim 链接直达</a>。</p>\n<h3 id=\"Tampermonkey\"><a href=\"#Tampermonkey\" class=\"headerlink\" title=\"Tampermonkey\"></a>Tampermonkey</h3><p>据悉，<code>Tampermonkey</code>，她是一款强大的难以想象的浏览器插件，俗称“油猴子”；据说，她是高手必备的 Chrome 扩展，毕竟只有高手中的高手，才能领略到 Tampermonkey 的优美；据坊间传言，就算 Chrome 没有其他扩展，只有 Tampermonkey，Chrome 依然能吸引到一大群死忠 … 其官方描述只一句  The world’s most popular userscript manager，但她的话题却是无尽的去延展；这是一款伟大的插件，各路高手对她的赞美，已然到无以复加的地步；个人品级不够，难叙她的强大，看管须自行探索；唯一句：略经初探，她的存在，就好如 Mac 系统下的第一神器  Alfred  一般，强于不强，不仅在软件本身，同时也取决于使用者的功夫，此路美景纵横，祝君好运(update @2017-01-24)。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo\" target=\"_blank\" rel=\"noopener\">Tampermonkey 链接直达</a></p>\n<h3 id=\"crxMouse-Chrome-Gestures\"><a href=\"#crxMouse-Chrome-Gestures\" class=\"headerlink\" title=\"crxMouse Chrome Gestures\"></a>crxMouse Chrome Gestures</h3><p>方便,快捷,充分发掘鼠标的所有操作，功能包括：鼠标手势、超级拖曳、滚轮手势、摇杆手势、平滑滚动、标签页列表等。在用<code>Vimium</code>之前，这真是挺常用的利器；当然如果你喜欢用鼠标，这款与你来讲，再好没有；你可讲常用的操作，定制鼠标手势；比如前进、后退、在新的标签页打开(默认，点击该链接一拖即可)等等（★★★★）</p>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/558479-20170122200310254-2024804592.jpg\" target=\"_blank\" rel=\"noopener\" title=\"|Chrmme鼠标手势-jeffjade.com\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/558479-20170122200310254-2024804592.jpg\" alt=\"|Chrmme鼠标手势-jeffjade.com\"></a>|Chrmme 鼠标手势-jeffjade.com</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/crxmouse-chrome-gestures/jlgkpaicikihijadgifklkbpdajbkhjo\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<blockquote>\n<p><em>题外话：</em>  你知道工作之余，写篇博文颇为不易；然而，国内聚合网站可谓多不胜数，而某度搜索，很多时候，对<code>聚合</code>的亲睐竟远胜于原创，唉。为满足下那小小虚荣，不得不在此插播一则说明，此篇整理悉数出自<a href=\"https://jeffjade.com/2017/01/23/118-chrome_awesome_plug-in/www.jeffjade.com\" target=\"_blank\" rel=\"noopener\">晚晴幽草轩</a>，欲转载以享之，烦请注明出处 (<em>^</em>^_)。</p>\n</blockquote>\n<h2 id=\"利器篇\"><a href=\"#利器篇\" class=\"headerlink\" title=\"利器篇\"></a>利器篇</h2><h3 id=\"OneTab\"><a href=\"#OneTab\" class=\"headerlink\" title=\"OneTab\"></a>OneTab</h3><p>了不得，这款插件我也是异常喜欢。当你发现自己有太多的标签页时，单击 OneTab 图标，将所有标签页转换成一个列表。当你需要再次访问这些标签页时，可以单独或全部恢复它们（★★★★★）。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"The-Great-Suspender\"><a href=\"#The-Great-Suspender\" class=\"headerlink\" title=\"The Great Suspender\"></a>The Great Suspender</h3><p>这是一款 Chrome 下的多标签页管理应用，用来临时休眠掉不使用的标签页，从而释放出更多的内存和资源，让你做更重要的事情；在需要的时候点一下就能恢复。这跟  <code>OneTab</code>  还是有些区别的。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/the-great-suspender/klbibkeccnjlkjkiokjodocebajanakg?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"LastPass\"><a href=\"#LastPass\" class=\"headerlink\" title=\"LastPass\"></a>LastPass</h3><p>密码管理软件。可将你所有的密码信息保存起来，你再也无需记住复杂繁多的密码了，只需登录到 lastpass，然后保存你的密码，lastpass 会自动帮你完成登录，不需要输入密码。它还允许你从任何主流的密码存储器导入和导出密码，捕获其它管理器无法捕获的密码包括很多 AJAX 表单。也可轻松地创建强大的密码。敏感信息在上传之前已在本地计算机上加密，因此就算是 LastPass 的员工也无法得到密码信息。更妙 de 在于，lastpass 支持的不仅仅是 Chrome，还有 Firefox、opera，甚至 IE;当然如果你有一套完善便捷的密码方案，可忽略之（★★★★）。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/lastpass/hdokiejnpimakedhajhdlcegeplioahd?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"Infinity-新标签页\"><a href=\"#Infinity-新标签页\" class=\"headerlink\" title=\"Infinity 新标签页\"></a>Infinity 新标签页</h3><p>Infinity 新标签页，基于 Chrome 的云应用服务，让你更优雅、轻松地使用 Chrome：她不仅让你的 Chrome<code>新标签页</code>，变得很唯美(风景美图背景)，且能十分实用——你可添加多个应用入口，且可随性自定义；虽然这功能跟<code>Vimium</code>的<code>B</code>有些重叠，却也蛮喜欢她的存在（★★★★★）。</p>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/InfinityE696B0E6A087E7ADBEE9A1B5.jpg\" target=\"_blank\" rel=\"noopener\" title=\"Infinity新标签页|jeffjade.com\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/InfinityE696B0E6A087E7ADBEE9A1B5.jpg\" alt=\"Infinity新标签页|jeffjade.com\"></a>Infinity 新标签页|jeffjade.com</p>\n<h3 id=\"Momentum\"><a href=\"#Momentum\" class=\"headerlink\" title=\"Momentum\"></a>Momentum</h3><p>一款清新的新标签页插件，具有待办、天气、搜索功能，最最重要的是，插件的大背景，非常具有创意和艺术气息，每天更换；这跟<code>Infinity</code>同为美好的存在，如你更在意简洁文艺，不妨用此款(话说我司上下班打卡提示，就是此风)。<br>s<br><a href=\"https://chrome.google.com/webstore/detail/momentum/laookkfknpbbblfpciffpaejjkokdgca\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"网页截图-注释-amp-批注\"><a href=\"#网页截图-注释-amp-批注\" class=\"headerlink\" title=\"网页截图:注释&amp;批注\"></a>网页截图:注释&amp;批注</h3><p>五星评级插件；她，可以捕获整个页面或任何部分(包括桌面窗口)，矩形，圆形，箭头，线条和文字，模糊敏感信息，一键上传，分享注释(也可以选择本地图片)。支持 PNG 和链接；实在是很有用的存在，值得拥有。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/awesome-screenshot-screen/nlipoenfbbikpbjkfpfillcgkoblgpmj?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"Joxi-Full-Page-Screen-Capture\"><a href=\"#Joxi-Full-Page-Screen-Capture\" class=\"headerlink\" title=\"Joxi Full Page Screen Capture\"></a>Joxi Full Page Screen Capture</h3><p><code>Joxi Full Page Screen Capture</code>  是一款可以帮助用户全屏截图的谷歌浏览器插件；用户在打开网页，需要截图的时候，不管该网页有没有滚动条，她都能完美地把整个网页进行截图。当然，也可以选取网页中的一部分进行截图，在选取了截图范围以后，用户还可以对截图进行简单的编辑。同类型的还有<code>Blipshot</code>（网页全屏、滚动截图）。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/joxi-full-page-screen-cap/jhcdlkgjiehgpnpolkbnmpffjodigbkb?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"Print-Friendly-amp-PDF\"><a href=\"#Print-Friendly-amp-PDF\" class=\"headerlink\" title=\"Print Friendly &amp; PDF\"></a>Print Friendly &amp; PDF</h3><p>一款可以帮助用户自定义打印内容，以及打印格式的谷歌浏览器插件，同时支持 PDF 的格式打印。Chrome 自带打印功能(command p 或者右键)，但不能满足复杂点的需求；而这款插件的存在，就解决了很多人的刚需：1. 可以滤掉一些不想打印的内容(去除打印页面中的所有图片、删除网页中的广告、删除多余的文字等方便的自定义打印的功能)；2. 对打印的格式重新进行调整(比如调节打印的字体大小)；还支持查看打印历史等等，如此贴心，值得拥有。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/print-friendly-pdf/ohlencieiipommannpdfcmfdpjjmeolj/related?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"二维码-QR-码-生成器\"><a href=\"#二维码-QR-码-生成器\" class=\"headerlink\" title=\"二维码(QR 码)生成器\"></a>二维码(QR 码)生成器</h3><p>可以生成当前页面二维码，手机直接扫二维码就可以访问当前页面；虽不是很常用，但需要时候确实是挺有用。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/%E4%BA%8C%E7%BB%B4%E7%A0%81qr%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/pflgjjogbmmcmfhfcnlohagkablhbpmg\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"花瓣网页收藏工具\"><a href=\"#花瓣网页收藏工具\" class=\"headerlink\" title=\"花瓣网页收藏工具\"></a>花瓣网页收藏工具</h3><p>图片爱好者的福音。此款插件的作用在于，在网页上出现的图片，都可以直接点击收藏到花瓣，提供画板作为分类进行收集，以后找图片素材或者欣赏之前看到过的好的图片时很方便；个人也是一直将其常开着。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/%E8%8A%B1%E7%93%A3%E7%BD%91%E9%A1%B5%E6%94%B6%E8%97%8F%E5%B7%A5%E5%85%B7/imamemhokkdleoelohnmkimbmpfglcil\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h2 id=\"清静篇\"><a href=\"#清静篇\" class=\"headerlink\" title=\"清静篇\"></a>清静篇</h2><h3 id=\"Adblock-Plus\"><a href=\"#Adblock-Plus\" class=\"headerlink\" title=\"Adblock Plus\"></a>Adblock Plus</h3><p>免费的广告拦截器，可阻止所有烦人的广告及恶意软件和跟踪。享受没有恼人广告的网络世界，网冲必备。</p>\n<blockquote>\n<p>这里有必要补充一下，对此，有网友提出  <code>ADM</code>,<code>Adguard</code>，以及  <code>广告终结者</code>  等过滤广告的插件，且呼声蛮高。然而，在得知这些讯息后，我并没有想立即去体验；缘由是，够用就好   那懒的魔咒发作了；而据说，这<code>广告终结者</code>可以屏蔽掉视频中的广告，Look，当止于懒的时候，很可能就失掉了些美好，不是么？</p>\n</blockquote>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/dsfdsfgdsg.png\" target=\"_blank\" rel=\"noopener\" title=\"Chrome|Adblock Plus\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/dsfdsfgdsg.png\" alt=\"Chrome|Adblock Plus\"></a>Chrome|Adblock Plus</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/adblock-plus/cfhdojbkjhnklbpkdaibdccddilifddb\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"Stylish\"><a href=\"#Stylish\" class=\"headerlink\" title=\"Stylish\"></a><a href=\"https://userstyles.org/\" target=\"_blank\" rel=\"noopener\">Stylish</a></h3><p>Restyle the web with Stylish（为任意网站自定义主题） !  其官方描述为：利用用户样式管理器 Stylish 来重新编辑网站的样式。您可利用 Stylish 为许多网站安装主题和皮肤，也可创建自己的主题和皮肤。@少数派 有一篇文章<a href=\"http://sspai.com/34508?from=jeffjade.com\" target=\"_blank\" rel=\"noopener\">不喜欢某个网站的样子？用 Stylish 给它一键「换肤」</a>，蛮详细的介绍了如何使用她，给常用网站换肤；譬  <a href=\"https://userstyles.org/styles/106272/weibo-v6\" target=\"_blank\" rel=\"noopener\">Weibo-v6</a>，<a href=\"https://userstyles.org/styles/108011/flat-zhihu-v2-4-12\" target=\"_blank\" rel=\"noopener\">flat-zhihu</a>  等，感觉还是蛮好的。当然，还可以使用 Stylish 自定义网页字体、实现去除广告、补全浏览器部分功能等等，这都属于进阶部分，需要额外去探索；坚信，主动去折腾，会让生活更多彩多姿（★★★★★）。Update@2017-02-03</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/stylish-custom-themes-for/fjnbnpbmkenffdnngjfgmeleoegfcffe?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"阅读模式\"><a href=\"#阅读模式\" class=\"headerlink\" title=\"阅读模式\"></a>阅读模式</h3><p>当你想用心去品味一篇文章时候，你会发现她的存在是多么的美好：她提供与 Safari 阅读模式功能一致的插件，浏览文章页时候可进入友好的阅读模式，并自定义阅读功能。同比之下，也体验下了<code>愉阅</code>，iReader，等等，效果都不如<code>阅读模式</code>来的简约和优美；<a href=\"https://chrome.google.com/webstore/detail/fokus/flkkpmjbbpijiedjdgnhkcgopgnflehe/related\" target=\"_blank\" rel=\"noopener\">Fokus</a>，这个 喜欢鼠标覆盖一段文字阅读，把其它地方阴影，以此来聚集注意力，想法虽妙，却需要额外手动触发，得失之间，看个人取舍了！</p>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/E99885E8AFBBE6A8A1E5BC8F.jpg\" target=\"_blank\" rel=\"noopener\" title=\"阅读模式-jeffjade.com\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/E99885E8AFBBE6A8A1E5BC8F.jpg\" alt=\"阅读模式-jeffjade.com\"></a>阅读模式-jeffjade.com</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/reader-view/iibolhpkjjmoepndefdmdlmbpfhlgjpl/related?utm_source=chrome-app-launcher-info-dialog\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"一键管理所有扩展\"><a href=\"#一键管理所有扩展\" class=\"headerlink\" title=\"一键管理所有扩展\"></a>一键管理所有扩展</h3><p>此插件为以前的一键禁用所有扩展-加强版。当你安装了蛮多好用插件之后，这款插件就显得很有作用了；要知道，很有用的插件，并不是都很常用，那些常驻内存，多少会导致浏览器会占用更多的消耗；而手动去在扩展中打开，用印度语讲，”亚克”！有这插件的存在，就好如男孩裤子有了拉链，Up 与 Down 之间就解决了两方面需求，值得拥有，If you Have More （★★★★★）。</p>\n<p><a href=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/E4B880E994AEE7AEA1E79086E68980E69C89E689A9E5B195.jpg\" target=\"_blank\" rel=\"noopener\" title=\"一键管理所有扩展插件-jeffjade.com\"><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/E4B880E994AEE7AEA1E79086E68980E69C89E689A9E5B195.jpg\" alt=\"一键管理所有扩展插件-jeffjade.com\"></a>一键管理所有扩展插件-jeffjade.com</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/%E4%B8%80%E9%94%AE%E7%AE%A1%E7%90%86%E6%89%80%E6%9C%89%E6%89%A9%E5%B1%95/niemebbfnfbjfojajlmnbiikmcpjkkja\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"眼不见心不烦\"><a href=\"#眼不见心不烦\" class=\"headerlink\" title=\"眼不见心不烦\"></a>眼不见心不烦</h3><p>此乃微博党的福音！在浏览器端，自己通过这个插件进行设置，可以将热门微博、会员推广等等内容窗口都给屏蔽了！还我们一个干净、舒服的微博环境！然而，在当下这手机端横行的年代，这款插件的辉煌，也就那样了(可微博客户端自行设置，据悉满多隐藏的功能)。</p>\n<h2 id=\"开发篇\"><a href=\"#开发篇\" class=\"headerlink\" title=\"开发篇\"></a>开发篇</h2><p>作为程序开发者，遇到好多“程序员”，非常不熟悉所用的 Editor。对于那些漠视(或无视)工具的 Coder，多少有些劝导（虽然，这看起来有点像我悟到出家了，也欲劝他们也剃度似的）。可是，这里倒的确有番说辞的是，程序语言也好、内功心法也罢，还是这 Chrome，那 Sublime 等等，归其根都是工具的范畴，有什么好漠视的？反倒是，对编辑器，PS，Sketch 等工具的熟悉，当是早于那些语言的；毕竟，你应该明白，编程的时候，不能被输出给限制太多不是？再者，既有的工具不用，反倒是以步代车，是何道理？(以步代车，还能借机会锻炼下身子呢，那么有 Tools 不用的你呢？)。</p>\n<h3 id=\"Json-Handle\"><a href=\"#Json-Handle\" class=\"headerlink\" title=\"Json-Handle\"></a>Json-Handle</h3><p>她可以帮助你在浏览器中查看 JSON 数据，并以优美的树视图姿势，展示出对应数据；如果你愿意，还可以配置快捷键，所需之时，一键呼出。在同类型插件中，这款是所见过最靓丽多姿的，并且功能完善；开发调试、手写 JSON，常备良品 （★★★★★）。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/json-handle/iahnhfdhidomcpggpaimmmahffihkfnj?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"Postman\"><a href=\"#Postman\" class=\"headerlink\" title=\"Postman\"></a>Postman</h3><p>口碑极好的一款接口调试工具；不管是从事前端，还是移动端开发，这都是一款必备神器；如若还未用它嗨起来，想必多少会加点儿班来嗨了(当然，这是一句玩笑话；毕竟即便不用，很多时候加点班都是少不了的) （★★★★★）。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"Vue-React-AngularJS-Devtools\"><a href=\"#Vue-React-AngularJS-Devtools\" class=\"headerlink\" title=\"Vue React AngularJS Devtools\"></a>Vue React AngularJS Devtools</h3><p>Vue 调试工具。如果你如今从事前端开发，大行其道的 MVVM 框架，决计是绕不过去的存在。那么以下是三大流行框架 Devtools，如需自取。<br><a href=\"https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd\" target=\"_blank\" rel=\"noopener\">Vue.js devtools</a></p>\n<p><a href=\"https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk\" target=\"_blank\" rel=\"noopener\">AngularJS Batarang</a></p>\n<p><a href=\"https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi\" target=\"_blank\" rel=\"noopener\">React Developer Tools</a></p>\n<h3 id=\"Octotree\"><a href=\"#Octotree\" class=\"headerlink\" title=\"Octotree\"></a>Octotree</h3><p>Code tree for GitHub and GitLab；作为五星好评的存在，大有相见恨晚的感觉，值得拥有；当你翻别人源码的时候，是否很苦恼，特别是你的网络不给力的时候，简直很抓狂，有否？而 Octotree 的存在，就是帮助你整理出来项目文件列表，立于侧边，好如编辑器一般；正如网友评论道： Can’t love it MORE （★★★★★）。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc/reviews\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"Allow-Control-Allow-Origin\"><a href=\"#Allow-Control-Allow-Origin\" class=\"headerlink\" title=\"Allow-Control-Allow-Origin: *\"></a>Allow-Control-Allow-Origin: *</h3><p>JS 同源策略保障我们的页面安全；但是开发期间，大家并不想看到这烦人的家伙；尤其是如今前后端分离的时代，你总是需要些办法以解决跨域，比如<code>代理</code>、<code>JSONP</code>、<code>改Host</code>等等；而使用  <code>Allow-Control-Allow-Origin: *</code>插件轻松解决这个问题。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"WEB-前端助手-FeHelper\"><a href=\"#WEB-前端助手-FeHelper\" class=\"headerlink\" title=\"WEB 前端助手(FeHelper)\"></a>WEB 前端助手(FeHelper)</h3><p>FE 助手：包括字符串编解码、图片 base64 编码、代码压缩、美化、JSON 格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、栅格检测、JS 运行效率分析等。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"CSSViewer\"><a href=\"#CSSViewer\" class=\"headerlink\" title=\"CSSViewer\"></a>CSSViewer</h3><p>CSSViewer 是一个简单的 CSS 属性查看器。它有一个浮动面板，指明鼠标所在处信息，提供其字体、文本、颜色、背景、框、定位和效果属性的说明。 CSSViewer 可以快速提供需要的基本 CSS 信息。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/cssviewer/ggfgijbpiheegefliciemofobhmofgce\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h3 id=\"Wappalyzer\"><a href=\"#Wappalyzer\" class=\"headerlink\" title=\"Wappalyzer\"></a><a href=\"https://wappalyzer.com/?from=jeffjade.com\" target=\"_blank\" rel=\"noopener\">Wappalyzer</a></h3><p>Identifies software on the web；<code>Wappalyzer</code>  是一个浏览器扩展，义译为 Web 应用指纹识别，它能够揭示某网站上使用的技术。它可以检测内容管理系统，电子商务平台，Web 服务器，JavaScript 框架，分析工具等等；浏览 Wappalyzer 能够检测到的应用的完整列表：<a href=\"https://wappalyzer.com/applications\" target=\"_blank\" rel=\"noopener\">https://wappalyzer.com/applications</a> 。据悉为渗透工程师必备，同比之下还有  <code>HackBar</code>、<code>Tamper Data</code>等等；倘若，你想知道一个网站，使用什么技术，用此插件就对了。</p>\n<p><a href=\"https://chrome.google.com/webstore/detail/wappalyzer/gppongmhjkpfnbhagpmjfkannfbllamg?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">链接直达</a></p>\n<h2 id=\"其他篇\"><a href=\"#其他篇\" class=\"headerlink\" title=\"其他篇\"></a>其他篇</h2><ul>\n<li><p><a href=\"https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif/reviews?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">SwitchyOmega</a>  五星级好评的存在(可以感受到，我朝爱自由上网的渴望与热忱)；她，轻松快捷地管理和切换多个代理设置，据悉常与<code>shadowsocks</code>互相配合，来完成科学上网的美好愿景。</p>\n</li>\n<li><p><a href=\"https://chrome.google.com/webstore/detail/v2ex-plus/daeclijmnojoemooblcbfeeceopnkolo/related\" target=\"_blank\" rel=\"noopener\">v2ex-plus</a>: 如果你常去  <code>V2ex</code>  跟程序员们一起聊聊天，吹吹水，涨涨姿势，发发帖子，可用之。</p>\n</li>\n<li><p><a href=\"https://chrome.google.com/webstore/detail/%E6%8E%98%E9%87%91/lecdifefmmfjnjjinhaennhdlmcaeeeb\" target=\"_blank\" rel=\"noopener\">掘金</a>  是一款技术分享社区，前端后端，设计产品都有涵盖，质量还好；这款插件即可一键打开之（备注，它默认当你打开新标签页就是打开它，虽可设置，但和 Infinity 目测有水火不容的冲突，然后就没然后了）爱学习如你，倒可以 Install 一下试试 (这不是广告，至少没钱拿)。</p>\n</li>\n</ul>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>工欲善其事，必先利其器，人们总是低估工具对自己心智模式的影响，请记住，好工具是好思想的容器；好工具也会蕴含好知识；如果你能学会善假于物也，自然界间，互联网里，包罗万象，任君所学；何须如今那些 “Teacher” 来猥亵了你的创造力？求知欲和热情的坚持，才是最好的师傅。闲言暂住，回到 Chrome 插件话题；Chrome 插件多不能数，非一篇能全之，那么你有什么好用的插件呢？期待共享。</p>\n<blockquote>\n<p>微注：  个人的见识总是有限的，所以有在 @V2EX 发帖  <a href=\"https://www.v2ex.com/t/336428?from=jeffjade.com\" target=\"_blank\" rel=\"noopener\">那些你觉得堪称神兵利器的 Chrome 插件</a>，在猴鸡交替之际，引发了网友热议，收获颇丰；文章中不少插件的推荐，就来源此处；如需增长见闻，不妨细观；另外，也有在 @黑客派 发帖<a href=\"https://hacpai.com/article/1485149167264?from=jeffjade.com\" target=\"_blank\" rel=\"noopener\">谈谈你觉得堪称神兵利器的 Chrome 插件</a>。</p>\n</blockquote>\n<p>值此将新年之际，大家都在忙着支付宝<code>积福</code>，或 QQ<code>红包</code>，或者享受回家团圆之乐，我则终将这篇文章整理了出来(后续漫加)；如果觉得有用，不妨考虑打赏一杯咖啡？好让在那些偶尔闲暇的夜里，可以有精神去敲敲打打，产出些有所用的文字。谨在此恭祝我朝人民：天天开心，事事顺心；新春快乐，阖家欢乐。</p>\n"},{"title":"HTTP状态码列表","date":"2017-11-21T18:58:00.000Z","_content":"\n经常用的 http 状态码\n\n1xx 消息——请求已被服务器接收，继续处理  \n2xx 成功——请求已成功被服务器接收、理解、并接受  \n3xx 重定向——需要后续操作才能完成这一请求  \n4xx 请求错误——请求含有词法错误或者无法被执行  \n5xx 服务器错误——服务器在处理某个正确请求时发生错误  \n100~199：表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程。  \n200~299：表示成功接收请求并已完成整个处理过程。常用 200  \n300~399：为完成请求，客户需进一步细化请求。例如：请求的资源已经移动一个新地址、常用 302（意味着你请求我，我让你去找别人）,307 和 304（我不给你这个资源，自己拿缓存）  \n400~499：客户端的请求有错误，常用 404（意味着你请求的资源在 web 服务器中没有）403（服务器拒绝访问，权限不够）  \n500~599：服务器端出现错误，常用 500\n\n1xx 消息  \n这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。\\[4\\] 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。  \n100 Continue  \n服务器已经接收到请求头，并且客户端应继续发送请求主体（在需要发送身体的请求的情况下：例如，POST 请求），或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。要使服务器检查请求的头部，客户端必须在其初始请求中发送 Expect: 100-continue 作为头部，并在发送正文之前接收 100 Continue 状态代码。响应代码 417 期望失败表示请求不应继续。\\[2\\]  \n101 Switching Protocols  \n服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在 Upgrade 消息头中定义的那些协议。\\[5\\]  \n只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的 HTTP 版本（如 HTTP/2）比旧版本更有优势，或者切换到一个实时且同步的协议（如 WebSocket）以传送利用此类特性的资源。  \n102 Processing（WebDAV；RFC 2518）  \nWebDAV 请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。该代码表示 ​​ 服务器已经收到并正在处理请求，但无响应可用。\\[6\\]这样可以防止客户端超时，并假设请求丢失。\n\n2xx 成功\\[编辑\\]  \n这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。\\[2\\]  \n200 OK  \n请求已成功，请求所希望的响应头或数据体将随此响应返回。实际的响应将取决于所使用的请求方法。在 GET 请求中，响应将包含与请求的资源相对应的实体。在 POST 请求中，响应将包含描述或操作结果的实体。\\[7\\]  \n201 Created  \n请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随 Location 头信息返回。假如需要的资源无法及时建立的话，应当返回'202 Accepted'。\\[8\\]  \n202 Accepted  \n服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理發生时被禁止。\\[9\\]  \n203 Non-Authoritative Information（自 HTTP / 1.1 起）  \n服务器是一个转换代理服务器（transforming proxy，例如网络加速器），以 200 OK 状态码为起源，但回应了原始响应的修改版本。\\[10\\]\\[11\\]  \n204 No Content  \n服务器成功处理了请求，没有返回任何内容。\\[12\\]  \n205 Reset Content  \n服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图。\\[13\\]  \n206 Partial Content（RFC 7233）  \n服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。\\[14\\]  \n207 Multi-Status（WebDAV；RFC 4918）  \n代表之后的消息体将是一个 XML 消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。\\[15\\]  \n208 Already Reported （WebDAV；RFC 5842）  \nDAV 绑定的成员已经在（多状态）响应之前的部分被列举，且未被再次包含。  \n226 IM Used （RFC 3229）  \n服务器已经满足了对资源的请求，对实体请求的一个或多个实体操作的结果表示。\n\n3xx 重定向\\[编辑\\]  \n这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。\\[2\\]  \n当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A 或 A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过 5 次的重定向。\\[17\\]  \n300 Multiple Choices  \n被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。\\[18\\]  \n除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616 规范并没有规定这样的自动选择该如何进行。  \n如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。  \n301 Moved Permanently  \n被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。\\[19\\]除非额外指定，否则这个响应也是可缓存的。  \n新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。  \n如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。  \n注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个 301 响应的话，接下来的重定向请求将会变成 GET 方式。  \n302 Found  \n要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。\\[20\\]由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。  \n新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。  \n如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。  \n注意：虽然 RFC 1945 和 RFC 2068 规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将 302 响应视作为 303 响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。\\[21\\]因此状态码 303 和 307 被添加了进来，用以明确服务器期待客户端进行何种反应。\\[22\\]  \n303 See Other  \n对应当前请求的响应可以在另一个 URI 上被找到，当响应于 POST（或 PUT / DELETE）接收到响应时，客户端应该假定服务器已经收到数据，并且应该使用单独的 GET 消息发出重定向。\\[23\\]这个方法的存在主要是为了允许由脚本激活的 POST 请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303 响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。  \n新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。  \n注意：许多 HTTP/1.1 版以前的浏览器不能正确理解 303 状态。如果需要考虑与这些浏览器之间的互动，302 状态码应该可以胜任，因为大多数的浏览器处理 302 响应时的方式恰恰就是上述规范要求客户端处理 303 响应时应当做的。  \n304 Not Modified  \n表示资源未被修改，因为请求头指定的版本 If-Modified-Since 或 If-None-Match。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。\\[24\\]  \n305 Use Proxy  \n被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立 305 响应。许多 HTTP 客户端（像是 Mozilla\\[25\\]和 Internet Explorer）都没有正确处理这种状态代码的响应，主要是出于安全考虑。\\[26\\]  \n注意：RFC 2068 中没有明确 305 响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。  \n306 Switch Proxy  \n在最新版的规范中，306 状态码已经不再被使用。最初是指“后续请求应使用指定的代理”。\\[27\\]  \n307 Temporary Redirect  \n在这种情况下，请求应该与另一个 URI 重复，但后续的请求应仍使用原始的 URI。 与 302 相反，当重新发出原始请求时，不允许更改请求方法。 例如，应该使用另一个 POST 请求来重复 POST 请求。\\[28\\]  \n308 Permanent Redirect (RFC 7538)  \n请求和所有将来的请求应该使用另一个 URI 重复。 307 和 308 重复 302 和 301 的行为，但不允许 HTTP 方法更改。 例如，将表单提交给永久重定向的资源可能会顺利进行。\\[29\\]  \n4xx 客户端错误\\[编辑\\]  \n这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。\\[30\\]  \n如果错误发生时客户端正在传送数据，那么使用 TCP 的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的 TCP 栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。  \n400 Bad Request  \n由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。\\[31\\]  \n401 Unauthorized（RFC 7235）  \n参见：HTTP 基本认证、HTTP 摘要认证  \n类似于 403 Forbidden，401 语义即“未认证”，即用户没有必要的凭据。\\[32\\]该状态码表示当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。\\[33\\]如果当前请求已经包含了 Authorization 证书，那么 401 响应代表着服务器验证已经拒绝了那些证书。如果 401 响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。  \n注意：当网站（通常是网站域名）禁止 IP 地址时，有些网站状态码显示的 401，表示该特定地址被拒绝访问网站。  \n402 Payment Required  \n该状态码是为了将来可能的需求而预留的。该状态码最初的意图可能被用作某种形式的数字现金或在线支付方案的一部分，但几乎没有哪家服务商使用，而且这个状态码通常不被使用。如果特定开发人员已超过请求的每日限制，Google Developers API 会使用此状态码。\\[34\\]  \n403 Forbidden  \n服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。  \n404 Not Found  \n请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。\\[35\\]没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用 410 状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404 这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。  \n405 Method Not Allowed  \n请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个 Allow 头信息用以表示出当前资源能够接受的请求方法的列表。例如，需要通过 POST 呈现数据的表单上的 GET 请求，或只读资源上的 PUT 请求。  \n鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回 405 错误。  \n406 Not Acceptable  \n参见：内容协商  \n请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，该请求不可接受。\\[36\\]  \n除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。  \n407 Proxy Authentication Required（RFC 2617）  \n与 401 响应类似，只不过客户端必须在代理服务器上进行身份验证。\\[37\\]代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。  \n408 Request Timeout  \n请求超时。根据 HTTP 规范，客户端没有在服务器预备等待的时间内完成一个请求的发送，客户端可以随时再次提交这一请求而无需进行任何更改。\\[38\\]  \n409 Conflict  \n表示因为请求存在冲突无法处理该请求，例如多个同步更新之间的编辑冲突。  \n410 Gone  \n表示所请求的资源不再可用，将不再可用。当资源被有意地删除并且资源应被清除时，应该使用这个。在收到 410 状态码后，用户应停止再次请求资源。\\[39\\]但大多数服务端不会使用此状态码，而是直接使用 404 状态码。  \n411 Length Required  \n服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。\\[40\\]  \n412 Precondition Failed（RFC 7232）  \n服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。\\[41\\]这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。  \n413 Request Entity Too Large（RFC 7231）  \n前称“Request Entity Too Large”，表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。\\[42\\]此种情况下，服务器可以关闭连接以免客户端继续发送此请求。  \n如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。  \n414 Request-URI Too Long（RFC 7231）  \n前称“Request-URI Too Long”，\\[43\\]表示请求的 URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。通常将太多数据的结果编码为 GET 请求的查询字符串，在这种情况下，应将其转换为 POST 请求。\\[44\\]这比较少见，通常的情况包括：  \n本应使用 POST 方法的表单提交变成了 GET 方法，导致查询字符串过长。  \n重定向 URI“黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。  \n客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行\\[45\\]。没有此类漏洞的服务器，应当返回 414 状态码。  \n415 Unsupported Media Type  \n对于当前请求的方法和所请求的资源，请求中提交的互联网媒体类型并不是服务器中所支持的格式，因此请求被拒绝。例如，客户端将图像上传格式为 svg，但服务器要求图像使用上传格式为 jpg。  \n416 Requested Range Not Satisfiable（RFC 7233）  \n前称“Requested Range Not Satisfiable”。\\[46\\]客户端已经要求文件的一部分（Byte serving），但服务器不能提供该部分。例如，如果客户端要求文件的一部分超出文件尾端。\\[47\\]  \n417 Expectation Failed  \n在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。\\[48\\]  \n418 I'm a teapot（RFC 2324）  \n本操作码是在 1998 年作为 IETF 的传统愚人节笑话, 在 RFC 2324 超文本咖啡壶控制协议'中定义的，并不需要在真实的 HTTP 服务器中定义。當一個控制茶壺的 HTCPCP 收到 BREW 或 POST 指令要求其煮咖啡時應當回傳此錯誤。\\[49\\]这个 HTTP 状态码在某些网站（包括 Google.com）與項目（如 Node.js、ASP.NET 和 Go 語言）中用作彩蛋。\\[50\\]  \n420 Enhance Your Caim  \nTwitter Search 与 Trends API 在客户端被限速的情况下返回。  \n421 Misdirected Request （RFC 7540）  \n该请求针对的是无法产生响应的服务器（例如因为连接重用）。\\[51\\]  \n422 Unprocessable Entity（WebDAV；RFC 4918 ）  \n请求格式正确，但是由于含有语义错误，无法响应。\\[15\\]  \n423 Locked（WebDAV；RFC 4918）  \n当前资源被锁定。\\[15\\]  \n424 Failed Dependency（WebDAV；RFC 4918）  \n由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。\\[15\\]  \n425 Unodered Cellection  \n在 WebDAV Advanced Collections Protocol 中定义，但 Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol 中并不存在。  \n426 Upgrade Required（RFC 2817）  \n客户端应当切换到 TLS/1.0，并在 HTTP/1.1 Upgrade header 中给出。\\[15\\]  \n428 Precondition Required (RFC 6585)  \n原服务器要求该请求满足一定条件。这是为了防止“‘未更新’问题，即客户端读取（GET）一个资源的状态，更改它，并将它写（PUT）回服务器，但这期间第三方已经在服务器上更改了该资源的状态，因此导致了冲突。”\\[52\\]  \n429 Too Many Requests （RFC 6585）  \n用户在给定的时间内发送了太多的请求。旨在用于网络限速。\\[52\\]  \n431 Request Header Fields Too Large （RFC 6585）  \n服务器不愿处理请求，因为一个或多个头字段过大。\\[52\\]  \n444 No Response  \nNginx 上 HTTP 服務器擴展。服務器不向客戶端返回任何信息，並關閉連接（有助於阻止惡意軟體）。  \n450 Blocked by Windows Parental Controls  \n這是一個由 Windows 家庭控制（Microsoft）HTTP 阻止的 450 狀態代碼的示例，用於信息和測試。  \n451 Unavailable For Legal Reasons  \n该访问因法律的要求而被拒絕，由 IETF 在 2015 核准后新增加。\\[53\\]\\[54\\]\\[55\\]  \n494 Request Header Too Large  \n這是在將合成為傅里葉變換的情況下，將各個數字顯示為行星輪的狀態碼。  \n5xx 服务器错误\\[编辑\\]  \n表示服务器无法完成明显有效的请求。\\[56\\]这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个 HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。\\[57\\]  \n500 Internal Server Error  \n通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息。\\[58\\]  \n501 Not Implemented  \n服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。\\[59\\]（例如，网络服务 API 的新功能）  \n502 Bad Gateway  \n作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。\\[60\\]  \n503 Service Unavailable  \n由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是暂时的，并且将在一段时间以后恢复。\\[61\\]如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理 500 响应的方式处理它。  \n504 Gateway Timeout  \n作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI 标识出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如 DNS）收到响应。\\[62\\]  \n注意：某些代理服务器在 DNS 查询超时时会返回 400 或者 500 错误。  \n505 HTTP Version Not Supported  \n服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。\\[63\\]这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。  \n506 Variant Also Negotiates（RFC 2295）  \n由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误，\\[64\\]被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。  \n507 Insufficient Storage（WebDAV；RFC 4918）  \n服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。\\[15\\]  \n508 Loop Detected （WebDAV；RFC 5842）  \n服务器在处理请求时陷入死循环。 （可代替 208 状态码）  \n510 Not Extended（RFC 2774）  \n获取资源所需要的策略并没有被满足。\\[65\\]  \n511 Network Authentication Required （RFC 6585）  \n客户端需要进行身份验证才能获得网络访问权限，旨在限制用户群访问特定网络。\n","source":"_posts/2017-11-22-HTTP状态码列表.md","raw":"---\ntitle: HTTP状态码列表\ntags:\n  - 技术\n  - 网络\ndate: 2017-11-22 02:58:00\ncategories: 前端\n---\n\n经常用的 http 状态码\n\n1xx 消息——请求已被服务器接收，继续处理  \n2xx 成功——请求已成功被服务器接收、理解、并接受  \n3xx 重定向——需要后续操作才能完成这一请求  \n4xx 请求错误——请求含有词法错误或者无法被执行  \n5xx 服务器错误——服务器在处理某个正确请求时发生错误  \n100~199：表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程。  \n200~299：表示成功接收请求并已完成整个处理过程。常用 200  \n300~399：为完成请求，客户需进一步细化请求。例如：请求的资源已经移动一个新地址、常用 302（意味着你请求我，我让你去找别人）,307 和 304（我不给你这个资源，自己拿缓存）  \n400~499：客户端的请求有错误，常用 404（意味着你请求的资源在 web 服务器中没有）403（服务器拒绝访问，权限不够）  \n500~599：服务器端出现错误，常用 500\n\n1xx 消息  \n这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。\\[4\\] 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。  \n100 Continue  \n服务器已经接收到请求头，并且客户端应继续发送请求主体（在需要发送身体的请求的情况下：例如，POST 请求），或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。要使服务器检查请求的头部，客户端必须在其初始请求中发送 Expect: 100-continue 作为头部，并在发送正文之前接收 100 Continue 状态代码。响应代码 417 期望失败表示请求不应继续。\\[2\\]  \n101 Switching Protocols  \n服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在 Upgrade 消息头中定义的那些协议。\\[5\\]  \n只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的 HTTP 版本（如 HTTP/2）比旧版本更有优势，或者切换到一个实时且同步的协议（如 WebSocket）以传送利用此类特性的资源。  \n102 Processing（WebDAV；RFC 2518）  \nWebDAV 请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。该代码表示 ​​ 服务器已经收到并正在处理请求，但无响应可用。\\[6\\]这样可以防止客户端超时，并假设请求丢失。\n\n2xx 成功\\[编辑\\]  \n这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。\\[2\\]  \n200 OK  \n请求已成功，请求所希望的响应头或数据体将随此响应返回。实际的响应将取决于所使用的请求方法。在 GET 请求中，响应将包含与请求的资源相对应的实体。在 POST 请求中，响应将包含描述或操作结果的实体。\\[7\\]  \n201 Created  \n请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随 Location 头信息返回。假如需要的资源无法及时建立的话，应当返回'202 Accepted'。\\[8\\]  \n202 Accepted  \n服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理發生时被禁止。\\[9\\]  \n203 Non-Authoritative Information（自 HTTP / 1.1 起）  \n服务器是一个转换代理服务器（transforming proxy，例如网络加速器），以 200 OK 状态码为起源，但回应了原始响应的修改版本。\\[10\\]\\[11\\]  \n204 No Content  \n服务器成功处理了请求，没有返回任何内容。\\[12\\]  \n205 Reset Content  \n服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图。\\[13\\]  \n206 Partial Content（RFC 7233）  \n服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。\\[14\\]  \n207 Multi-Status（WebDAV；RFC 4918）  \n代表之后的消息体将是一个 XML 消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。\\[15\\]  \n208 Already Reported （WebDAV；RFC 5842）  \nDAV 绑定的成员已经在（多状态）响应之前的部分被列举，且未被再次包含。  \n226 IM Used （RFC 3229）  \n服务器已经满足了对资源的请求，对实体请求的一个或多个实体操作的结果表示。\n\n3xx 重定向\\[编辑\\]  \n这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。\\[2\\]  \n当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A 或 A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过 5 次的重定向。\\[17\\]  \n300 Multiple Choices  \n被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。\\[18\\]  \n除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616 规范并没有规定这样的自动选择该如何进行。  \n如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。  \n301 Moved Permanently  \n被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。\\[19\\]除非额外指定，否则这个响应也是可缓存的。  \n新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。  \n如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。  \n注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个 301 响应的话，接下来的重定向请求将会变成 GET 方式。  \n302 Found  \n要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。\\[20\\]由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。  \n新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。  \n如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。  \n注意：虽然 RFC 1945 和 RFC 2068 规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将 302 响应视作为 303 响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。\\[21\\]因此状态码 303 和 307 被添加了进来，用以明确服务器期待客户端进行何种反应。\\[22\\]  \n303 See Other  \n对应当前请求的响应可以在另一个 URI 上被找到，当响应于 POST（或 PUT / DELETE）接收到响应时，客户端应该假定服务器已经收到数据，并且应该使用单独的 GET 消息发出重定向。\\[23\\]这个方法的存在主要是为了允许由脚本激活的 POST 请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303 响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。  \n新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。  \n注意：许多 HTTP/1.1 版以前的浏览器不能正确理解 303 状态。如果需要考虑与这些浏览器之间的互动，302 状态码应该可以胜任，因为大多数的浏览器处理 302 响应时的方式恰恰就是上述规范要求客户端处理 303 响应时应当做的。  \n304 Not Modified  \n表示资源未被修改，因为请求头指定的版本 If-Modified-Since 或 If-None-Match。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。\\[24\\]  \n305 Use Proxy  \n被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立 305 响应。许多 HTTP 客户端（像是 Mozilla\\[25\\]和 Internet Explorer）都没有正确处理这种状态代码的响应，主要是出于安全考虑。\\[26\\]  \n注意：RFC 2068 中没有明确 305 响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。  \n306 Switch Proxy  \n在最新版的规范中，306 状态码已经不再被使用。最初是指“后续请求应使用指定的代理”。\\[27\\]  \n307 Temporary Redirect  \n在这种情况下，请求应该与另一个 URI 重复，但后续的请求应仍使用原始的 URI。 与 302 相反，当重新发出原始请求时，不允许更改请求方法。 例如，应该使用另一个 POST 请求来重复 POST 请求。\\[28\\]  \n308 Permanent Redirect (RFC 7538)  \n请求和所有将来的请求应该使用另一个 URI 重复。 307 和 308 重复 302 和 301 的行为，但不允许 HTTP 方法更改。 例如，将表单提交给永久重定向的资源可能会顺利进行。\\[29\\]  \n4xx 客户端错误\\[编辑\\]  \n这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。\\[30\\]  \n如果错误发生时客户端正在传送数据，那么使用 TCP 的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的 TCP 栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。  \n400 Bad Request  \n由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。\\[31\\]  \n401 Unauthorized（RFC 7235）  \n参见：HTTP 基本认证、HTTP 摘要认证  \n类似于 403 Forbidden，401 语义即“未认证”，即用户没有必要的凭据。\\[32\\]该状态码表示当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。\\[33\\]如果当前请求已经包含了 Authorization 证书，那么 401 响应代表着服务器验证已经拒绝了那些证书。如果 401 响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。  \n注意：当网站（通常是网站域名）禁止 IP 地址时，有些网站状态码显示的 401，表示该特定地址被拒绝访问网站。  \n402 Payment Required  \n该状态码是为了将来可能的需求而预留的。该状态码最初的意图可能被用作某种形式的数字现金或在线支付方案的一部分，但几乎没有哪家服务商使用，而且这个状态码通常不被使用。如果特定开发人员已超过请求的每日限制，Google Developers API 会使用此状态码。\\[34\\]  \n403 Forbidden  \n服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。  \n404 Not Found  \n请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。\\[35\\]没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用 410 状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404 这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。  \n405 Method Not Allowed  \n请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个 Allow 头信息用以表示出当前资源能够接受的请求方法的列表。例如，需要通过 POST 呈现数据的表单上的 GET 请求，或只读资源上的 PUT 请求。  \n鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回 405 错误。  \n406 Not Acceptable  \n参见：内容协商  \n请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，该请求不可接受。\\[36\\]  \n除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。  \n407 Proxy Authentication Required（RFC 2617）  \n与 401 响应类似，只不过客户端必须在代理服务器上进行身份验证。\\[37\\]代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。  \n408 Request Timeout  \n请求超时。根据 HTTP 规范，客户端没有在服务器预备等待的时间内完成一个请求的发送，客户端可以随时再次提交这一请求而无需进行任何更改。\\[38\\]  \n409 Conflict  \n表示因为请求存在冲突无法处理该请求，例如多个同步更新之间的编辑冲突。  \n410 Gone  \n表示所请求的资源不再可用，将不再可用。当资源被有意地删除并且资源应被清除时，应该使用这个。在收到 410 状态码后，用户应停止再次请求资源。\\[39\\]但大多数服务端不会使用此状态码，而是直接使用 404 状态码。  \n411 Length Required  \n服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。\\[40\\]  \n412 Precondition Failed（RFC 7232）  \n服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。\\[41\\]这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。  \n413 Request Entity Too Large（RFC 7231）  \n前称“Request Entity Too Large”，表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。\\[42\\]此种情况下，服务器可以关闭连接以免客户端继续发送此请求。  \n如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。  \n414 Request-URI Too Long（RFC 7231）  \n前称“Request-URI Too Long”，\\[43\\]表示请求的 URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。通常将太多数据的结果编码为 GET 请求的查询字符串，在这种情况下，应将其转换为 POST 请求。\\[44\\]这比较少见，通常的情况包括：  \n本应使用 POST 方法的表单提交变成了 GET 方法，导致查询字符串过长。  \n重定向 URI“黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。  \n客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行\\[45\\]。没有此类漏洞的服务器，应当返回 414 状态码。  \n415 Unsupported Media Type  \n对于当前请求的方法和所请求的资源，请求中提交的互联网媒体类型并不是服务器中所支持的格式，因此请求被拒绝。例如，客户端将图像上传格式为 svg，但服务器要求图像使用上传格式为 jpg。  \n416 Requested Range Not Satisfiable（RFC 7233）  \n前称“Requested Range Not Satisfiable”。\\[46\\]客户端已经要求文件的一部分（Byte serving），但服务器不能提供该部分。例如，如果客户端要求文件的一部分超出文件尾端。\\[47\\]  \n417 Expectation Failed  \n在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。\\[48\\]  \n418 I'm a teapot（RFC 2324）  \n本操作码是在 1998 年作为 IETF 的传统愚人节笑话, 在 RFC 2324 超文本咖啡壶控制协议'中定义的，并不需要在真实的 HTTP 服务器中定义。當一個控制茶壺的 HTCPCP 收到 BREW 或 POST 指令要求其煮咖啡時應當回傳此錯誤。\\[49\\]这个 HTTP 状态码在某些网站（包括 Google.com）與項目（如 Node.js、ASP.NET 和 Go 語言）中用作彩蛋。\\[50\\]  \n420 Enhance Your Caim  \nTwitter Search 与 Trends API 在客户端被限速的情况下返回。  \n421 Misdirected Request （RFC 7540）  \n该请求针对的是无法产生响应的服务器（例如因为连接重用）。\\[51\\]  \n422 Unprocessable Entity（WebDAV；RFC 4918 ）  \n请求格式正确，但是由于含有语义错误，无法响应。\\[15\\]  \n423 Locked（WebDAV；RFC 4918）  \n当前资源被锁定。\\[15\\]  \n424 Failed Dependency（WebDAV；RFC 4918）  \n由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。\\[15\\]  \n425 Unodered Cellection  \n在 WebDAV Advanced Collections Protocol 中定义，但 Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol 中并不存在。  \n426 Upgrade Required（RFC 2817）  \n客户端应当切换到 TLS/1.0，并在 HTTP/1.1 Upgrade header 中给出。\\[15\\]  \n428 Precondition Required (RFC 6585)  \n原服务器要求该请求满足一定条件。这是为了防止“‘未更新’问题，即客户端读取（GET）一个资源的状态，更改它，并将它写（PUT）回服务器，但这期间第三方已经在服务器上更改了该资源的状态，因此导致了冲突。”\\[52\\]  \n429 Too Many Requests （RFC 6585）  \n用户在给定的时间内发送了太多的请求。旨在用于网络限速。\\[52\\]  \n431 Request Header Fields Too Large （RFC 6585）  \n服务器不愿处理请求，因为一个或多个头字段过大。\\[52\\]  \n444 No Response  \nNginx 上 HTTP 服務器擴展。服務器不向客戶端返回任何信息，並關閉連接（有助於阻止惡意軟體）。  \n450 Blocked by Windows Parental Controls  \n這是一個由 Windows 家庭控制（Microsoft）HTTP 阻止的 450 狀態代碼的示例，用於信息和測試。  \n451 Unavailable For Legal Reasons  \n该访问因法律的要求而被拒絕，由 IETF 在 2015 核准后新增加。\\[53\\]\\[54\\]\\[55\\]  \n494 Request Header Too Large  \n這是在將合成為傅里葉變換的情況下，將各個數字顯示為行星輪的狀態碼。  \n5xx 服务器错误\\[编辑\\]  \n表示服务器无法完成明显有效的请求。\\[56\\]这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个 HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。\\[57\\]  \n500 Internal Server Error  \n通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息。\\[58\\]  \n501 Not Implemented  \n服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。\\[59\\]（例如，网络服务 API 的新功能）  \n502 Bad Gateway  \n作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。\\[60\\]  \n503 Service Unavailable  \n由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是暂时的，并且将在一段时间以后恢复。\\[61\\]如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理 500 响应的方式处理它。  \n504 Gateway Timeout  \n作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI 标识出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如 DNS）收到响应。\\[62\\]  \n注意：某些代理服务器在 DNS 查询超时时会返回 400 或者 500 错误。  \n505 HTTP Version Not Supported  \n服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。\\[63\\]这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。  \n506 Variant Also Negotiates（RFC 2295）  \n由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误，\\[64\\]被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。  \n507 Insufficient Storage（WebDAV；RFC 4918）  \n服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。\\[15\\]  \n508 Loop Detected （WebDAV；RFC 5842）  \n服务器在处理请求时陷入死循环。 （可代替 208 状态码）  \n510 Not Extended（RFC 2774）  \n获取资源所需要的策略并没有被满足。\\[65\\]  \n511 Network Authentication Required （RFC 6585）  \n客户端需要进行身份验证才能获得网络访问权限，旨在限制用户群访问特定网络。\n","slug":"2017-11-22-HTTP状态码列表","published":1,"updated":"2020-03-14T06:49:17.058Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvo0006t4k8y2e308xsb","content":"<p>经常用的 http 状态码</p>\n<p>1xx 消息——请求已被服务器接收，继续处理<br>2xx 成功——请求已成功被服务器接收、理解、并接受<br>3xx 重定向——需要后续操作才能完成这一请求<br>4xx 请求错误——请求含有词法错误或者无法被执行<br>5xx 服务器错误——服务器在处理某个正确请求时发生错误<br>100<del>199：表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程。<br>200</del>299：表示成功接收请求并已完成整个处理过程。常用 200<br>300<del>399：为完成请求，客户需进一步细化请求。例如：请求的资源已经移动一个新地址、常用 302（意味着你请求我，我让你去找别人）,307 和 304（我不给你这个资源，自己拿缓存）<br>400</del>499：客户端的请求有错误，常用 404（意味着你请求的资源在 web 服务器中没有）403（服务器拒绝访问，权限不够）<br>500~599：服务器端出现错误，常用 500</p>\n<p>1xx 消息<br>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。[4] 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。<br>100 Continue<br>服务器已经接收到请求头，并且客户端应继续发送请求主体（在需要发送身体的请求的情况下：例如，POST 请求），或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。要使服务器检查请求的头部，客户端必须在其初始请求中发送 Expect: 100-continue 作为头部，并在发送正文之前接收 100 Continue 状态代码。响应代码 417 期望失败表示请求不应继续。[2]<br>101 Switching Protocols<br>服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在 Upgrade 消息头中定义的那些协议。[5]<br>只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的 HTTP 版本（如 HTTP/2）比旧版本更有优势，或者切换到一个实时且同步的协议（如 WebSocket）以传送利用此类特性的资源。<br>102 Processing（WebDAV；RFC 2518）<br>WebDAV 请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。该代码表示 ​​ 服务器已经收到并正在处理请求，但无响应可用。[6]这样可以防止客户端超时，并假设请求丢失。</p>\n<p>2xx 成功[编辑]<br>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。[2]<br>200 OK<br>请求已成功，请求所希望的响应头或数据体将随此响应返回。实际的响应将取决于所使用的请求方法。在 GET 请求中，响应将包含与请求的资源相对应的实体。在 POST 请求中，响应将包含描述或操作结果的实体。[7]<br>201 Created<br>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随 Location 头信息返回。假如需要的资源无法及时建立的话，应当返回’202 Accepted’。[8]<br>202 Accepted<br>服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理發生时被禁止。[9]<br>203 Non-Authoritative Information（自 HTTP / 1.1 起）<br>服务器是一个转换代理服务器（transforming proxy，例如网络加速器），以 200 OK 状态码为起源，但回应了原始响应的修改版本。[10][11]<br>204 No Content<br>服务器成功处理了请求，没有返回任何内容。[12]<br>205 Reset Content<br>服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图。[13]<br>206 Partial Content（RFC 7233）<br>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。[14]<br>207 Multi-Status（WebDAV；RFC 4918）<br>代表之后的消息体将是一个 XML 消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。[15]<br>208 Already Reported （WebDAV；RFC 5842）<br>DAV 绑定的成员已经在（多状态）响应之前的部分被列举，且未被再次包含。<br>226 IM Used （RFC 3229）<br>服务器已经满足了对资源的请求，对实体请求的一个或多个实体操作的结果表示。</p>\n<p>3xx 重定向[编辑]<br>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。[2]<br>当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A 或 A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过 5 次的重定向。[17]<br>300 Multiple Choices<br>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。[18]<br>除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616 规范并没有规定这样的自动选择该如何进行。<br>如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。<br>301 Moved Permanently<br>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。[19]除非额外指定，否则这个响应也是可缓存的。<br>新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。<br>如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<br>注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个 301 响应的话，接下来的重定向请求将会变成 GET 方式。<br>302 Found<br>要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。[20]由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。<br>新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。<br>如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<br>注意：虽然 RFC 1945 和 RFC 2068 规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将 302 响应视作为 303 响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。[21]因此状态码 303 和 307 被添加了进来，用以明确服务器期待客户端进行何种反应。[22]<br>303 See Other<br>对应当前请求的响应可以在另一个 URI 上被找到，当响应于 POST（或 PUT / DELETE）接收到响应时，客户端应该假定服务器已经收到数据，并且应该使用单独的 GET 消息发出重定向。[23]这个方法的存在主要是为了允许由脚本激活的 POST 请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303 响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。<br>新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。<br>注意：许多 HTTP/1.1 版以前的浏览器不能正确理解 303 状态。如果需要考虑与这些浏览器之间的互动，302 状态码应该可以胜任，因为大多数的浏览器处理 302 响应时的方式恰恰就是上述规范要求客户端处理 303 响应时应当做的。<br>304 Not Modified<br>表示资源未被修改，因为请求头指定的版本 If-Modified-Since 或 If-None-Match。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。[24]<br>305 Use Proxy<br>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立 305 响应。许多 HTTP 客户端（像是 Mozilla[25]和 Internet Explorer）都没有正确处理这种状态代码的响应，主要是出于安全考虑。[26]<br>注意：RFC 2068 中没有明确 305 响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。<br>306 Switch Proxy<br>在最新版的规范中，306 状态码已经不再被使用。最初是指“后续请求应使用指定的代理”。[27]<br>307 Temporary Redirect<br>在这种情况下，请求应该与另一个 URI 重复，但后续的请求应仍使用原始的 URI。 与 302 相反，当重新发出原始请求时，不允许更改请求方法。 例如，应该使用另一个 POST 请求来重复 POST 请求。[28]<br>308 Permanent Redirect (RFC 7538)<br>请求和所有将来的请求应该使用另一个 URI 重复。 307 和 308 重复 302 和 301 的行为，但不允许 HTTP 方法更改。 例如，将表单提交给永久重定向的资源可能会顺利进行。[29]<br>4xx 客户端错误[编辑]<br>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。[30]<br>如果错误发生时客户端正在传送数据，那么使用 TCP 的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的 TCP 栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。<br>400 Bad Request<br>由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。[31]<br>401 Unauthorized（RFC 7235）<br>参见：HTTP 基本认证、HTTP 摘要认证<br>类似于 403 Forbidden，401 语义即“未认证”，即用户没有必要的凭据。[32]该状态码表示当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。[33]如果当前请求已经包含了 Authorization 证书，那么 401 响应代表着服务器验证已经拒绝了那些证书。如果 401 响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。<br>注意：当网站（通常是网站域名）禁止 IP 地址时，有些网站状态码显示的 401，表示该特定地址被拒绝访问网站。<br>402 Payment Required<br>该状态码是为了将来可能的需求而预留的。该状态码最初的意图可能被用作某种形式的数字现金或在线支付方案的一部分，但几乎没有哪家服务商使用，而且这个状态码通常不被使用。如果特定开发人员已超过请求的每日限制，Google Developers API 会使用此状态码。[34]<br>403 Forbidden<br>服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。<br>404 Not Found<br>请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。[35]没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用 410 状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404 这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。<br>405 Method Not Allowed<br>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个 Allow 头信息用以表示出当前资源能够接受的请求方法的列表。例如，需要通过 POST 呈现数据的表单上的 GET 请求，或只读资源上的 PUT 请求。<br>鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回 405 错误。<br>406 Not Acceptable<br>参见：内容协商<br>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，该请求不可接受。[36]<br>除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。<br>407 Proxy Authentication Required（RFC 2617）<br>与 401 响应类似，只不过客户端必须在代理服务器上进行身份验证。[37]代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。<br>408 Request Timeout<br>请求超时。根据 HTTP 规范，客户端没有在服务器预备等待的时间内完成一个请求的发送，客户端可以随时再次提交这一请求而无需进行任何更改。[38]<br>409 Conflict<br>表示因为请求存在冲突无法处理该请求，例如多个同步更新之间的编辑冲突。<br>410 Gone<br>表示所请求的资源不再可用，将不再可用。当资源被有意地删除并且资源应被清除时，应该使用这个。在收到 410 状态码后，用户应停止再次请求资源。[39]但大多数服务端不会使用此状态码，而是直接使用 404 状态码。<br>411 Length Required<br>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。[40]<br>412 Precondition Failed（RFC 7232）<br>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。[41]这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。<br>413 Request Entity Too Large（RFC 7231）<br>前称“Request Entity Too Large”，表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。[42]此种情况下，服务器可以关闭连接以免客户端继续发送此请求。<br>如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。<br>414 Request-URI Too Long（RFC 7231）<br>前称“Request-URI Too Long”，[43]表示请求的 URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。通常将太多数据的结果编码为 GET 请求的查询字符串，在这种情况下，应将其转换为 POST 请求。[44]这比较少见，通常的情况包括：<br>本应使用 POST 方法的表单提交变成了 GET 方法，导致查询字符串过长。<br>重定向 URI“黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。<br>客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[45]。没有此类漏洞的服务器，应当返回 414 状态码。<br>415 Unsupported Media Type<br>对于当前请求的方法和所请求的资源，请求中提交的互联网媒体类型并不是服务器中所支持的格式，因此请求被拒绝。例如，客户端将图像上传格式为 svg，但服务器要求图像使用上传格式为 jpg。<br>416 Requested Range Not Satisfiable（RFC 7233）<br>前称“Requested Range Not Satisfiable”。[46]客户端已经要求文件的一部分（Byte serving），但服务器不能提供该部分。例如，如果客户端要求文件的一部分超出文件尾端。[47]<br>417 Expectation Failed<br>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。[48]<br>418 I’m a teapot（RFC 2324）<br>本操作码是在 1998 年作为 IETF 的传统愚人节笑话, 在 RFC 2324 超文本咖啡壶控制协议’中定义的，并不需要在真实的 HTTP 服务器中定义。當一個控制茶壺的 HTCPCP 收到 BREW 或 POST 指令要求其煮咖啡時應當回傳此錯誤。[49]这个 HTTP 状态码在某些网站（包括 Google.com）與項目（如 Node.js、ASP.NET 和 Go 語言）中用作彩蛋。[50]<br>420 Enhance Your Caim<br>Twitter Search 与 Trends API 在客户端被限速的情况下返回。<br>421 Misdirected Request （RFC 7540）<br>该请求针对的是无法产生响应的服务器（例如因为连接重用）。[51]<br>422 Unprocessable Entity（WebDAV；RFC 4918 ）<br>请求格式正确，但是由于含有语义错误，无法响应。[15]<br>423 Locked（WebDAV；RFC 4918）<br>当前资源被锁定。[15]<br>424 Failed Dependency（WebDAV；RFC 4918）<br>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。[15]<br>425 Unodered Cellection<br>在 WebDAV Advanced Collections Protocol 中定义，但 Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol 中并不存在。<br>426 Upgrade Required（RFC 2817）<br>客户端应当切换到 TLS/1.0，并在 HTTP/1.1 Upgrade header 中给出。[15]<br>428 Precondition Required (RFC 6585)<br>原服务器要求该请求满足一定条件。这是为了防止“‘未更新’问题，即客户端读取（GET）一个资源的状态，更改它，并将它写（PUT）回服务器，但这期间第三方已经在服务器上更改了该资源的状态，因此导致了冲突。”[52]<br>429 Too Many Requests （RFC 6585）<br>用户在给定的时间内发送了太多的请求。旨在用于网络限速。[52]<br>431 Request Header Fields Too Large （RFC 6585）<br>服务器不愿处理请求，因为一个或多个头字段过大。[52]<br>444 No Response<br>Nginx 上 HTTP 服務器擴展。服務器不向客戶端返回任何信息，並關閉連接（有助於阻止惡意軟體）。<br>450 Blocked by Windows Parental Controls<br>這是一個由 Windows 家庭控制（Microsoft）HTTP 阻止的 450 狀態代碼的示例，用於信息和測試。<br>451 Unavailable For Legal Reasons<br>该访问因法律的要求而被拒絕，由 IETF 在 2015 核准后新增加。[53][54][55]<br>494 Request Header Too Large<br>這是在將合成為傅里葉變換的情況下，將各個數字顯示為行星輪的狀態碼。<br>5xx 服务器错误[编辑]<br>表示服务器无法完成明显有效的请求。[56]这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个 HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。[57]<br>500 Internal Server Error<br>通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息。[58]<br>501 Not Implemented<br>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。[59]（例如，网络服务 API 的新功能）<br>502 Bad Gateway<br>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。[60]<br>503 Service Unavailable<br>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是暂时的，并且将在一段时间以后恢复。[61]如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理 500 响应的方式处理它。<br>504 Gateway Timeout<br>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI 标识出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如 DNS）收到响应。[62]<br>注意：某些代理服务器在 DNS 查询超时时会返回 400 或者 500 错误。<br>505 HTTP Version Not Supported<br>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。[63]这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。<br>506 Variant Also Negotiates（RFC 2295）<br>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误，[64]被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。<br>507 Insufficient Storage（WebDAV；RFC 4918）<br>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。[15]<br>508 Loop Detected （WebDAV；RFC 5842）<br>服务器在处理请求时陷入死循环。 （可代替 208 状态码）<br>510 Not Extended（RFC 2774）<br>获取资源所需要的策略并没有被满足。[65]<br>511 Network Authentication Required （RFC 6585）<br>客户端需要进行身份验证才能获得网络访问权限，旨在限制用户群访问特定网络。</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>经常用的 http 状态码</p>\n<p>1xx 消息——请求已被服务器接收，继续处理<br>2xx 成功——请求已成功被服务器接收、理解、并接受<br>3xx 重定向——需要后续操作才能完成这一请求<br>4xx 请求错误——请求含有词法错误或者无法被执行<br>5xx 服务器错误——服务器在处理某个正确请求时发生错误<br>100<del>199：表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程。<br>200</del>299：表示成功接收请求并已完成整个处理过程。常用 200<br>300<del>399：为完成请求，客户需进一步细化请求。例如：请求的资源已经移动一个新地址、常用 302（意味着你请求我，我让你去找别人）,307 和 304（我不给你这个资源，自己拿缓存）<br>400</del>499：客户端的请求有错误，常用 404（意味着你请求的资源在 web 服务器中没有）403（服务器拒绝访问，权限不够）<br>500~599：服务器端出现错误，常用 500</p>\n<p>1xx 消息<br>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。[4] 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。<br>100 Continue<br>服务器已经接收到请求头，并且客户端应继续发送请求主体（在需要发送身体的请求的情况下：例如，POST 请求），或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。要使服务器检查请求的头部，客户端必须在其初始请求中发送 Expect: 100-continue 作为头部，并在发送正文之前接收 100 Continue 状态代码。响应代码 417 期望失败表示请求不应继续。[2]<br>101 Switching Protocols<br>服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在 Upgrade 消息头中定义的那些协议。[5]<br>只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的 HTTP 版本（如 HTTP/2）比旧版本更有优势，或者切换到一个实时且同步的协议（如 WebSocket）以传送利用此类特性的资源。<br>102 Processing（WebDAV；RFC 2518）<br>WebDAV 请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。该代码表示 ​​ 服务器已经收到并正在处理请求，但无响应可用。[6]这样可以防止客户端超时，并假设请求丢失。</p>\n<p>2xx 成功[编辑]<br>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。[2]<br>200 OK<br>请求已成功，请求所希望的响应头或数据体将随此响应返回。实际的响应将取决于所使用的请求方法。在 GET 请求中，响应将包含与请求的资源相对应的实体。在 POST 请求中，响应将包含描述或操作结果的实体。[7]<br>201 Created<br>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随 Location 头信息返回。假如需要的资源无法及时建立的话，应当返回’202 Accepted’。[8]<br>202 Accepted<br>服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理發生时被禁止。[9]<br>203 Non-Authoritative Information（自 HTTP / 1.1 起）<br>服务器是一个转换代理服务器（transforming proxy，例如网络加速器），以 200 OK 状态码为起源，但回应了原始响应的修改版本。[10][11]<br>204 No Content<br>服务器成功处理了请求，没有返回任何内容。[12]<br>205 Reset Content<br>服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图。[13]<br>206 Partial Content（RFC 7233）<br>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。[14]<br>207 Multi-Status（WebDAV；RFC 4918）<br>代表之后的消息体将是一个 XML 消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。[15]<br>208 Already Reported （WebDAV；RFC 5842）<br>DAV 绑定的成员已经在（多状态）响应之前的部分被列举，且未被再次包含。<br>226 IM Used （RFC 3229）<br>服务器已经满足了对资源的请求，对实体请求的一个或多个实体操作的结果表示。</p>\n<p>3xx 重定向[编辑]<br>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。[2]<br>当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A 或 A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过 5 次的重定向。[17]<br>300 Multiple Choices<br>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。[18]<br>除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616 规范并没有规定这样的自动选择该如何进行。<br>如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。<br>301 Moved Permanently<br>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。[19]除非额外指定，否则这个响应也是可缓存的。<br>新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。<br>如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<br>注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个 301 响应的话，接下来的重定向请求将会变成 GET 方式。<br>302 Found<br>要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。[20]由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。<br>新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。<br>如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<br>注意：虽然 RFC 1945 和 RFC 2068 规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将 302 响应视作为 303 响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。[21]因此状态码 303 和 307 被添加了进来，用以明确服务器期待客户端进行何种反应。[22]<br>303 See Other<br>对应当前请求的响应可以在另一个 URI 上被找到，当响应于 POST（或 PUT / DELETE）接收到响应时，客户端应该假定服务器已经收到数据，并且应该使用单独的 GET 消息发出重定向。[23]这个方法的存在主要是为了允许由脚本激活的 POST 请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303 响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。<br>新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。<br>注意：许多 HTTP/1.1 版以前的浏览器不能正确理解 303 状态。如果需要考虑与这些浏览器之间的互动，302 状态码应该可以胜任，因为大多数的浏览器处理 302 响应时的方式恰恰就是上述规范要求客户端处理 303 响应时应当做的。<br>304 Not Modified<br>表示资源未被修改，因为请求头指定的版本 If-Modified-Since 或 If-None-Match。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。[24]<br>305 Use Proxy<br>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立 305 响应。许多 HTTP 客户端（像是 Mozilla[25]和 Internet Explorer）都没有正确处理这种状态代码的响应，主要是出于安全考虑。[26]<br>注意：RFC 2068 中没有明确 305 响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。<br>306 Switch Proxy<br>在最新版的规范中，306 状态码已经不再被使用。最初是指“后续请求应使用指定的代理”。[27]<br>307 Temporary Redirect<br>在这种情况下，请求应该与另一个 URI 重复，但后续的请求应仍使用原始的 URI。 与 302 相反，当重新发出原始请求时，不允许更改请求方法。 例如，应该使用另一个 POST 请求来重复 POST 请求。[28]<br>308 Permanent Redirect (RFC 7538)<br>请求和所有将来的请求应该使用另一个 URI 重复。 307 和 308 重复 302 和 301 的行为，但不允许 HTTP 方法更改。 例如，将表单提交给永久重定向的资源可能会顺利进行。[29]<br>4xx 客户端错误[编辑]<br>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。[30]<br>如果错误发生时客户端正在传送数据，那么使用 TCP 的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的 TCP 栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。<br>400 Bad Request<br>由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。[31]<br>401 Unauthorized（RFC 7235）<br>参见：HTTP 基本认证、HTTP 摘要认证<br>类似于 403 Forbidden，401 语义即“未认证”，即用户没有必要的凭据。[32]该状态码表示当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。[33]如果当前请求已经包含了 Authorization 证书，那么 401 响应代表着服务器验证已经拒绝了那些证书。如果 401 响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。<br>注意：当网站（通常是网站域名）禁止 IP 地址时，有些网站状态码显示的 401，表示该特定地址被拒绝访问网站。<br>402 Payment Required<br>该状态码是为了将来可能的需求而预留的。该状态码最初的意图可能被用作某种形式的数字现金或在线支付方案的一部分，但几乎没有哪家服务商使用，而且这个状态码通常不被使用。如果特定开发人员已超过请求的每日限制，Google Developers API 会使用此状态码。[34]<br>403 Forbidden<br>服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。<br>404 Not Found<br>请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。[35]没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用 410 状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404 这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。<br>405 Method Not Allowed<br>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个 Allow 头信息用以表示出当前资源能够接受的请求方法的列表。例如，需要通过 POST 呈现数据的表单上的 GET 请求，或只读资源上的 PUT 请求。<br>鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回 405 错误。<br>406 Not Acceptable<br>参见：内容协商<br>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，该请求不可接受。[36]<br>除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。<br>407 Proxy Authentication Required（RFC 2617）<br>与 401 响应类似，只不过客户端必须在代理服务器上进行身份验证。[37]代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。<br>408 Request Timeout<br>请求超时。根据 HTTP 规范，客户端没有在服务器预备等待的时间内完成一个请求的发送，客户端可以随时再次提交这一请求而无需进行任何更改。[38]<br>409 Conflict<br>表示因为请求存在冲突无法处理该请求，例如多个同步更新之间的编辑冲突。<br>410 Gone<br>表示所请求的资源不再可用，将不再可用。当资源被有意地删除并且资源应被清除时，应该使用这个。在收到 410 状态码后，用户应停止再次请求资源。[39]但大多数服务端不会使用此状态码，而是直接使用 404 状态码。<br>411 Length Required<br>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。[40]<br>412 Precondition Failed（RFC 7232）<br>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。[41]这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。<br>413 Request Entity Too Large（RFC 7231）<br>前称“Request Entity Too Large”，表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。[42]此种情况下，服务器可以关闭连接以免客户端继续发送此请求。<br>如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。<br>414 Request-URI Too Long（RFC 7231）<br>前称“Request-URI Too Long”，[43]表示请求的 URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。通常将太多数据的结果编码为 GET 请求的查询字符串，在这种情况下，应将其转换为 POST 请求。[44]这比较少见，通常的情况包括：<br>本应使用 POST 方法的表单提交变成了 GET 方法，导致查询字符串过长。<br>重定向 URI“黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。<br>客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[45]。没有此类漏洞的服务器，应当返回 414 状态码。<br>415 Unsupported Media Type<br>对于当前请求的方法和所请求的资源，请求中提交的互联网媒体类型并不是服务器中所支持的格式，因此请求被拒绝。例如，客户端将图像上传格式为 svg，但服务器要求图像使用上传格式为 jpg。<br>416 Requested Range Not Satisfiable（RFC 7233）<br>前称“Requested Range Not Satisfiable”。[46]客户端已经要求文件的一部分（Byte serving），但服务器不能提供该部分。例如，如果客户端要求文件的一部分超出文件尾端。[47]<br>417 Expectation Failed<br>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。[48]<br>418 I’m a teapot（RFC 2324）<br>本操作码是在 1998 年作为 IETF 的传统愚人节笑话, 在 RFC 2324 超文本咖啡壶控制协议’中定义的，并不需要在真实的 HTTP 服务器中定义。當一個控制茶壺的 HTCPCP 收到 BREW 或 POST 指令要求其煮咖啡時應當回傳此錯誤。[49]这个 HTTP 状态码在某些网站（包括 Google.com）與項目（如 Node.js、ASP.NET 和 Go 語言）中用作彩蛋。[50]<br>420 Enhance Your Caim<br>Twitter Search 与 Trends API 在客户端被限速的情况下返回。<br>421 Misdirected Request （RFC 7540）<br>该请求针对的是无法产生响应的服务器（例如因为连接重用）。[51]<br>422 Unprocessable Entity（WebDAV；RFC 4918 ）<br>请求格式正确，但是由于含有语义错误，无法响应。[15]<br>423 Locked（WebDAV；RFC 4918）<br>当前资源被锁定。[15]<br>424 Failed Dependency（WebDAV；RFC 4918）<br>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。[15]<br>425 Unodered Cellection<br>在 WebDAV Advanced Collections Protocol 中定义，但 Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol 中并不存在。<br>426 Upgrade Required（RFC 2817）<br>客户端应当切换到 TLS/1.0，并在 HTTP/1.1 Upgrade header 中给出。[15]<br>428 Precondition Required (RFC 6585)<br>原服务器要求该请求满足一定条件。这是为了防止“‘未更新’问题，即客户端读取（GET）一个资源的状态，更改它，并将它写（PUT）回服务器，但这期间第三方已经在服务器上更改了该资源的状态，因此导致了冲突。”[52]<br>429 Too Many Requests （RFC 6585）<br>用户在给定的时间内发送了太多的请求。旨在用于网络限速。[52]<br>431 Request Header Fields Too Large （RFC 6585）<br>服务器不愿处理请求，因为一个或多个头字段过大。[52]<br>444 No Response<br>Nginx 上 HTTP 服務器擴展。服務器不向客戶端返回任何信息，並關閉連接（有助於阻止惡意軟體）。<br>450 Blocked by Windows Parental Controls<br>這是一個由 Windows 家庭控制（Microsoft）HTTP 阻止的 450 狀態代碼的示例，用於信息和測試。<br>451 Unavailable For Legal Reasons<br>该访问因法律的要求而被拒絕，由 IETF 在 2015 核准后新增加。[53][54][55]<br>494 Request Header Too Large<br>這是在將合成為傅里葉變換的情況下，將各個數字顯示為行星輪的狀態碼。<br>5xx 服务器错误[编辑]<br>表示服务器无法完成明显有效的请求。[56]这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个 HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。[57]<br>500 Internal Server Error<br>通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息。[58]<br>501 Not Implemented<br>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。[59]（例如，网络服务 API 的新功能）<br>502 Bad Gateway<br>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。[60]<br>503 Service Unavailable<br>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是暂时的，并且将在一段时间以后恢复。[61]如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理 500 响应的方式处理它。<br>504 Gateway Timeout<br>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI 标识出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如 DNS）收到响应。[62]<br>注意：某些代理服务器在 DNS 查询超时时会返回 400 或者 500 错误。<br>505 HTTP Version Not Supported<br>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。[63]这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。<br>506 Variant Also Negotiates（RFC 2295）<br>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误，[64]被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。<br>507 Insufficient Storage（WebDAV；RFC 4918）<br>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。[15]<br>508 Loop Detected （WebDAV；RFC 5842）<br>服务器在处理请求时陷入死循环。 （可代替 208 状态码）<br>510 Not Extended（RFC 2774）<br>获取资源所需要的策略并没有被满足。[65]<br>511 Network Authentication Required （RFC 6585）<br>客户端需要进行身份验证才能获得网络访问权限，旨在限制用户群访问特定网络。</p>\n"},{"layout":"post","title":"发哨子的人","date":"2020-03-13T03:57:26.000Z","img":"https://s1.ax1x.com/2020/03/12/8mBQ3V.jpg","top":true,"toc":false,"_content":"\n> **全文摘取《人物》发哨子的人**\n> 为了躲避审查,可谓是无所不用其极,戏剧般的艺术绽放往往藏着更为悲伤的故事\n\n## ![8mBQ3V.jpg](https://s1.ax1x.com/2020/03/12/8mBQ3V.jpg)\n\n---\n\n> 如果这些医⽣都能够得到及时的提醒，或许就不会有这⼀天\n\n![8mNX8S.png](https://s1.ax1x.com/2020/03/12/8mNX8S.png)\n\n##### 2019 年 12 ⽉ 30 ⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒检测报告，她⽤红⾊圈 出「SARS 冠状病毒」字样，当⼤学同学问起时，她将这份报告拍下来传给了这位 同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转发这份报告的⼈就包括 那 8 位被警⽅训诫的医⽣。 这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有 的、严厉的斥责」，称她是作为专业⼈⼠在造谣。 此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称 为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的 ⼈」。\n\n这是《⼈物》3 ⽉刊封⾯《武汉医⽣》的第⼆篇报道。\n\n##### 接到武汉市中⼼医院急诊科主任艾芬同意采访的短信是 3 ⽉ 1 ⽇凌晨 5 点，⼤约半⼩ 时后，3 ⽉ 1 ⽇凌晨 5 点 32 分，她的同事、甲状腺乳腺外科主任江学庆因感染新冠肺 炎去世。两天后，该院眼科副主任梅仲明过世，他和李⽂亮是同⼀科室。\n\n##### 截⽌ 2020 年 3 ⽉ 9 ⽇，武汉市中⼼医院已有 4 位医护⼈员因感染新冠肺炎去世——疫 情发⽣以来，这家离华南海鲜市场只⼏公⾥的医院成为了武汉市职⼯感染⼈数最多 的医院之⼀，据媒体报道医院超过 200 ⼈被感染，其中包括三个副院⻓和多名职能 部⻔主任，多个科室主任⽬前正在⽤ ECMO 维持。\n\n##### 死亡的阴影笼罩着这家武汉市最⼤的三甲医院，有医⽣告诉《⼈物》，在医院的⼤ 群⾥，⼏乎没有⼈说话，只在私下默默悼念、讨论。 悲剧原本有机会避免。2019 年 12 ⽉ 30 ⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒 检测报告，她⽤红⾊圈出「SARS 冠状病毒」字样，当⼤学同学问起时，她将这份 报告拍下来传给了这位同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转 发这份报告的⼈就包括那 8 位被警⽅训诫的医⽣。\n\n##### 这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有 的、严厉的斥责」，称她是作为专业⼈⼠在造谣。 3 ⽉ 2 ⽇下午，艾芬在武汉市中⼼医院南京路院区接受了《⼈物》的专访。她⼀个⼈ 坐在急诊室办公室中，曾经⼀天接诊超过 1500 位患者的急诊科此时已恢复了安静， 急诊⼤厅⾥只躺着⼀名流浪汉。\n\n##### 此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称 为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的 ⼈」。采访中，艾芬数次提起「后悔」这个词，她后悔当初被约谈后没有继续吹响 哨声，特别是对于过世的同事，「早知道有今天，我管他批评不批评，『⽼⼦』到 处说，是不是？」\n\n> 关于武汉市中⼼医院和艾芬本⼈在过去的两个多⽉中到底经历了什么？以下，是艾 芬的讲述——\n\n![8maOXQ.png](https://s1.ax1x.com/2020/03/12/8maOXQ.png)\n\n## 前所未有的训斥\n\n##### 去年 12 ⽉ 16 ⽇，我们南京路院区急诊科接诊了⼀位病⼈。莫名其妙⾼烧，⼀直⽤药 都不好，体温动都不动⼀下。22 号就转到了呼吸科，做了纤维⽀⽓管镜取了肺泡灌 洗液，送去外⾯做⾼通量测序，后来⼝头报出来是冠状病毒。当时，具体管床的同 事在我⽿边嚼了⼏遍：艾主任，那个⼈报的是冠状病毒。后来我们才知道那个病⼈ 是在华南海鲜做事的。\n\n##### 紧接着 12 ⽉ 27 ⽇，南京路院区⼜来了⼀个病⼈，是我们科⼀位医⽣的侄⼉，40 多 岁，没有任何基础疾病，肺部⼀塌糊涂，⾎氧饱和只有 90%，在下⾯其他医院已经 治疗了将近 10 天左右都没有任何好转，病⼈收到了呼吸科监护室住院。同样做了纤 维⽀⽓管镜取了肺泡灌洗液送去检测。\n\n##### 12 ⽉ 30 ⽇那天中午，我在同济医院⼯作的同学发了⼀张微信对话截图给我，截图上 写着：「最近不要去华南啊，那⾥蛮多⼈⾼烧……」他问我是不是真的，当时，我 正在电脑上看⼀个很典型的肺部感染患者的 CT，我就把 CT 录了⼀段 11 秒钟的视频 传给他，告诉他这是上午来我们急诊的⼀个病⼈，也是华南海鲜市场的。\n\n##### 当天下午 4 点刚过，同事给我看了⼀份报告，上⾯写的是：SARS 冠状病毒、绿脓假 单胞菌、46 种⼝腔/呼吸道定植菌。我仔细看了很多遍报告，下⾯的注释写着：SA RS 冠状病毒是⼀种单股正链 RNA 病毒。该病毒主要传播⽅式为近距离⻜沫传播或 接触患者呼吸道分泌物，可引起的⼀种具有明显传染性，可累及多个脏器系统的特 殊肺炎，也称⾮典型肺炎。\n\n##### 当时，我吓出了⼀身冷汗，这是⼀个很可怕的东⻄。病⼈收在呼吸科，按道理应该 呼吸科上报这个情况，但是为了保险和重视起⻅，我还是⽴刻打电话上报给了医院 公共卫⽣科和院感科。当时我们医院呼吸科主任正好从我⻔⼝过，他是参加过⾮典 的⼈，我把他抓住，说，我们有个病⼈收到你们科室，发现了这个东⻄。他当时⼀ 看就说，那就麻烦了。我就知道这个事情麻烦了。\n\n##### 给医院打完电话，我也给我同学传了这份报告，特意在「SARS 冠状病毒、绿脓假 单胞菌、46 种⼝腔/呼吸道定植菌」这⼀排字上画了个红圈，⽬的是提醒他注意、 重视。我也把报告发在了科室医⽣群⾥⾯，提醒⼤家注意防范。\n\n##### 当天晚上，这个东⻄就传遍了，各处传的截屏都是我画红圈的那个照⽚，包括后来 知道李⽂亮传在群⾥的也是那份。我⼼⾥当时就想可能坏事⼉了。10 点 20，医院发 来了信息，是转市卫健委的通知，⼤意就是关于不明原因肺炎，不要随意对外发 布，避免引起群众恐慌，如果因为信息泄露引发恐慌，要追责。 我当时⼼⾥就很害怕，⽴刻把这条信息转给了我同学。过了⼤概⼀个⼩时，医院⼜ 来了⼀份通知，再次强调群内的相关消息不能外传。⼀天后，1 ⽉ 1 ⽇晚上 11 点 46 分，医院监察科科⻓给我发了条消息，让我第⼆天早上过去⼀下。\n\n##### 那⼀晚上我都没有睡着，很担忧，翻来覆去地想，但⼜觉得凡事总有两⾯性，即便 造成不良影响，但提醒武汉的医务⼈员注意防范也不⼀定是个坏事。第⼆天早上 8 点多⼀点，还没有等我交完班，催我过去的电话就打来了。 之后的约谈，我遭受了前所未有的、⾮常严厉的斥责。\n\n##### 当时，谈话的领导说，「我们出去开会都抬不起头，某某某主任批评我们医院那个 艾芬，作为武汉市中⼼医院急诊科主任，你是专业⼈⼠，怎么能够没有原则没有组 织纪律造谣⽣事？」这是原话。让我回去跟科室的 200 多号⼈⼀个个地⼝头传达到 位，不能发微信、短信传达，只能当⾯聊或者打电话，不许说关于这个肺炎的任何 事情，「连⾃⼰的⽼公都不能说」……\n\n##### 我整个⼈⼀下⼦就懵了，他不是批评你这个⼈⼯作不努⼒，⽽是好像整个武汉市发 展的⼤好局⾯被我⼀个⼈破坏了。我当时有⼀种很绝望的感觉，我是⼀个平时认认 真真、勤勤恳恳⼯作的⼈，我觉得⾃⼰做的事情都是按规矩来的，都是有道理的。\n\n##### 我犯了什么错？我看到了这个报告，我也上报医院了，我和我的同学，同⾏之间对 于某⼀个病⼈的情况进⾏交流，没有透露病⼈的任何私⼈信息，就相当于是医学⽣ 之间讨论⼀个病案，当你作为⼀个临床的医⽣，已经知道在病⼈身上发现了⼀种很 重要的病毒，别的医⽣问起，你怎么可能不说呢？这是你当医⽣的本能，对不对？\n\n##### 我做错什么了？我做了⼀个医⽣、⼀个⼈正常应该做的事情，换作是任何⼈我觉得 都会这么做。 我当时的情绪也很激动，说，这个事是我做的，跟其余⼈都没有关系，你们⼲脆把 我抓去坐牢吧。我说我现在这个状态不适合在这个岗位上继续⼯作了，想要休息⼀ 段时间。领导没有同意，说这个时候正是考验我的时候。\n\n##### 当天晚上回家，我记得蛮清楚，进⻔后就跟我⽼公讲，我要是出了什么事情，你就 好好地把孩⼦带⼤。因为我的⼆宝还很⼩，才 1 岁多。他当时觉得莫名其妙，我没 有跟他说⾃⼰被训话的事，1 ⽉ 20 号，钟南⼭说了⼈传⼈之后，我才跟他说那天发 ⽣了什么。那期间，我只是提醒家⼈不要去⼈多的地⽅，出⻔要戴⼝罩。\n\n## 外围科室\n\n##### 很多⼈担⼼我也是那 8 个⼈之⼀被叫去训诫。实际上我没有被公安局训诫，后来有 好朋友问我，你是不是吹哨⼈？我说我不是吹哨⼈，我是那个发哨⼦的⼈。\n\n##### 但那次约谈对我的打击很⼤，⾮常⼤。回来后我感觉整个⼈⼼都垮了，真的是强打 着精神，认真做事，后来所有的⼈再来问我，我就不能回答了。\n\n##### 我能做的就是先让急诊科重视防护。我们急诊科 200 多⼈，从 1 ⽉ 1 号开始，我就叫 ⼤家加强防护，所有的⼈必须戴⼝罩、戴帽⼦、⽤⼿快消。记得有⼀天交班有个男 护⼠没戴⼝罩，我⻢上就当场骂他「以后不戴⼝罩就不要来上班了」。\n\n##### 1 ⽉ 9 号，我下班时看⻅预检台⼀个病⼈对着⼤家咳，从那天后，我就要求他们必须 给来看病的病⼈发⼝罩，⼀⼈发⼀个，这个时候不要节约钱，当时外⾯在说没有⼈传⼈，我⼜要在这⾥强调戴⼝罩加强防护，都是很⽭盾的。\n\n##### 那段时间确实很压抑，⾮常痛苦。有医⽣提出来要把隔离⾐穿外头，医院⾥开会说 不让，说隔离⾐穿外头会造成恐慌。我就让科室的⼈把隔离服穿⽩⼤褂⾥⾯，这是 不符合规范的，很荒谬的。\n\n##### 我们眼睁睁地看着病⼈越来越多，传播区域的半径越来越⼤，先是华南海鲜市场附 近可能跟它有关系，然后就传传传，半径越来越⼤。很多是家庭传染的，最先的 7 个⼈当中就有妈妈给⼉⼦送饭得的病。有诊所的⽼板得病，也是来打针的病⼈传给 他的，都是重得不得了。我就知道肯定有⼈传⼈。如果没有⼈传⼈，华南海鲜市场 1 ⽉ 1 ⽇就关闭了，怎么病⼈会越来越多呢？ 很多时候我都在想，如果他们当时不那样训斥我，⼼平⽓和地问⼀下这件事情的来 ⻰去脉，再请别的呼吸科专家⼀起沟通⼀下，也许局⾯会好⼀些，我⾄少可以在医 院内部多交流⼀下。如果是 1 ⽉ 1 号⼤家都这样引起警惕，就不会有那么多悲剧了。\n\n##### 1 ⽉ 3 号下午，在南京路院区，泌尿外科的医⽣们聚集在⼀起回顾⽼主任的⼯作历 程，参会的胡卫峰医⽣今年 43 岁，现在正在抢救；1 ⽉ 8 号下午，南京路院区 22 楼，江学庆主任还组织了武汉市甲乳患者康复联欢会；1 ⽉ 11 号早上，科室跟我汇报 急诊科抢救室护⼠胡紫薇感染，她应该是中⼼医院第⼀个被感染的护⼠，我第⼀时 间给医务科科⻓打电话汇报，然后医院紧急开了会，会上指示把「两下肺感染，病 毒性肺炎？」的报告改成「两肺散在感染」；1 ⽉ 16 号最后⼀次周会上，⼀位副院 ⻓还在说：「⼤家都要有⼀点医学常识，某些⾼年资的医⽣不要⾃⼰把⾃⼰搞得吓死⼈的。」另⼀位领导上台继续说：「没有⼈传⼈，可防可治可控。」⼀天后，1 ⽉ 17 号，江学庆住院，10 天后插管、上 ECMO。\n\n##### 中⼼医院的代价这么⼤，就是跟我们的医务⼈员没有信息透明化有关。你看倒下的 ⼈，急诊科和呼吸科的倒是没有那么重的，因为我们有防护意识，并且⼀⽣病就赶 紧休息治疗。重的都是外围科室，李⽂亮是眼科的，江学庆是甲乳科的。\n\n##### 江学庆真的⾮常好的⼀个⼈，医术很⾼，全院的两个中国医师奖之⼀。⽽且我们还 是邻居，我们⼀个单元，我住四⼗⼏楼，他住三⼗⼏楼，关系都很好，但是平时因 为⼯作太忙，就只能开会、搞医院活动时候⻅⻅⾯。他是个⼯作狂，要么就在⼿术 室，要么就在看⻔诊。谁也不会特意跑去跟他说，江主任，你要注意，戴⼝罩。他 也没有时间和精⼒打听这些事，他肯定就⼤意了：「有什么关系？就是个肺炎。」 这个是他们科室的⼈告诉我的。\n\n##### 如果这些医⽣都能够得到及时的提醒，或许就不会有这⼀天。所以，作为当事⼈的 我⾮常后悔，早知道有今天，我管他批评不批评我，「⽼⼦」到处说，是不是？ 虽然和李⽂亮同在⼀个医院，⼀直到去世之前我都不认得他，因为医院 4000 多号 ⼈太多了，平时也忙。他去世前的那天晚上，ICU 的主任跟我打电话借急诊科的⼼ 脏按压器，说李⽂亮要抢救，我⼀听这个消息⼤吃⼀惊，李⽂亮这个事整个过程我 不了解，但是他的病情跟他受训斥之后⼼情不好有没有关系？这我要打个问号，因 为受训的感觉我感同身受。\n\n##### 后来，事情发展到这⼀步，证明李⽂亮是对的时候，他的⼼情我⾮常能理解，可能 跟我的⼼情⼀样，不是激动、⾼兴，⽽是后悔，后悔当初就应该继续⼤声疾呼，应 该在所有的⼈问我们的时候，继续说。很多很多次我都在想，如果时间能够倒回来 该多好。\n\n![8mwPUI.png](https://s1.ax1x.com/2020/03/12/8mwPUI.png)\n\n## 活着就是好的\n\n##### 在 1 ⽉ 23 ⽇封城前⼀天的晚上，有相关部⻔的朋友打电话问我武汉市急诊病⼈的真 实情况。我说你代表私⼈，还是代表公家。他说我代表私⼈。我说代表个⼈就告诉 你真话，1 ⽉ 21 号，我们急诊科接诊 1523 个病⼈，是往常最多时的 3 倍，其中发烧的 有 655 个⼈。\n\n##### 那段时间急诊科的状况，经历过的⼈⼀辈⼦都忘不了，甚⾄会颠覆你的所有⼈⽣ 观。如果说这是打仗，急诊科就在最前线。但当时的情况是，后⾯的病区已经饱和了， 基本上⼀个病⼈都不收，ICU 也坚决不收，说⾥⾯有⼲净的病⼈，⼀进去就污染 了。病⼈不断地往急诊科涌，后⾯的路⼜不通，就全部堆在急诊科。病⼈来看病， ⼀排队随便就是⼏个⼩时，我们也完全没法下班，发热⻔诊和急诊也都不分了，⼤ 厅⾥堆满了病⼈，抢救室输液室⾥到处都是病⼈。 还有的病⼈家属来了，说要⼀张床，我的爸爸在汽⻋⾥⾯不⾏了，因为那时候地下 ⻋库已封，他⻋⼦也堵着开不进来。我没办法，带着⼈和设备跑去汽⻋⾥去，⼀ 看，⼈已经死了，你说是什么感受，很难受很难受。这个⼈就死在汽⻋⾥，连下⻋ 的机会都没有。\n\n##### 还有⼀位⽼⼈，⽼伴刚在⾦银潭医院去世了，她的⼉⼦、⼥⼉都被感染了，在打 针，照顾她的是⼥婿，⼀来我看她病得⾮常重，联系呼吸科给收进去住院，她⼥婿 ⼀看就是个有⽂化有素质的⼈，过来跟我说谢谢医⽣等等的，我⼼⾥⼀紧，说快 去，根本耽误不了了。结果送去就去世了。⼀句谢谢虽然⼏秒钟，但也耽误了⼏ 秒。这句谢谢压得我很沉重。 还有很多⼈把⾃⼰的家⼈送到监护室的时候，就是他们⻅的最后⼀⾯，你永远⻅不 着了。\n\n##### 我记得⼤年三⼗的早上我来交班，我说我们来照个相，纪念⼀下这个⼤年三⼗，还 发了个朋友圈。那天，⼤家都没有说什么祝福，这种时候，活着就是好的。\n\n##### 以前，你如果有⼀点失误，⽐如没有及时打针，病⼈都可能还去闹，现在没⼈了， 没有⼈跟你吵，没有⼈跟你闹了，所有⼈都被这种突然来的打击击垮了，搞蒙了。 病⼈死了，很少看到家属有很伤⼼地哭的，因为太多了，太多了。有些家属也不会 说医⽣求求你救救我的家⼈，⽽是跟医⽣说，唉，那就快点解脱吧，已经到了这个 地步。因为这时候每个⼈怕的都是⾃⼰被感染。\n\n##### ⼀天发热⻔诊⻔⼝的排队，要排 5 个⼩时。正排着⼀个⼥的倒下了，看她穿着⽪ ⾐，背着包包，穿着⾼跟鞋，应该是很讲究的⼀个中年⼥性，可是没有⼈敢上前去 扶她，就在地上躺了很久。只得我去喊护⼠、医⽣来去扶她。 1 ⽉ 30 号我早上来上班，⼀个⽩发⽼⼈的⼉⼦ 32 岁死了，他就盯着看医⽣给他开死 亡证明。根本没有眼泪，怎么哭？没办法哭。看他的打扮，可能就是⼀个外来的打 ⼯的，没有任何渠道去反映。没有确诊，他的⼉⼦，就变成了⼀张死亡证明。 这也是我想要去呼吁⼀下的。在急诊科死亡的病⼈都是没有诊断、没办法确诊的病 例，等这个疫情过去之后，我希望能给他们⼀个交代，给他们的家庭⼀些安抚，我 们的病⼈很可怜的，很可怜。\n\n## 「幸运」\n\n##### 做了这么多年医⽣，我⼀直觉得没有什么困难能够打倒我，这也和我的经历、个性 有关。\n\n##### 9 岁那年我爸爸就胃癌去世了，那个时候我就想着⻓⼤了当个医⽣去救别⼈的命。 后来⾼考的时候，我的志愿填的全部都是医学专业，最后考取了同济医学院。1997 年我⼤学毕业，就到了中⼼医院，之前在⼼⾎管内科⼯作，2010 年到急诊科当主任 的。我觉得急诊科就像我的⼀个孩⼦⼀样，我把它搞成这么⼤，搞得⼤家团结起来，做 成这个局⾯不容易，所以很珍惜，⾮常珍惜这个集体。\n\n##### 前⼏天，我的⼀个护⼠发朋友圈说，好怀念以前忙碌的⼤急诊，那种忙跟这种忙完 全是两个概念。 在这次疫情之前，⼼梗、脑梗、消化道出⾎、外伤等等这些才是我们急诊的范畴。 那种忙是有成就感的忙，⽬的明确，针对各种类型的病⼈都有很通畅的流程，很成 熟，下⼀步⼲什么，怎么做，出了问题找哪⼀个。⽽这⼀次是这么多危重病⼈没办 法去处理，没办法收住院，⽽且我们医务⼈员还在这种⻛险之中，这种忙真的很⽆ 奈，很痛⼼。\n\n##### 有⼀天早上 8 点，我们科⼀个年轻医⽣跟我发微信，也是蛮有性格的，说我今天不 来上班了，不舒服。因为我们这⾥都有规矩的，你不舒服要提前跟我说好安排，你 到 8 点钟跟我说，我到哪⾥去找⼈。他在微信中对我发脾⽓，说⼤量的⾼度疑似病例被你领导的急诊科放回社会，我们这是作孽！我理解他是因为作为医⽣的良知， 但我也急了，我说你可以去告我，如果你是急诊科主任，你该怎么办？ 后来，这个医⽣休息了⼏天后，还是照样来⼯作。他不是说怕死怕累，⽽是遇到这 种情况，⼀下⼦⾯对这么多病⼈感到很崩溃。\n\n##### 作为医⽣来说，特别是后⾯很多来⽀援的医⽣，根本⼼理上受不了，碰到这种情况 懵了，有的医⽣、护⼠就哭。⼀个是哭别⼈，再⼀个也是哭⾃⼰，因为每个⼈都不 知道什么时候就轮到⾃⼰感染。 ⼤概在 1 ⽉中下旬，医院的领导也陆陆续续地都病倒了，包括我们的⻔办主任，三 位副院⻓。医务科科⻓的⼥⼉也病了，他也在家⾥休息。所以基本上那⼀段时间是 没有⼈管你，你就在那⼉战⽃吧，就是那种感觉。\n\n##### 我身边的⼈也开始⼀个接⼀个地倒掉。1 ⽉ 18 ⽇，早上 8 点半，我们倒的第⼀个医 ⽣，他说主任我中招了，不烧，只做了 CT，肺部⼀⼤坨磨玻璃。不⼀会⼉，隔离病 房负责的⼀个责任护⼠，告诉我说他也倒了。晚上，我们的护⼠⻓也倒了。我当时 ⾮常真实的第⼀感觉是——幸运，因为倒得早，可以早点下战场。\n\n##### 这三个⼈我都密切接触过，我就是抱着必倒的信念每天在⼯作，结果⼀直没倒。全 院的⼈都觉得我是个奇迹。我⾃⼰分析了⼀下，可能是因为我本身有哮喘，在⽤⼀ 些吸⼊性的激素，可能会抑制这些病毒在肺内沉积。 我总觉得我们做急诊的⼈都算是有情怀的⼈——在中国的医院，急诊科的地位在所 有科室当中应该是⽐较低的，因为⼤家觉得急诊，⽆⾮就是个通道，把病⼈收进去 就⾏了。这次抗疫中，这种忽视也⼀直都存在。\n\n##### 早期的时候，物资不够，有时候分给急诊科的防护服质量⾮常差，看到我们的护⼠ 竟然穿着这种⾐服上班，我很⽣⽓，在周会群⾥⾯发脾⽓。后来还是好多主任把他 们⾃⼰科室藏的⾐服都给我了。 还有吃饭问题。病⼈多的时候管理混乱，他们根本想不到急诊科还差东⻄吃，很多 科室下班了都有吃的喝的，摆⼀⼤排，我们这⾥什么都没有，发热⻔诊的微信群 ⾥，有医⽣抱怨，「我们急诊科只有纸尿裤……」我们在最前线战⽃，结果是这 样，有时候⼼⾥真的很⽓。\n\n##### 我们这个集体真的是很好，⼤家都是只有⽣病了才下⽕线。这次，我们急诊科有 40 多个⼈感染了。我把所有⽣病的⼈建了⼀个群，本来叫「急诊⽣病群」，护⼠⻓说不吉利，改成「急诊加油群」。就是⽣病的⼈也没有很悲伤、很绝望、很抱怨的⼼ 态，都是蛮积极的，就是⼤家互相帮助，共度难关那种⼼态。 这些孩⼦们、年轻⼈都⾮常好，就是跟着我受委屈了。我也希望这次疫情过后，国 家能加⼤对急诊科的投⼊，在很多国家的医疗体系中，急诊专业都是⾮常受重视 的。\n\n![8m0Ul8.png](https://s1.ax1x.com/2020/03/12/8m0Ul8.png)\n\n## 不能达到的幸福\n\n##### 2 ⽉ 17 号，我收到了⼀条微信，是那个同济医院的同学发给我的，他跟我说「对不 起」，我说：幸好你传出去了，及时提醒了⼀部分⼈。他如果不传出去的话，可能 就没有李⽂亮他们这 8 个⼈，知道的⼈可能就会更少。\n\n##### 这次，我们有三个⼥医⽣全家感染。两个⼥医⽣的公公、婆婆加⽼公感染，⼀个⼥ 医⽣的爸爸、妈妈、姐姐、⽼公，加她⾃⼰ 5 个⼈感染。⼤家都觉得这么早就发现 这个病毒，结果却是这样，造成这么⼤的损失，代价太惨重了。 这种代价体现在⽅⽅⾯⾯。除了去世的⼈，患病的⼈也在承受。 我们「急诊加油群」⾥，⼤家经常会交流身体状况，有⼈问⼼率总在 120 次/分，要 不要紧？那肯定要紧，⼀动就⼼慌，这对他们终身都会有影响的，以后年纪⼤了会不会⼼衰？这都不好说。以后别⼈可以去爬⼭，出去旅游，他们可能就不⾏，那都是有可能的。\n\n##### 还有武汉。你说我们武汉是个多热闹的地⽅，现在⼀路上都是安安静静的，很多东 ⻄买不到，还搞得全国都来⽀援。前⼏天⼴⻄的⼀个医疗队的护⼠在⼯作的时候突 然昏迷了，抢救，后来⼈⼼跳有了，但还是在昏迷。她如果不来的话，在家⾥可以 过得好好的，也不会出这种意外。所以，我觉得我们⽋⼤家的⼈情，真的是。\n\n##### 经历过这次的疫情，对医院⾥很多⼈的打击都⾮常⼤。我下⾯好⼏个医务⼈员都有 了辞职的想法，包括⼀些⻣⼲。⼤家之前对于这个职业的那些观念、常识都难免有 点动摇——就是你这么努⼒⼯作到底对不对？就像江学庆⼀样，他⼯作太认真，太 对病⼈好，每⼀年的过年过节都在做⼿术。今天有⼈发⼀个江学庆⼥⼉写的微信， 说她爸爸的时间全部给了病⼈。 我⾃⼰也有过⽆数次的念头，是不是也回到家做个家庭主妇？疫情之后，我基本上 没回家，和我⽼公住在外⾯，我妹妹在家帮我照顾孩⼦。我的⼆宝都不认得我了， 他看视频对我没感觉，我很失落，我⽣这个⼆胎不容易，出⽣的时候他有 10 ⽄，妊 娠糖尿病我也得了，原本我还⼀直喂奶的，这⼀次也断了奶——做这个决定的时 候，我有点难过，我⽼公就跟我说，他说⼈的⼀⽣能够遇到⼀件这样的事情，并且 你不光是参与者，你还要带⼀个团队去打这场仗，那也是⼀件很有意义的事情，等 将来⼀切都恢复正常以后⼤家再去回忆，也是⼀个很宝贵的经历。\n\n##### 2 ⽉ 21 号早上领导和我谈话，其实我想问⼏个问题，⽐如有没有觉得那天批评我批 评错了？我希望能够给我⼀个道歉。但是我不敢问。没有⼈在任何场合跟我说表示 抱歉这句话。但我依然觉得，这次的事情更加说明了每个⼈还是要坚持⾃⼰独⽴的 思想，因为要有⼈站出来说真话，必须要有⼈，这个世界必须要有不同的声⾳，是 吧？作为武汉⼈，我们哪⼀个不热爱⾃⼰的城市？我们现在回想起来以前过得那种最普 通的⽣活，是多么奢侈的幸福。我现在觉得把宝宝抱着，陪他出去玩⼀下滑梯或者 跟⽼公出去看个电影，在以前再平常都不过，到现在来说都是⼀种幸福，都是不能 达到的幸福。\n\n## 结语\n\n> 这是我们所处的世界,无比真实却无可奈何,现在连说真话的权利都要被封杀,被和谐,我反反复复看了这篇文章,在此传播真实的声音,这篇文章不会被删除,希望大家能平安健康。\n","source":"_posts/2020-03-13-发哨子的人.md","raw":"---\nlayout: post\ntitle: 发哨子的人\ndate: 2020-03-13 11:57:26\nimg: https://s1.ax1x.com/2020/03/12/8mBQ3V.jpg\ntop: true\ntoc: false\ntags: [人生百态]\ncategories: 琐碎\n---\n\n> **全文摘取《人物》发哨子的人**\n> 为了躲避审查,可谓是无所不用其极,戏剧般的艺术绽放往往藏着更为悲伤的故事\n\n## ![8mBQ3V.jpg](https://s1.ax1x.com/2020/03/12/8mBQ3V.jpg)\n\n---\n\n> 如果这些医⽣都能够得到及时的提醒，或许就不会有这⼀天\n\n![8mNX8S.png](https://s1.ax1x.com/2020/03/12/8mNX8S.png)\n\n##### 2019 年 12 ⽉ 30 ⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒检测报告，她⽤红⾊圈 出「SARS 冠状病毒」字样，当⼤学同学问起时，她将这份报告拍下来传给了这位 同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转发这份报告的⼈就包括 那 8 位被警⽅训诫的医⽣。 这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有 的、严厉的斥责」，称她是作为专业⼈⼠在造谣。 此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称 为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的 ⼈」。\n\n这是《⼈物》3 ⽉刊封⾯《武汉医⽣》的第⼆篇报道。\n\n##### 接到武汉市中⼼医院急诊科主任艾芬同意采访的短信是 3 ⽉ 1 ⽇凌晨 5 点，⼤约半⼩ 时后，3 ⽉ 1 ⽇凌晨 5 点 32 分，她的同事、甲状腺乳腺外科主任江学庆因感染新冠肺 炎去世。两天后，该院眼科副主任梅仲明过世，他和李⽂亮是同⼀科室。\n\n##### 截⽌ 2020 年 3 ⽉ 9 ⽇，武汉市中⼼医院已有 4 位医护⼈员因感染新冠肺炎去世——疫 情发⽣以来，这家离华南海鲜市场只⼏公⾥的医院成为了武汉市职⼯感染⼈数最多 的医院之⼀，据媒体报道医院超过 200 ⼈被感染，其中包括三个副院⻓和多名职能 部⻔主任，多个科室主任⽬前正在⽤ ECMO 维持。\n\n##### 死亡的阴影笼罩着这家武汉市最⼤的三甲医院，有医⽣告诉《⼈物》，在医院的⼤ 群⾥，⼏乎没有⼈说话，只在私下默默悼念、讨论。 悲剧原本有机会避免。2019 年 12 ⽉ 30 ⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒 检测报告，她⽤红⾊圈出「SARS 冠状病毒」字样，当⼤学同学问起时，她将这份 报告拍下来传给了这位同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转 发这份报告的⼈就包括那 8 位被警⽅训诫的医⽣。\n\n##### 这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有 的、严厉的斥责」，称她是作为专业⼈⼠在造谣。 3 ⽉ 2 ⽇下午，艾芬在武汉市中⼼医院南京路院区接受了《⼈物》的专访。她⼀个⼈ 坐在急诊室办公室中，曾经⼀天接诊超过 1500 位患者的急诊科此时已恢复了安静， 急诊⼤厅⾥只躺着⼀名流浪汉。\n\n##### 此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称 为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的 ⼈」。采访中，艾芬数次提起「后悔」这个词，她后悔当初被约谈后没有继续吹响 哨声，特别是对于过世的同事，「早知道有今天，我管他批评不批评，『⽼⼦』到 处说，是不是？」\n\n> 关于武汉市中⼼医院和艾芬本⼈在过去的两个多⽉中到底经历了什么？以下，是艾 芬的讲述——\n\n![8maOXQ.png](https://s1.ax1x.com/2020/03/12/8maOXQ.png)\n\n## 前所未有的训斥\n\n##### 去年 12 ⽉ 16 ⽇，我们南京路院区急诊科接诊了⼀位病⼈。莫名其妙⾼烧，⼀直⽤药 都不好，体温动都不动⼀下。22 号就转到了呼吸科，做了纤维⽀⽓管镜取了肺泡灌 洗液，送去外⾯做⾼通量测序，后来⼝头报出来是冠状病毒。当时，具体管床的同 事在我⽿边嚼了⼏遍：艾主任，那个⼈报的是冠状病毒。后来我们才知道那个病⼈ 是在华南海鲜做事的。\n\n##### 紧接着 12 ⽉ 27 ⽇，南京路院区⼜来了⼀个病⼈，是我们科⼀位医⽣的侄⼉，40 多 岁，没有任何基础疾病，肺部⼀塌糊涂，⾎氧饱和只有 90%，在下⾯其他医院已经 治疗了将近 10 天左右都没有任何好转，病⼈收到了呼吸科监护室住院。同样做了纤 维⽀⽓管镜取了肺泡灌洗液送去检测。\n\n##### 12 ⽉ 30 ⽇那天中午，我在同济医院⼯作的同学发了⼀张微信对话截图给我，截图上 写着：「最近不要去华南啊，那⾥蛮多⼈⾼烧……」他问我是不是真的，当时，我 正在电脑上看⼀个很典型的肺部感染患者的 CT，我就把 CT 录了⼀段 11 秒钟的视频 传给他，告诉他这是上午来我们急诊的⼀个病⼈，也是华南海鲜市场的。\n\n##### 当天下午 4 点刚过，同事给我看了⼀份报告，上⾯写的是：SARS 冠状病毒、绿脓假 单胞菌、46 种⼝腔/呼吸道定植菌。我仔细看了很多遍报告，下⾯的注释写着：SA RS 冠状病毒是⼀种单股正链 RNA 病毒。该病毒主要传播⽅式为近距离⻜沫传播或 接触患者呼吸道分泌物，可引起的⼀种具有明显传染性，可累及多个脏器系统的特 殊肺炎，也称⾮典型肺炎。\n\n##### 当时，我吓出了⼀身冷汗，这是⼀个很可怕的东⻄。病⼈收在呼吸科，按道理应该 呼吸科上报这个情况，但是为了保险和重视起⻅，我还是⽴刻打电话上报给了医院 公共卫⽣科和院感科。当时我们医院呼吸科主任正好从我⻔⼝过，他是参加过⾮典 的⼈，我把他抓住，说，我们有个病⼈收到你们科室，发现了这个东⻄。他当时⼀ 看就说，那就麻烦了。我就知道这个事情麻烦了。\n\n##### 给医院打完电话，我也给我同学传了这份报告，特意在「SARS 冠状病毒、绿脓假 单胞菌、46 种⼝腔/呼吸道定植菌」这⼀排字上画了个红圈，⽬的是提醒他注意、 重视。我也把报告发在了科室医⽣群⾥⾯，提醒⼤家注意防范。\n\n##### 当天晚上，这个东⻄就传遍了，各处传的截屏都是我画红圈的那个照⽚，包括后来 知道李⽂亮传在群⾥的也是那份。我⼼⾥当时就想可能坏事⼉了。10 点 20，医院发 来了信息，是转市卫健委的通知，⼤意就是关于不明原因肺炎，不要随意对外发 布，避免引起群众恐慌，如果因为信息泄露引发恐慌，要追责。 我当时⼼⾥就很害怕，⽴刻把这条信息转给了我同学。过了⼤概⼀个⼩时，医院⼜ 来了⼀份通知，再次强调群内的相关消息不能外传。⼀天后，1 ⽉ 1 ⽇晚上 11 点 46 分，医院监察科科⻓给我发了条消息，让我第⼆天早上过去⼀下。\n\n##### 那⼀晚上我都没有睡着，很担忧，翻来覆去地想，但⼜觉得凡事总有两⾯性，即便 造成不良影响，但提醒武汉的医务⼈员注意防范也不⼀定是个坏事。第⼆天早上 8 点多⼀点，还没有等我交完班，催我过去的电话就打来了。 之后的约谈，我遭受了前所未有的、⾮常严厉的斥责。\n\n##### 当时，谈话的领导说，「我们出去开会都抬不起头，某某某主任批评我们医院那个 艾芬，作为武汉市中⼼医院急诊科主任，你是专业⼈⼠，怎么能够没有原则没有组 织纪律造谣⽣事？」这是原话。让我回去跟科室的 200 多号⼈⼀个个地⼝头传达到 位，不能发微信、短信传达，只能当⾯聊或者打电话，不许说关于这个肺炎的任何 事情，「连⾃⼰的⽼公都不能说」……\n\n##### 我整个⼈⼀下⼦就懵了，他不是批评你这个⼈⼯作不努⼒，⽽是好像整个武汉市发 展的⼤好局⾯被我⼀个⼈破坏了。我当时有⼀种很绝望的感觉，我是⼀个平时认认 真真、勤勤恳恳⼯作的⼈，我觉得⾃⼰做的事情都是按规矩来的，都是有道理的。\n\n##### 我犯了什么错？我看到了这个报告，我也上报医院了，我和我的同学，同⾏之间对 于某⼀个病⼈的情况进⾏交流，没有透露病⼈的任何私⼈信息，就相当于是医学⽣ 之间讨论⼀个病案，当你作为⼀个临床的医⽣，已经知道在病⼈身上发现了⼀种很 重要的病毒，别的医⽣问起，你怎么可能不说呢？这是你当医⽣的本能，对不对？\n\n##### 我做错什么了？我做了⼀个医⽣、⼀个⼈正常应该做的事情，换作是任何⼈我觉得 都会这么做。 我当时的情绪也很激动，说，这个事是我做的，跟其余⼈都没有关系，你们⼲脆把 我抓去坐牢吧。我说我现在这个状态不适合在这个岗位上继续⼯作了，想要休息⼀ 段时间。领导没有同意，说这个时候正是考验我的时候。\n\n##### 当天晚上回家，我记得蛮清楚，进⻔后就跟我⽼公讲，我要是出了什么事情，你就 好好地把孩⼦带⼤。因为我的⼆宝还很⼩，才 1 岁多。他当时觉得莫名其妙，我没 有跟他说⾃⼰被训话的事，1 ⽉ 20 号，钟南⼭说了⼈传⼈之后，我才跟他说那天发 ⽣了什么。那期间，我只是提醒家⼈不要去⼈多的地⽅，出⻔要戴⼝罩。\n\n## 外围科室\n\n##### 很多⼈担⼼我也是那 8 个⼈之⼀被叫去训诫。实际上我没有被公安局训诫，后来有 好朋友问我，你是不是吹哨⼈？我说我不是吹哨⼈，我是那个发哨⼦的⼈。\n\n##### 但那次约谈对我的打击很⼤，⾮常⼤。回来后我感觉整个⼈⼼都垮了，真的是强打 着精神，认真做事，后来所有的⼈再来问我，我就不能回答了。\n\n##### 我能做的就是先让急诊科重视防护。我们急诊科 200 多⼈，从 1 ⽉ 1 号开始，我就叫 ⼤家加强防护，所有的⼈必须戴⼝罩、戴帽⼦、⽤⼿快消。记得有⼀天交班有个男 护⼠没戴⼝罩，我⻢上就当场骂他「以后不戴⼝罩就不要来上班了」。\n\n##### 1 ⽉ 9 号，我下班时看⻅预检台⼀个病⼈对着⼤家咳，从那天后，我就要求他们必须 给来看病的病⼈发⼝罩，⼀⼈发⼀个，这个时候不要节约钱，当时外⾯在说没有⼈传⼈，我⼜要在这⾥强调戴⼝罩加强防护，都是很⽭盾的。\n\n##### 那段时间确实很压抑，⾮常痛苦。有医⽣提出来要把隔离⾐穿外头，医院⾥开会说 不让，说隔离⾐穿外头会造成恐慌。我就让科室的⼈把隔离服穿⽩⼤褂⾥⾯，这是 不符合规范的，很荒谬的。\n\n##### 我们眼睁睁地看着病⼈越来越多，传播区域的半径越来越⼤，先是华南海鲜市场附 近可能跟它有关系，然后就传传传，半径越来越⼤。很多是家庭传染的，最先的 7 个⼈当中就有妈妈给⼉⼦送饭得的病。有诊所的⽼板得病，也是来打针的病⼈传给 他的，都是重得不得了。我就知道肯定有⼈传⼈。如果没有⼈传⼈，华南海鲜市场 1 ⽉ 1 ⽇就关闭了，怎么病⼈会越来越多呢？ 很多时候我都在想，如果他们当时不那样训斥我，⼼平⽓和地问⼀下这件事情的来 ⻰去脉，再请别的呼吸科专家⼀起沟通⼀下，也许局⾯会好⼀些，我⾄少可以在医 院内部多交流⼀下。如果是 1 ⽉ 1 号⼤家都这样引起警惕，就不会有那么多悲剧了。\n\n##### 1 ⽉ 3 号下午，在南京路院区，泌尿外科的医⽣们聚集在⼀起回顾⽼主任的⼯作历 程，参会的胡卫峰医⽣今年 43 岁，现在正在抢救；1 ⽉ 8 号下午，南京路院区 22 楼，江学庆主任还组织了武汉市甲乳患者康复联欢会；1 ⽉ 11 号早上，科室跟我汇报 急诊科抢救室护⼠胡紫薇感染，她应该是中⼼医院第⼀个被感染的护⼠，我第⼀时 间给医务科科⻓打电话汇报，然后医院紧急开了会，会上指示把「两下肺感染，病 毒性肺炎？」的报告改成「两肺散在感染」；1 ⽉ 16 号最后⼀次周会上，⼀位副院 ⻓还在说：「⼤家都要有⼀点医学常识，某些⾼年资的医⽣不要⾃⼰把⾃⼰搞得吓死⼈的。」另⼀位领导上台继续说：「没有⼈传⼈，可防可治可控。」⼀天后，1 ⽉ 17 号，江学庆住院，10 天后插管、上 ECMO。\n\n##### 中⼼医院的代价这么⼤，就是跟我们的医务⼈员没有信息透明化有关。你看倒下的 ⼈，急诊科和呼吸科的倒是没有那么重的，因为我们有防护意识，并且⼀⽣病就赶 紧休息治疗。重的都是外围科室，李⽂亮是眼科的，江学庆是甲乳科的。\n\n##### 江学庆真的⾮常好的⼀个⼈，医术很⾼，全院的两个中国医师奖之⼀。⽽且我们还 是邻居，我们⼀个单元，我住四⼗⼏楼，他住三⼗⼏楼，关系都很好，但是平时因 为⼯作太忙，就只能开会、搞医院活动时候⻅⻅⾯。他是个⼯作狂，要么就在⼿术 室，要么就在看⻔诊。谁也不会特意跑去跟他说，江主任，你要注意，戴⼝罩。他 也没有时间和精⼒打听这些事，他肯定就⼤意了：「有什么关系？就是个肺炎。」 这个是他们科室的⼈告诉我的。\n\n##### 如果这些医⽣都能够得到及时的提醒，或许就不会有这⼀天。所以，作为当事⼈的 我⾮常后悔，早知道有今天，我管他批评不批评我，「⽼⼦」到处说，是不是？ 虽然和李⽂亮同在⼀个医院，⼀直到去世之前我都不认得他，因为医院 4000 多号 ⼈太多了，平时也忙。他去世前的那天晚上，ICU 的主任跟我打电话借急诊科的⼼ 脏按压器，说李⽂亮要抢救，我⼀听这个消息⼤吃⼀惊，李⽂亮这个事整个过程我 不了解，但是他的病情跟他受训斥之后⼼情不好有没有关系？这我要打个问号，因 为受训的感觉我感同身受。\n\n##### 后来，事情发展到这⼀步，证明李⽂亮是对的时候，他的⼼情我⾮常能理解，可能 跟我的⼼情⼀样，不是激动、⾼兴，⽽是后悔，后悔当初就应该继续⼤声疾呼，应 该在所有的⼈问我们的时候，继续说。很多很多次我都在想，如果时间能够倒回来 该多好。\n\n![8mwPUI.png](https://s1.ax1x.com/2020/03/12/8mwPUI.png)\n\n## 活着就是好的\n\n##### 在 1 ⽉ 23 ⽇封城前⼀天的晚上，有相关部⻔的朋友打电话问我武汉市急诊病⼈的真 实情况。我说你代表私⼈，还是代表公家。他说我代表私⼈。我说代表个⼈就告诉 你真话，1 ⽉ 21 号，我们急诊科接诊 1523 个病⼈，是往常最多时的 3 倍，其中发烧的 有 655 个⼈。\n\n##### 那段时间急诊科的状况，经历过的⼈⼀辈⼦都忘不了，甚⾄会颠覆你的所有⼈⽣ 观。如果说这是打仗，急诊科就在最前线。但当时的情况是，后⾯的病区已经饱和了， 基本上⼀个病⼈都不收，ICU 也坚决不收，说⾥⾯有⼲净的病⼈，⼀进去就污染 了。病⼈不断地往急诊科涌，后⾯的路⼜不通，就全部堆在急诊科。病⼈来看病， ⼀排队随便就是⼏个⼩时，我们也完全没法下班，发热⻔诊和急诊也都不分了，⼤ 厅⾥堆满了病⼈，抢救室输液室⾥到处都是病⼈。 还有的病⼈家属来了，说要⼀张床，我的爸爸在汽⻋⾥⾯不⾏了，因为那时候地下 ⻋库已封，他⻋⼦也堵着开不进来。我没办法，带着⼈和设备跑去汽⻋⾥去，⼀ 看，⼈已经死了，你说是什么感受，很难受很难受。这个⼈就死在汽⻋⾥，连下⻋ 的机会都没有。\n\n##### 还有⼀位⽼⼈，⽼伴刚在⾦银潭医院去世了，她的⼉⼦、⼥⼉都被感染了，在打 针，照顾她的是⼥婿，⼀来我看她病得⾮常重，联系呼吸科给收进去住院，她⼥婿 ⼀看就是个有⽂化有素质的⼈，过来跟我说谢谢医⽣等等的，我⼼⾥⼀紧，说快 去，根本耽误不了了。结果送去就去世了。⼀句谢谢虽然⼏秒钟，但也耽误了⼏ 秒。这句谢谢压得我很沉重。 还有很多⼈把⾃⼰的家⼈送到监护室的时候，就是他们⻅的最后⼀⾯，你永远⻅不 着了。\n\n##### 我记得⼤年三⼗的早上我来交班，我说我们来照个相，纪念⼀下这个⼤年三⼗，还 发了个朋友圈。那天，⼤家都没有说什么祝福，这种时候，活着就是好的。\n\n##### 以前，你如果有⼀点失误，⽐如没有及时打针，病⼈都可能还去闹，现在没⼈了， 没有⼈跟你吵，没有⼈跟你闹了，所有⼈都被这种突然来的打击击垮了，搞蒙了。 病⼈死了，很少看到家属有很伤⼼地哭的，因为太多了，太多了。有些家属也不会 说医⽣求求你救救我的家⼈，⽽是跟医⽣说，唉，那就快点解脱吧，已经到了这个 地步。因为这时候每个⼈怕的都是⾃⼰被感染。\n\n##### ⼀天发热⻔诊⻔⼝的排队，要排 5 个⼩时。正排着⼀个⼥的倒下了，看她穿着⽪ ⾐，背着包包，穿着⾼跟鞋，应该是很讲究的⼀个中年⼥性，可是没有⼈敢上前去 扶她，就在地上躺了很久。只得我去喊护⼠、医⽣来去扶她。 1 ⽉ 30 号我早上来上班，⼀个⽩发⽼⼈的⼉⼦ 32 岁死了，他就盯着看医⽣给他开死 亡证明。根本没有眼泪，怎么哭？没办法哭。看他的打扮，可能就是⼀个外来的打 ⼯的，没有任何渠道去反映。没有确诊，他的⼉⼦，就变成了⼀张死亡证明。 这也是我想要去呼吁⼀下的。在急诊科死亡的病⼈都是没有诊断、没办法确诊的病 例，等这个疫情过去之后，我希望能给他们⼀个交代，给他们的家庭⼀些安抚，我 们的病⼈很可怜的，很可怜。\n\n## 「幸运」\n\n##### 做了这么多年医⽣，我⼀直觉得没有什么困难能够打倒我，这也和我的经历、个性 有关。\n\n##### 9 岁那年我爸爸就胃癌去世了，那个时候我就想着⻓⼤了当个医⽣去救别⼈的命。 后来⾼考的时候，我的志愿填的全部都是医学专业，最后考取了同济医学院。1997 年我⼤学毕业，就到了中⼼医院，之前在⼼⾎管内科⼯作，2010 年到急诊科当主任 的。我觉得急诊科就像我的⼀个孩⼦⼀样，我把它搞成这么⼤，搞得⼤家团结起来，做 成这个局⾯不容易，所以很珍惜，⾮常珍惜这个集体。\n\n##### 前⼏天，我的⼀个护⼠发朋友圈说，好怀念以前忙碌的⼤急诊，那种忙跟这种忙完 全是两个概念。 在这次疫情之前，⼼梗、脑梗、消化道出⾎、外伤等等这些才是我们急诊的范畴。 那种忙是有成就感的忙，⽬的明确，针对各种类型的病⼈都有很通畅的流程，很成 熟，下⼀步⼲什么，怎么做，出了问题找哪⼀个。⽽这⼀次是这么多危重病⼈没办 法去处理，没办法收住院，⽽且我们医务⼈员还在这种⻛险之中，这种忙真的很⽆ 奈，很痛⼼。\n\n##### 有⼀天早上 8 点，我们科⼀个年轻医⽣跟我发微信，也是蛮有性格的，说我今天不 来上班了，不舒服。因为我们这⾥都有规矩的，你不舒服要提前跟我说好安排，你 到 8 点钟跟我说，我到哪⾥去找⼈。他在微信中对我发脾⽓，说⼤量的⾼度疑似病例被你领导的急诊科放回社会，我们这是作孽！我理解他是因为作为医⽣的良知， 但我也急了，我说你可以去告我，如果你是急诊科主任，你该怎么办？ 后来，这个医⽣休息了⼏天后，还是照样来⼯作。他不是说怕死怕累，⽽是遇到这 种情况，⼀下⼦⾯对这么多病⼈感到很崩溃。\n\n##### 作为医⽣来说，特别是后⾯很多来⽀援的医⽣，根本⼼理上受不了，碰到这种情况 懵了，有的医⽣、护⼠就哭。⼀个是哭别⼈，再⼀个也是哭⾃⼰，因为每个⼈都不 知道什么时候就轮到⾃⼰感染。 ⼤概在 1 ⽉中下旬，医院的领导也陆陆续续地都病倒了，包括我们的⻔办主任，三 位副院⻓。医务科科⻓的⼥⼉也病了，他也在家⾥休息。所以基本上那⼀段时间是 没有⼈管你，你就在那⼉战⽃吧，就是那种感觉。\n\n##### 我身边的⼈也开始⼀个接⼀个地倒掉。1 ⽉ 18 ⽇，早上 8 点半，我们倒的第⼀个医 ⽣，他说主任我中招了，不烧，只做了 CT，肺部⼀⼤坨磨玻璃。不⼀会⼉，隔离病 房负责的⼀个责任护⼠，告诉我说他也倒了。晚上，我们的护⼠⻓也倒了。我当时 ⾮常真实的第⼀感觉是——幸运，因为倒得早，可以早点下战场。\n\n##### 这三个⼈我都密切接触过，我就是抱着必倒的信念每天在⼯作，结果⼀直没倒。全 院的⼈都觉得我是个奇迹。我⾃⼰分析了⼀下，可能是因为我本身有哮喘，在⽤⼀ 些吸⼊性的激素，可能会抑制这些病毒在肺内沉积。 我总觉得我们做急诊的⼈都算是有情怀的⼈——在中国的医院，急诊科的地位在所 有科室当中应该是⽐较低的，因为⼤家觉得急诊，⽆⾮就是个通道，把病⼈收进去 就⾏了。这次抗疫中，这种忽视也⼀直都存在。\n\n##### 早期的时候，物资不够，有时候分给急诊科的防护服质量⾮常差，看到我们的护⼠ 竟然穿着这种⾐服上班，我很⽣⽓，在周会群⾥⾯发脾⽓。后来还是好多主任把他 们⾃⼰科室藏的⾐服都给我了。 还有吃饭问题。病⼈多的时候管理混乱，他们根本想不到急诊科还差东⻄吃，很多 科室下班了都有吃的喝的，摆⼀⼤排，我们这⾥什么都没有，发热⻔诊的微信群 ⾥，有医⽣抱怨，「我们急诊科只有纸尿裤……」我们在最前线战⽃，结果是这 样，有时候⼼⾥真的很⽓。\n\n##### 我们这个集体真的是很好，⼤家都是只有⽣病了才下⽕线。这次，我们急诊科有 40 多个⼈感染了。我把所有⽣病的⼈建了⼀个群，本来叫「急诊⽣病群」，护⼠⻓说不吉利，改成「急诊加油群」。就是⽣病的⼈也没有很悲伤、很绝望、很抱怨的⼼ 态，都是蛮积极的，就是⼤家互相帮助，共度难关那种⼼态。 这些孩⼦们、年轻⼈都⾮常好，就是跟着我受委屈了。我也希望这次疫情过后，国 家能加⼤对急诊科的投⼊，在很多国家的医疗体系中，急诊专业都是⾮常受重视 的。\n\n![8m0Ul8.png](https://s1.ax1x.com/2020/03/12/8m0Ul8.png)\n\n## 不能达到的幸福\n\n##### 2 ⽉ 17 号，我收到了⼀条微信，是那个同济医院的同学发给我的，他跟我说「对不 起」，我说：幸好你传出去了，及时提醒了⼀部分⼈。他如果不传出去的话，可能 就没有李⽂亮他们这 8 个⼈，知道的⼈可能就会更少。\n\n##### 这次，我们有三个⼥医⽣全家感染。两个⼥医⽣的公公、婆婆加⽼公感染，⼀个⼥ 医⽣的爸爸、妈妈、姐姐、⽼公，加她⾃⼰ 5 个⼈感染。⼤家都觉得这么早就发现 这个病毒，结果却是这样，造成这么⼤的损失，代价太惨重了。 这种代价体现在⽅⽅⾯⾯。除了去世的⼈，患病的⼈也在承受。 我们「急诊加油群」⾥，⼤家经常会交流身体状况，有⼈问⼼率总在 120 次/分，要 不要紧？那肯定要紧，⼀动就⼼慌，这对他们终身都会有影响的，以后年纪⼤了会不会⼼衰？这都不好说。以后别⼈可以去爬⼭，出去旅游，他们可能就不⾏，那都是有可能的。\n\n##### 还有武汉。你说我们武汉是个多热闹的地⽅，现在⼀路上都是安安静静的，很多东 ⻄买不到，还搞得全国都来⽀援。前⼏天⼴⻄的⼀个医疗队的护⼠在⼯作的时候突 然昏迷了，抢救，后来⼈⼼跳有了，但还是在昏迷。她如果不来的话，在家⾥可以 过得好好的，也不会出这种意外。所以，我觉得我们⽋⼤家的⼈情，真的是。\n\n##### 经历过这次的疫情，对医院⾥很多⼈的打击都⾮常⼤。我下⾯好⼏个医务⼈员都有 了辞职的想法，包括⼀些⻣⼲。⼤家之前对于这个职业的那些观念、常识都难免有 点动摇——就是你这么努⼒⼯作到底对不对？就像江学庆⼀样，他⼯作太认真，太 对病⼈好，每⼀年的过年过节都在做⼿术。今天有⼈发⼀个江学庆⼥⼉写的微信， 说她爸爸的时间全部给了病⼈。 我⾃⼰也有过⽆数次的念头，是不是也回到家做个家庭主妇？疫情之后，我基本上 没回家，和我⽼公住在外⾯，我妹妹在家帮我照顾孩⼦。我的⼆宝都不认得我了， 他看视频对我没感觉，我很失落，我⽣这个⼆胎不容易，出⽣的时候他有 10 ⽄，妊 娠糖尿病我也得了，原本我还⼀直喂奶的，这⼀次也断了奶——做这个决定的时 候，我有点难过，我⽼公就跟我说，他说⼈的⼀⽣能够遇到⼀件这样的事情，并且 你不光是参与者，你还要带⼀个团队去打这场仗，那也是⼀件很有意义的事情，等 将来⼀切都恢复正常以后⼤家再去回忆，也是⼀个很宝贵的经历。\n\n##### 2 ⽉ 21 号早上领导和我谈话，其实我想问⼏个问题，⽐如有没有觉得那天批评我批 评错了？我希望能够给我⼀个道歉。但是我不敢问。没有⼈在任何场合跟我说表示 抱歉这句话。但我依然觉得，这次的事情更加说明了每个⼈还是要坚持⾃⼰独⽴的 思想，因为要有⼈站出来说真话，必须要有⼈，这个世界必须要有不同的声⾳，是 吧？作为武汉⼈，我们哪⼀个不热爱⾃⼰的城市？我们现在回想起来以前过得那种最普 通的⽣活，是多么奢侈的幸福。我现在觉得把宝宝抱着，陪他出去玩⼀下滑梯或者 跟⽼公出去看个电影，在以前再平常都不过，到现在来说都是⼀种幸福，都是不能 达到的幸福。\n\n## 结语\n\n> 这是我们所处的世界,无比真实却无可奈何,现在连说真话的权利都要被封杀,被和谐,我反反复复看了这篇文章,在此传播真实的声音,这篇文章不会被删除,希望大家能平安健康。\n","slug":"2020-03-13-发哨子的人","published":1,"updated":"2020-03-14T06:52:36.525Z","comments":1,"photos":[],"link":"","_id":"ck7u2pvo1006w4k8yg2g007pp","content":"<blockquote>\n<p><strong>全文摘取《人物》发哨子的人</strong><br>为了躲避审查,可谓是无所不用其极,戏剧般的艺术绽放往往藏着更为悲伤的故事</p>\n</blockquote>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"https://s1.ax1x.com/2020/03/12/8mBQ3V.jpg\" alt=\"8mBQ3V.jpg\"></h2><hr>\n<blockquote>\n<p>如果这些医⽣都能够得到及时的提醒，或许就不会有这⼀天</p>\n</blockquote>\n<p><img src=\"https://s1.ax1x.com/2020/03/12/8mNX8S.png\" alt=\"8mNX8S.png\"></p>\n<h5 id=\"2019-年-12-⽉-30-⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒检测报告，她⽤红⾊圈-出「SARS-冠状病毒」字样，当⼤学同学问起时，她将这份报告拍下来传给了这位-同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转发这份报告的⼈就包括-那-8-位被警⽅训诫的医⽣。-这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有-的、严厉的斥责」，称她是作为专业⼈⼠在造谣。-此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称-为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的-⼈」。\"><a href=\"#2019-年-12-⽉-30-⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒检测报告，她⽤红⾊圈-出「SARS-冠状病毒」字样，当⼤学同学问起时，她将这份报告拍下来传给了这位-同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转发这份报告的⼈就包括-那-8-位被警⽅训诫的医⽣。-这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有-的、严厉的斥责」，称她是作为专业⼈⼠在造谣。-此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称-为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的-⼈」。\" class=\"headerlink\" title=\"2019 年 12 ⽉ 30 ⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒检测报告，她⽤红⾊圈 出「SARS 冠状病毒」字样，当⼤学同学问起时，她将这份报告拍下来传给了这位 同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转发这份报告的⼈就包括 那 8 位被警⽅训诫的医⽣。 这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有 的、严厉的斥责」，称她是作为专业⼈⼠在造谣。 此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称 为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的 ⼈」。\"></a>2019 年 12 ⽉ 30 ⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒检测报告，她⽤红⾊圈 出「SARS 冠状病毒」字样，当⼤学同学问起时，她将这份报告拍下来传给了这位 同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转发这份报告的⼈就包括 那 8 位被警⽅训诫的医⽣。 这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有 的、严厉的斥责」，称她是作为专业⼈⼠在造谣。 此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称 为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的 ⼈」。</h5><p>这是《⼈物》3 ⽉刊封⾯《武汉医⽣》的第⼆篇报道。</p>\n<h5 id=\"接到武汉市中⼼医院急诊科主任艾芬同意采访的短信是-3-⽉-1-⽇凌晨-5-点，⼤约半⼩-时后，3-⽉-1-⽇凌晨-5-点-32-分，她的同事、甲状腺乳腺外科主任江学庆因感染新冠肺-炎去世。两天后，该院眼科副主任梅仲明过世，他和李⽂亮是同⼀科室。\"><a href=\"#接到武汉市中⼼医院急诊科主任艾芬同意采访的短信是-3-⽉-1-⽇凌晨-5-点，⼤约半⼩-时后，3-⽉-1-⽇凌晨-5-点-32-分，她的同事、甲状腺乳腺外科主任江学庆因感染新冠肺-炎去世。两天后，该院眼科副主任梅仲明过世，他和李⽂亮是同⼀科室。\" class=\"headerlink\" title=\"接到武汉市中⼼医院急诊科主任艾芬同意采访的短信是 3 ⽉ 1 ⽇凌晨 5 点，⼤约半⼩ 时后，3 ⽉ 1 ⽇凌晨 5 点 32 分，她的同事、甲状腺乳腺外科主任江学庆因感染新冠肺 炎去世。两天后，该院眼科副主任梅仲明过世，他和李⽂亮是同⼀科室。\"></a>接到武汉市中⼼医院急诊科主任艾芬同意采访的短信是 3 ⽉ 1 ⽇凌晨 5 点，⼤约半⼩ 时后，3 ⽉ 1 ⽇凌晨 5 点 32 分，她的同事、甲状腺乳腺外科主任江学庆因感染新冠肺 炎去世。两天后，该院眼科副主任梅仲明过世，他和李⽂亮是同⼀科室。</h5><h5 id=\"截⽌-2020-年-3-⽉-9-⽇，武汉市中⼼医院已有-4-位医护⼈员因感染新冠肺炎去世——疫-情发⽣以来，这家离华南海鲜市场只⼏公⾥的医院成为了武汉市职⼯感染⼈数最多-的医院之⼀，据媒体报道医院超过-200-⼈被感染，其中包括三个副院⻓和多名职能-部⻔主任，多个科室主任⽬前正在⽤-ECMO-维持。\"><a href=\"#截⽌-2020-年-3-⽉-9-⽇，武汉市中⼼医院已有-4-位医护⼈员因感染新冠肺炎去世——疫-情发⽣以来，这家离华南海鲜市场只⼏公⾥的医院成为了武汉市职⼯感染⼈数最多-的医院之⼀，据媒体报道医院超过-200-⼈被感染，其中包括三个副院⻓和多名职能-部⻔主任，多个科室主任⽬前正在⽤-ECMO-维持。\" class=\"headerlink\" title=\"截⽌ 2020 年 3 ⽉ 9 ⽇，武汉市中⼼医院已有 4 位医护⼈员因感染新冠肺炎去世——疫 情发⽣以来，这家离华南海鲜市场只⼏公⾥的医院成为了武汉市职⼯感染⼈数最多 的医院之⼀，据媒体报道医院超过 200 ⼈被感染，其中包括三个副院⻓和多名职能 部⻔主任，多个科室主任⽬前正在⽤ ECMO 维持。\"></a>截⽌ 2020 年 3 ⽉ 9 ⽇，武汉市中⼼医院已有 4 位医护⼈员因感染新冠肺炎去世——疫 情发⽣以来，这家离华南海鲜市场只⼏公⾥的医院成为了武汉市职⼯感染⼈数最多 的医院之⼀，据媒体报道医院超过 200 ⼈被感染，其中包括三个副院⻓和多名职能 部⻔主任，多个科室主任⽬前正在⽤ ECMO 维持。</h5><h5 id=\"死亡的阴影笼罩着这家武汉市最⼤的三甲医院，有医⽣告诉《⼈物》，在医院的⼤-群⾥，⼏乎没有⼈说话，只在私下默默悼念、讨论。-悲剧原本有机会避免。2019-年-12-⽉-30-⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒-检测报告，她⽤红⾊圈出「SARS-冠状病毒」字样，当⼤学同学问起时，她将这份-报告拍下来传给了这位同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转-发这份报告的⼈就包括那-8-位被警⽅训诫的医⽣。\"><a href=\"#死亡的阴影笼罩着这家武汉市最⼤的三甲医院，有医⽣告诉《⼈物》，在医院的⼤-群⾥，⼏乎没有⼈说话，只在私下默默悼念、讨论。-悲剧原本有机会避免。2019-年-12-⽉-30-⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒-检测报告，她⽤红⾊圈出「SARS-冠状病毒」字样，当⼤学同学问起时，她将这份-报告拍下来传给了这位同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转-发这份报告的⼈就包括那-8-位被警⽅训诫的医⽣。\" class=\"headerlink\" title=\"死亡的阴影笼罩着这家武汉市最⼤的三甲医院，有医⽣告诉《⼈物》，在医院的⼤ 群⾥，⼏乎没有⼈说话，只在私下默默悼念、讨论。 悲剧原本有机会避免。2019 年 12 ⽉ 30 ⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒 检测报告，她⽤红⾊圈出「SARS 冠状病毒」字样，当⼤学同学问起时，她将这份 报告拍下来传给了这位同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转 发这份报告的⼈就包括那 8 位被警⽅训诫的医⽣。\"></a>死亡的阴影笼罩着这家武汉市最⼤的三甲医院，有医⽣告诉《⼈物》，在医院的⼤ 群⾥，⼏乎没有⼈说话，只在私下默默悼念、讨论。 悲剧原本有机会避免。2019 年 12 ⽉ 30 ⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒 检测报告，她⽤红⾊圈出「SARS 冠状病毒」字样，当⼤学同学问起时，她将这份 报告拍下来传给了这位同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转 发这份报告的⼈就包括那 8 位被警⽅训诫的医⽣。</h5><h5 id=\"这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有-的、严厉的斥责」，称她是作为专业⼈⼠在造谣。-3-⽉-2-⽇下午，艾芬在武汉市中⼼医院南京路院区接受了《⼈物》的专访。她⼀个⼈-坐在急诊室办公室中，曾经⼀天接诊超过-1500-位患者的急诊科此时已恢复了安静，-急诊⼤厅⾥只躺着⼀名流浪汉。\"><a href=\"#这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有-的、严厉的斥责」，称她是作为专业⼈⼠在造谣。-3-⽉-2-⽇下午，艾芬在武汉市中⼼医院南京路院区接受了《⼈物》的专访。她⼀个⼈-坐在急诊室办公室中，曾经⼀天接诊超过-1500-位患者的急诊科此时已恢复了安静，-急诊⼤厅⾥只躺着⼀名流浪汉。\" class=\"headerlink\" title=\"这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有 的、严厉的斥责」，称她是作为专业⼈⼠在造谣。 3 ⽉ 2 ⽇下午，艾芬在武汉市中⼼医院南京路院区接受了《⼈物》的专访。她⼀个⼈ 坐在急诊室办公室中，曾经⼀天接诊超过 1500 位患者的急诊科此时已恢复了安静， 急诊⼤厅⾥只躺着⼀名流浪汉。\"></a>这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有 的、严厉的斥责」，称她是作为专业⼈⼠在造谣。 3 ⽉ 2 ⽇下午，艾芬在武汉市中⼼医院南京路院区接受了《⼈物》的专访。她⼀个⼈ 坐在急诊室办公室中，曾经⼀天接诊超过 1500 位患者的急诊科此时已恢复了安静， 急诊⼤厅⾥只躺着⼀名流浪汉。</h5><h5 id=\"此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称-为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的-⼈」。采访中，艾芬数次提起「后悔」这个词，她后悔当初被约谈后没有继续吹响-哨声，特别是对于过世的同事，「早知道有今天，我管他批评不批评，『⽼⼦』到-处说，是不是？」\"><a href=\"#此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称-为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的-⼈」。采访中，艾芬数次提起「后悔」这个词，她后悔当初被约谈后没有继续吹响-哨声，特别是对于过世的同事，「早知道有今天，我管他批评不批评，『⽼⼦』到-处说，是不是？」\" class=\"headerlink\" title=\"此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称 为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的 ⼈」。采访中，艾芬数次提起「后悔」这个词，她后悔当初被约谈后没有继续吹响 哨声，特别是对于过世的同事，「早知道有今天，我管他批评不批评，『⽼⼦』到 处说，是不是？」\"></a>此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称 为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的 ⼈」。采访中，艾芬数次提起「后悔」这个词，她后悔当初被约谈后没有继续吹响 哨声，特别是对于过世的同事，「早知道有今天，我管他批评不批评，『⽼⼦』到 处说，是不是？」</h5><blockquote>\n<p>关于武汉市中⼼医院和艾芬本⼈在过去的两个多⽉中到底经历了什么？以下，是艾 芬的讲述——</p>\n</blockquote>\n<p><img src=\"https://s1.ax1x.com/2020/03/12/8maOXQ.png\" alt=\"8maOXQ.png\"></p>\n<h2 id=\"前所未有的训斥\"><a href=\"#前所未有的训斥\" class=\"headerlink\" title=\"前所未有的训斥\"></a>前所未有的训斥</h2><h5 id=\"去年-12-⽉-16-⽇，我们南京路院区急诊科接诊了⼀位病⼈。莫名其妙⾼烧，⼀直⽤药-都不好，体温动都不动⼀下。22-号就转到了呼吸科，做了纤维⽀⽓管镜取了肺泡灌-洗液，送去外⾯做⾼通量测序，后来⼝头报出来是冠状病毒。当时，具体管床的同-事在我⽿边嚼了⼏遍：艾主任，那个⼈报的是冠状病毒。后来我们才知道那个病⼈-是在华南海鲜做事的。\"><a href=\"#去年-12-⽉-16-⽇，我们南京路院区急诊科接诊了⼀位病⼈。莫名其妙⾼烧，⼀直⽤药-都不好，体温动都不动⼀下。22-号就转到了呼吸科，做了纤维⽀⽓管镜取了肺泡灌-洗液，送去外⾯做⾼通量测序，后来⼝头报出来是冠状病毒。当时，具体管床的同-事在我⽿边嚼了⼏遍：艾主任，那个⼈报的是冠状病毒。后来我们才知道那个病⼈-是在华南海鲜做事的。\" class=\"headerlink\" title=\"去年 12 ⽉ 16 ⽇，我们南京路院区急诊科接诊了⼀位病⼈。莫名其妙⾼烧，⼀直⽤药 都不好，体温动都不动⼀下。22 号就转到了呼吸科，做了纤维⽀⽓管镜取了肺泡灌 洗液，送去外⾯做⾼通量测序，后来⼝头报出来是冠状病毒。当时，具体管床的同 事在我⽿边嚼了⼏遍：艾主任，那个⼈报的是冠状病毒。后来我们才知道那个病⼈ 是在华南海鲜做事的。\"></a>去年 12 ⽉ 16 ⽇，我们南京路院区急诊科接诊了⼀位病⼈。莫名其妙⾼烧，⼀直⽤药 都不好，体温动都不动⼀下。22 号就转到了呼吸科，做了纤维⽀⽓管镜取了肺泡灌 洗液，送去外⾯做⾼通量测序，后来⼝头报出来是冠状病毒。当时，具体管床的同 事在我⽿边嚼了⼏遍：艾主任，那个⼈报的是冠状病毒。后来我们才知道那个病⼈ 是在华南海鲜做事的。</h5><h5 id=\"紧接着-12-⽉-27-⽇，南京路院区⼜来了⼀个病⼈，是我们科⼀位医⽣的侄⼉，40-多-岁，没有任何基础疾病，肺部⼀塌糊涂，⾎氧饱和只有-90-，在下⾯其他医院已经-治疗了将近-10-天左右都没有任何好转，病⼈收到了呼吸科监护室住院。同样做了纤-维⽀⽓管镜取了肺泡灌洗液送去检测。\"><a href=\"#紧接着-12-⽉-27-⽇，南京路院区⼜来了⼀个病⼈，是我们科⼀位医⽣的侄⼉，40-多-岁，没有任何基础疾病，肺部⼀塌糊涂，⾎氧饱和只有-90-，在下⾯其他医院已经-治疗了将近-10-天左右都没有任何好转，病⼈收到了呼吸科监护室住院。同样做了纤-维⽀⽓管镜取了肺泡灌洗液送去检测。\" class=\"headerlink\" title=\"紧接着 12 ⽉ 27 ⽇，南京路院区⼜来了⼀个病⼈，是我们科⼀位医⽣的侄⼉，40 多 岁，没有任何基础疾病，肺部⼀塌糊涂，⾎氧饱和只有 90%，在下⾯其他医院已经 治疗了将近 10 天左右都没有任何好转，病⼈收到了呼吸科监护室住院。同样做了纤 维⽀⽓管镜取了肺泡灌洗液送去检测。\"></a>紧接着 12 ⽉ 27 ⽇，南京路院区⼜来了⼀个病⼈，是我们科⼀位医⽣的侄⼉，40 多 岁，没有任何基础疾病，肺部⼀塌糊涂，⾎氧饱和只有 90%，在下⾯其他医院已经 治疗了将近 10 天左右都没有任何好转，病⼈收到了呼吸科监护室住院。同样做了纤 维⽀⽓管镜取了肺泡灌洗液送去检测。</h5><h5 id=\"12-⽉-30-⽇那天中午，我在同济医院⼯作的同学发了⼀张微信对话截图给我，截图上-写着：「最近不要去华南啊，那⾥蛮多⼈⾼烧……」他问我是不是真的，当时，我-正在电脑上看⼀个很典型的肺部感染患者的-CT，我就把-CT-录了⼀段-11-秒钟的视频-传给他，告诉他这是上午来我们急诊的⼀个病⼈，也是华南海鲜市场的。\"><a href=\"#12-⽉-30-⽇那天中午，我在同济医院⼯作的同学发了⼀张微信对话截图给我，截图上-写着：「最近不要去华南啊，那⾥蛮多⼈⾼烧……」他问我是不是真的，当时，我-正在电脑上看⼀个很典型的肺部感染患者的-CT，我就把-CT-录了⼀段-11-秒钟的视频-传给他，告诉他这是上午来我们急诊的⼀个病⼈，也是华南海鲜市场的。\" class=\"headerlink\" title=\"12 ⽉ 30 ⽇那天中午，我在同济医院⼯作的同学发了⼀张微信对话截图给我，截图上 写着：「最近不要去华南啊，那⾥蛮多⼈⾼烧……」他问我是不是真的，当时，我 正在电脑上看⼀个很典型的肺部感染患者的 CT，我就把 CT 录了⼀段 11 秒钟的视频 传给他，告诉他这是上午来我们急诊的⼀个病⼈，也是华南海鲜市场的。\"></a>12 ⽉ 30 ⽇那天中午，我在同济医院⼯作的同学发了⼀张微信对话截图给我，截图上 写着：「最近不要去华南啊，那⾥蛮多⼈⾼烧……」他问我是不是真的，当时，我 正在电脑上看⼀个很典型的肺部感染患者的 CT，我就把 CT 录了⼀段 11 秒钟的视频 传给他，告诉他这是上午来我们急诊的⼀个病⼈，也是华南海鲜市场的。</h5><h5 id=\"当天下午-4-点刚过，同事给我看了⼀份报告，上⾯写的是：SARS-冠状病毒、绿脓假-单胞菌、46-种⼝腔-呼吸道定植菌。我仔细看了很多遍报告，下⾯的注释写着：SA-RS-冠状病毒是⼀种单股正链-RNA-病毒。该病毒主要传播⽅式为近距离⻜沫传播或-接触患者呼吸道分泌物，可引起的⼀种具有明显传染性，可累及多个脏器系统的特-殊肺炎，也称⾮典型肺炎。\"><a href=\"#当天下午-4-点刚过，同事给我看了⼀份报告，上⾯写的是：SARS-冠状病毒、绿脓假-单胞菌、46-种⼝腔-呼吸道定植菌。我仔细看了很多遍报告，下⾯的注释写着：SA-RS-冠状病毒是⼀种单股正链-RNA-病毒。该病毒主要传播⽅式为近距离⻜沫传播或-接触患者呼吸道分泌物，可引起的⼀种具有明显传染性，可累及多个脏器系统的特-殊肺炎，也称⾮典型肺炎。\" class=\"headerlink\" title=\"当天下午 4 点刚过，同事给我看了⼀份报告，上⾯写的是：SARS 冠状病毒、绿脓假 单胞菌、46 种⼝腔/呼吸道定植菌。我仔细看了很多遍报告，下⾯的注释写着：SA RS 冠状病毒是⼀种单股正链 RNA 病毒。该病毒主要传播⽅式为近距离⻜沫传播或 接触患者呼吸道分泌物，可引起的⼀种具有明显传染性，可累及多个脏器系统的特 殊肺炎，也称⾮典型肺炎。\"></a>当天下午 4 点刚过，同事给我看了⼀份报告，上⾯写的是：SARS 冠状病毒、绿脓假 单胞菌、46 种⼝腔/呼吸道定植菌。我仔细看了很多遍报告，下⾯的注释写着：SA RS 冠状病毒是⼀种单股正链 RNA 病毒。该病毒主要传播⽅式为近距离⻜沫传播或 接触患者呼吸道分泌物，可引起的⼀种具有明显传染性，可累及多个脏器系统的特 殊肺炎，也称⾮典型肺炎。</h5><h5 id=\"当时，我吓出了⼀身冷汗，这是⼀个很可怕的东⻄。病⼈收在呼吸科，按道理应该-呼吸科上报这个情况，但是为了保险和重视起⻅，我还是⽴刻打电话上报给了医院-公共卫⽣科和院感科。当时我们医院呼吸科主任正好从我⻔⼝过，他是参加过⾮典-的⼈，我把他抓住，说，我们有个病⼈收到你们科室，发现了这个东⻄。他当时⼀-看就说，那就麻烦了。我就知道这个事情麻烦了。\"><a href=\"#当时，我吓出了⼀身冷汗，这是⼀个很可怕的东⻄。病⼈收在呼吸科，按道理应该-呼吸科上报这个情况，但是为了保险和重视起⻅，我还是⽴刻打电话上报给了医院-公共卫⽣科和院感科。当时我们医院呼吸科主任正好从我⻔⼝过，他是参加过⾮典-的⼈，我把他抓住，说，我们有个病⼈收到你们科室，发现了这个东⻄。他当时⼀-看就说，那就麻烦了。我就知道这个事情麻烦了。\" class=\"headerlink\" title=\"当时，我吓出了⼀身冷汗，这是⼀个很可怕的东⻄。病⼈收在呼吸科，按道理应该 呼吸科上报这个情况，但是为了保险和重视起⻅，我还是⽴刻打电话上报给了医院 公共卫⽣科和院感科。当时我们医院呼吸科主任正好从我⻔⼝过，他是参加过⾮典 的⼈，我把他抓住，说，我们有个病⼈收到你们科室，发现了这个东⻄。他当时⼀ 看就说，那就麻烦了。我就知道这个事情麻烦了。\"></a>当时，我吓出了⼀身冷汗，这是⼀个很可怕的东⻄。病⼈收在呼吸科，按道理应该 呼吸科上报这个情况，但是为了保险和重视起⻅，我还是⽴刻打电话上报给了医院 公共卫⽣科和院感科。当时我们医院呼吸科主任正好从我⻔⼝过，他是参加过⾮典 的⼈，我把他抓住，说，我们有个病⼈收到你们科室，发现了这个东⻄。他当时⼀ 看就说，那就麻烦了。我就知道这个事情麻烦了。</h5><h5 id=\"给医院打完电话，我也给我同学传了这份报告，特意在「SARS-冠状病毒、绿脓假-单胞菌、46-种⼝腔-呼吸道定植菌」这⼀排字上画了个红圈，⽬的是提醒他注意、-重视。我也把报告发在了科室医⽣群⾥⾯，提醒⼤家注意防范。\"><a href=\"#给医院打完电话，我也给我同学传了这份报告，特意在「SARS-冠状病毒、绿脓假-单胞菌、46-种⼝腔-呼吸道定植菌」这⼀排字上画了个红圈，⽬的是提醒他注意、-重视。我也把报告发在了科室医⽣群⾥⾯，提醒⼤家注意防范。\" class=\"headerlink\" title=\"给医院打完电话，我也给我同学传了这份报告，特意在「SARS 冠状病毒、绿脓假 单胞菌、46 种⼝腔/呼吸道定植菌」这⼀排字上画了个红圈，⽬的是提醒他注意、 重视。我也把报告发在了科室医⽣群⾥⾯，提醒⼤家注意防范。\"></a>给医院打完电话，我也给我同学传了这份报告，特意在「SARS 冠状病毒、绿脓假 单胞菌、46 种⼝腔/呼吸道定植菌」这⼀排字上画了个红圈，⽬的是提醒他注意、 重视。我也把报告发在了科室医⽣群⾥⾯，提醒⼤家注意防范。</h5><h5 id=\"当天晚上，这个东⻄就传遍了，各处传的截屏都是我画红圈的那个照⽚，包括后来-知道李⽂亮传在群⾥的也是那份。我⼼⾥当时就想可能坏事⼉了。10-点-20，医院发-来了信息，是转市卫健委的通知，⼤意就是关于不明原因肺炎，不要随意对外发-布，避免引起群众恐慌，如果因为信息泄露引发恐慌，要追责。-我当时⼼⾥就很害怕，⽴刻把这条信息转给了我同学。过了⼤概⼀个⼩时，医院⼜-来了⼀份通知，再次强调群内的相关消息不能外传。⼀天后，1-⽉-1-⽇晚上-11-点-46-分，医院监察科科⻓给我发了条消息，让我第⼆天早上过去⼀下。\"><a href=\"#当天晚上，这个东⻄就传遍了，各处传的截屏都是我画红圈的那个照⽚，包括后来-知道李⽂亮传在群⾥的也是那份。我⼼⾥当时就想可能坏事⼉了。10-点-20，医院发-来了信息，是转市卫健委的通知，⼤意就是关于不明原因肺炎，不要随意对外发-布，避免引起群众恐慌，如果因为信息泄露引发恐慌，要追责。-我当时⼼⾥就很害怕，⽴刻把这条信息转给了我同学。过了⼤概⼀个⼩时，医院⼜-来了⼀份通知，再次强调群内的相关消息不能外传。⼀天后，1-⽉-1-⽇晚上-11-点-46-分，医院监察科科⻓给我发了条消息，让我第⼆天早上过去⼀下。\" class=\"headerlink\" title=\"当天晚上，这个东⻄就传遍了，各处传的截屏都是我画红圈的那个照⽚，包括后来 知道李⽂亮传在群⾥的也是那份。我⼼⾥当时就想可能坏事⼉了。10 点 20，医院发 来了信息，是转市卫健委的通知，⼤意就是关于不明原因肺炎，不要随意对外发 布，避免引起群众恐慌，如果因为信息泄露引发恐慌，要追责。 我当时⼼⾥就很害怕，⽴刻把这条信息转给了我同学。过了⼤概⼀个⼩时，医院⼜ 来了⼀份通知，再次强调群内的相关消息不能外传。⼀天后，1 ⽉ 1 ⽇晚上 11 点 46 分，医院监察科科⻓给我发了条消息，让我第⼆天早上过去⼀下。\"></a>当天晚上，这个东⻄就传遍了，各处传的截屏都是我画红圈的那个照⽚，包括后来 知道李⽂亮传在群⾥的也是那份。我⼼⾥当时就想可能坏事⼉了。10 点 20，医院发 来了信息，是转市卫健委的通知，⼤意就是关于不明原因肺炎，不要随意对外发 布，避免引起群众恐慌，如果因为信息泄露引发恐慌，要追责。 我当时⼼⾥就很害怕，⽴刻把这条信息转给了我同学。过了⼤概⼀个⼩时，医院⼜ 来了⼀份通知，再次强调群内的相关消息不能外传。⼀天后，1 ⽉ 1 ⽇晚上 11 点 46 分，医院监察科科⻓给我发了条消息，让我第⼆天早上过去⼀下。</h5><h5 id=\"那⼀晚上我都没有睡着，很担忧，翻来覆去地想，但⼜觉得凡事总有两⾯性，即便-造成不良影响，但提醒武汉的医务⼈员注意防范也不⼀定是个坏事。第⼆天早上-8-点多⼀点，还没有等我交完班，催我过去的电话就打来了。-之后的约谈，我遭受了前所未有的、⾮常严厉的斥责。\"><a href=\"#那⼀晚上我都没有睡着，很担忧，翻来覆去地想，但⼜觉得凡事总有两⾯性，即便-造成不良影响，但提醒武汉的医务⼈员注意防范也不⼀定是个坏事。第⼆天早上-8-点多⼀点，还没有等我交完班，催我过去的电话就打来了。-之后的约谈，我遭受了前所未有的、⾮常严厉的斥责。\" class=\"headerlink\" title=\"那⼀晚上我都没有睡着，很担忧，翻来覆去地想，但⼜觉得凡事总有两⾯性，即便 造成不良影响，但提醒武汉的医务⼈员注意防范也不⼀定是个坏事。第⼆天早上 8 点多⼀点，还没有等我交完班，催我过去的电话就打来了。 之后的约谈，我遭受了前所未有的、⾮常严厉的斥责。\"></a>那⼀晚上我都没有睡着，很担忧，翻来覆去地想，但⼜觉得凡事总有两⾯性，即便 造成不良影响，但提醒武汉的医务⼈员注意防范也不⼀定是个坏事。第⼆天早上 8 点多⼀点，还没有等我交完班，催我过去的电话就打来了。 之后的约谈，我遭受了前所未有的、⾮常严厉的斥责。</h5><h5 id=\"当时，谈话的领导说，「我们出去开会都抬不起头，某某某主任批评我们医院那个-艾芬，作为武汉市中⼼医院急诊科主任，你是专业⼈⼠，怎么能够没有原则没有组-织纪律造谣⽣事？」这是原话。让我回去跟科室的-200-多号⼈⼀个个地⼝头传达到-位，不能发微信、短信传达，只能当⾯聊或者打电话，不许说关于这个肺炎的任何-事情，「连⾃⼰的⽼公都不能说」……\"><a href=\"#当时，谈话的领导说，「我们出去开会都抬不起头，某某某主任批评我们医院那个-艾芬，作为武汉市中⼼医院急诊科主任，你是专业⼈⼠，怎么能够没有原则没有组-织纪律造谣⽣事？」这是原话。让我回去跟科室的-200-多号⼈⼀个个地⼝头传达到-位，不能发微信、短信传达，只能当⾯聊或者打电话，不许说关于这个肺炎的任何-事情，「连⾃⼰的⽼公都不能说」……\" class=\"headerlink\" title=\"当时，谈话的领导说，「我们出去开会都抬不起头，某某某主任批评我们医院那个 艾芬，作为武汉市中⼼医院急诊科主任，你是专业⼈⼠，怎么能够没有原则没有组 织纪律造谣⽣事？」这是原话。让我回去跟科室的 200 多号⼈⼀个个地⼝头传达到 位，不能发微信、短信传达，只能当⾯聊或者打电话，不许说关于这个肺炎的任何 事情，「连⾃⼰的⽼公都不能说」……\"></a>当时，谈话的领导说，「我们出去开会都抬不起头，某某某主任批评我们医院那个 艾芬，作为武汉市中⼼医院急诊科主任，你是专业⼈⼠，怎么能够没有原则没有组 织纪律造谣⽣事？」这是原话。让我回去跟科室的 200 多号⼈⼀个个地⼝头传达到 位，不能发微信、短信传达，只能当⾯聊或者打电话，不许说关于这个肺炎的任何 事情，「连⾃⼰的⽼公都不能说」……</h5><h5 id=\"我整个⼈⼀下⼦就懵了，他不是批评你这个⼈⼯作不努⼒，⽽是好像整个武汉市发-展的⼤好局⾯被我⼀个⼈破坏了。我当时有⼀种很绝望的感觉，我是⼀个平时认认-真真、勤勤恳恳⼯作的⼈，我觉得⾃⼰做的事情都是按规矩来的，都是有道理的。\"><a href=\"#我整个⼈⼀下⼦就懵了，他不是批评你这个⼈⼯作不努⼒，⽽是好像整个武汉市发-展的⼤好局⾯被我⼀个⼈破坏了。我当时有⼀种很绝望的感觉，我是⼀个平时认认-真真、勤勤恳恳⼯作的⼈，我觉得⾃⼰做的事情都是按规矩来的，都是有道理的。\" class=\"headerlink\" title=\"我整个⼈⼀下⼦就懵了，他不是批评你这个⼈⼯作不努⼒，⽽是好像整个武汉市发 展的⼤好局⾯被我⼀个⼈破坏了。我当时有⼀种很绝望的感觉，我是⼀个平时认认 真真、勤勤恳恳⼯作的⼈，我觉得⾃⼰做的事情都是按规矩来的，都是有道理的。\"></a>我整个⼈⼀下⼦就懵了，他不是批评你这个⼈⼯作不努⼒，⽽是好像整个武汉市发 展的⼤好局⾯被我⼀个⼈破坏了。我当时有⼀种很绝望的感觉，我是⼀个平时认认 真真、勤勤恳恳⼯作的⼈，我觉得⾃⼰做的事情都是按规矩来的，都是有道理的。</h5><h5 id=\"我犯了什么错？我看到了这个报告，我也上报医院了，我和我的同学，同⾏之间对-于某⼀个病⼈的情况进⾏交流，没有透露病⼈的任何私⼈信息，就相当于是医学⽣-之间讨论⼀个病案，当你作为⼀个临床的医⽣，已经知道在病⼈身上发现了⼀种很-重要的病毒，别的医⽣问起，你怎么可能不说呢？这是你当医⽣的本能，对不对？\"><a href=\"#我犯了什么错？我看到了这个报告，我也上报医院了，我和我的同学，同⾏之间对-于某⼀个病⼈的情况进⾏交流，没有透露病⼈的任何私⼈信息，就相当于是医学⽣-之间讨论⼀个病案，当你作为⼀个临床的医⽣，已经知道在病⼈身上发现了⼀种很-重要的病毒，别的医⽣问起，你怎么可能不说呢？这是你当医⽣的本能，对不对？\" class=\"headerlink\" title=\"我犯了什么错？我看到了这个报告，我也上报医院了，我和我的同学，同⾏之间对 于某⼀个病⼈的情况进⾏交流，没有透露病⼈的任何私⼈信息，就相当于是医学⽣ 之间讨论⼀个病案，当你作为⼀个临床的医⽣，已经知道在病⼈身上发现了⼀种很 重要的病毒，别的医⽣问起，你怎么可能不说呢？这是你当医⽣的本能，对不对？\"></a>我犯了什么错？我看到了这个报告，我也上报医院了，我和我的同学，同⾏之间对 于某⼀个病⼈的情况进⾏交流，没有透露病⼈的任何私⼈信息，就相当于是医学⽣ 之间讨论⼀个病案，当你作为⼀个临床的医⽣，已经知道在病⼈身上发现了⼀种很 重要的病毒，别的医⽣问起，你怎么可能不说呢？这是你当医⽣的本能，对不对？</h5><h5 id=\"我做错什么了？我做了⼀个医⽣、⼀个⼈正常应该做的事情，换作是任何⼈我觉得-都会这么做。-我当时的情绪也很激动，说，这个事是我做的，跟其余⼈都没有关系，你们⼲脆把-我抓去坐牢吧。我说我现在这个状态不适合在这个岗位上继续⼯作了，想要休息⼀-段时间。领导没有同意，说这个时候正是考验我的时候。\"><a href=\"#我做错什么了？我做了⼀个医⽣、⼀个⼈正常应该做的事情，换作是任何⼈我觉得-都会这么做。-我当时的情绪也很激动，说，这个事是我做的，跟其余⼈都没有关系，你们⼲脆把-我抓去坐牢吧。我说我现在这个状态不适合在这个岗位上继续⼯作了，想要休息⼀-段时间。领导没有同意，说这个时候正是考验我的时候。\" class=\"headerlink\" title=\"我做错什么了？我做了⼀个医⽣、⼀个⼈正常应该做的事情，换作是任何⼈我觉得 都会这么做。 我当时的情绪也很激动，说，这个事是我做的，跟其余⼈都没有关系，你们⼲脆把 我抓去坐牢吧。我说我现在这个状态不适合在这个岗位上继续⼯作了，想要休息⼀ 段时间。领导没有同意，说这个时候正是考验我的时候。\"></a>我做错什么了？我做了⼀个医⽣、⼀个⼈正常应该做的事情，换作是任何⼈我觉得 都会这么做。 我当时的情绪也很激动，说，这个事是我做的，跟其余⼈都没有关系，你们⼲脆把 我抓去坐牢吧。我说我现在这个状态不适合在这个岗位上继续⼯作了，想要休息⼀ 段时间。领导没有同意，说这个时候正是考验我的时候。</h5><h5 id=\"当天晚上回家，我记得蛮清楚，进⻔后就跟我⽼公讲，我要是出了什么事情，你就-好好地把孩⼦带⼤。因为我的⼆宝还很⼩，才-1-岁多。他当时觉得莫名其妙，我没-有跟他说⾃⼰被训话的事，1-⽉-20-号，钟南⼭说了⼈传⼈之后，我才跟他说那天发-⽣了什么。那期间，我只是提醒家⼈不要去⼈多的地⽅，出⻔要戴⼝罩。\"><a href=\"#当天晚上回家，我记得蛮清楚，进⻔后就跟我⽼公讲，我要是出了什么事情，你就-好好地把孩⼦带⼤。因为我的⼆宝还很⼩，才-1-岁多。他当时觉得莫名其妙，我没-有跟他说⾃⼰被训话的事，1-⽉-20-号，钟南⼭说了⼈传⼈之后，我才跟他说那天发-⽣了什么。那期间，我只是提醒家⼈不要去⼈多的地⽅，出⻔要戴⼝罩。\" class=\"headerlink\" title=\"当天晚上回家，我记得蛮清楚，进⻔后就跟我⽼公讲，我要是出了什么事情，你就 好好地把孩⼦带⼤。因为我的⼆宝还很⼩，才 1 岁多。他当时觉得莫名其妙，我没 有跟他说⾃⼰被训话的事，1 ⽉ 20 号，钟南⼭说了⼈传⼈之后，我才跟他说那天发 ⽣了什么。那期间，我只是提醒家⼈不要去⼈多的地⽅，出⻔要戴⼝罩。\"></a>当天晚上回家，我记得蛮清楚，进⻔后就跟我⽼公讲，我要是出了什么事情，你就 好好地把孩⼦带⼤。因为我的⼆宝还很⼩，才 1 岁多。他当时觉得莫名其妙，我没 有跟他说⾃⼰被训话的事，1 ⽉ 20 号，钟南⼭说了⼈传⼈之后，我才跟他说那天发 ⽣了什么。那期间，我只是提醒家⼈不要去⼈多的地⽅，出⻔要戴⼝罩。</h5><h2 id=\"外围科室\"><a href=\"#外围科室\" class=\"headerlink\" title=\"外围科室\"></a>外围科室</h2><h5 id=\"很多⼈担⼼我也是那-8-个⼈之⼀被叫去训诫。实际上我没有被公安局训诫，后来有-好朋友问我，你是不是吹哨⼈？我说我不是吹哨⼈，我是那个发哨⼦的⼈。\"><a href=\"#很多⼈担⼼我也是那-8-个⼈之⼀被叫去训诫。实际上我没有被公安局训诫，后来有-好朋友问我，你是不是吹哨⼈？我说我不是吹哨⼈，我是那个发哨⼦的⼈。\" class=\"headerlink\" title=\"很多⼈担⼼我也是那 8 个⼈之⼀被叫去训诫。实际上我没有被公安局训诫，后来有 好朋友问我，你是不是吹哨⼈？我说我不是吹哨⼈，我是那个发哨⼦的⼈。\"></a>很多⼈担⼼我也是那 8 个⼈之⼀被叫去训诫。实际上我没有被公安局训诫，后来有 好朋友问我，你是不是吹哨⼈？我说我不是吹哨⼈，我是那个发哨⼦的⼈。</h5><h5 id=\"但那次约谈对我的打击很⼤，⾮常⼤。回来后我感觉整个⼈⼼都垮了，真的是强打-着精神，认真做事，后来所有的⼈再来问我，我就不能回答了。\"><a href=\"#但那次约谈对我的打击很⼤，⾮常⼤。回来后我感觉整个⼈⼼都垮了，真的是强打-着精神，认真做事，后来所有的⼈再来问我，我就不能回答了。\" class=\"headerlink\" title=\"但那次约谈对我的打击很⼤，⾮常⼤。回来后我感觉整个⼈⼼都垮了，真的是强打 着精神，认真做事，后来所有的⼈再来问我，我就不能回答了。\"></a>但那次约谈对我的打击很⼤，⾮常⼤。回来后我感觉整个⼈⼼都垮了，真的是强打 着精神，认真做事，后来所有的⼈再来问我，我就不能回答了。</h5><h5 id=\"我能做的就是先让急诊科重视防护。我们急诊科-200-多⼈，从-1-⽉-1-号开始，我就叫-⼤家加强防护，所有的⼈必须戴⼝罩、戴帽⼦、⽤⼿快消。记得有⼀天交班有个男-护⼠没戴⼝罩，我⻢上就当场骂他「以后不戴⼝罩就不要来上班了」。\"><a href=\"#我能做的就是先让急诊科重视防护。我们急诊科-200-多⼈，从-1-⽉-1-号开始，我就叫-⼤家加强防护，所有的⼈必须戴⼝罩、戴帽⼦、⽤⼿快消。记得有⼀天交班有个男-护⼠没戴⼝罩，我⻢上就当场骂他「以后不戴⼝罩就不要来上班了」。\" class=\"headerlink\" title=\"我能做的就是先让急诊科重视防护。我们急诊科 200 多⼈，从 1 ⽉ 1 号开始，我就叫 ⼤家加强防护，所有的⼈必须戴⼝罩、戴帽⼦、⽤⼿快消。记得有⼀天交班有个男 护⼠没戴⼝罩，我⻢上就当场骂他「以后不戴⼝罩就不要来上班了」。\"></a>我能做的就是先让急诊科重视防护。我们急诊科 200 多⼈，从 1 ⽉ 1 号开始，我就叫 ⼤家加强防护，所有的⼈必须戴⼝罩、戴帽⼦、⽤⼿快消。记得有⼀天交班有个男 护⼠没戴⼝罩，我⻢上就当场骂他「以后不戴⼝罩就不要来上班了」。</h5><h5 id=\"1-⽉-9-号，我下班时看⻅预检台⼀个病⼈对着⼤家咳，从那天后，我就要求他们必须-给来看病的病⼈发⼝罩，⼀⼈发⼀个，这个时候不要节约钱，当时外⾯在说没有⼈传⼈，我⼜要在这⾥强调戴⼝罩加强防护，都是很⽭盾的。\"><a href=\"#1-⽉-9-号，我下班时看⻅预检台⼀个病⼈对着⼤家咳，从那天后，我就要求他们必须-给来看病的病⼈发⼝罩，⼀⼈发⼀个，这个时候不要节约钱，当时外⾯在说没有⼈传⼈，我⼜要在这⾥强调戴⼝罩加强防护，都是很⽭盾的。\" class=\"headerlink\" title=\"1 ⽉ 9 号，我下班时看⻅预检台⼀个病⼈对着⼤家咳，从那天后，我就要求他们必须 给来看病的病⼈发⼝罩，⼀⼈发⼀个，这个时候不要节约钱，当时外⾯在说没有⼈传⼈，我⼜要在这⾥强调戴⼝罩加强防护，都是很⽭盾的。\"></a>1 ⽉ 9 号，我下班时看⻅预检台⼀个病⼈对着⼤家咳，从那天后，我就要求他们必须 给来看病的病⼈发⼝罩，⼀⼈发⼀个，这个时候不要节约钱，当时外⾯在说没有⼈传⼈，我⼜要在这⾥强调戴⼝罩加强防护，都是很⽭盾的。</h5><h5 id=\"那段时间确实很压抑，⾮常痛苦。有医⽣提出来要把隔离⾐穿外头，医院⾥开会说-不让，说隔离⾐穿外头会造成恐慌。我就让科室的⼈把隔离服穿⽩⼤褂⾥⾯，这是-不符合规范的，很荒谬的。\"><a href=\"#那段时间确实很压抑，⾮常痛苦。有医⽣提出来要把隔离⾐穿外头，医院⾥开会说-不让，说隔离⾐穿外头会造成恐慌。我就让科室的⼈把隔离服穿⽩⼤褂⾥⾯，这是-不符合规范的，很荒谬的。\" class=\"headerlink\" title=\"那段时间确实很压抑，⾮常痛苦。有医⽣提出来要把隔离⾐穿外头，医院⾥开会说 不让，说隔离⾐穿外头会造成恐慌。我就让科室的⼈把隔离服穿⽩⼤褂⾥⾯，这是 不符合规范的，很荒谬的。\"></a>那段时间确实很压抑，⾮常痛苦。有医⽣提出来要把隔离⾐穿外头，医院⾥开会说 不让，说隔离⾐穿外头会造成恐慌。我就让科室的⼈把隔离服穿⽩⼤褂⾥⾯，这是 不符合规范的，很荒谬的。</h5><h5 id=\"我们眼睁睁地看着病⼈越来越多，传播区域的半径越来越⼤，先是华南海鲜市场附-近可能跟它有关系，然后就传传传，半径越来越⼤。很多是家庭传染的，最先的-7-个⼈当中就有妈妈给⼉⼦送饭得的病。有诊所的⽼板得病，也是来打针的病⼈传给-他的，都是重得不得了。我就知道肯定有⼈传⼈。如果没有⼈传⼈，华南海鲜市场-1-⽉-1-⽇就关闭了，怎么病⼈会越来越多呢？-很多时候我都在想，如果他们当时不那样训斥我，⼼平⽓和地问⼀下这件事情的来-⻰去脉，再请别的呼吸科专家⼀起沟通⼀下，也许局⾯会好⼀些，我⾄少可以在医-院内部多交流⼀下。如果是-1-⽉-1-号⼤家都这样引起警惕，就不会有那么多悲剧了。\"><a href=\"#我们眼睁睁地看着病⼈越来越多，传播区域的半径越来越⼤，先是华南海鲜市场附-近可能跟它有关系，然后就传传传，半径越来越⼤。很多是家庭传染的，最先的-7-个⼈当中就有妈妈给⼉⼦送饭得的病。有诊所的⽼板得病，也是来打针的病⼈传给-他的，都是重得不得了。我就知道肯定有⼈传⼈。如果没有⼈传⼈，华南海鲜市场-1-⽉-1-⽇就关闭了，怎么病⼈会越来越多呢？-很多时候我都在想，如果他们当时不那样训斥我，⼼平⽓和地问⼀下这件事情的来-⻰去脉，再请别的呼吸科专家⼀起沟通⼀下，也许局⾯会好⼀些，我⾄少可以在医-院内部多交流⼀下。如果是-1-⽉-1-号⼤家都这样引起警惕，就不会有那么多悲剧了。\" class=\"headerlink\" title=\"我们眼睁睁地看着病⼈越来越多，传播区域的半径越来越⼤，先是华南海鲜市场附 近可能跟它有关系，然后就传传传，半径越来越⼤。很多是家庭传染的，最先的 7 个⼈当中就有妈妈给⼉⼦送饭得的病。有诊所的⽼板得病，也是来打针的病⼈传给 他的，都是重得不得了。我就知道肯定有⼈传⼈。如果没有⼈传⼈，华南海鲜市场 1 ⽉ 1 ⽇就关闭了，怎么病⼈会越来越多呢？ 很多时候我都在想，如果他们当时不那样训斥我，⼼平⽓和地问⼀下这件事情的来 ⻰去脉，再请别的呼吸科专家⼀起沟通⼀下，也许局⾯会好⼀些，我⾄少可以在医 院内部多交流⼀下。如果是 1 ⽉ 1 号⼤家都这样引起警惕，就不会有那么多悲剧了。\"></a>我们眼睁睁地看着病⼈越来越多，传播区域的半径越来越⼤，先是华南海鲜市场附 近可能跟它有关系，然后就传传传，半径越来越⼤。很多是家庭传染的，最先的 7 个⼈当中就有妈妈给⼉⼦送饭得的病。有诊所的⽼板得病，也是来打针的病⼈传给 他的，都是重得不得了。我就知道肯定有⼈传⼈。如果没有⼈传⼈，华南海鲜市场 1 ⽉ 1 ⽇就关闭了，怎么病⼈会越来越多呢？ 很多时候我都在想，如果他们当时不那样训斥我，⼼平⽓和地问⼀下这件事情的来 ⻰去脉，再请别的呼吸科专家⼀起沟通⼀下，也许局⾯会好⼀些，我⾄少可以在医 院内部多交流⼀下。如果是 1 ⽉ 1 号⼤家都这样引起警惕，就不会有那么多悲剧了。</h5><h5 id=\"1-⽉-3-号下午，在南京路院区，泌尿外科的医⽣们聚集在⼀起回顾⽼主任的⼯作历-程，参会的胡卫峰医⽣今年-43-岁，现在正在抢救；1-⽉-8-号下午，南京路院区-22-楼，江学庆主任还组织了武汉市甲乳患者康复联欢会；1-⽉-11-号早上，科室跟我汇报-急诊科抢救室护⼠胡紫薇感染，她应该是中⼼医院第⼀个被感染的护⼠，我第⼀时-间给医务科科⻓打电话汇报，然后医院紧急开了会，会上指示把「两下肺感染，病-毒性肺炎？」的报告改成「两肺散在感染」；1-⽉-16-号最后⼀次周会上，⼀位副院-⻓还在说：「⼤家都要有⼀点医学常识，某些⾼年资的医⽣不要⾃⼰把⾃⼰搞得吓死⼈的。」另⼀位领导上台继续说：「没有⼈传⼈，可防可治可控。」⼀天后，1-⽉-17-号，江学庆住院，10-天后插管、上-ECMO。\"><a href=\"#1-⽉-3-号下午，在南京路院区，泌尿外科的医⽣们聚集在⼀起回顾⽼主任的⼯作历-程，参会的胡卫峰医⽣今年-43-岁，现在正在抢救；1-⽉-8-号下午，南京路院区-22-楼，江学庆主任还组织了武汉市甲乳患者康复联欢会；1-⽉-11-号早上，科室跟我汇报-急诊科抢救室护⼠胡紫薇感染，她应该是中⼼医院第⼀个被感染的护⼠，我第⼀时-间给医务科科⻓打电话汇报，然后医院紧急开了会，会上指示把「两下肺感染，病-毒性肺炎？」的报告改成「两肺散在感染」；1-⽉-16-号最后⼀次周会上，⼀位副院-⻓还在说：「⼤家都要有⼀点医学常识，某些⾼年资的医⽣不要⾃⼰把⾃⼰搞得吓死⼈的。」另⼀位领导上台继续说：「没有⼈传⼈，可防可治可控。」⼀天后，1-⽉-17-号，江学庆住院，10-天后插管、上-ECMO。\" class=\"headerlink\" title=\"1 ⽉ 3 号下午，在南京路院区，泌尿外科的医⽣们聚集在⼀起回顾⽼主任的⼯作历 程，参会的胡卫峰医⽣今年 43 岁，现在正在抢救；1 ⽉ 8 号下午，南京路院区 22 楼，江学庆主任还组织了武汉市甲乳患者康复联欢会；1 ⽉ 11 号早上，科室跟我汇报 急诊科抢救室护⼠胡紫薇感染，她应该是中⼼医院第⼀个被感染的护⼠，我第⼀时 间给医务科科⻓打电话汇报，然后医院紧急开了会，会上指示把「两下肺感染，病 毒性肺炎？」的报告改成「两肺散在感染」；1 ⽉ 16 号最后⼀次周会上，⼀位副院 ⻓还在说：「⼤家都要有⼀点医学常识，某些⾼年资的医⽣不要⾃⼰把⾃⼰搞得吓死⼈的。」另⼀位领导上台继续说：「没有⼈传⼈，可防可治可控。」⼀天后，1 ⽉ 17 号，江学庆住院，10 天后插管、上 ECMO。\"></a>1 ⽉ 3 号下午，在南京路院区，泌尿外科的医⽣们聚集在⼀起回顾⽼主任的⼯作历 程，参会的胡卫峰医⽣今年 43 岁，现在正在抢救；1 ⽉ 8 号下午，南京路院区 22 楼，江学庆主任还组织了武汉市甲乳患者康复联欢会；1 ⽉ 11 号早上，科室跟我汇报 急诊科抢救室护⼠胡紫薇感染，她应该是中⼼医院第⼀个被感染的护⼠，我第⼀时 间给医务科科⻓打电话汇报，然后医院紧急开了会，会上指示把「两下肺感染，病 毒性肺炎？」的报告改成「两肺散在感染」；1 ⽉ 16 号最后⼀次周会上，⼀位副院 ⻓还在说：「⼤家都要有⼀点医学常识，某些⾼年资的医⽣不要⾃⼰把⾃⼰搞得吓死⼈的。」另⼀位领导上台继续说：「没有⼈传⼈，可防可治可控。」⼀天后，1 ⽉ 17 号，江学庆住院，10 天后插管、上 ECMO。</h5><h5 id=\"中⼼医院的代价这么⼤，就是跟我们的医务⼈员没有信息透明化有关。你看倒下的-⼈，急诊科和呼吸科的倒是没有那么重的，因为我们有防护意识，并且⼀⽣病就赶-紧休息治疗。重的都是外围科室，李⽂亮是眼科的，江学庆是甲乳科的。\"><a href=\"#中⼼医院的代价这么⼤，就是跟我们的医务⼈员没有信息透明化有关。你看倒下的-⼈，急诊科和呼吸科的倒是没有那么重的，因为我们有防护意识，并且⼀⽣病就赶-紧休息治疗。重的都是外围科室，李⽂亮是眼科的，江学庆是甲乳科的。\" class=\"headerlink\" title=\"中⼼医院的代价这么⼤，就是跟我们的医务⼈员没有信息透明化有关。你看倒下的 ⼈，急诊科和呼吸科的倒是没有那么重的，因为我们有防护意识，并且⼀⽣病就赶 紧休息治疗。重的都是外围科室，李⽂亮是眼科的，江学庆是甲乳科的。\"></a>中⼼医院的代价这么⼤，就是跟我们的医务⼈员没有信息透明化有关。你看倒下的 ⼈，急诊科和呼吸科的倒是没有那么重的，因为我们有防护意识，并且⼀⽣病就赶 紧休息治疗。重的都是外围科室，李⽂亮是眼科的，江学庆是甲乳科的。</h5><h5 id=\"江学庆真的⾮常好的⼀个⼈，医术很⾼，全院的两个中国医师奖之⼀。⽽且我们还-是邻居，我们⼀个单元，我住四⼗⼏楼，他住三⼗⼏楼，关系都很好，但是平时因-为⼯作太忙，就只能开会、搞医院活动时候⻅⻅⾯。他是个⼯作狂，要么就在⼿术-室，要么就在看⻔诊。谁也不会特意跑去跟他说，江主任，你要注意，戴⼝罩。他-也没有时间和精⼒打听这些事，他肯定就⼤意了：「有什么关系？就是个肺炎。」-这个是他们科室的⼈告诉我的。\"><a href=\"#江学庆真的⾮常好的⼀个⼈，医术很⾼，全院的两个中国医师奖之⼀。⽽且我们还-是邻居，我们⼀个单元，我住四⼗⼏楼，他住三⼗⼏楼，关系都很好，但是平时因-为⼯作太忙，就只能开会、搞医院活动时候⻅⻅⾯。他是个⼯作狂，要么就在⼿术-室，要么就在看⻔诊。谁也不会特意跑去跟他说，江主任，你要注意，戴⼝罩。他-也没有时间和精⼒打听这些事，他肯定就⼤意了：「有什么关系？就是个肺炎。」-这个是他们科室的⼈告诉我的。\" class=\"headerlink\" title=\"江学庆真的⾮常好的⼀个⼈，医术很⾼，全院的两个中国医师奖之⼀。⽽且我们还 是邻居，我们⼀个单元，我住四⼗⼏楼，他住三⼗⼏楼，关系都很好，但是平时因 为⼯作太忙，就只能开会、搞医院活动时候⻅⻅⾯。他是个⼯作狂，要么就在⼿术 室，要么就在看⻔诊。谁也不会特意跑去跟他说，江主任，你要注意，戴⼝罩。他 也没有时间和精⼒打听这些事，他肯定就⼤意了：「有什么关系？就是个肺炎。」 这个是他们科室的⼈告诉我的。\"></a>江学庆真的⾮常好的⼀个⼈，医术很⾼，全院的两个中国医师奖之⼀。⽽且我们还 是邻居，我们⼀个单元，我住四⼗⼏楼，他住三⼗⼏楼，关系都很好，但是平时因 为⼯作太忙，就只能开会、搞医院活动时候⻅⻅⾯。他是个⼯作狂，要么就在⼿术 室，要么就在看⻔诊。谁也不会特意跑去跟他说，江主任，你要注意，戴⼝罩。他 也没有时间和精⼒打听这些事，他肯定就⼤意了：「有什么关系？就是个肺炎。」 这个是他们科室的⼈告诉我的。</h5><h5 id=\"如果这些医⽣都能够得到及时的提醒，或许就不会有这⼀天。所以，作为当事⼈的-我⾮常后悔，早知道有今天，我管他批评不批评我，「⽼⼦」到处说，是不是？-虽然和李⽂亮同在⼀个医院，⼀直到去世之前我都不认得他，因为医院-4000-多号-⼈太多了，平时也忙。他去世前的那天晚上，ICU-的主任跟我打电话借急诊科的⼼-脏按压器，说李⽂亮要抢救，我⼀听这个消息⼤吃⼀惊，李⽂亮这个事整个过程我-不了解，但是他的病情跟他受训斥之后⼼情不好有没有关系？这我要打个问号，因-为受训的感觉我感同身受。\"><a href=\"#如果这些医⽣都能够得到及时的提醒，或许就不会有这⼀天。所以，作为当事⼈的-我⾮常后悔，早知道有今天，我管他批评不批评我，「⽼⼦」到处说，是不是？-虽然和李⽂亮同在⼀个医院，⼀直到去世之前我都不认得他，因为医院-4000-多号-⼈太多了，平时也忙。他去世前的那天晚上，ICU-的主任跟我打电话借急诊科的⼼-脏按压器，说李⽂亮要抢救，我⼀听这个消息⼤吃⼀惊，李⽂亮这个事整个过程我-不了解，但是他的病情跟他受训斥之后⼼情不好有没有关系？这我要打个问号，因-为受训的感觉我感同身受。\" class=\"headerlink\" title=\"如果这些医⽣都能够得到及时的提醒，或许就不会有这⼀天。所以，作为当事⼈的 我⾮常后悔，早知道有今天，我管他批评不批评我，「⽼⼦」到处说，是不是？ 虽然和李⽂亮同在⼀个医院，⼀直到去世之前我都不认得他，因为医院 4000 多号 ⼈太多了，平时也忙。他去世前的那天晚上，ICU 的主任跟我打电话借急诊科的⼼ 脏按压器，说李⽂亮要抢救，我⼀听这个消息⼤吃⼀惊，李⽂亮这个事整个过程我 不了解，但是他的病情跟他受训斥之后⼼情不好有没有关系？这我要打个问号，因 为受训的感觉我感同身受。\"></a>如果这些医⽣都能够得到及时的提醒，或许就不会有这⼀天。所以，作为当事⼈的 我⾮常后悔，早知道有今天，我管他批评不批评我，「⽼⼦」到处说，是不是？ 虽然和李⽂亮同在⼀个医院，⼀直到去世之前我都不认得他，因为医院 4000 多号 ⼈太多了，平时也忙。他去世前的那天晚上，ICU 的主任跟我打电话借急诊科的⼼ 脏按压器，说李⽂亮要抢救，我⼀听这个消息⼤吃⼀惊，李⽂亮这个事整个过程我 不了解，但是他的病情跟他受训斥之后⼼情不好有没有关系？这我要打个问号，因 为受训的感觉我感同身受。</h5><h5 id=\"后来，事情发展到这⼀步，证明李⽂亮是对的时候，他的⼼情我⾮常能理解，可能-跟我的⼼情⼀样，不是激动、⾼兴，⽽是后悔，后悔当初就应该继续⼤声疾呼，应-该在所有的⼈问我们的时候，继续说。很多很多次我都在想，如果时间能够倒回来-该多好。\"><a href=\"#后来，事情发展到这⼀步，证明李⽂亮是对的时候，他的⼼情我⾮常能理解，可能-跟我的⼼情⼀样，不是激动、⾼兴，⽽是后悔，后悔当初就应该继续⼤声疾呼，应-该在所有的⼈问我们的时候，继续说。很多很多次我都在想，如果时间能够倒回来-该多好。\" class=\"headerlink\" title=\"后来，事情发展到这⼀步，证明李⽂亮是对的时候，他的⼼情我⾮常能理解，可能 跟我的⼼情⼀样，不是激动、⾼兴，⽽是后悔，后悔当初就应该继续⼤声疾呼，应 该在所有的⼈问我们的时候，继续说。很多很多次我都在想，如果时间能够倒回来 该多好。\"></a>后来，事情发展到这⼀步，证明李⽂亮是对的时候，他的⼼情我⾮常能理解，可能 跟我的⼼情⼀样，不是激动、⾼兴，⽽是后悔，后悔当初就应该继续⼤声疾呼，应 该在所有的⼈问我们的时候，继续说。很多很多次我都在想，如果时间能够倒回来 该多好。</h5><p><img src=\"https://s1.ax1x.com/2020/03/12/8mwPUI.png\" alt=\"8mwPUI.png\"></p>\n<h2 id=\"活着就是好的\"><a href=\"#活着就是好的\" class=\"headerlink\" title=\"活着就是好的\"></a>活着就是好的</h2><h5 id=\"在-1-⽉-23-⽇封城前⼀天的晚上，有相关部⻔的朋友打电话问我武汉市急诊病⼈的真-实情况。我说你代表私⼈，还是代表公家。他说我代表私⼈。我说代表个⼈就告诉-你真话，1-⽉-21-号，我们急诊科接诊-1523-个病⼈，是往常最多时的-3-倍，其中发烧的-有-655-个⼈。\"><a href=\"#在-1-⽉-23-⽇封城前⼀天的晚上，有相关部⻔的朋友打电话问我武汉市急诊病⼈的真-实情况。我说你代表私⼈，还是代表公家。他说我代表私⼈。我说代表个⼈就告诉-你真话，1-⽉-21-号，我们急诊科接诊-1523-个病⼈，是往常最多时的-3-倍，其中发烧的-有-655-个⼈。\" class=\"headerlink\" title=\"在 1 ⽉ 23 ⽇封城前⼀天的晚上，有相关部⻔的朋友打电话问我武汉市急诊病⼈的真 实情况。我说你代表私⼈，还是代表公家。他说我代表私⼈。我说代表个⼈就告诉 你真话，1 ⽉ 21 号，我们急诊科接诊 1523 个病⼈，是往常最多时的 3 倍，其中发烧的 有 655 个⼈。\"></a>在 1 ⽉ 23 ⽇封城前⼀天的晚上，有相关部⻔的朋友打电话问我武汉市急诊病⼈的真 实情况。我说你代表私⼈，还是代表公家。他说我代表私⼈。我说代表个⼈就告诉 你真话，1 ⽉ 21 号，我们急诊科接诊 1523 个病⼈，是往常最多时的 3 倍，其中发烧的 有 655 个⼈。</h5><h5 id=\"那段时间急诊科的状况，经历过的⼈⼀辈⼦都忘不了，甚⾄会颠覆你的所有⼈⽣-观。如果说这是打仗，急诊科就在最前线。但当时的情况是，后⾯的病区已经饱和了，-基本上⼀个病⼈都不收，ICU-也坚决不收，说⾥⾯有⼲净的病⼈，⼀进去就污染-了。病⼈不断地往急诊科涌，后⾯的路⼜不通，就全部堆在急诊科。病⼈来看病，-⼀排队随便就是⼏个⼩时，我们也完全没法下班，发热⻔诊和急诊也都不分了，⼤-厅⾥堆满了病⼈，抢救室输液室⾥到处都是病⼈。-还有的病⼈家属来了，说要⼀张床，我的爸爸在汽⻋⾥⾯不⾏了，因为那时候地下-⻋库已封，他⻋⼦也堵着开不进来。我没办法，带着⼈和设备跑去汽⻋⾥去，⼀-看，⼈已经死了，你说是什么感受，很难受很难受。这个⼈就死在汽⻋⾥，连下⻋-的机会都没有。\"><a href=\"#那段时间急诊科的状况，经历过的⼈⼀辈⼦都忘不了，甚⾄会颠覆你的所有⼈⽣-观。如果说这是打仗，急诊科就在最前线。但当时的情况是，后⾯的病区已经饱和了，-基本上⼀个病⼈都不收，ICU-也坚决不收，说⾥⾯有⼲净的病⼈，⼀进去就污染-了。病⼈不断地往急诊科涌，后⾯的路⼜不通，就全部堆在急诊科。病⼈来看病，-⼀排队随便就是⼏个⼩时，我们也完全没法下班，发热⻔诊和急诊也都不分了，⼤-厅⾥堆满了病⼈，抢救室输液室⾥到处都是病⼈。-还有的病⼈家属来了，说要⼀张床，我的爸爸在汽⻋⾥⾯不⾏了，因为那时候地下-⻋库已封，他⻋⼦也堵着开不进来。我没办法，带着⼈和设备跑去汽⻋⾥去，⼀-看，⼈已经死了，你说是什么感受，很难受很难受。这个⼈就死在汽⻋⾥，连下⻋-的机会都没有。\" class=\"headerlink\" title=\"那段时间急诊科的状况，经历过的⼈⼀辈⼦都忘不了，甚⾄会颠覆你的所有⼈⽣ 观。如果说这是打仗，急诊科就在最前线。但当时的情况是，后⾯的病区已经饱和了， 基本上⼀个病⼈都不收，ICU 也坚决不收，说⾥⾯有⼲净的病⼈，⼀进去就污染 了。病⼈不断地往急诊科涌，后⾯的路⼜不通，就全部堆在急诊科。病⼈来看病， ⼀排队随便就是⼏个⼩时，我们也完全没法下班，发热⻔诊和急诊也都不分了，⼤ 厅⾥堆满了病⼈，抢救室输液室⾥到处都是病⼈。 还有的病⼈家属来了，说要⼀张床，我的爸爸在汽⻋⾥⾯不⾏了，因为那时候地下 ⻋库已封，他⻋⼦也堵着开不进来。我没办法，带着⼈和设备跑去汽⻋⾥去，⼀ 看，⼈已经死了，你说是什么感受，很难受很难受。这个⼈就死在汽⻋⾥，连下⻋ 的机会都没有。\"></a>那段时间急诊科的状况，经历过的⼈⼀辈⼦都忘不了，甚⾄会颠覆你的所有⼈⽣ 观。如果说这是打仗，急诊科就在最前线。但当时的情况是，后⾯的病区已经饱和了， 基本上⼀个病⼈都不收，ICU 也坚决不收，说⾥⾯有⼲净的病⼈，⼀进去就污染 了。病⼈不断地往急诊科涌，后⾯的路⼜不通，就全部堆在急诊科。病⼈来看病， ⼀排队随便就是⼏个⼩时，我们也完全没法下班，发热⻔诊和急诊也都不分了，⼤ 厅⾥堆满了病⼈，抢救室输液室⾥到处都是病⼈。 还有的病⼈家属来了，说要⼀张床，我的爸爸在汽⻋⾥⾯不⾏了，因为那时候地下 ⻋库已封，他⻋⼦也堵着开不进来。我没办法，带着⼈和设备跑去汽⻋⾥去，⼀ 看，⼈已经死了，你说是什么感受，很难受很难受。这个⼈就死在汽⻋⾥，连下⻋ 的机会都没有。</h5><h5 id=\"还有⼀位⽼⼈，⽼伴刚在⾦银潭医院去世了，她的⼉⼦、⼥⼉都被感染了，在打-针，照顾她的是⼥婿，⼀来我看她病得⾮常重，联系呼吸科给收进去住院，她⼥婿-⼀看就是个有⽂化有素质的⼈，过来跟我说谢谢医⽣等等的，我⼼⾥⼀紧，说快-去，根本耽误不了了。结果送去就去世了。⼀句谢谢虽然⼏秒钟，但也耽误了⼏-秒。这句谢谢压得我很沉重。-还有很多⼈把⾃⼰的家⼈送到监护室的时候，就是他们⻅的最后⼀⾯，你永远⻅不-着了。\"><a href=\"#还有⼀位⽼⼈，⽼伴刚在⾦银潭医院去世了，她的⼉⼦、⼥⼉都被感染了，在打-针，照顾她的是⼥婿，⼀来我看她病得⾮常重，联系呼吸科给收进去住院，她⼥婿-⼀看就是个有⽂化有素质的⼈，过来跟我说谢谢医⽣等等的，我⼼⾥⼀紧，说快-去，根本耽误不了了。结果送去就去世了。⼀句谢谢虽然⼏秒钟，但也耽误了⼏-秒。这句谢谢压得我很沉重。-还有很多⼈把⾃⼰的家⼈送到监护室的时候，就是他们⻅的最后⼀⾯，你永远⻅不-着了。\" class=\"headerlink\" title=\"还有⼀位⽼⼈，⽼伴刚在⾦银潭医院去世了，她的⼉⼦、⼥⼉都被感染了，在打 针，照顾她的是⼥婿，⼀来我看她病得⾮常重，联系呼吸科给收进去住院，她⼥婿 ⼀看就是个有⽂化有素质的⼈，过来跟我说谢谢医⽣等等的，我⼼⾥⼀紧，说快 去，根本耽误不了了。结果送去就去世了。⼀句谢谢虽然⼏秒钟，但也耽误了⼏ 秒。这句谢谢压得我很沉重。 还有很多⼈把⾃⼰的家⼈送到监护室的时候，就是他们⻅的最后⼀⾯，你永远⻅不 着了。\"></a>还有⼀位⽼⼈，⽼伴刚在⾦银潭医院去世了，她的⼉⼦、⼥⼉都被感染了，在打 针，照顾她的是⼥婿，⼀来我看她病得⾮常重，联系呼吸科给收进去住院，她⼥婿 ⼀看就是个有⽂化有素质的⼈，过来跟我说谢谢医⽣等等的，我⼼⾥⼀紧，说快 去，根本耽误不了了。结果送去就去世了。⼀句谢谢虽然⼏秒钟，但也耽误了⼏ 秒。这句谢谢压得我很沉重。 还有很多⼈把⾃⼰的家⼈送到监护室的时候，就是他们⻅的最后⼀⾯，你永远⻅不 着了。</h5><h5 id=\"我记得⼤年三⼗的早上我来交班，我说我们来照个相，纪念⼀下这个⼤年三⼗，还-发了个朋友圈。那天，⼤家都没有说什么祝福，这种时候，活着就是好的。\"><a href=\"#我记得⼤年三⼗的早上我来交班，我说我们来照个相，纪念⼀下这个⼤年三⼗，还-发了个朋友圈。那天，⼤家都没有说什么祝福，这种时候，活着就是好的。\" class=\"headerlink\" title=\"我记得⼤年三⼗的早上我来交班，我说我们来照个相，纪念⼀下这个⼤年三⼗，还 发了个朋友圈。那天，⼤家都没有说什么祝福，这种时候，活着就是好的。\"></a>我记得⼤年三⼗的早上我来交班，我说我们来照个相，纪念⼀下这个⼤年三⼗，还 发了个朋友圈。那天，⼤家都没有说什么祝福，这种时候，活着就是好的。</h5><h5 id=\"以前，你如果有⼀点失误，⽐如没有及时打针，病⼈都可能还去闹，现在没⼈了，-没有⼈跟你吵，没有⼈跟你闹了，所有⼈都被这种突然来的打击击垮了，搞蒙了。-病⼈死了，很少看到家属有很伤⼼地哭的，因为太多了，太多了。有些家属也不会-说医⽣求求你救救我的家⼈，⽽是跟医⽣说，唉，那就快点解脱吧，已经到了这个-地步。因为这时候每个⼈怕的都是⾃⼰被感染。\"><a href=\"#以前，你如果有⼀点失误，⽐如没有及时打针，病⼈都可能还去闹，现在没⼈了，-没有⼈跟你吵，没有⼈跟你闹了，所有⼈都被这种突然来的打击击垮了，搞蒙了。-病⼈死了，很少看到家属有很伤⼼地哭的，因为太多了，太多了。有些家属也不会-说医⽣求求你救救我的家⼈，⽽是跟医⽣说，唉，那就快点解脱吧，已经到了这个-地步。因为这时候每个⼈怕的都是⾃⼰被感染。\" class=\"headerlink\" title=\"以前，你如果有⼀点失误，⽐如没有及时打针，病⼈都可能还去闹，现在没⼈了， 没有⼈跟你吵，没有⼈跟你闹了，所有⼈都被这种突然来的打击击垮了，搞蒙了。 病⼈死了，很少看到家属有很伤⼼地哭的，因为太多了，太多了。有些家属也不会 说医⽣求求你救救我的家⼈，⽽是跟医⽣说，唉，那就快点解脱吧，已经到了这个 地步。因为这时候每个⼈怕的都是⾃⼰被感染。\"></a>以前，你如果有⼀点失误，⽐如没有及时打针，病⼈都可能还去闹，现在没⼈了， 没有⼈跟你吵，没有⼈跟你闹了，所有⼈都被这种突然来的打击击垮了，搞蒙了。 病⼈死了，很少看到家属有很伤⼼地哭的，因为太多了，太多了。有些家属也不会 说医⽣求求你救救我的家⼈，⽽是跟医⽣说，唉，那就快点解脱吧，已经到了这个 地步。因为这时候每个⼈怕的都是⾃⼰被感染。</h5><h5 id=\"⼀天发热⻔诊⻔⼝的排队，要排-5-个⼩时。正排着⼀个⼥的倒下了，看她穿着⽪-⾐，背着包包，穿着⾼跟鞋，应该是很讲究的⼀个中年⼥性，可是没有⼈敢上前去-扶她，就在地上躺了很久。只得我去喊护⼠、医⽣来去扶她。-1-⽉-30-号我早上来上班，⼀个⽩发⽼⼈的⼉⼦-32-岁死了，他就盯着看医⽣给他开死-亡证明。根本没有眼泪，怎么哭？没办法哭。看他的打扮，可能就是⼀个外来的打-⼯的，没有任何渠道去反映。没有确诊，他的⼉⼦，就变成了⼀张死亡证明。-这也是我想要去呼吁⼀下的。在急诊科死亡的病⼈都是没有诊断、没办法确诊的病-例，等这个疫情过去之后，我希望能给他们⼀个交代，给他们的家庭⼀些安抚，我-们的病⼈很可怜的，很可怜。\"><a href=\"#⼀天发热⻔诊⻔⼝的排队，要排-5-个⼩时。正排着⼀个⼥的倒下了，看她穿着⽪-⾐，背着包包，穿着⾼跟鞋，应该是很讲究的⼀个中年⼥性，可是没有⼈敢上前去-扶她，就在地上躺了很久。只得我去喊护⼠、医⽣来去扶她。-1-⽉-30-号我早上来上班，⼀个⽩发⽼⼈的⼉⼦-32-岁死了，他就盯着看医⽣给他开死-亡证明。根本没有眼泪，怎么哭？没办法哭。看他的打扮，可能就是⼀个外来的打-⼯的，没有任何渠道去反映。没有确诊，他的⼉⼦，就变成了⼀张死亡证明。-这也是我想要去呼吁⼀下的。在急诊科死亡的病⼈都是没有诊断、没办法确诊的病-例，等这个疫情过去之后，我希望能给他们⼀个交代，给他们的家庭⼀些安抚，我-们的病⼈很可怜的，很可怜。\" class=\"headerlink\" title=\"⼀天发热⻔诊⻔⼝的排队，要排 5 个⼩时。正排着⼀个⼥的倒下了，看她穿着⽪ ⾐，背着包包，穿着⾼跟鞋，应该是很讲究的⼀个中年⼥性，可是没有⼈敢上前去 扶她，就在地上躺了很久。只得我去喊护⼠、医⽣来去扶她。 1 ⽉ 30 号我早上来上班，⼀个⽩发⽼⼈的⼉⼦ 32 岁死了，他就盯着看医⽣给他开死 亡证明。根本没有眼泪，怎么哭？没办法哭。看他的打扮，可能就是⼀个外来的打 ⼯的，没有任何渠道去反映。没有确诊，他的⼉⼦，就变成了⼀张死亡证明。 这也是我想要去呼吁⼀下的。在急诊科死亡的病⼈都是没有诊断、没办法确诊的病 例，等这个疫情过去之后，我希望能给他们⼀个交代，给他们的家庭⼀些安抚，我 们的病⼈很可怜的，很可怜。\"></a>⼀天发热⻔诊⻔⼝的排队，要排 5 个⼩时。正排着⼀个⼥的倒下了，看她穿着⽪ ⾐，背着包包，穿着⾼跟鞋，应该是很讲究的⼀个中年⼥性，可是没有⼈敢上前去 扶她，就在地上躺了很久。只得我去喊护⼠、医⽣来去扶她。 1 ⽉ 30 号我早上来上班，⼀个⽩发⽼⼈的⼉⼦ 32 岁死了，他就盯着看医⽣给他开死 亡证明。根本没有眼泪，怎么哭？没办法哭。看他的打扮，可能就是⼀个外来的打 ⼯的，没有任何渠道去反映。没有确诊，他的⼉⼦，就变成了⼀张死亡证明。 这也是我想要去呼吁⼀下的。在急诊科死亡的病⼈都是没有诊断、没办法确诊的病 例，等这个疫情过去之后，我希望能给他们⼀个交代，给他们的家庭⼀些安抚，我 们的病⼈很可怜的，很可怜。</h5><h2 id=\"「幸运」\"><a href=\"#「幸运」\" class=\"headerlink\" title=\"「幸运」\"></a>「幸运」</h2><h5 id=\"做了这么多年医⽣，我⼀直觉得没有什么困难能够打倒我，这也和我的经历、个性-有关。\"><a href=\"#做了这么多年医⽣，我⼀直觉得没有什么困难能够打倒我，这也和我的经历、个性-有关。\" class=\"headerlink\" title=\"做了这么多年医⽣，我⼀直觉得没有什么困难能够打倒我，这也和我的经历、个性 有关。\"></a>做了这么多年医⽣，我⼀直觉得没有什么困难能够打倒我，这也和我的经历、个性 有关。</h5><h5 id=\"9-岁那年我爸爸就胃癌去世了，那个时候我就想着⻓⼤了当个医⽣去救别⼈的命。-后来⾼考的时候，我的志愿填的全部都是医学专业，最后考取了同济医学院。1997-年我⼤学毕业，就到了中⼼医院，之前在⼼⾎管内科⼯作，2010-年到急诊科当主任-的。我觉得急诊科就像我的⼀个孩⼦⼀样，我把它搞成这么⼤，搞得⼤家团结起来，做-成这个局⾯不容易，所以很珍惜，⾮常珍惜这个集体。\"><a href=\"#9-岁那年我爸爸就胃癌去世了，那个时候我就想着⻓⼤了当个医⽣去救别⼈的命。-后来⾼考的时候，我的志愿填的全部都是医学专业，最后考取了同济医学院。1997-年我⼤学毕业，就到了中⼼医院，之前在⼼⾎管内科⼯作，2010-年到急诊科当主任-的。我觉得急诊科就像我的⼀个孩⼦⼀样，我把它搞成这么⼤，搞得⼤家团结起来，做-成这个局⾯不容易，所以很珍惜，⾮常珍惜这个集体。\" class=\"headerlink\" title=\"9 岁那年我爸爸就胃癌去世了，那个时候我就想着⻓⼤了当个医⽣去救别⼈的命。 后来⾼考的时候，我的志愿填的全部都是医学专业，最后考取了同济医学院。1997 年我⼤学毕业，就到了中⼼医院，之前在⼼⾎管内科⼯作，2010 年到急诊科当主任 的。我觉得急诊科就像我的⼀个孩⼦⼀样，我把它搞成这么⼤，搞得⼤家团结起来，做 成这个局⾯不容易，所以很珍惜，⾮常珍惜这个集体。\"></a>9 岁那年我爸爸就胃癌去世了，那个时候我就想着⻓⼤了当个医⽣去救别⼈的命。 后来⾼考的时候，我的志愿填的全部都是医学专业，最后考取了同济医学院。1997 年我⼤学毕业，就到了中⼼医院，之前在⼼⾎管内科⼯作，2010 年到急诊科当主任 的。我觉得急诊科就像我的⼀个孩⼦⼀样，我把它搞成这么⼤，搞得⼤家团结起来，做 成这个局⾯不容易，所以很珍惜，⾮常珍惜这个集体。</h5><h5 id=\"前⼏天，我的⼀个护⼠发朋友圈说，好怀念以前忙碌的⼤急诊，那种忙跟这种忙完-全是两个概念。-在这次疫情之前，⼼梗、脑梗、消化道出⾎、外伤等等这些才是我们急诊的范畴。-那种忙是有成就感的忙，⽬的明确，针对各种类型的病⼈都有很通畅的流程，很成-熟，下⼀步⼲什么，怎么做，出了问题找哪⼀个。⽽这⼀次是这么多危重病⼈没办-法去处理，没办法收住院，⽽且我们医务⼈员还在这种⻛险之中，这种忙真的很⽆-奈，很痛⼼。\"><a href=\"#前⼏天，我的⼀个护⼠发朋友圈说，好怀念以前忙碌的⼤急诊，那种忙跟这种忙完-全是两个概念。-在这次疫情之前，⼼梗、脑梗、消化道出⾎、外伤等等这些才是我们急诊的范畴。-那种忙是有成就感的忙，⽬的明确，针对各种类型的病⼈都有很通畅的流程，很成-熟，下⼀步⼲什么，怎么做，出了问题找哪⼀个。⽽这⼀次是这么多危重病⼈没办-法去处理，没办法收住院，⽽且我们医务⼈员还在这种⻛险之中，这种忙真的很⽆-奈，很痛⼼。\" class=\"headerlink\" title=\"前⼏天，我的⼀个护⼠发朋友圈说，好怀念以前忙碌的⼤急诊，那种忙跟这种忙完 全是两个概念。 在这次疫情之前，⼼梗、脑梗、消化道出⾎、外伤等等这些才是我们急诊的范畴。 那种忙是有成就感的忙，⽬的明确，针对各种类型的病⼈都有很通畅的流程，很成 熟，下⼀步⼲什么，怎么做，出了问题找哪⼀个。⽽这⼀次是这么多危重病⼈没办 法去处理，没办法收住院，⽽且我们医务⼈员还在这种⻛险之中，这种忙真的很⽆ 奈，很痛⼼。\"></a>前⼏天，我的⼀个护⼠发朋友圈说，好怀念以前忙碌的⼤急诊，那种忙跟这种忙完 全是两个概念。 在这次疫情之前，⼼梗、脑梗、消化道出⾎、外伤等等这些才是我们急诊的范畴。 那种忙是有成就感的忙，⽬的明确，针对各种类型的病⼈都有很通畅的流程，很成 熟，下⼀步⼲什么，怎么做，出了问题找哪⼀个。⽽这⼀次是这么多危重病⼈没办 法去处理，没办法收住院，⽽且我们医务⼈员还在这种⻛险之中，这种忙真的很⽆ 奈，很痛⼼。</h5><h5 id=\"有⼀天早上-8-点，我们科⼀个年轻医⽣跟我发微信，也是蛮有性格的，说我今天不-来上班了，不舒服。因为我们这⾥都有规矩的，你不舒服要提前跟我说好安排，你-到-8-点钟跟我说，我到哪⾥去找⼈。他在微信中对我发脾⽓，说⼤量的⾼度疑似病例被你领导的急诊科放回社会，我们这是作孽！我理解他是因为作为医⽣的良知，-但我也急了，我说你可以去告我，如果你是急诊科主任，你该怎么办？-后来，这个医⽣休息了⼏天后，还是照样来⼯作。他不是说怕死怕累，⽽是遇到这-种情况，⼀下⼦⾯对这么多病⼈感到很崩溃。\"><a href=\"#有⼀天早上-8-点，我们科⼀个年轻医⽣跟我发微信，也是蛮有性格的，说我今天不-来上班了，不舒服。因为我们这⾥都有规矩的，你不舒服要提前跟我说好安排，你-到-8-点钟跟我说，我到哪⾥去找⼈。他在微信中对我发脾⽓，说⼤量的⾼度疑似病例被你领导的急诊科放回社会，我们这是作孽！我理解他是因为作为医⽣的良知，-但我也急了，我说你可以去告我，如果你是急诊科主任，你该怎么办？-后来，这个医⽣休息了⼏天后，还是照样来⼯作。他不是说怕死怕累，⽽是遇到这-种情况，⼀下⼦⾯对这么多病⼈感到很崩溃。\" class=\"headerlink\" title=\"有⼀天早上 8 点，我们科⼀个年轻医⽣跟我发微信，也是蛮有性格的，说我今天不 来上班了，不舒服。因为我们这⾥都有规矩的，你不舒服要提前跟我说好安排，你 到 8 点钟跟我说，我到哪⾥去找⼈。他在微信中对我发脾⽓，说⼤量的⾼度疑似病例被你领导的急诊科放回社会，我们这是作孽！我理解他是因为作为医⽣的良知， 但我也急了，我说你可以去告我，如果你是急诊科主任，你该怎么办？ 后来，这个医⽣休息了⼏天后，还是照样来⼯作。他不是说怕死怕累，⽽是遇到这 种情况，⼀下⼦⾯对这么多病⼈感到很崩溃。\"></a>有⼀天早上 8 点，我们科⼀个年轻医⽣跟我发微信，也是蛮有性格的，说我今天不 来上班了，不舒服。因为我们这⾥都有规矩的，你不舒服要提前跟我说好安排，你 到 8 点钟跟我说，我到哪⾥去找⼈。他在微信中对我发脾⽓，说⼤量的⾼度疑似病例被你领导的急诊科放回社会，我们这是作孽！我理解他是因为作为医⽣的良知， 但我也急了，我说你可以去告我，如果你是急诊科主任，你该怎么办？ 后来，这个医⽣休息了⼏天后，还是照样来⼯作。他不是说怕死怕累，⽽是遇到这 种情况，⼀下⼦⾯对这么多病⼈感到很崩溃。</h5><h5 id=\"作为医⽣来说，特别是后⾯很多来⽀援的医⽣，根本⼼理上受不了，碰到这种情况-懵了，有的医⽣、护⼠就哭。⼀个是哭别⼈，再⼀个也是哭⾃⼰，因为每个⼈都不-知道什么时候就轮到⾃⼰感染。-⼤概在-1-⽉中下旬，医院的领导也陆陆续续地都病倒了，包括我们的⻔办主任，三-位副院⻓。医务科科⻓的⼥⼉也病了，他也在家⾥休息。所以基本上那⼀段时间是-没有⼈管你，你就在那⼉战⽃吧，就是那种感觉。\"><a href=\"#作为医⽣来说，特别是后⾯很多来⽀援的医⽣，根本⼼理上受不了，碰到这种情况-懵了，有的医⽣、护⼠就哭。⼀个是哭别⼈，再⼀个也是哭⾃⼰，因为每个⼈都不-知道什么时候就轮到⾃⼰感染。-⼤概在-1-⽉中下旬，医院的领导也陆陆续续地都病倒了，包括我们的⻔办主任，三-位副院⻓。医务科科⻓的⼥⼉也病了，他也在家⾥休息。所以基本上那⼀段时间是-没有⼈管你，你就在那⼉战⽃吧，就是那种感觉。\" class=\"headerlink\" title=\"作为医⽣来说，特别是后⾯很多来⽀援的医⽣，根本⼼理上受不了，碰到这种情况 懵了，有的医⽣、护⼠就哭。⼀个是哭别⼈，再⼀个也是哭⾃⼰，因为每个⼈都不 知道什么时候就轮到⾃⼰感染。 ⼤概在 1 ⽉中下旬，医院的领导也陆陆续续地都病倒了，包括我们的⻔办主任，三 位副院⻓。医务科科⻓的⼥⼉也病了，他也在家⾥休息。所以基本上那⼀段时间是 没有⼈管你，你就在那⼉战⽃吧，就是那种感觉。\"></a>作为医⽣来说，特别是后⾯很多来⽀援的医⽣，根本⼼理上受不了，碰到这种情况 懵了，有的医⽣、护⼠就哭。⼀个是哭别⼈，再⼀个也是哭⾃⼰，因为每个⼈都不 知道什么时候就轮到⾃⼰感染。 ⼤概在 1 ⽉中下旬，医院的领导也陆陆续续地都病倒了，包括我们的⻔办主任，三 位副院⻓。医务科科⻓的⼥⼉也病了，他也在家⾥休息。所以基本上那⼀段时间是 没有⼈管你，你就在那⼉战⽃吧，就是那种感觉。</h5><h5 id=\"我身边的⼈也开始⼀个接⼀个地倒掉。1-⽉-18-⽇，早上-8-点半，我们倒的第⼀个医-⽣，他说主任我中招了，不烧，只做了-CT，肺部⼀⼤坨磨玻璃。不⼀会⼉，隔离病-房负责的⼀个责任护⼠，告诉我说他也倒了。晚上，我们的护⼠⻓也倒了。我当时-⾮常真实的第⼀感觉是——幸运，因为倒得早，可以早点下战场。\"><a href=\"#我身边的⼈也开始⼀个接⼀个地倒掉。1-⽉-18-⽇，早上-8-点半，我们倒的第⼀个医-⽣，他说主任我中招了，不烧，只做了-CT，肺部⼀⼤坨磨玻璃。不⼀会⼉，隔离病-房负责的⼀个责任护⼠，告诉我说他也倒了。晚上，我们的护⼠⻓也倒了。我当时-⾮常真实的第⼀感觉是——幸运，因为倒得早，可以早点下战场。\" class=\"headerlink\" title=\"我身边的⼈也开始⼀个接⼀个地倒掉。1 ⽉ 18 ⽇，早上 8 点半，我们倒的第⼀个医 ⽣，他说主任我中招了，不烧，只做了 CT，肺部⼀⼤坨磨玻璃。不⼀会⼉，隔离病 房负责的⼀个责任护⼠，告诉我说他也倒了。晚上，我们的护⼠⻓也倒了。我当时 ⾮常真实的第⼀感觉是——幸运，因为倒得早，可以早点下战场。\"></a>我身边的⼈也开始⼀个接⼀个地倒掉。1 ⽉ 18 ⽇，早上 8 点半，我们倒的第⼀个医 ⽣，他说主任我中招了，不烧，只做了 CT，肺部⼀⼤坨磨玻璃。不⼀会⼉，隔离病 房负责的⼀个责任护⼠，告诉我说他也倒了。晚上，我们的护⼠⻓也倒了。我当时 ⾮常真实的第⼀感觉是——幸运，因为倒得早，可以早点下战场。</h5><h5 id=\"这三个⼈我都密切接触过，我就是抱着必倒的信念每天在⼯作，结果⼀直没倒。全-院的⼈都觉得我是个奇迹。我⾃⼰分析了⼀下，可能是因为我本身有哮喘，在⽤⼀-些吸⼊性的激素，可能会抑制这些病毒在肺内沉积。-我总觉得我们做急诊的⼈都算是有情怀的⼈——在中国的医院，急诊科的地位在所-有科室当中应该是⽐较低的，因为⼤家觉得急诊，⽆⾮就是个通道，把病⼈收进去-就⾏了。这次抗疫中，这种忽视也⼀直都存在。\"><a href=\"#这三个⼈我都密切接触过，我就是抱着必倒的信念每天在⼯作，结果⼀直没倒。全-院的⼈都觉得我是个奇迹。我⾃⼰分析了⼀下，可能是因为我本身有哮喘，在⽤⼀-些吸⼊性的激素，可能会抑制这些病毒在肺内沉积。-我总觉得我们做急诊的⼈都算是有情怀的⼈——在中国的医院，急诊科的地位在所-有科室当中应该是⽐较低的，因为⼤家觉得急诊，⽆⾮就是个通道，把病⼈收进去-就⾏了。这次抗疫中，这种忽视也⼀直都存在。\" class=\"headerlink\" title=\"这三个⼈我都密切接触过，我就是抱着必倒的信念每天在⼯作，结果⼀直没倒。全 院的⼈都觉得我是个奇迹。我⾃⼰分析了⼀下，可能是因为我本身有哮喘，在⽤⼀ 些吸⼊性的激素，可能会抑制这些病毒在肺内沉积。 我总觉得我们做急诊的⼈都算是有情怀的⼈——在中国的医院，急诊科的地位在所 有科室当中应该是⽐较低的，因为⼤家觉得急诊，⽆⾮就是个通道，把病⼈收进去 就⾏了。这次抗疫中，这种忽视也⼀直都存在。\"></a>这三个⼈我都密切接触过，我就是抱着必倒的信念每天在⼯作，结果⼀直没倒。全 院的⼈都觉得我是个奇迹。我⾃⼰分析了⼀下，可能是因为我本身有哮喘，在⽤⼀ 些吸⼊性的激素，可能会抑制这些病毒在肺内沉积。 我总觉得我们做急诊的⼈都算是有情怀的⼈——在中国的医院，急诊科的地位在所 有科室当中应该是⽐较低的，因为⼤家觉得急诊，⽆⾮就是个通道，把病⼈收进去 就⾏了。这次抗疫中，这种忽视也⼀直都存在。</h5><h5 id=\"早期的时候，物资不够，有时候分给急诊科的防护服质量⾮常差，看到我们的护⼠-竟然穿着这种⾐服上班，我很⽣⽓，在周会群⾥⾯发脾⽓。后来还是好多主任把他-们⾃⼰科室藏的⾐服都给我了。-还有吃饭问题。病⼈多的时候管理混乱，他们根本想不到急诊科还差东⻄吃，很多-科室下班了都有吃的喝的，摆⼀⼤排，我们这⾥什么都没有，发热⻔诊的微信群-⾥，有医⽣抱怨，「我们急诊科只有纸尿裤……」我们在最前线战⽃，结果是这-样，有时候⼼⾥真的很⽓。\"><a href=\"#早期的时候，物资不够，有时候分给急诊科的防护服质量⾮常差，看到我们的护⼠-竟然穿着这种⾐服上班，我很⽣⽓，在周会群⾥⾯发脾⽓。后来还是好多主任把他-们⾃⼰科室藏的⾐服都给我了。-还有吃饭问题。病⼈多的时候管理混乱，他们根本想不到急诊科还差东⻄吃，很多-科室下班了都有吃的喝的，摆⼀⼤排，我们这⾥什么都没有，发热⻔诊的微信群-⾥，有医⽣抱怨，「我们急诊科只有纸尿裤……」我们在最前线战⽃，结果是这-样，有时候⼼⾥真的很⽓。\" class=\"headerlink\" title=\"早期的时候，物资不够，有时候分给急诊科的防护服质量⾮常差，看到我们的护⼠ 竟然穿着这种⾐服上班，我很⽣⽓，在周会群⾥⾯发脾⽓。后来还是好多主任把他 们⾃⼰科室藏的⾐服都给我了。 还有吃饭问题。病⼈多的时候管理混乱，他们根本想不到急诊科还差东⻄吃，很多 科室下班了都有吃的喝的，摆⼀⼤排，我们这⾥什么都没有，发热⻔诊的微信群 ⾥，有医⽣抱怨，「我们急诊科只有纸尿裤……」我们在最前线战⽃，结果是这 样，有时候⼼⾥真的很⽓。\"></a>早期的时候，物资不够，有时候分给急诊科的防护服质量⾮常差，看到我们的护⼠ 竟然穿着这种⾐服上班，我很⽣⽓，在周会群⾥⾯发脾⽓。后来还是好多主任把他 们⾃⼰科室藏的⾐服都给我了。 还有吃饭问题。病⼈多的时候管理混乱，他们根本想不到急诊科还差东⻄吃，很多 科室下班了都有吃的喝的，摆⼀⼤排，我们这⾥什么都没有，发热⻔诊的微信群 ⾥，有医⽣抱怨，「我们急诊科只有纸尿裤……」我们在最前线战⽃，结果是这 样，有时候⼼⾥真的很⽓。</h5><h5 id=\"我们这个集体真的是很好，⼤家都是只有⽣病了才下⽕线。这次，我们急诊科有-40-多个⼈感染了。我把所有⽣病的⼈建了⼀个群，本来叫「急诊⽣病群」，护⼠⻓说不吉利，改成「急诊加油群」。就是⽣病的⼈也没有很悲伤、很绝望、很抱怨的⼼-态，都是蛮积极的，就是⼤家互相帮助，共度难关那种⼼态。-这些孩⼦们、年轻⼈都⾮常好，就是跟着我受委屈了。我也希望这次疫情过后，国-家能加⼤对急诊科的投⼊，在很多国家的医疗体系中，急诊专业都是⾮常受重视-的。\"><a href=\"#我们这个集体真的是很好，⼤家都是只有⽣病了才下⽕线。这次，我们急诊科有-40-多个⼈感染了。我把所有⽣病的⼈建了⼀个群，本来叫「急诊⽣病群」，护⼠⻓说不吉利，改成「急诊加油群」。就是⽣病的⼈也没有很悲伤、很绝望、很抱怨的⼼-态，都是蛮积极的，就是⼤家互相帮助，共度难关那种⼼态。-这些孩⼦们、年轻⼈都⾮常好，就是跟着我受委屈了。我也希望这次疫情过后，国-家能加⼤对急诊科的投⼊，在很多国家的医疗体系中，急诊专业都是⾮常受重视-的。\" class=\"headerlink\" title=\"我们这个集体真的是很好，⼤家都是只有⽣病了才下⽕线。这次，我们急诊科有 40 多个⼈感染了。我把所有⽣病的⼈建了⼀个群，本来叫「急诊⽣病群」，护⼠⻓说不吉利，改成「急诊加油群」。就是⽣病的⼈也没有很悲伤、很绝望、很抱怨的⼼ 态，都是蛮积极的，就是⼤家互相帮助，共度难关那种⼼态。 这些孩⼦们、年轻⼈都⾮常好，就是跟着我受委屈了。我也希望这次疫情过后，国 家能加⼤对急诊科的投⼊，在很多国家的医疗体系中，急诊专业都是⾮常受重视 的。\"></a>我们这个集体真的是很好，⼤家都是只有⽣病了才下⽕线。这次，我们急诊科有 40 多个⼈感染了。我把所有⽣病的⼈建了⼀个群，本来叫「急诊⽣病群」，护⼠⻓说不吉利，改成「急诊加油群」。就是⽣病的⼈也没有很悲伤、很绝望、很抱怨的⼼ 态，都是蛮积极的，就是⼤家互相帮助，共度难关那种⼼态。 这些孩⼦们、年轻⼈都⾮常好，就是跟着我受委屈了。我也希望这次疫情过后，国 家能加⼤对急诊科的投⼊，在很多国家的医疗体系中，急诊专业都是⾮常受重视 的。</h5><p><img src=\"https://s1.ax1x.com/2020/03/12/8m0Ul8.png\" alt=\"8m0Ul8.png\"></p>\n<h2 id=\"不能达到的幸福\"><a href=\"#不能达到的幸福\" class=\"headerlink\" title=\"不能达到的幸福\"></a>不能达到的幸福</h2><h5 id=\"2-⽉-17-号，我收到了⼀条微信，是那个同济医院的同学发给我的，他跟我说「对不-起」，我说：幸好你传出去了，及时提醒了⼀部分⼈。他如果不传出去的话，可能-就没有李⽂亮他们这-8-个⼈，知道的⼈可能就会更少。\"><a href=\"#2-⽉-17-号，我收到了⼀条微信，是那个同济医院的同学发给我的，他跟我说「对不-起」，我说：幸好你传出去了，及时提醒了⼀部分⼈。他如果不传出去的话，可能-就没有李⽂亮他们这-8-个⼈，知道的⼈可能就会更少。\" class=\"headerlink\" title=\"2 ⽉ 17 号，我收到了⼀条微信，是那个同济医院的同学发给我的，他跟我说「对不 起」，我说：幸好你传出去了，及时提醒了⼀部分⼈。他如果不传出去的话，可能 就没有李⽂亮他们这 8 个⼈，知道的⼈可能就会更少。\"></a>2 ⽉ 17 号，我收到了⼀条微信，是那个同济医院的同学发给我的，他跟我说「对不 起」，我说：幸好你传出去了，及时提醒了⼀部分⼈。他如果不传出去的话，可能 就没有李⽂亮他们这 8 个⼈，知道的⼈可能就会更少。</h5><h5 id=\"这次，我们有三个⼥医⽣全家感染。两个⼥医⽣的公公、婆婆加⽼公感染，⼀个⼥-医⽣的爸爸、妈妈、姐姐、⽼公，加她⾃⼰-5-个⼈感染。⼤家都觉得这么早就发现-这个病毒，结果却是这样，造成这么⼤的损失，代价太惨重了。-这种代价体现在⽅⽅⾯⾯。除了去世的⼈，患病的⼈也在承受。-我们「急诊加油群」⾥，⼤家经常会交流身体状况，有⼈问⼼率总在-120-次-分，要-不要紧？那肯定要紧，⼀动就⼼慌，这对他们终身都会有影响的，以后年纪⼤了会不会⼼衰？这都不好说。以后别⼈可以去爬⼭，出去旅游，他们可能就不⾏，那都是有可能的。\"><a href=\"#这次，我们有三个⼥医⽣全家感染。两个⼥医⽣的公公、婆婆加⽼公感染，⼀个⼥-医⽣的爸爸、妈妈、姐姐、⽼公，加她⾃⼰-5-个⼈感染。⼤家都觉得这么早就发现-这个病毒，结果却是这样，造成这么⼤的损失，代价太惨重了。-这种代价体现在⽅⽅⾯⾯。除了去世的⼈，患病的⼈也在承受。-我们「急诊加油群」⾥，⼤家经常会交流身体状况，有⼈问⼼率总在-120-次-分，要-不要紧？那肯定要紧，⼀动就⼼慌，这对他们终身都会有影响的，以后年纪⼤了会不会⼼衰？这都不好说。以后别⼈可以去爬⼭，出去旅游，他们可能就不⾏，那都是有可能的。\" class=\"headerlink\" title=\"这次，我们有三个⼥医⽣全家感染。两个⼥医⽣的公公、婆婆加⽼公感染，⼀个⼥ 医⽣的爸爸、妈妈、姐姐、⽼公，加她⾃⼰ 5 个⼈感染。⼤家都觉得这么早就发现 这个病毒，结果却是这样，造成这么⼤的损失，代价太惨重了。 这种代价体现在⽅⽅⾯⾯。除了去世的⼈，患病的⼈也在承受。 我们「急诊加油群」⾥，⼤家经常会交流身体状况，有⼈问⼼率总在 120 次/分，要 不要紧？那肯定要紧，⼀动就⼼慌，这对他们终身都会有影响的，以后年纪⼤了会不会⼼衰？这都不好说。以后别⼈可以去爬⼭，出去旅游，他们可能就不⾏，那都是有可能的。\"></a>这次，我们有三个⼥医⽣全家感染。两个⼥医⽣的公公、婆婆加⽼公感染，⼀个⼥ 医⽣的爸爸、妈妈、姐姐、⽼公，加她⾃⼰ 5 个⼈感染。⼤家都觉得这么早就发现 这个病毒，结果却是这样，造成这么⼤的损失，代价太惨重了。 这种代价体现在⽅⽅⾯⾯。除了去世的⼈，患病的⼈也在承受。 我们「急诊加油群」⾥，⼤家经常会交流身体状况，有⼈问⼼率总在 120 次/分，要 不要紧？那肯定要紧，⼀动就⼼慌，这对他们终身都会有影响的，以后年纪⼤了会不会⼼衰？这都不好说。以后别⼈可以去爬⼭，出去旅游，他们可能就不⾏，那都是有可能的。</h5><h5 id=\"还有武汉。你说我们武汉是个多热闹的地⽅，现在⼀路上都是安安静静的，很多东-⻄买不到，还搞得全国都来⽀援。前⼏天⼴⻄的⼀个医疗队的护⼠在⼯作的时候突-然昏迷了，抢救，后来⼈⼼跳有了，但还是在昏迷。她如果不来的话，在家⾥可以-过得好好的，也不会出这种意外。所以，我觉得我们⽋⼤家的⼈情，真的是。\"><a href=\"#还有武汉。你说我们武汉是个多热闹的地⽅，现在⼀路上都是安安静静的，很多东-⻄买不到，还搞得全国都来⽀援。前⼏天⼴⻄的⼀个医疗队的护⼠在⼯作的时候突-然昏迷了，抢救，后来⼈⼼跳有了，但还是在昏迷。她如果不来的话，在家⾥可以-过得好好的，也不会出这种意外。所以，我觉得我们⽋⼤家的⼈情，真的是。\" class=\"headerlink\" title=\"还有武汉。你说我们武汉是个多热闹的地⽅，现在⼀路上都是安安静静的，很多东 ⻄买不到，还搞得全国都来⽀援。前⼏天⼴⻄的⼀个医疗队的护⼠在⼯作的时候突 然昏迷了，抢救，后来⼈⼼跳有了，但还是在昏迷。她如果不来的话，在家⾥可以 过得好好的，也不会出这种意外。所以，我觉得我们⽋⼤家的⼈情，真的是。\"></a>还有武汉。你说我们武汉是个多热闹的地⽅，现在⼀路上都是安安静静的，很多东 ⻄买不到，还搞得全国都来⽀援。前⼏天⼴⻄的⼀个医疗队的护⼠在⼯作的时候突 然昏迷了，抢救，后来⼈⼼跳有了，但还是在昏迷。她如果不来的话，在家⾥可以 过得好好的，也不会出这种意外。所以，我觉得我们⽋⼤家的⼈情，真的是。</h5><h5 id=\"经历过这次的疫情，对医院⾥很多⼈的打击都⾮常⼤。我下⾯好⼏个医务⼈员都有-了辞职的想法，包括⼀些⻣⼲。⼤家之前对于这个职业的那些观念、常识都难免有-点动摇——就是你这么努⼒⼯作到底对不对？就像江学庆⼀样，他⼯作太认真，太-对病⼈好，每⼀年的过年过节都在做⼿术。今天有⼈发⼀个江学庆⼥⼉写的微信，-说她爸爸的时间全部给了病⼈。-我⾃⼰也有过⽆数次的念头，是不是也回到家做个家庭主妇？疫情之后，我基本上-没回家，和我⽼公住在外⾯，我妹妹在家帮我照顾孩⼦。我的⼆宝都不认得我了，-他看视频对我没感觉，我很失落，我⽣这个⼆胎不容易，出⽣的时候他有-10-⽄，妊-娠糖尿病我也得了，原本我还⼀直喂奶的，这⼀次也断了奶——做这个决定的时-候，我有点难过，我⽼公就跟我说，他说⼈的⼀⽣能够遇到⼀件这样的事情，并且-你不光是参与者，你还要带⼀个团队去打这场仗，那也是⼀件很有意义的事情，等-将来⼀切都恢复正常以后⼤家再去回忆，也是⼀个很宝贵的经历。\"><a href=\"#经历过这次的疫情，对医院⾥很多⼈的打击都⾮常⼤。我下⾯好⼏个医务⼈员都有-了辞职的想法，包括⼀些⻣⼲。⼤家之前对于这个职业的那些观念、常识都难免有-点动摇——就是你这么努⼒⼯作到底对不对？就像江学庆⼀样，他⼯作太认真，太-对病⼈好，每⼀年的过年过节都在做⼿术。今天有⼈发⼀个江学庆⼥⼉写的微信，-说她爸爸的时间全部给了病⼈。-我⾃⼰也有过⽆数次的念头，是不是也回到家做个家庭主妇？疫情之后，我基本上-没回家，和我⽼公住在外⾯，我妹妹在家帮我照顾孩⼦。我的⼆宝都不认得我了，-他看视频对我没感觉，我很失落，我⽣这个⼆胎不容易，出⽣的时候他有-10-⽄，妊-娠糖尿病我也得了，原本我还⼀直喂奶的，这⼀次也断了奶——做这个决定的时-候，我有点难过，我⽼公就跟我说，他说⼈的⼀⽣能够遇到⼀件这样的事情，并且-你不光是参与者，你还要带⼀个团队去打这场仗，那也是⼀件很有意义的事情，等-将来⼀切都恢复正常以后⼤家再去回忆，也是⼀个很宝贵的经历。\" class=\"headerlink\" title=\"经历过这次的疫情，对医院⾥很多⼈的打击都⾮常⼤。我下⾯好⼏个医务⼈员都有 了辞职的想法，包括⼀些⻣⼲。⼤家之前对于这个职业的那些观念、常识都难免有 点动摇——就是你这么努⼒⼯作到底对不对？就像江学庆⼀样，他⼯作太认真，太 对病⼈好，每⼀年的过年过节都在做⼿术。今天有⼈发⼀个江学庆⼥⼉写的微信， 说她爸爸的时间全部给了病⼈。 我⾃⼰也有过⽆数次的念头，是不是也回到家做个家庭主妇？疫情之后，我基本上 没回家，和我⽼公住在外⾯，我妹妹在家帮我照顾孩⼦。我的⼆宝都不认得我了， 他看视频对我没感觉，我很失落，我⽣这个⼆胎不容易，出⽣的时候他有 10 ⽄，妊 娠糖尿病我也得了，原本我还⼀直喂奶的，这⼀次也断了奶——做这个决定的时 候，我有点难过，我⽼公就跟我说，他说⼈的⼀⽣能够遇到⼀件这样的事情，并且 你不光是参与者，你还要带⼀个团队去打这场仗，那也是⼀件很有意义的事情，等 将来⼀切都恢复正常以后⼤家再去回忆，也是⼀个很宝贵的经历。\"></a>经历过这次的疫情，对医院⾥很多⼈的打击都⾮常⼤。我下⾯好⼏个医务⼈员都有 了辞职的想法，包括⼀些⻣⼲。⼤家之前对于这个职业的那些观念、常识都难免有 点动摇——就是你这么努⼒⼯作到底对不对？就像江学庆⼀样，他⼯作太认真，太 对病⼈好，每⼀年的过年过节都在做⼿术。今天有⼈发⼀个江学庆⼥⼉写的微信， 说她爸爸的时间全部给了病⼈。 我⾃⼰也有过⽆数次的念头，是不是也回到家做个家庭主妇？疫情之后，我基本上 没回家，和我⽼公住在外⾯，我妹妹在家帮我照顾孩⼦。我的⼆宝都不认得我了， 他看视频对我没感觉，我很失落，我⽣这个⼆胎不容易，出⽣的时候他有 10 ⽄，妊 娠糖尿病我也得了，原本我还⼀直喂奶的，这⼀次也断了奶——做这个决定的时 候，我有点难过，我⽼公就跟我说，他说⼈的⼀⽣能够遇到⼀件这样的事情，并且 你不光是参与者，你还要带⼀个团队去打这场仗，那也是⼀件很有意义的事情，等 将来⼀切都恢复正常以后⼤家再去回忆，也是⼀个很宝贵的经历。</h5><h5 id=\"2-⽉-21-号早上领导和我谈话，其实我想问⼏个问题，⽐如有没有觉得那天批评我批-评错了？我希望能够给我⼀个道歉。但是我不敢问。没有⼈在任何场合跟我说表示-抱歉这句话。但我依然觉得，这次的事情更加说明了每个⼈还是要坚持⾃⼰独⽴的-思想，因为要有⼈站出来说真话，必须要有⼈，这个世界必须要有不同的声⾳，是-吧？作为武汉⼈，我们哪⼀个不热爱⾃⼰的城市？我们现在回想起来以前过得那种最普-通的⽣活，是多么奢侈的幸福。我现在觉得把宝宝抱着，陪他出去玩⼀下滑梯或者-跟⽼公出去看个电影，在以前再平常都不过，到现在来说都是⼀种幸福，都是不能-达到的幸福。\"><a href=\"#2-⽉-21-号早上领导和我谈话，其实我想问⼏个问题，⽐如有没有觉得那天批评我批-评错了？我希望能够给我⼀个道歉。但是我不敢问。没有⼈在任何场合跟我说表示-抱歉这句话。但我依然觉得，这次的事情更加说明了每个⼈还是要坚持⾃⼰独⽴的-思想，因为要有⼈站出来说真话，必须要有⼈，这个世界必须要有不同的声⾳，是-吧？作为武汉⼈，我们哪⼀个不热爱⾃⼰的城市？我们现在回想起来以前过得那种最普-通的⽣活，是多么奢侈的幸福。我现在觉得把宝宝抱着，陪他出去玩⼀下滑梯或者-跟⽼公出去看个电影，在以前再平常都不过，到现在来说都是⼀种幸福，都是不能-达到的幸福。\" class=\"headerlink\" title=\"2 ⽉ 21 号早上领导和我谈话，其实我想问⼏个问题，⽐如有没有觉得那天批评我批 评错了？我希望能够给我⼀个道歉。但是我不敢问。没有⼈在任何场合跟我说表示 抱歉这句话。但我依然觉得，这次的事情更加说明了每个⼈还是要坚持⾃⼰独⽴的 思想，因为要有⼈站出来说真话，必须要有⼈，这个世界必须要有不同的声⾳，是 吧？作为武汉⼈，我们哪⼀个不热爱⾃⼰的城市？我们现在回想起来以前过得那种最普 通的⽣活，是多么奢侈的幸福。我现在觉得把宝宝抱着，陪他出去玩⼀下滑梯或者 跟⽼公出去看个电影，在以前再平常都不过，到现在来说都是⼀种幸福，都是不能 达到的幸福。\"></a>2 ⽉ 21 号早上领导和我谈话，其实我想问⼏个问题，⽐如有没有觉得那天批评我批 评错了？我希望能够给我⼀个道歉。但是我不敢问。没有⼈在任何场合跟我说表示 抱歉这句话。但我依然觉得，这次的事情更加说明了每个⼈还是要坚持⾃⼰独⽴的 思想，因为要有⼈站出来说真话，必须要有⼈，这个世界必须要有不同的声⾳，是 吧？作为武汉⼈，我们哪⼀个不热爱⾃⼰的城市？我们现在回想起来以前过得那种最普 通的⽣活，是多么奢侈的幸福。我现在觉得把宝宝抱着，陪他出去玩⼀下滑梯或者 跟⽼公出去看个电影，在以前再平常都不过，到现在来说都是⼀种幸福，都是不能 达到的幸福。</h5><h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><blockquote>\n<p>这是我们所处的世界,无比真实却无可奈何,现在连说真话的权利都要被封杀,被和谐,我反反复复看了这篇文章,在此传播真实的声音,这篇文章不会被删除,希望大家能平安健康。</p>\n</blockquote>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<blockquote>\n<p><strong>全文摘取《人物》发哨子的人</strong><br>为了躲避审查,可谓是无所不用其极,戏剧般的艺术绽放往往藏着更为悲伤的故事</p>\n</blockquote>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"https://s1.ax1x.com/2020/03/12/8mBQ3V.jpg\" alt=\"8mBQ3V.jpg\"></h2><hr>\n<blockquote>\n<p>如果这些医⽣都能够得到及时的提醒，或许就不会有这⼀天</p>\n</blockquote>\n<p><img src=\"https://s1.ax1x.com/2020/03/12/8mNX8S.png\" alt=\"8mNX8S.png\"></p>\n<h5 id=\"2019-年-12-⽉-30-⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒检测报告，她⽤红⾊圈-出「SARS-冠状病毒」字样，当⼤学同学问起时，她将这份报告拍下来传给了这位-同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转发这份报告的⼈就包括-那-8-位被警⽅训诫的医⽣。-这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有-的、严厉的斥责」，称她是作为专业⼈⼠在造谣。-此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称-为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的-⼈」。\"><a href=\"#2019-年-12-⽉-30-⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒检测报告，她⽤红⾊圈-出「SARS-冠状病毒」字样，当⼤学同学问起时，她将这份报告拍下来传给了这位-同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转发这份报告的⼈就包括-那-8-位被警⽅训诫的医⽣。-这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有-的、严厉的斥责」，称她是作为专业⼈⼠在造谣。-此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称-为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的-⼈」。\" class=\"headerlink\" title=\"2019 年 12 ⽉ 30 ⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒检测报告，她⽤红⾊圈 出「SARS 冠状病毒」字样，当⼤学同学问起时，她将这份报告拍下来传给了这位 同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转发这份报告的⼈就包括 那 8 位被警⽅训诫的医⽣。 这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有 的、严厉的斥责」，称她是作为专业⼈⼠在造谣。 此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称 为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的 ⼈」。\"></a>2019 年 12 ⽉ 30 ⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒检测报告，她⽤红⾊圈 出「SARS 冠状病毒」字样，当⼤学同学问起时，她将这份报告拍下来传给了这位 同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转发这份报告的⼈就包括 那 8 位被警⽅训诫的医⽣。 这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有 的、严厉的斥责」，称她是作为专业⼈⼠在造谣。 此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称 为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的 ⼈」。</h5><p>这是《⼈物》3 ⽉刊封⾯《武汉医⽣》的第⼆篇报道。</p>\n<h5 id=\"接到武汉市中⼼医院急诊科主任艾芬同意采访的短信是-3-⽉-1-⽇凌晨-5-点，⼤约半⼩-时后，3-⽉-1-⽇凌晨-5-点-32-分，她的同事、甲状腺乳腺外科主任江学庆因感染新冠肺-炎去世。两天后，该院眼科副主任梅仲明过世，他和李⽂亮是同⼀科室。\"><a href=\"#接到武汉市中⼼医院急诊科主任艾芬同意采访的短信是-3-⽉-1-⽇凌晨-5-点，⼤约半⼩-时后，3-⽉-1-⽇凌晨-5-点-32-分，她的同事、甲状腺乳腺外科主任江学庆因感染新冠肺-炎去世。两天后，该院眼科副主任梅仲明过世，他和李⽂亮是同⼀科室。\" class=\"headerlink\" title=\"接到武汉市中⼼医院急诊科主任艾芬同意采访的短信是 3 ⽉ 1 ⽇凌晨 5 点，⼤约半⼩ 时后，3 ⽉ 1 ⽇凌晨 5 点 32 分，她的同事、甲状腺乳腺外科主任江学庆因感染新冠肺 炎去世。两天后，该院眼科副主任梅仲明过世，他和李⽂亮是同⼀科室。\"></a>接到武汉市中⼼医院急诊科主任艾芬同意采访的短信是 3 ⽉ 1 ⽇凌晨 5 点，⼤约半⼩ 时后，3 ⽉ 1 ⽇凌晨 5 点 32 分，她的同事、甲状腺乳腺外科主任江学庆因感染新冠肺 炎去世。两天后，该院眼科副主任梅仲明过世，他和李⽂亮是同⼀科室。</h5><h5 id=\"截⽌-2020-年-3-⽉-9-⽇，武汉市中⼼医院已有-4-位医护⼈员因感染新冠肺炎去世——疫-情发⽣以来，这家离华南海鲜市场只⼏公⾥的医院成为了武汉市职⼯感染⼈数最多-的医院之⼀，据媒体报道医院超过-200-⼈被感染，其中包括三个副院⻓和多名职能-部⻔主任，多个科室主任⽬前正在⽤-ECMO-维持。\"><a href=\"#截⽌-2020-年-3-⽉-9-⽇，武汉市中⼼医院已有-4-位医护⼈员因感染新冠肺炎去世——疫-情发⽣以来，这家离华南海鲜市场只⼏公⾥的医院成为了武汉市职⼯感染⼈数最多-的医院之⼀，据媒体报道医院超过-200-⼈被感染，其中包括三个副院⻓和多名职能-部⻔主任，多个科室主任⽬前正在⽤-ECMO-维持。\" class=\"headerlink\" title=\"截⽌ 2020 年 3 ⽉ 9 ⽇，武汉市中⼼医院已有 4 位医护⼈员因感染新冠肺炎去世——疫 情发⽣以来，这家离华南海鲜市场只⼏公⾥的医院成为了武汉市职⼯感染⼈数最多 的医院之⼀，据媒体报道医院超过 200 ⼈被感染，其中包括三个副院⻓和多名职能 部⻔主任，多个科室主任⽬前正在⽤ ECMO 维持。\"></a>截⽌ 2020 年 3 ⽉ 9 ⽇，武汉市中⼼医院已有 4 位医护⼈员因感染新冠肺炎去世——疫 情发⽣以来，这家离华南海鲜市场只⼏公⾥的医院成为了武汉市职⼯感染⼈数最多 的医院之⼀，据媒体报道医院超过 200 ⼈被感染，其中包括三个副院⻓和多名职能 部⻔主任，多个科室主任⽬前正在⽤ ECMO 维持。</h5><h5 id=\"死亡的阴影笼罩着这家武汉市最⼤的三甲医院，有医⽣告诉《⼈物》，在医院的⼤-群⾥，⼏乎没有⼈说话，只在私下默默悼念、讨论。-悲剧原本有机会避免。2019-年-12-⽉-30-⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒-检测报告，她⽤红⾊圈出「SARS-冠状病毒」字样，当⼤学同学问起时，她将这份-报告拍下来传给了这位同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转-发这份报告的⼈就包括那-8-位被警⽅训诫的医⽣。\"><a href=\"#死亡的阴影笼罩着这家武汉市最⼤的三甲医院，有医⽣告诉《⼈物》，在医院的⼤-群⾥，⼏乎没有⼈说话，只在私下默默悼念、讨论。-悲剧原本有机会避免。2019-年-12-⽉-30-⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒-检测报告，她⽤红⾊圈出「SARS-冠状病毒」字样，当⼤学同学问起时，她将这份-报告拍下来传给了这位同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转-发这份报告的⼈就包括那-8-位被警⽅训诫的医⽣。\" class=\"headerlink\" title=\"死亡的阴影笼罩着这家武汉市最⼤的三甲医院，有医⽣告诉《⼈物》，在医院的⼤ 群⾥，⼏乎没有⼈说话，只在私下默默悼念、讨论。 悲剧原本有机会避免。2019 年 12 ⽉ 30 ⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒 检测报告，她⽤红⾊圈出「SARS 冠状病毒」字样，当⼤学同学问起时，她将这份 报告拍下来传给了这位同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转 发这份报告的⼈就包括那 8 位被警⽅训诫的医⽣。\"></a>死亡的阴影笼罩着这家武汉市最⼤的三甲医院，有医⽣告诉《⼈物》，在医院的⼤ 群⾥，⼏乎没有⼈说话，只在私下默默悼念、讨论。 悲剧原本有机会避免。2019 年 12 ⽉ 30 ⽇，艾芬曾拿到过⼀份不明肺炎病⼈的病毒 检测报告，她⽤红⾊圈出「SARS 冠状病毒」字样，当⼤学同学问起时，她将这份 报告拍下来传给了这位同是医⽣的同学。当晚，这份报告传遍了武汉的医⽣圈，转 发这份报告的⼈就包括那 8 位被警⽅训诫的医⽣。</h5><h5 id=\"这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有-的、严厉的斥责」，称她是作为专业⼈⼠在造谣。-3-⽉-2-⽇下午，艾芬在武汉市中⼼医院南京路院区接受了《⼈物》的专访。她⼀个⼈-坐在急诊室办公室中，曾经⼀天接诊超过-1500-位患者的急诊科此时已恢复了安静，-急诊⼤厅⾥只躺着⼀名流浪汉。\"><a href=\"#这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有-的、严厉的斥责」，称她是作为专业⼈⼠在造谣。-3-⽉-2-⽇下午，艾芬在武汉市中⼼医院南京路院区接受了《⼈物》的专访。她⼀个⼈-坐在急诊室办公室中，曾经⼀天接诊超过-1500-位患者的急诊科此时已恢复了安静，-急诊⼤厅⾥只躺着⼀名流浪汉。\" class=\"headerlink\" title=\"这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有 的、严厉的斥责」，称她是作为专业⼈⼠在造谣。 3 ⽉ 2 ⽇下午，艾芬在武汉市中⼼医院南京路院区接受了《⼈物》的专访。她⼀个⼈ 坐在急诊室办公室中，曾经⼀天接诊超过 1500 位患者的急诊科此时已恢复了安静， 急诊⼤厅⾥只躺着⼀名流浪汉。\"></a>这给艾芬带来了麻烦，作为传播的源头，她被医院纪委约谈，遭受了「前所未有 的、严厉的斥责」，称她是作为专业⼈⼠在造谣。 3 ⽉ 2 ⽇下午，艾芬在武汉市中⼼医院南京路院区接受了《⼈物》的专访。她⼀个⼈ 坐在急诊室办公室中，曾经⼀天接诊超过 1500 位患者的急诊科此时已恢复了安静， 急诊⼤厅⾥只躺着⼀名流浪汉。</h5><h5 id=\"此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称-为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的-⼈」。采访中，艾芬数次提起「后悔」这个词，她后悔当初被约谈后没有继续吹响-哨声，特别是对于过世的同事，「早知道有今天，我管他批评不批评，『⽼⼦』到-处说，是不是？」\"><a href=\"#此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称-为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的-⼈」。采访中，艾芬数次提起「后悔」这个词，她后悔当初被约谈后没有继续吹响-哨声，特别是对于过世的同事，「早知道有今天，我管他批评不批评，『⽼⼦』到-处说，是不是？」\" class=\"headerlink\" title=\"此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称 为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的 ⼈」。采访中，艾芬数次提起「后悔」这个词，她后悔当初被约谈后没有继续吹响 哨声，特别是对于过世的同事，「早知道有今天，我管他批评不批评，『⽼⼦』到 处说，是不是？」\"></a>此前的⼀些报道，艾芬被称为「⼜⼀个被训诫的⼥医⽣浮出⽔⾯」，也有⼈将她称 为「吹哨⼈」，艾芬纠正了这个说法，她说⾃⼰不是吹哨⼈，是那个「发哨⼦的 ⼈」。采访中，艾芬数次提起「后悔」这个词，她后悔当初被约谈后没有继续吹响 哨声，特别是对于过世的同事，「早知道有今天，我管他批评不批评，『⽼⼦』到 处说，是不是？」</h5><blockquote>\n<p>关于武汉市中⼼医院和艾芬本⼈在过去的两个多⽉中到底经历了什么？以下，是艾 芬的讲述——</p>\n</blockquote>\n<p><img src=\"https://s1.ax1x.com/2020/03/12/8maOXQ.png\" alt=\"8maOXQ.png\"></p>\n<h2 id=\"前所未有的训斥\"><a href=\"#前所未有的训斥\" class=\"headerlink\" title=\"前所未有的训斥\"></a>前所未有的训斥</h2><h5 id=\"去年-12-⽉-16-⽇，我们南京路院区急诊科接诊了⼀位病⼈。莫名其妙⾼烧，⼀直⽤药-都不好，体温动都不动⼀下。22-号就转到了呼吸科，做了纤维⽀⽓管镜取了肺泡灌-洗液，送去外⾯做⾼通量测序，后来⼝头报出来是冠状病毒。当时，具体管床的同-事在我⽿边嚼了⼏遍：艾主任，那个⼈报的是冠状病毒。后来我们才知道那个病⼈-是在华南海鲜做事的。\"><a href=\"#去年-12-⽉-16-⽇，我们南京路院区急诊科接诊了⼀位病⼈。莫名其妙⾼烧，⼀直⽤药-都不好，体温动都不动⼀下。22-号就转到了呼吸科，做了纤维⽀⽓管镜取了肺泡灌-洗液，送去外⾯做⾼通量测序，后来⼝头报出来是冠状病毒。当时，具体管床的同-事在我⽿边嚼了⼏遍：艾主任，那个⼈报的是冠状病毒。后来我们才知道那个病⼈-是在华南海鲜做事的。\" class=\"headerlink\" title=\"去年 12 ⽉ 16 ⽇，我们南京路院区急诊科接诊了⼀位病⼈。莫名其妙⾼烧，⼀直⽤药 都不好，体温动都不动⼀下。22 号就转到了呼吸科，做了纤维⽀⽓管镜取了肺泡灌 洗液，送去外⾯做⾼通量测序，后来⼝头报出来是冠状病毒。当时，具体管床的同 事在我⽿边嚼了⼏遍：艾主任，那个⼈报的是冠状病毒。后来我们才知道那个病⼈ 是在华南海鲜做事的。\"></a>去年 12 ⽉ 16 ⽇，我们南京路院区急诊科接诊了⼀位病⼈。莫名其妙⾼烧，⼀直⽤药 都不好，体温动都不动⼀下。22 号就转到了呼吸科，做了纤维⽀⽓管镜取了肺泡灌 洗液，送去外⾯做⾼通量测序，后来⼝头报出来是冠状病毒。当时，具体管床的同 事在我⽿边嚼了⼏遍：艾主任，那个⼈报的是冠状病毒。后来我们才知道那个病⼈ 是在华南海鲜做事的。</h5><h5 id=\"紧接着-12-⽉-27-⽇，南京路院区⼜来了⼀个病⼈，是我们科⼀位医⽣的侄⼉，40-多-岁，没有任何基础疾病，肺部⼀塌糊涂，⾎氧饱和只有-90-，在下⾯其他医院已经-治疗了将近-10-天左右都没有任何好转，病⼈收到了呼吸科监护室住院。同样做了纤-维⽀⽓管镜取了肺泡灌洗液送去检测。\"><a href=\"#紧接着-12-⽉-27-⽇，南京路院区⼜来了⼀个病⼈，是我们科⼀位医⽣的侄⼉，40-多-岁，没有任何基础疾病，肺部⼀塌糊涂，⾎氧饱和只有-90-，在下⾯其他医院已经-治疗了将近-10-天左右都没有任何好转，病⼈收到了呼吸科监护室住院。同样做了纤-维⽀⽓管镜取了肺泡灌洗液送去检测。\" class=\"headerlink\" title=\"紧接着 12 ⽉ 27 ⽇，南京路院区⼜来了⼀个病⼈，是我们科⼀位医⽣的侄⼉，40 多 岁，没有任何基础疾病，肺部⼀塌糊涂，⾎氧饱和只有 90%，在下⾯其他医院已经 治疗了将近 10 天左右都没有任何好转，病⼈收到了呼吸科监护室住院。同样做了纤 维⽀⽓管镜取了肺泡灌洗液送去检测。\"></a>紧接着 12 ⽉ 27 ⽇，南京路院区⼜来了⼀个病⼈，是我们科⼀位医⽣的侄⼉，40 多 岁，没有任何基础疾病，肺部⼀塌糊涂，⾎氧饱和只有 90%，在下⾯其他医院已经 治疗了将近 10 天左右都没有任何好转，病⼈收到了呼吸科监护室住院。同样做了纤 维⽀⽓管镜取了肺泡灌洗液送去检测。</h5><h5 id=\"12-⽉-30-⽇那天中午，我在同济医院⼯作的同学发了⼀张微信对话截图给我，截图上-写着：「最近不要去华南啊，那⾥蛮多⼈⾼烧……」他问我是不是真的，当时，我-正在电脑上看⼀个很典型的肺部感染患者的-CT，我就把-CT-录了⼀段-11-秒钟的视频-传给他，告诉他这是上午来我们急诊的⼀个病⼈，也是华南海鲜市场的。\"><a href=\"#12-⽉-30-⽇那天中午，我在同济医院⼯作的同学发了⼀张微信对话截图给我，截图上-写着：「最近不要去华南啊，那⾥蛮多⼈⾼烧……」他问我是不是真的，当时，我-正在电脑上看⼀个很典型的肺部感染患者的-CT，我就把-CT-录了⼀段-11-秒钟的视频-传给他，告诉他这是上午来我们急诊的⼀个病⼈，也是华南海鲜市场的。\" class=\"headerlink\" title=\"12 ⽉ 30 ⽇那天中午，我在同济医院⼯作的同学发了⼀张微信对话截图给我，截图上 写着：「最近不要去华南啊，那⾥蛮多⼈⾼烧……」他问我是不是真的，当时，我 正在电脑上看⼀个很典型的肺部感染患者的 CT，我就把 CT 录了⼀段 11 秒钟的视频 传给他，告诉他这是上午来我们急诊的⼀个病⼈，也是华南海鲜市场的。\"></a>12 ⽉ 30 ⽇那天中午，我在同济医院⼯作的同学发了⼀张微信对话截图给我，截图上 写着：「最近不要去华南啊，那⾥蛮多⼈⾼烧……」他问我是不是真的，当时，我 正在电脑上看⼀个很典型的肺部感染患者的 CT，我就把 CT 录了⼀段 11 秒钟的视频 传给他，告诉他这是上午来我们急诊的⼀个病⼈，也是华南海鲜市场的。</h5><h5 id=\"当天下午-4-点刚过，同事给我看了⼀份报告，上⾯写的是：SARS-冠状病毒、绿脓假-单胞菌、46-种⼝腔-呼吸道定植菌。我仔细看了很多遍报告，下⾯的注释写着：SA-RS-冠状病毒是⼀种单股正链-RNA-病毒。该病毒主要传播⽅式为近距离⻜沫传播或-接触患者呼吸道分泌物，可引起的⼀种具有明显传染性，可累及多个脏器系统的特-殊肺炎，也称⾮典型肺炎。\"><a href=\"#当天下午-4-点刚过，同事给我看了⼀份报告，上⾯写的是：SARS-冠状病毒、绿脓假-单胞菌、46-种⼝腔-呼吸道定植菌。我仔细看了很多遍报告，下⾯的注释写着：SA-RS-冠状病毒是⼀种单股正链-RNA-病毒。该病毒主要传播⽅式为近距离⻜沫传播或-接触患者呼吸道分泌物，可引起的⼀种具有明显传染性，可累及多个脏器系统的特-殊肺炎，也称⾮典型肺炎。\" class=\"headerlink\" title=\"当天下午 4 点刚过，同事给我看了⼀份报告，上⾯写的是：SARS 冠状病毒、绿脓假 单胞菌、46 种⼝腔/呼吸道定植菌。我仔细看了很多遍报告，下⾯的注释写着：SA RS 冠状病毒是⼀种单股正链 RNA 病毒。该病毒主要传播⽅式为近距离⻜沫传播或 接触患者呼吸道分泌物，可引起的⼀种具有明显传染性，可累及多个脏器系统的特 殊肺炎，也称⾮典型肺炎。\"></a>当天下午 4 点刚过，同事给我看了⼀份报告，上⾯写的是：SARS 冠状病毒、绿脓假 单胞菌、46 种⼝腔/呼吸道定植菌。我仔细看了很多遍报告，下⾯的注释写着：SA RS 冠状病毒是⼀种单股正链 RNA 病毒。该病毒主要传播⽅式为近距离⻜沫传播或 接触患者呼吸道分泌物，可引起的⼀种具有明显传染性，可累及多个脏器系统的特 殊肺炎，也称⾮典型肺炎。</h5><h5 id=\"当时，我吓出了⼀身冷汗，这是⼀个很可怕的东⻄。病⼈收在呼吸科，按道理应该-呼吸科上报这个情况，但是为了保险和重视起⻅，我还是⽴刻打电话上报给了医院-公共卫⽣科和院感科。当时我们医院呼吸科主任正好从我⻔⼝过，他是参加过⾮典-的⼈，我把他抓住，说，我们有个病⼈收到你们科室，发现了这个东⻄。他当时⼀-看就说，那就麻烦了。我就知道这个事情麻烦了。\"><a href=\"#当时，我吓出了⼀身冷汗，这是⼀个很可怕的东⻄。病⼈收在呼吸科，按道理应该-呼吸科上报这个情况，但是为了保险和重视起⻅，我还是⽴刻打电话上报给了医院-公共卫⽣科和院感科。当时我们医院呼吸科主任正好从我⻔⼝过，他是参加过⾮典-的⼈，我把他抓住，说，我们有个病⼈收到你们科室，发现了这个东⻄。他当时⼀-看就说，那就麻烦了。我就知道这个事情麻烦了。\" class=\"headerlink\" title=\"当时，我吓出了⼀身冷汗，这是⼀个很可怕的东⻄。病⼈收在呼吸科，按道理应该 呼吸科上报这个情况，但是为了保险和重视起⻅，我还是⽴刻打电话上报给了医院 公共卫⽣科和院感科。当时我们医院呼吸科主任正好从我⻔⼝过，他是参加过⾮典 的⼈，我把他抓住，说，我们有个病⼈收到你们科室，发现了这个东⻄。他当时⼀ 看就说，那就麻烦了。我就知道这个事情麻烦了。\"></a>当时，我吓出了⼀身冷汗，这是⼀个很可怕的东⻄。病⼈收在呼吸科，按道理应该 呼吸科上报这个情况，但是为了保险和重视起⻅，我还是⽴刻打电话上报给了医院 公共卫⽣科和院感科。当时我们医院呼吸科主任正好从我⻔⼝过，他是参加过⾮典 的⼈，我把他抓住，说，我们有个病⼈收到你们科室，发现了这个东⻄。他当时⼀ 看就说，那就麻烦了。我就知道这个事情麻烦了。</h5><h5 id=\"给医院打完电话，我也给我同学传了这份报告，特意在「SARS-冠状病毒、绿脓假-单胞菌、46-种⼝腔-呼吸道定植菌」这⼀排字上画了个红圈，⽬的是提醒他注意、-重视。我也把报告发在了科室医⽣群⾥⾯，提醒⼤家注意防范。\"><a href=\"#给医院打完电话，我也给我同学传了这份报告，特意在「SARS-冠状病毒、绿脓假-单胞菌、46-种⼝腔-呼吸道定植菌」这⼀排字上画了个红圈，⽬的是提醒他注意、-重视。我也把报告发在了科室医⽣群⾥⾯，提醒⼤家注意防范。\" class=\"headerlink\" title=\"给医院打完电话，我也给我同学传了这份报告，特意在「SARS 冠状病毒、绿脓假 单胞菌、46 种⼝腔/呼吸道定植菌」这⼀排字上画了个红圈，⽬的是提醒他注意、 重视。我也把报告发在了科室医⽣群⾥⾯，提醒⼤家注意防范。\"></a>给医院打完电话，我也给我同学传了这份报告，特意在「SARS 冠状病毒、绿脓假 单胞菌、46 种⼝腔/呼吸道定植菌」这⼀排字上画了个红圈，⽬的是提醒他注意、 重视。我也把报告发在了科室医⽣群⾥⾯，提醒⼤家注意防范。</h5><h5 id=\"当天晚上，这个东⻄就传遍了，各处传的截屏都是我画红圈的那个照⽚，包括后来-知道李⽂亮传在群⾥的也是那份。我⼼⾥当时就想可能坏事⼉了。10-点-20，医院发-来了信息，是转市卫健委的通知，⼤意就是关于不明原因肺炎，不要随意对外发-布，避免引起群众恐慌，如果因为信息泄露引发恐慌，要追责。-我当时⼼⾥就很害怕，⽴刻把这条信息转给了我同学。过了⼤概⼀个⼩时，医院⼜-来了⼀份通知，再次强调群内的相关消息不能外传。⼀天后，1-⽉-1-⽇晚上-11-点-46-分，医院监察科科⻓给我发了条消息，让我第⼆天早上过去⼀下。\"><a href=\"#当天晚上，这个东⻄就传遍了，各处传的截屏都是我画红圈的那个照⽚，包括后来-知道李⽂亮传在群⾥的也是那份。我⼼⾥当时就想可能坏事⼉了。10-点-20，医院发-来了信息，是转市卫健委的通知，⼤意就是关于不明原因肺炎，不要随意对外发-布，避免引起群众恐慌，如果因为信息泄露引发恐慌，要追责。-我当时⼼⾥就很害怕，⽴刻把这条信息转给了我同学。过了⼤概⼀个⼩时，医院⼜-来了⼀份通知，再次强调群内的相关消息不能外传。⼀天后，1-⽉-1-⽇晚上-11-点-46-分，医院监察科科⻓给我发了条消息，让我第⼆天早上过去⼀下。\" class=\"headerlink\" title=\"当天晚上，这个东⻄就传遍了，各处传的截屏都是我画红圈的那个照⽚，包括后来 知道李⽂亮传在群⾥的也是那份。我⼼⾥当时就想可能坏事⼉了。10 点 20，医院发 来了信息，是转市卫健委的通知，⼤意就是关于不明原因肺炎，不要随意对外发 布，避免引起群众恐慌，如果因为信息泄露引发恐慌，要追责。 我当时⼼⾥就很害怕，⽴刻把这条信息转给了我同学。过了⼤概⼀个⼩时，医院⼜ 来了⼀份通知，再次强调群内的相关消息不能外传。⼀天后，1 ⽉ 1 ⽇晚上 11 点 46 分，医院监察科科⻓给我发了条消息，让我第⼆天早上过去⼀下。\"></a>当天晚上，这个东⻄就传遍了，各处传的截屏都是我画红圈的那个照⽚，包括后来 知道李⽂亮传在群⾥的也是那份。我⼼⾥当时就想可能坏事⼉了。10 点 20，医院发 来了信息，是转市卫健委的通知，⼤意就是关于不明原因肺炎，不要随意对外发 布，避免引起群众恐慌，如果因为信息泄露引发恐慌，要追责。 我当时⼼⾥就很害怕，⽴刻把这条信息转给了我同学。过了⼤概⼀个⼩时，医院⼜ 来了⼀份通知，再次强调群内的相关消息不能外传。⼀天后，1 ⽉ 1 ⽇晚上 11 点 46 分，医院监察科科⻓给我发了条消息，让我第⼆天早上过去⼀下。</h5><h5 id=\"那⼀晚上我都没有睡着，很担忧，翻来覆去地想，但⼜觉得凡事总有两⾯性，即便-造成不良影响，但提醒武汉的医务⼈员注意防范也不⼀定是个坏事。第⼆天早上-8-点多⼀点，还没有等我交完班，催我过去的电话就打来了。-之后的约谈，我遭受了前所未有的、⾮常严厉的斥责。\"><a href=\"#那⼀晚上我都没有睡着，很担忧，翻来覆去地想，但⼜觉得凡事总有两⾯性，即便-造成不良影响，但提醒武汉的医务⼈员注意防范也不⼀定是个坏事。第⼆天早上-8-点多⼀点，还没有等我交完班，催我过去的电话就打来了。-之后的约谈，我遭受了前所未有的、⾮常严厉的斥责。\" class=\"headerlink\" title=\"那⼀晚上我都没有睡着，很担忧，翻来覆去地想，但⼜觉得凡事总有两⾯性，即便 造成不良影响，但提醒武汉的医务⼈员注意防范也不⼀定是个坏事。第⼆天早上 8 点多⼀点，还没有等我交完班，催我过去的电话就打来了。 之后的约谈，我遭受了前所未有的、⾮常严厉的斥责。\"></a>那⼀晚上我都没有睡着，很担忧，翻来覆去地想，但⼜觉得凡事总有两⾯性，即便 造成不良影响，但提醒武汉的医务⼈员注意防范也不⼀定是个坏事。第⼆天早上 8 点多⼀点，还没有等我交完班，催我过去的电话就打来了。 之后的约谈，我遭受了前所未有的、⾮常严厉的斥责。</h5><h5 id=\"当时，谈话的领导说，「我们出去开会都抬不起头，某某某主任批评我们医院那个-艾芬，作为武汉市中⼼医院急诊科主任，你是专业⼈⼠，怎么能够没有原则没有组-织纪律造谣⽣事？」这是原话。让我回去跟科室的-200-多号⼈⼀个个地⼝头传达到-位，不能发微信、短信传达，只能当⾯聊或者打电话，不许说关于这个肺炎的任何-事情，「连⾃⼰的⽼公都不能说」……\"><a href=\"#当时，谈话的领导说，「我们出去开会都抬不起头，某某某主任批评我们医院那个-艾芬，作为武汉市中⼼医院急诊科主任，你是专业⼈⼠，怎么能够没有原则没有组-织纪律造谣⽣事？」这是原话。让我回去跟科室的-200-多号⼈⼀个个地⼝头传达到-位，不能发微信、短信传达，只能当⾯聊或者打电话，不许说关于这个肺炎的任何-事情，「连⾃⼰的⽼公都不能说」……\" class=\"headerlink\" title=\"当时，谈话的领导说，「我们出去开会都抬不起头，某某某主任批评我们医院那个 艾芬，作为武汉市中⼼医院急诊科主任，你是专业⼈⼠，怎么能够没有原则没有组 织纪律造谣⽣事？」这是原话。让我回去跟科室的 200 多号⼈⼀个个地⼝头传达到 位，不能发微信、短信传达，只能当⾯聊或者打电话，不许说关于这个肺炎的任何 事情，「连⾃⼰的⽼公都不能说」……\"></a>当时，谈话的领导说，「我们出去开会都抬不起头，某某某主任批评我们医院那个 艾芬，作为武汉市中⼼医院急诊科主任，你是专业⼈⼠，怎么能够没有原则没有组 织纪律造谣⽣事？」这是原话。让我回去跟科室的 200 多号⼈⼀个个地⼝头传达到 位，不能发微信、短信传达，只能当⾯聊或者打电话，不许说关于这个肺炎的任何 事情，「连⾃⼰的⽼公都不能说」……</h5><h5 id=\"我整个⼈⼀下⼦就懵了，他不是批评你这个⼈⼯作不努⼒，⽽是好像整个武汉市发-展的⼤好局⾯被我⼀个⼈破坏了。我当时有⼀种很绝望的感觉，我是⼀个平时认认-真真、勤勤恳恳⼯作的⼈，我觉得⾃⼰做的事情都是按规矩来的，都是有道理的。\"><a href=\"#我整个⼈⼀下⼦就懵了，他不是批评你这个⼈⼯作不努⼒，⽽是好像整个武汉市发-展的⼤好局⾯被我⼀个⼈破坏了。我当时有⼀种很绝望的感觉，我是⼀个平时认认-真真、勤勤恳恳⼯作的⼈，我觉得⾃⼰做的事情都是按规矩来的，都是有道理的。\" class=\"headerlink\" title=\"我整个⼈⼀下⼦就懵了，他不是批评你这个⼈⼯作不努⼒，⽽是好像整个武汉市发 展的⼤好局⾯被我⼀个⼈破坏了。我当时有⼀种很绝望的感觉，我是⼀个平时认认 真真、勤勤恳恳⼯作的⼈，我觉得⾃⼰做的事情都是按规矩来的，都是有道理的。\"></a>我整个⼈⼀下⼦就懵了，他不是批评你这个⼈⼯作不努⼒，⽽是好像整个武汉市发 展的⼤好局⾯被我⼀个⼈破坏了。我当时有⼀种很绝望的感觉，我是⼀个平时认认 真真、勤勤恳恳⼯作的⼈，我觉得⾃⼰做的事情都是按规矩来的，都是有道理的。</h5><h5 id=\"我犯了什么错？我看到了这个报告，我也上报医院了，我和我的同学，同⾏之间对-于某⼀个病⼈的情况进⾏交流，没有透露病⼈的任何私⼈信息，就相当于是医学⽣-之间讨论⼀个病案，当你作为⼀个临床的医⽣，已经知道在病⼈身上发现了⼀种很-重要的病毒，别的医⽣问起，你怎么可能不说呢？这是你当医⽣的本能，对不对？\"><a href=\"#我犯了什么错？我看到了这个报告，我也上报医院了，我和我的同学，同⾏之间对-于某⼀个病⼈的情况进⾏交流，没有透露病⼈的任何私⼈信息，就相当于是医学⽣-之间讨论⼀个病案，当你作为⼀个临床的医⽣，已经知道在病⼈身上发现了⼀种很-重要的病毒，别的医⽣问起，你怎么可能不说呢？这是你当医⽣的本能，对不对？\" class=\"headerlink\" title=\"我犯了什么错？我看到了这个报告，我也上报医院了，我和我的同学，同⾏之间对 于某⼀个病⼈的情况进⾏交流，没有透露病⼈的任何私⼈信息，就相当于是医学⽣ 之间讨论⼀个病案，当你作为⼀个临床的医⽣，已经知道在病⼈身上发现了⼀种很 重要的病毒，别的医⽣问起，你怎么可能不说呢？这是你当医⽣的本能，对不对？\"></a>我犯了什么错？我看到了这个报告，我也上报医院了，我和我的同学，同⾏之间对 于某⼀个病⼈的情况进⾏交流，没有透露病⼈的任何私⼈信息，就相当于是医学⽣ 之间讨论⼀个病案，当你作为⼀个临床的医⽣，已经知道在病⼈身上发现了⼀种很 重要的病毒，别的医⽣问起，你怎么可能不说呢？这是你当医⽣的本能，对不对？</h5><h5 id=\"我做错什么了？我做了⼀个医⽣、⼀个⼈正常应该做的事情，换作是任何⼈我觉得-都会这么做。-我当时的情绪也很激动，说，这个事是我做的，跟其余⼈都没有关系，你们⼲脆把-我抓去坐牢吧。我说我现在这个状态不适合在这个岗位上继续⼯作了，想要休息⼀-段时间。领导没有同意，说这个时候正是考验我的时候。\"><a href=\"#我做错什么了？我做了⼀个医⽣、⼀个⼈正常应该做的事情，换作是任何⼈我觉得-都会这么做。-我当时的情绪也很激动，说，这个事是我做的，跟其余⼈都没有关系，你们⼲脆把-我抓去坐牢吧。我说我现在这个状态不适合在这个岗位上继续⼯作了，想要休息⼀-段时间。领导没有同意，说这个时候正是考验我的时候。\" class=\"headerlink\" title=\"我做错什么了？我做了⼀个医⽣、⼀个⼈正常应该做的事情，换作是任何⼈我觉得 都会这么做。 我当时的情绪也很激动，说，这个事是我做的，跟其余⼈都没有关系，你们⼲脆把 我抓去坐牢吧。我说我现在这个状态不适合在这个岗位上继续⼯作了，想要休息⼀ 段时间。领导没有同意，说这个时候正是考验我的时候。\"></a>我做错什么了？我做了⼀个医⽣、⼀个⼈正常应该做的事情，换作是任何⼈我觉得 都会这么做。 我当时的情绪也很激动，说，这个事是我做的，跟其余⼈都没有关系，你们⼲脆把 我抓去坐牢吧。我说我现在这个状态不适合在这个岗位上继续⼯作了，想要休息⼀ 段时间。领导没有同意，说这个时候正是考验我的时候。</h5><h5 id=\"当天晚上回家，我记得蛮清楚，进⻔后就跟我⽼公讲，我要是出了什么事情，你就-好好地把孩⼦带⼤。因为我的⼆宝还很⼩，才-1-岁多。他当时觉得莫名其妙，我没-有跟他说⾃⼰被训话的事，1-⽉-20-号，钟南⼭说了⼈传⼈之后，我才跟他说那天发-⽣了什么。那期间，我只是提醒家⼈不要去⼈多的地⽅，出⻔要戴⼝罩。\"><a href=\"#当天晚上回家，我记得蛮清楚，进⻔后就跟我⽼公讲，我要是出了什么事情，你就-好好地把孩⼦带⼤。因为我的⼆宝还很⼩，才-1-岁多。他当时觉得莫名其妙，我没-有跟他说⾃⼰被训话的事，1-⽉-20-号，钟南⼭说了⼈传⼈之后，我才跟他说那天发-⽣了什么。那期间，我只是提醒家⼈不要去⼈多的地⽅，出⻔要戴⼝罩。\" class=\"headerlink\" title=\"当天晚上回家，我记得蛮清楚，进⻔后就跟我⽼公讲，我要是出了什么事情，你就 好好地把孩⼦带⼤。因为我的⼆宝还很⼩，才 1 岁多。他当时觉得莫名其妙，我没 有跟他说⾃⼰被训话的事，1 ⽉ 20 号，钟南⼭说了⼈传⼈之后，我才跟他说那天发 ⽣了什么。那期间，我只是提醒家⼈不要去⼈多的地⽅，出⻔要戴⼝罩。\"></a>当天晚上回家，我记得蛮清楚，进⻔后就跟我⽼公讲，我要是出了什么事情，你就 好好地把孩⼦带⼤。因为我的⼆宝还很⼩，才 1 岁多。他当时觉得莫名其妙，我没 有跟他说⾃⼰被训话的事，1 ⽉ 20 号，钟南⼭说了⼈传⼈之后，我才跟他说那天发 ⽣了什么。那期间，我只是提醒家⼈不要去⼈多的地⽅，出⻔要戴⼝罩。</h5><h2 id=\"外围科室\"><a href=\"#外围科室\" class=\"headerlink\" title=\"外围科室\"></a>外围科室</h2><h5 id=\"很多⼈担⼼我也是那-8-个⼈之⼀被叫去训诫。实际上我没有被公安局训诫，后来有-好朋友问我，你是不是吹哨⼈？我说我不是吹哨⼈，我是那个发哨⼦的⼈。\"><a href=\"#很多⼈担⼼我也是那-8-个⼈之⼀被叫去训诫。实际上我没有被公安局训诫，后来有-好朋友问我，你是不是吹哨⼈？我说我不是吹哨⼈，我是那个发哨⼦的⼈。\" class=\"headerlink\" title=\"很多⼈担⼼我也是那 8 个⼈之⼀被叫去训诫。实际上我没有被公安局训诫，后来有 好朋友问我，你是不是吹哨⼈？我说我不是吹哨⼈，我是那个发哨⼦的⼈。\"></a>很多⼈担⼼我也是那 8 个⼈之⼀被叫去训诫。实际上我没有被公安局训诫，后来有 好朋友问我，你是不是吹哨⼈？我说我不是吹哨⼈，我是那个发哨⼦的⼈。</h5><h5 id=\"但那次约谈对我的打击很⼤，⾮常⼤。回来后我感觉整个⼈⼼都垮了，真的是强打-着精神，认真做事，后来所有的⼈再来问我，我就不能回答了。\"><a href=\"#但那次约谈对我的打击很⼤，⾮常⼤。回来后我感觉整个⼈⼼都垮了，真的是强打-着精神，认真做事，后来所有的⼈再来问我，我就不能回答了。\" class=\"headerlink\" title=\"但那次约谈对我的打击很⼤，⾮常⼤。回来后我感觉整个⼈⼼都垮了，真的是强打 着精神，认真做事，后来所有的⼈再来问我，我就不能回答了。\"></a>但那次约谈对我的打击很⼤，⾮常⼤。回来后我感觉整个⼈⼼都垮了，真的是强打 着精神，认真做事，后来所有的⼈再来问我，我就不能回答了。</h5><h5 id=\"我能做的就是先让急诊科重视防护。我们急诊科-200-多⼈，从-1-⽉-1-号开始，我就叫-⼤家加强防护，所有的⼈必须戴⼝罩、戴帽⼦、⽤⼿快消。记得有⼀天交班有个男-护⼠没戴⼝罩，我⻢上就当场骂他「以后不戴⼝罩就不要来上班了」。\"><a href=\"#我能做的就是先让急诊科重视防护。我们急诊科-200-多⼈，从-1-⽉-1-号开始，我就叫-⼤家加强防护，所有的⼈必须戴⼝罩、戴帽⼦、⽤⼿快消。记得有⼀天交班有个男-护⼠没戴⼝罩，我⻢上就当场骂他「以后不戴⼝罩就不要来上班了」。\" class=\"headerlink\" title=\"我能做的就是先让急诊科重视防护。我们急诊科 200 多⼈，从 1 ⽉ 1 号开始，我就叫 ⼤家加强防护，所有的⼈必须戴⼝罩、戴帽⼦、⽤⼿快消。记得有⼀天交班有个男 护⼠没戴⼝罩，我⻢上就当场骂他「以后不戴⼝罩就不要来上班了」。\"></a>我能做的就是先让急诊科重视防护。我们急诊科 200 多⼈，从 1 ⽉ 1 号开始，我就叫 ⼤家加强防护，所有的⼈必须戴⼝罩、戴帽⼦、⽤⼿快消。记得有⼀天交班有个男 护⼠没戴⼝罩，我⻢上就当场骂他「以后不戴⼝罩就不要来上班了」。</h5><h5 id=\"1-⽉-9-号，我下班时看⻅预检台⼀个病⼈对着⼤家咳，从那天后，我就要求他们必须-给来看病的病⼈发⼝罩，⼀⼈发⼀个，这个时候不要节约钱，当时外⾯在说没有⼈传⼈，我⼜要在这⾥强调戴⼝罩加强防护，都是很⽭盾的。\"><a href=\"#1-⽉-9-号，我下班时看⻅预检台⼀个病⼈对着⼤家咳，从那天后，我就要求他们必须-给来看病的病⼈发⼝罩，⼀⼈发⼀个，这个时候不要节约钱，当时外⾯在说没有⼈传⼈，我⼜要在这⾥强调戴⼝罩加强防护，都是很⽭盾的。\" class=\"headerlink\" title=\"1 ⽉ 9 号，我下班时看⻅预检台⼀个病⼈对着⼤家咳，从那天后，我就要求他们必须 给来看病的病⼈发⼝罩，⼀⼈发⼀个，这个时候不要节约钱，当时外⾯在说没有⼈传⼈，我⼜要在这⾥强调戴⼝罩加强防护，都是很⽭盾的。\"></a>1 ⽉ 9 号，我下班时看⻅预检台⼀个病⼈对着⼤家咳，从那天后，我就要求他们必须 给来看病的病⼈发⼝罩，⼀⼈发⼀个，这个时候不要节约钱，当时外⾯在说没有⼈传⼈，我⼜要在这⾥强调戴⼝罩加强防护，都是很⽭盾的。</h5><h5 id=\"那段时间确实很压抑，⾮常痛苦。有医⽣提出来要把隔离⾐穿外头，医院⾥开会说-不让，说隔离⾐穿外头会造成恐慌。我就让科室的⼈把隔离服穿⽩⼤褂⾥⾯，这是-不符合规范的，很荒谬的。\"><a href=\"#那段时间确实很压抑，⾮常痛苦。有医⽣提出来要把隔离⾐穿外头，医院⾥开会说-不让，说隔离⾐穿外头会造成恐慌。我就让科室的⼈把隔离服穿⽩⼤褂⾥⾯，这是-不符合规范的，很荒谬的。\" class=\"headerlink\" title=\"那段时间确实很压抑，⾮常痛苦。有医⽣提出来要把隔离⾐穿外头，医院⾥开会说 不让，说隔离⾐穿外头会造成恐慌。我就让科室的⼈把隔离服穿⽩⼤褂⾥⾯，这是 不符合规范的，很荒谬的。\"></a>那段时间确实很压抑，⾮常痛苦。有医⽣提出来要把隔离⾐穿外头，医院⾥开会说 不让，说隔离⾐穿外头会造成恐慌。我就让科室的⼈把隔离服穿⽩⼤褂⾥⾯，这是 不符合规范的，很荒谬的。</h5><h5 id=\"我们眼睁睁地看着病⼈越来越多，传播区域的半径越来越⼤，先是华南海鲜市场附-近可能跟它有关系，然后就传传传，半径越来越⼤。很多是家庭传染的，最先的-7-个⼈当中就有妈妈给⼉⼦送饭得的病。有诊所的⽼板得病，也是来打针的病⼈传给-他的，都是重得不得了。我就知道肯定有⼈传⼈。如果没有⼈传⼈，华南海鲜市场-1-⽉-1-⽇就关闭了，怎么病⼈会越来越多呢？-很多时候我都在想，如果他们当时不那样训斥我，⼼平⽓和地问⼀下这件事情的来-⻰去脉，再请别的呼吸科专家⼀起沟通⼀下，也许局⾯会好⼀些，我⾄少可以在医-院内部多交流⼀下。如果是-1-⽉-1-号⼤家都这样引起警惕，就不会有那么多悲剧了。\"><a href=\"#我们眼睁睁地看着病⼈越来越多，传播区域的半径越来越⼤，先是华南海鲜市场附-近可能跟它有关系，然后就传传传，半径越来越⼤。很多是家庭传染的，最先的-7-个⼈当中就有妈妈给⼉⼦送饭得的病。有诊所的⽼板得病，也是来打针的病⼈传给-他的，都是重得不得了。我就知道肯定有⼈传⼈。如果没有⼈传⼈，华南海鲜市场-1-⽉-1-⽇就关闭了，怎么病⼈会越来越多呢？-很多时候我都在想，如果他们当时不那样训斥我，⼼平⽓和地问⼀下这件事情的来-⻰去脉，再请别的呼吸科专家⼀起沟通⼀下，也许局⾯会好⼀些，我⾄少可以在医-院内部多交流⼀下。如果是-1-⽉-1-号⼤家都这样引起警惕，就不会有那么多悲剧了。\" class=\"headerlink\" title=\"我们眼睁睁地看着病⼈越来越多，传播区域的半径越来越⼤，先是华南海鲜市场附 近可能跟它有关系，然后就传传传，半径越来越⼤。很多是家庭传染的，最先的 7 个⼈当中就有妈妈给⼉⼦送饭得的病。有诊所的⽼板得病，也是来打针的病⼈传给 他的，都是重得不得了。我就知道肯定有⼈传⼈。如果没有⼈传⼈，华南海鲜市场 1 ⽉ 1 ⽇就关闭了，怎么病⼈会越来越多呢？ 很多时候我都在想，如果他们当时不那样训斥我，⼼平⽓和地问⼀下这件事情的来 ⻰去脉，再请别的呼吸科专家⼀起沟通⼀下，也许局⾯会好⼀些，我⾄少可以在医 院内部多交流⼀下。如果是 1 ⽉ 1 号⼤家都这样引起警惕，就不会有那么多悲剧了。\"></a>我们眼睁睁地看着病⼈越来越多，传播区域的半径越来越⼤，先是华南海鲜市场附 近可能跟它有关系，然后就传传传，半径越来越⼤。很多是家庭传染的，最先的 7 个⼈当中就有妈妈给⼉⼦送饭得的病。有诊所的⽼板得病，也是来打针的病⼈传给 他的，都是重得不得了。我就知道肯定有⼈传⼈。如果没有⼈传⼈，华南海鲜市场 1 ⽉ 1 ⽇就关闭了，怎么病⼈会越来越多呢？ 很多时候我都在想，如果他们当时不那样训斥我，⼼平⽓和地问⼀下这件事情的来 ⻰去脉，再请别的呼吸科专家⼀起沟通⼀下，也许局⾯会好⼀些，我⾄少可以在医 院内部多交流⼀下。如果是 1 ⽉ 1 号⼤家都这样引起警惕，就不会有那么多悲剧了。</h5><h5 id=\"1-⽉-3-号下午，在南京路院区，泌尿外科的医⽣们聚集在⼀起回顾⽼主任的⼯作历-程，参会的胡卫峰医⽣今年-43-岁，现在正在抢救；1-⽉-8-号下午，南京路院区-22-楼，江学庆主任还组织了武汉市甲乳患者康复联欢会；1-⽉-11-号早上，科室跟我汇报-急诊科抢救室护⼠胡紫薇感染，她应该是中⼼医院第⼀个被感染的护⼠，我第⼀时-间给医务科科⻓打电话汇报，然后医院紧急开了会，会上指示把「两下肺感染，病-毒性肺炎？」的报告改成「两肺散在感染」；1-⽉-16-号最后⼀次周会上，⼀位副院-⻓还在说：「⼤家都要有⼀点医学常识，某些⾼年资的医⽣不要⾃⼰把⾃⼰搞得吓死⼈的。」另⼀位领导上台继续说：「没有⼈传⼈，可防可治可控。」⼀天后，1-⽉-17-号，江学庆住院，10-天后插管、上-ECMO。\"><a href=\"#1-⽉-3-号下午，在南京路院区，泌尿外科的医⽣们聚集在⼀起回顾⽼主任的⼯作历-程，参会的胡卫峰医⽣今年-43-岁，现在正在抢救；1-⽉-8-号下午，南京路院区-22-楼，江学庆主任还组织了武汉市甲乳患者康复联欢会；1-⽉-11-号早上，科室跟我汇报-急诊科抢救室护⼠胡紫薇感染，她应该是中⼼医院第⼀个被感染的护⼠，我第⼀时-间给医务科科⻓打电话汇报，然后医院紧急开了会，会上指示把「两下肺感染，病-毒性肺炎？」的报告改成「两肺散在感染」；1-⽉-16-号最后⼀次周会上，⼀位副院-⻓还在说：「⼤家都要有⼀点医学常识，某些⾼年资的医⽣不要⾃⼰把⾃⼰搞得吓死⼈的。」另⼀位领导上台继续说：「没有⼈传⼈，可防可治可控。」⼀天后，1-⽉-17-号，江学庆住院，10-天后插管、上-ECMO。\" class=\"headerlink\" title=\"1 ⽉ 3 号下午，在南京路院区，泌尿外科的医⽣们聚集在⼀起回顾⽼主任的⼯作历 程，参会的胡卫峰医⽣今年 43 岁，现在正在抢救；1 ⽉ 8 号下午，南京路院区 22 楼，江学庆主任还组织了武汉市甲乳患者康复联欢会；1 ⽉ 11 号早上，科室跟我汇报 急诊科抢救室护⼠胡紫薇感染，她应该是中⼼医院第⼀个被感染的护⼠，我第⼀时 间给医务科科⻓打电话汇报，然后医院紧急开了会，会上指示把「两下肺感染，病 毒性肺炎？」的报告改成「两肺散在感染」；1 ⽉ 16 号最后⼀次周会上，⼀位副院 ⻓还在说：「⼤家都要有⼀点医学常识，某些⾼年资的医⽣不要⾃⼰把⾃⼰搞得吓死⼈的。」另⼀位领导上台继续说：「没有⼈传⼈，可防可治可控。」⼀天后，1 ⽉ 17 号，江学庆住院，10 天后插管、上 ECMO。\"></a>1 ⽉ 3 号下午，在南京路院区，泌尿外科的医⽣们聚集在⼀起回顾⽼主任的⼯作历 程，参会的胡卫峰医⽣今年 43 岁，现在正在抢救；1 ⽉ 8 号下午，南京路院区 22 楼，江学庆主任还组织了武汉市甲乳患者康复联欢会；1 ⽉ 11 号早上，科室跟我汇报 急诊科抢救室护⼠胡紫薇感染，她应该是中⼼医院第⼀个被感染的护⼠，我第⼀时 间给医务科科⻓打电话汇报，然后医院紧急开了会，会上指示把「两下肺感染，病 毒性肺炎？」的报告改成「两肺散在感染」；1 ⽉ 16 号最后⼀次周会上，⼀位副院 ⻓还在说：「⼤家都要有⼀点医学常识，某些⾼年资的医⽣不要⾃⼰把⾃⼰搞得吓死⼈的。」另⼀位领导上台继续说：「没有⼈传⼈，可防可治可控。」⼀天后，1 ⽉ 17 号，江学庆住院，10 天后插管、上 ECMO。</h5><h5 id=\"中⼼医院的代价这么⼤，就是跟我们的医务⼈员没有信息透明化有关。你看倒下的-⼈，急诊科和呼吸科的倒是没有那么重的，因为我们有防护意识，并且⼀⽣病就赶-紧休息治疗。重的都是外围科室，李⽂亮是眼科的，江学庆是甲乳科的。\"><a href=\"#中⼼医院的代价这么⼤，就是跟我们的医务⼈员没有信息透明化有关。你看倒下的-⼈，急诊科和呼吸科的倒是没有那么重的，因为我们有防护意识，并且⼀⽣病就赶-紧休息治疗。重的都是外围科室，李⽂亮是眼科的，江学庆是甲乳科的。\" class=\"headerlink\" title=\"中⼼医院的代价这么⼤，就是跟我们的医务⼈员没有信息透明化有关。你看倒下的 ⼈，急诊科和呼吸科的倒是没有那么重的，因为我们有防护意识，并且⼀⽣病就赶 紧休息治疗。重的都是外围科室，李⽂亮是眼科的，江学庆是甲乳科的。\"></a>中⼼医院的代价这么⼤，就是跟我们的医务⼈员没有信息透明化有关。你看倒下的 ⼈，急诊科和呼吸科的倒是没有那么重的，因为我们有防护意识，并且⼀⽣病就赶 紧休息治疗。重的都是外围科室，李⽂亮是眼科的，江学庆是甲乳科的。</h5><h5 id=\"江学庆真的⾮常好的⼀个⼈，医术很⾼，全院的两个中国医师奖之⼀。⽽且我们还-是邻居，我们⼀个单元，我住四⼗⼏楼，他住三⼗⼏楼，关系都很好，但是平时因-为⼯作太忙，就只能开会、搞医院活动时候⻅⻅⾯。他是个⼯作狂，要么就在⼿术-室，要么就在看⻔诊。谁也不会特意跑去跟他说，江主任，你要注意，戴⼝罩。他-也没有时间和精⼒打听这些事，他肯定就⼤意了：「有什么关系？就是个肺炎。」-这个是他们科室的⼈告诉我的。\"><a href=\"#江学庆真的⾮常好的⼀个⼈，医术很⾼，全院的两个中国医师奖之⼀。⽽且我们还-是邻居，我们⼀个单元，我住四⼗⼏楼，他住三⼗⼏楼，关系都很好，但是平时因-为⼯作太忙，就只能开会、搞医院活动时候⻅⻅⾯。他是个⼯作狂，要么就在⼿术-室，要么就在看⻔诊。谁也不会特意跑去跟他说，江主任，你要注意，戴⼝罩。他-也没有时间和精⼒打听这些事，他肯定就⼤意了：「有什么关系？就是个肺炎。」-这个是他们科室的⼈告诉我的。\" class=\"headerlink\" title=\"江学庆真的⾮常好的⼀个⼈，医术很⾼，全院的两个中国医师奖之⼀。⽽且我们还 是邻居，我们⼀个单元，我住四⼗⼏楼，他住三⼗⼏楼，关系都很好，但是平时因 为⼯作太忙，就只能开会、搞医院活动时候⻅⻅⾯。他是个⼯作狂，要么就在⼿术 室，要么就在看⻔诊。谁也不会特意跑去跟他说，江主任，你要注意，戴⼝罩。他 也没有时间和精⼒打听这些事，他肯定就⼤意了：「有什么关系？就是个肺炎。」 这个是他们科室的⼈告诉我的。\"></a>江学庆真的⾮常好的⼀个⼈，医术很⾼，全院的两个中国医师奖之⼀。⽽且我们还 是邻居，我们⼀个单元，我住四⼗⼏楼，他住三⼗⼏楼，关系都很好，但是平时因 为⼯作太忙，就只能开会、搞医院活动时候⻅⻅⾯。他是个⼯作狂，要么就在⼿术 室，要么就在看⻔诊。谁也不会特意跑去跟他说，江主任，你要注意，戴⼝罩。他 也没有时间和精⼒打听这些事，他肯定就⼤意了：「有什么关系？就是个肺炎。」 这个是他们科室的⼈告诉我的。</h5><h5 id=\"如果这些医⽣都能够得到及时的提醒，或许就不会有这⼀天。所以，作为当事⼈的-我⾮常后悔，早知道有今天，我管他批评不批评我，「⽼⼦」到处说，是不是？-虽然和李⽂亮同在⼀个医院，⼀直到去世之前我都不认得他，因为医院-4000-多号-⼈太多了，平时也忙。他去世前的那天晚上，ICU-的主任跟我打电话借急诊科的⼼-脏按压器，说李⽂亮要抢救，我⼀听这个消息⼤吃⼀惊，李⽂亮这个事整个过程我-不了解，但是他的病情跟他受训斥之后⼼情不好有没有关系？这我要打个问号，因-为受训的感觉我感同身受。\"><a href=\"#如果这些医⽣都能够得到及时的提醒，或许就不会有这⼀天。所以，作为当事⼈的-我⾮常后悔，早知道有今天，我管他批评不批评我，「⽼⼦」到处说，是不是？-虽然和李⽂亮同在⼀个医院，⼀直到去世之前我都不认得他，因为医院-4000-多号-⼈太多了，平时也忙。他去世前的那天晚上，ICU-的主任跟我打电话借急诊科的⼼-脏按压器，说李⽂亮要抢救，我⼀听这个消息⼤吃⼀惊，李⽂亮这个事整个过程我-不了解，但是他的病情跟他受训斥之后⼼情不好有没有关系？这我要打个问号，因-为受训的感觉我感同身受。\" class=\"headerlink\" title=\"如果这些医⽣都能够得到及时的提醒，或许就不会有这⼀天。所以，作为当事⼈的 我⾮常后悔，早知道有今天，我管他批评不批评我，「⽼⼦」到处说，是不是？ 虽然和李⽂亮同在⼀个医院，⼀直到去世之前我都不认得他，因为医院 4000 多号 ⼈太多了，平时也忙。他去世前的那天晚上，ICU 的主任跟我打电话借急诊科的⼼ 脏按压器，说李⽂亮要抢救，我⼀听这个消息⼤吃⼀惊，李⽂亮这个事整个过程我 不了解，但是他的病情跟他受训斥之后⼼情不好有没有关系？这我要打个问号，因 为受训的感觉我感同身受。\"></a>如果这些医⽣都能够得到及时的提醒，或许就不会有这⼀天。所以，作为当事⼈的 我⾮常后悔，早知道有今天，我管他批评不批评我，「⽼⼦」到处说，是不是？ 虽然和李⽂亮同在⼀个医院，⼀直到去世之前我都不认得他，因为医院 4000 多号 ⼈太多了，平时也忙。他去世前的那天晚上，ICU 的主任跟我打电话借急诊科的⼼ 脏按压器，说李⽂亮要抢救，我⼀听这个消息⼤吃⼀惊，李⽂亮这个事整个过程我 不了解，但是他的病情跟他受训斥之后⼼情不好有没有关系？这我要打个问号，因 为受训的感觉我感同身受。</h5><h5 id=\"后来，事情发展到这⼀步，证明李⽂亮是对的时候，他的⼼情我⾮常能理解，可能-跟我的⼼情⼀样，不是激动、⾼兴，⽽是后悔，后悔当初就应该继续⼤声疾呼，应-该在所有的⼈问我们的时候，继续说。很多很多次我都在想，如果时间能够倒回来-该多好。\"><a href=\"#后来，事情发展到这⼀步，证明李⽂亮是对的时候，他的⼼情我⾮常能理解，可能-跟我的⼼情⼀样，不是激动、⾼兴，⽽是后悔，后悔当初就应该继续⼤声疾呼，应-该在所有的⼈问我们的时候，继续说。很多很多次我都在想，如果时间能够倒回来-该多好。\" class=\"headerlink\" title=\"后来，事情发展到这⼀步，证明李⽂亮是对的时候，他的⼼情我⾮常能理解，可能 跟我的⼼情⼀样，不是激动、⾼兴，⽽是后悔，后悔当初就应该继续⼤声疾呼，应 该在所有的⼈问我们的时候，继续说。很多很多次我都在想，如果时间能够倒回来 该多好。\"></a>后来，事情发展到这⼀步，证明李⽂亮是对的时候，他的⼼情我⾮常能理解，可能 跟我的⼼情⼀样，不是激动、⾼兴，⽽是后悔，后悔当初就应该继续⼤声疾呼，应 该在所有的⼈问我们的时候，继续说。很多很多次我都在想，如果时间能够倒回来 该多好。</h5><p><img src=\"https://s1.ax1x.com/2020/03/12/8mwPUI.png\" alt=\"8mwPUI.png\"></p>\n<h2 id=\"活着就是好的\"><a href=\"#活着就是好的\" class=\"headerlink\" title=\"活着就是好的\"></a>活着就是好的</h2><h5 id=\"在-1-⽉-23-⽇封城前⼀天的晚上，有相关部⻔的朋友打电话问我武汉市急诊病⼈的真-实情况。我说你代表私⼈，还是代表公家。他说我代表私⼈。我说代表个⼈就告诉-你真话，1-⽉-21-号，我们急诊科接诊-1523-个病⼈，是往常最多时的-3-倍，其中发烧的-有-655-个⼈。\"><a href=\"#在-1-⽉-23-⽇封城前⼀天的晚上，有相关部⻔的朋友打电话问我武汉市急诊病⼈的真-实情况。我说你代表私⼈，还是代表公家。他说我代表私⼈。我说代表个⼈就告诉-你真话，1-⽉-21-号，我们急诊科接诊-1523-个病⼈，是往常最多时的-3-倍，其中发烧的-有-655-个⼈。\" class=\"headerlink\" title=\"在 1 ⽉ 23 ⽇封城前⼀天的晚上，有相关部⻔的朋友打电话问我武汉市急诊病⼈的真 实情况。我说你代表私⼈，还是代表公家。他说我代表私⼈。我说代表个⼈就告诉 你真话，1 ⽉ 21 号，我们急诊科接诊 1523 个病⼈，是往常最多时的 3 倍，其中发烧的 有 655 个⼈。\"></a>在 1 ⽉ 23 ⽇封城前⼀天的晚上，有相关部⻔的朋友打电话问我武汉市急诊病⼈的真 实情况。我说你代表私⼈，还是代表公家。他说我代表私⼈。我说代表个⼈就告诉 你真话，1 ⽉ 21 号，我们急诊科接诊 1523 个病⼈，是往常最多时的 3 倍，其中发烧的 有 655 个⼈。</h5><h5 id=\"那段时间急诊科的状况，经历过的⼈⼀辈⼦都忘不了，甚⾄会颠覆你的所有⼈⽣-观。如果说这是打仗，急诊科就在最前线。但当时的情况是，后⾯的病区已经饱和了，-基本上⼀个病⼈都不收，ICU-也坚决不收，说⾥⾯有⼲净的病⼈，⼀进去就污染-了。病⼈不断地往急诊科涌，后⾯的路⼜不通，就全部堆在急诊科。病⼈来看病，-⼀排队随便就是⼏个⼩时，我们也完全没法下班，发热⻔诊和急诊也都不分了，⼤-厅⾥堆满了病⼈，抢救室输液室⾥到处都是病⼈。-还有的病⼈家属来了，说要⼀张床，我的爸爸在汽⻋⾥⾯不⾏了，因为那时候地下-⻋库已封，他⻋⼦也堵着开不进来。我没办法，带着⼈和设备跑去汽⻋⾥去，⼀-看，⼈已经死了，你说是什么感受，很难受很难受。这个⼈就死在汽⻋⾥，连下⻋-的机会都没有。\"><a href=\"#那段时间急诊科的状况，经历过的⼈⼀辈⼦都忘不了，甚⾄会颠覆你的所有⼈⽣-观。如果说这是打仗，急诊科就在最前线。但当时的情况是，后⾯的病区已经饱和了，-基本上⼀个病⼈都不收，ICU-也坚决不收，说⾥⾯有⼲净的病⼈，⼀进去就污染-了。病⼈不断地往急诊科涌，后⾯的路⼜不通，就全部堆在急诊科。病⼈来看病，-⼀排队随便就是⼏个⼩时，我们也完全没法下班，发热⻔诊和急诊也都不分了，⼤-厅⾥堆满了病⼈，抢救室输液室⾥到处都是病⼈。-还有的病⼈家属来了，说要⼀张床，我的爸爸在汽⻋⾥⾯不⾏了，因为那时候地下-⻋库已封，他⻋⼦也堵着开不进来。我没办法，带着⼈和设备跑去汽⻋⾥去，⼀-看，⼈已经死了，你说是什么感受，很难受很难受。这个⼈就死在汽⻋⾥，连下⻋-的机会都没有。\" class=\"headerlink\" title=\"那段时间急诊科的状况，经历过的⼈⼀辈⼦都忘不了，甚⾄会颠覆你的所有⼈⽣ 观。如果说这是打仗，急诊科就在最前线。但当时的情况是，后⾯的病区已经饱和了， 基本上⼀个病⼈都不收，ICU 也坚决不收，说⾥⾯有⼲净的病⼈，⼀进去就污染 了。病⼈不断地往急诊科涌，后⾯的路⼜不通，就全部堆在急诊科。病⼈来看病， ⼀排队随便就是⼏个⼩时，我们也完全没法下班，发热⻔诊和急诊也都不分了，⼤ 厅⾥堆满了病⼈，抢救室输液室⾥到处都是病⼈。 还有的病⼈家属来了，说要⼀张床，我的爸爸在汽⻋⾥⾯不⾏了，因为那时候地下 ⻋库已封，他⻋⼦也堵着开不进来。我没办法，带着⼈和设备跑去汽⻋⾥去，⼀ 看，⼈已经死了，你说是什么感受，很难受很难受。这个⼈就死在汽⻋⾥，连下⻋ 的机会都没有。\"></a>那段时间急诊科的状况，经历过的⼈⼀辈⼦都忘不了，甚⾄会颠覆你的所有⼈⽣ 观。如果说这是打仗，急诊科就在最前线。但当时的情况是，后⾯的病区已经饱和了， 基本上⼀个病⼈都不收，ICU 也坚决不收，说⾥⾯有⼲净的病⼈，⼀进去就污染 了。病⼈不断地往急诊科涌，后⾯的路⼜不通，就全部堆在急诊科。病⼈来看病， ⼀排队随便就是⼏个⼩时，我们也完全没法下班，发热⻔诊和急诊也都不分了，⼤ 厅⾥堆满了病⼈，抢救室输液室⾥到处都是病⼈。 还有的病⼈家属来了，说要⼀张床，我的爸爸在汽⻋⾥⾯不⾏了，因为那时候地下 ⻋库已封，他⻋⼦也堵着开不进来。我没办法，带着⼈和设备跑去汽⻋⾥去，⼀ 看，⼈已经死了，你说是什么感受，很难受很难受。这个⼈就死在汽⻋⾥，连下⻋ 的机会都没有。</h5><h5 id=\"还有⼀位⽼⼈，⽼伴刚在⾦银潭医院去世了，她的⼉⼦、⼥⼉都被感染了，在打-针，照顾她的是⼥婿，⼀来我看她病得⾮常重，联系呼吸科给收进去住院，她⼥婿-⼀看就是个有⽂化有素质的⼈，过来跟我说谢谢医⽣等等的，我⼼⾥⼀紧，说快-去，根本耽误不了了。结果送去就去世了。⼀句谢谢虽然⼏秒钟，但也耽误了⼏-秒。这句谢谢压得我很沉重。-还有很多⼈把⾃⼰的家⼈送到监护室的时候，就是他们⻅的最后⼀⾯，你永远⻅不-着了。\"><a href=\"#还有⼀位⽼⼈，⽼伴刚在⾦银潭医院去世了，她的⼉⼦、⼥⼉都被感染了，在打-针，照顾她的是⼥婿，⼀来我看她病得⾮常重，联系呼吸科给收进去住院，她⼥婿-⼀看就是个有⽂化有素质的⼈，过来跟我说谢谢医⽣等等的，我⼼⾥⼀紧，说快-去，根本耽误不了了。结果送去就去世了。⼀句谢谢虽然⼏秒钟，但也耽误了⼏-秒。这句谢谢压得我很沉重。-还有很多⼈把⾃⼰的家⼈送到监护室的时候，就是他们⻅的最后⼀⾯，你永远⻅不-着了。\" class=\"headerlink\" title=\"还有⼀位⽼⼈，⽼伴刚在⾦银潭医院去世了，她的⼉⼦、⼥⼉都被感染了，在打 针，照顾她的是⼥婿，⼀来我看她病得⾮常重，联系呼吸科给收进去住院，她⼥婿 ⼀看就是个有⽂化有素质的⼈，过来跟我说谢谢医⽣等等的，我⼼⾥⼀紧，说快 去，根本耽误不了了。结果送去就去世了。⼀句谢谢虽然⼏秒钟，但也耽误了⼏ 秒。这句谢谢压得我很沉重。 还有很多⼈把⾃⼰的家⼈送到监护室的时候，就是他们⻅的最后⼀⾯，你永远⻅不 着了。\"></a>还有⼀位⽼⼈，⽼伴刚在⾦银潭医院去世了，她的⼉⼦、⼥⼉都被感染了，在打 针，照顾她的是⼥婿，⼀来我看她病得⾮常重，联系呼吸科给收进去住院，她⼥婿 ⼀看就是个有⽂化有素质的⼈，过来跟我说谢谢医⽣等等的，我⼼⾥⼀紧，说快 去，根本耽误不了了。结果送去就去世了。⼀句谢谢虽然⼏秒钟，但也耽误了⼏ 秒。这句谢谢压得我很沉重。 还有很多⼈把⾃⼰的家⼈送到监护室的时候，就是他们⻅的最后⼀⾯，你永远⻅不 着了。</h5><h5 id=\"我记得⼤年三⼗的早上我来交班，我说我们来照个相，纪念⼀下这个⼤年三⼗，还-发了个朋友圈。那天，⼤家都没有说什么祝福，这种时候，活着就是好的。\"><a href=\"#我记得⼤年三⼗的早上我来交班，我说我们来照个相，纪念⼀下这个⼤年三⼗，还-发了个朋友圈。那天，⼤家都没有说什么祝福，这种时候，活着就是好的。\" class=\"headerlink\" title=\"我记得⼤年三⼗的早上我来交班，我说我们来照个相，纪念⼀下这个⼤年三⼗，还 发了个朋友圈。那天，⼤家都没有说什么祝福，这种时候，活着就是好的。\"></a>我记得⼤年三⼗的早上我来交班，我说我们来照个相，纪念⼀下这个⼤年三⼗，还 发了个朋友圈。那天，⼤家都没有说什么祝福，这种时候，活着就是好的。</h5><h5 id=\"以前，你如果有⼀点失误，⽐如没有及时打针，病⼈都可能还去闹，现在没⼈了，-没有⼈跟你吵，没有⼈跟你闹了，所有⼈都被这种突然来的打击击垮了，搞蒙了。-病⼈死了，很少看到家属有很伤⼼地哭的，因为太多了，太多了。有些家属也不会-说医⽣求求你救救我的家⼈，⽽是跟医⽣说，唉，那就快点解脱吧，已经到了这个-地步。因为这时候每个⼈怕的都是⾃⼰被感染。\"><a href=\"#以前，你如果有⼀点失误，⽐如没有及时打针，病⼈都可能还去闹，现在没⼈了，-没有⼈跟你吵，没有⼈跟你闹了，所有⼈都被这种突然来的打击击垮了，搞蒙了。-病⼈死了，很少看到家属有很伤⼼地哭的，因为太多了，太多了。有些家属也不会-说医⽣求求你救救我的家⼈，⽽是跟医⽣说，唉，那就快点解脱吧，已经到了这个-地步。因为这时候每个⼈怕的都是⾃⼰被感染。\" class=\"headerlink\" title=\"以前，你如果有⼀点失误，⽐如没有及时打针，病⼈都可能还去闹，现在没⼈了， 没有⼈跟你吵，没有⼈跟你闹了，所有⼈都被这种突然来的打击击垮了，搞蒙了。 病⼈死了，很少看到家属有很伤⼼地哭的，因为太多了，太多了。有些家属也不会 说医⽣求求你救救我的家⼈，⽽是跟医⽣说，唉，那就快点解脱吧，已经到了这个 地步。因为这时候每个⼈怕的都是⾃⼰被感染。\"></a>以前，你如果有⼀点失误，⽐如没有及时打针，病⼈都可能还去闹，现在没⼈了， 没有⼈跟你吵，没有⼈跟你闹了，所有⼈都被这种突然来的打击击垮了，搞蒙了。 病⼈死了，很少看到家属有很伤⼼地哭的，因为太多了，太多了。有些家属也不会 说医⽣求求你救救我的家⼈，⽽是跟医⽣说，唉，那就快点解脱吧，已经到了这个 地步。因为这时候每个⼈怕的都是⾃⼰被感染。</h5><h5 id=\"⼀天发热⻔诊⻔⼝的排队，要排-5-个⼩时。正排着⼀个⼥的倒下了，看她穿着⽪-⾐，背着包包，穿着⾼跟鞋，应该是很讲究的⼀个中年⼥性，可是没有⼈敢上前去-扶她，就在地上躺了很久。只得我去喊护⼠、医⽣来去扶她。-1-⽉-30-号我早上来上班，⼀个⽩发⽼⼈的⼉⼦-32-岁死了，他就盯着看医⽣给他开死-亡证明。根本没有眼泪，怎么哭？没办法哭。看他的打扮，可能就是⼀个外来的打-⼯的，没有任何渠道去反映。没有确诊，他的⼉⼦，就变成了⼀张死亡证明。-这也是我想要去呼吁⼀下的。在急诊科死亡的病⼈都是没有诊断、没办法确诊的病-例，等这个疫情过去之后，我希望能给他们⼀个交代，给他们的家庭⼀些安抚，我-们的病⼈很可怜的，很可怜。\"><a href=\"#⼀天发热⻔诊⻔⼝的排队，要排-5-个⼩时。正排着⼀个⼥的倒下了，看她穿着⽪-⾐，背着包包，穿着⾼跟鞋，应该是很讲究的⼀个中年⼥性，可是没有⼈敢上前去-扶她，就在地上躺了很久。只得我去喊护⼠、医⽣来去扶她。-1-⽉-30-号我早上来上班，⼀个⽩发⽼⼈的⼉⼦-32-岁死了，他就盯着看医⽣给他开死-亡证明。根本没有眼泪，怎么哭？没办法哭。看他的打扮，可能就是⼀个外来的打-⼯的，没有任何渠道去反映。没有确诊，他的⼉⼦，就变成了⼀张死亡证明。-这也是我想要去呼吁⼀下的。在急诊科死亡的病⼈都是没有诊断、没办法确诊的病-例，等这个疫情过去之后，我希望能给他们⼀个交代，给他们的家庭⼀些安抚，我-们的病⼈很可怜的，很可怜。\" class=\"headerlink\" title=\"⼀天发热⻔诊⻔⼝的排队，要排 5 个⼩时。正排着⼀个⼥的倒下了，看她穿着⽪ ⾐，背着包包，穿着⾼跟鞋，应该是很讲究的⼀个中年⼥性，可是没有⼈敢上前去 扶她，就在地上躺了很久。只得我去喊护⼠、医⽣来去扶她。 1 ⽉ 30 号我早上来上班，⼀个⽩发⽼⼈的⼉⼦ 32 岁死了，他就盯着看医⽣给他开死 亡证明。根本没有眼泪，怎么哭？没办法哭。看他的打扮，可能就是⼀个外来的打 ⼯的，没有任何渠道去反映。没有确诊，他的⼉⼦，就变成了⼀张死亡证明。 这也是我想要去呼吁⼀下的。在急诊科死亡的病⼈都是没有诊断、没办法确诊的病 例，等这个疫情过去之后，我希望能给他们⼀个交代，给他们的家庭⼀些安抚，我 们的病⼈很可怜的，很可怜。\"></a>⼀天发热⻔诊⻔⼝的排队，要排 5 个⼩时。正排着⼀个⼥的倒下了，看她穿着⽪ ⾐，背着包包，穿着⾼跟鞋，应该是很讲究的⼀个中年⼥性，可是没有⼈敢上前去 扶她，就在地上躺了很久。只得我去喊护⼠、医⽣来去扶她。 1 ⽉ 30 号我早上来上班，⼀个⽩发⽼⼈的⼉⼦ 32 岁死了，他就盯着看医⽣给他开死 亡证明。根本没有眼泪，怎么哭？没办法哭。看他的打扮，可能就是⼀个外来的打 ⼯的，没有任何渠道去反映。没有确诊，他的⼉⼦，就变成了⼀张死亡证明。 这也是我想要去呼吁⼀下的。在急诊科死亡的病⼈都是没有诊断、没办法确诊的病 例，等这个疫情过去之后，我希望能给他们⼀个交代，给他们的家庭⼀些安抚，我 们的病⼈很可怜的，很可怜。</h5><h2 id=\"「幸运」\"><a href=\"#「幸运」\" class=\"headerlink\" title=\"「幸运」\"></a>「幸运」</h2><h5 id=\"做了这么多年医⽣，我⼀直觉得没有什么困难能够打倒我，这也和我的经历、个性-有关。\"><a href=\"#做了这么多年医⽣，我⼀直觉得没有什么困难能够打倒我，这也和我的经历、个性-有关。\" class=\"headerlink\" title=\"做了这么多年医⽣，我⼀直觉得没有什么困难能够打倒我，这也和我的经历、个性 有关。\"></a>做了这么多年医⽣，我⼀直觉得没有什么困难能够打倒我，这也和我的经历、个性 有关。</h5><h5 id=\"9-岁那年我爸爸就胃癌去世了，那个时候我就想着⻓⼤了当个医⽣去救别⼈的命。-后来⾼考的时候，我的志愿填的全部都是医学专业，最后考取了同济医学院。1997-年我⼤学毕业，就到了中⼼医院，之前在⼼⾎管内科⼯作，2010-年到急诊科当主任-的。我觉得急诊科就像我的⼀个孩⼦⼀样，我把它搞成这么⼤，搞得⼤家团结起来，做-成这个局⾯不容易，所以很珍惜，⾮常珍惜这个集体。\"><a href=\"#9-岁那年我爸爸就胃癌去世了，那个时候我就想着⻓⼤了当个医⽣去救别⼈的命。-后来⾼考的时候，我的志愿填的全部都是医学专业，最后考取了同济医学院。1997-年我⼤学毕业，就到了中⼼医院，之前在⼼⾎管内科⼯作，2010-年到急诊科当主任-的。我觉得急诊科就像我的⼀个孩⼦⼀样，我把它搞成这么⼤，搞得⼤家团结起来，做-成这个局⾯不容易，所以很珍惜，⾮常珍惜这个集体。\" class=\"headerlink\" title=\"9 岁那年我爸爸就胃癌去世了，那个时候我就想着⻓⼤了当个医⽣去救别⼈的命。 后来⾼考的时候，我的志愿填的全部都是医学专业，最后考取了同济医学院。1997 年我⼤学毕业，就到了中⼼医院，之前在⼼⾎管内科⼯作，2010 年到急诊科当主任 的。我觉得急诊科就像我的⼀个孩⼦⼀样，我把它搞成这么⼤，搞得⼤家团结起来，做 成这个局⾯不容易，所以很珍惜，⾮常珍惜这个集体。\"></a>9 岁那年我爸爸就胃癌去世了，那个时候我就想着⻓⼤了当个医⽣去救别⼈的命。 后来⾼考的时候，我的志愿填的全部都是医学专业，最后考取了同济医学院。1997 年我⼤学毕业，就到了中⼼医院，之前在⼼⾎管内科⼯作，2010 年到急诊科当主任 的。我觉得急诊科就像我的⼀个孩⼦⼀样，我把它搞成这么⼤，搞得⼤家团结起来，做 成这个局⾯不容易，所以很珍惜，⾮常珍惜这个集体。</h5><h5 id=\"前⼏天，我的⼀个护⼠发朋友圈说，好怀念以前忙碌的⼤急诊，那种忙跟这种忙完-全是两个概念。-在这次疫情之前，⼼梗、脑梗、消化道出⾎、外伤等等这些才是我们急诊的范畴。-那种忙是有成就感的忙，⽬的明确，针对各种类型的病⼈都有很通畅的流程，很成-熟，下⼀步⼲什么，怎么做，出了问题找哪⼀个。⽽这⼀次是这么多危重病⼈没办-法去处理，没办法收住院，⽽且我们医务⼈员还在这种⻛险之中，这种忙真的很⽆-奈，很痛⼼。\"><a href=\"#前⼏天，我的⼀个护⼠发朋友圈说，好怀念以前忙碌的⼤急诊，那种忙跟这种忙完-全是两个概念。-在这次疫情之前，⼼梗、脑梗、消化道出⾎、外伤等等这些才是我们急诊的范畴。-那种忙是有成就感的忙，⽬的明确，针对各种类型的病⼈都有很通畅的流程，很成-熟，下⼀步⼲什么，怎么做，出了问题找哪⼀个。⽽这⼀次是这么多危重病⼈没办-法去处理，没办法收住院，⽽且我们医务⼈员还在这种⻛险之中，这种忙真的很⽆-奈，很痛⼼。\" class=\"headerlink\" title=\"前⼏天，我的⼀个护⼠发朋友圈说，好怀念以前忙碌的⼤急诊，那种忙跟这种忙完 全是两个概念。 在这次疫情之前，⼼梗、脑梗、消化道出⾎、外伤等等这些才是我们急诊的范畴。 那种忙是有成就感的忙，⽬的明确，针对各种类型的病⼈都有很通畅的流程，很成 熟，下⼀步⼲什么，怎么做，出了问题找哪⼀个。⽽这⼀次是这么多危重病⼈没办 法去处理，没办法收住院，⽽且我们医务⼈员还在这种⻛险之中，这种忙真的很⽆ 奈，很痛⼼。\"></a>前⼏天，我的⼀个护⼠发朋友圈说，好怀念以前忙碌的⼤急诊，那种忙跟这种忙完 全是两个概念。 在这次疫情之前，⼼梗、脑梗、消化道出⾎、外伤等等这些才是我们急诊的范畴。 那种忙是有成就感的忙，⽬的明确，针对各种类型的病⼈都有很通畅的流程，很成 熟，下⼀步⼲什么，怎么做，出了问题找哪⼀个。⽽这⼀次是这么多危重病⼈没办 法去处理，没办法收住院，⽽且我们医务⼈员还在这种⻛险之中，这种忙真的很⽆ 奈，很痛⼼。</h5><h5 id=\"有⼀天早上-8-点，我们科⼀个年轻医⽣跟我发微信，也是蛮有性格的，说我今天不-来上班了，不舒服。因为我们这⾥都有规矩的，你不舒服要提前跟我说好安排，你-到-8-点钟跟我说，我到哪⾥去找⼈。他在微信中对我发脾⽓，说⼤量的⾼度疑似病例被你领导的急诊科放回社会，我们这是作孽！我理解他是因为作为医⽣的良知，-但我也急了，我说你可以去告我，如果你是急诊科主任，你该怎么办？-后来，这个医⽣休息了⼏天后，还是照样来⼯作。他不是说怕死怕累，⽽是遇到这-种情况，⼀下⼦⾯对这么多病⼈感到很崩溃。\"><a href=\"#有⼀天早上-8-点，我们科⼀个年轻医⽣跟我发微信，也是蛮有性格的，说我今天不-来上班了，不舒服。因为我们这⾥都有规矩的，你不舒服要提前跟我说好安排，你-到-8-点钟跟我说，我到哪⾥去找⼈。他在微信中对我发脾⽓，说⼤量的⾼度疑似病例被你领导的急诊科放回社会，我们这是作孽！我理解他是因为作为医⽣的良知，-但我也急了，我说你可以去告我，如果你是急诊科主任，你该怎么办？-后来，这个医⽣休息了⼏天后，还是照样来⼯作。他不是说怕死怕累，⽽是遇到这-种情况，⼀下⼦⾯对这么多病⼈感到很崩溃。\" class=\"headerlink\" title=\"有⼀天早上 8 点，我们科⼀个年轻医⽣跟我发微信，也是蛮有性格的，说我今天不 来上班了，不舒服。因为我们这⾥都有规矩的，你不舒服要提前跟我说好安排，你 到 8 点钟跟我说，我到哪⾥去找⼈。他在微信中对我发脾⽓，说⼤量的⾼度疑似病例被你领导的急诊科放回社会，我们这是作孽！我理解他是因为作为医⽣的良知， 但我也急了，我说你可以去告我，如果你是急诊科主任，你该怎么办？ 后来，这个医⽣休息了⼏天后，还是照样来⼯作。他不是说怕死怕累，⽽是遇到这 种情况，⼀下⼦⾯对这么多病⼈感到很崩溃。\"></a>有⼀天早上 8 点，我们科⼀个年轻医⽣跟我发微信，也是蛮有性格的，说我今天不 来上班了，不舒服。因为我们这⾥都有规矩的，你不舒服要提前跟我说好安排，你 到 8 点钟跟我说，我到哪⾥去找⼈。他在微信中对我发脾⽓，说⼤量的⾼度疑似病例被你领导的急诊科放回社会，我们这是作孽！我理解他是因为作为医⽣的良知， 但我也急了，我说你可以去告我，如果你是急诊科主任，你该怎么办？ 后来，这个医⽣休息了⼏天后，还是照样来⼯作。他不是说怕死怕累，⽽是遇到这 种情况，⼀下⼦⾯对这么多病⼈感到很崩溃。</h5><h5 id=\"作为医⽣来说，特别是后⾯很多来⽀援的医⽣，根本⼼理上受不了，碰到这种情况-懵了，有的医⽣、护⼠就哭。⼀个是哭别⼈，再⼀个也是哭⾃⼰，因为每个⼈都不-知道什么时候就轮到⾃⼰感染。-⼤概在-1-⽉中下旬，医院的领导也陆陆续续地都病倒了，包括我们的⻔办主任，三-位副院⻓。医务科科⻓的⼥⼉也病了，他也在家⾥休息。所以基本上那⼀段时间是-没有⼈管你，你就在那⼉战⽃吧，就是那种感觉。\"><a href=\"#作为医⽣来说，特别是后⾯很多来⽀援的医⽣，根本⼼理上受不了，碰到这种情况-懵了，有的医⽣、护⼠就哭。⼀个是哭别⼈，再⼀个也是哭⾃⼰，因为每个⼈都不-知道什么时候就轮到⾃⼰感染。-⼤概在-1-⽉中下旬，医院的领导也陆陆续续地都病倒了，包括我们的⻔办主任，三-位副院⻓。医务科科⻓的⼥⼉也病了，他也在家⾥休息。所以基本上那⼀段时间是-没有⼈管你，你就在那⼉战⽃吧，就是那种感觉。\" class=\"headerlink\" title=\"作为医⽣来说，特别是后⾯很多来⽀援的医⽣，根本⼼理上受不了，碰到这种情况 懵了，有的医⽣、护⼠就哭。⼀个是哭别⼈，再⼀个也是哭⾃⼰，因为每个⼈都不 知道什么时候就轮到⾃⼰感染。 ⼤概在 1 ⽉中下旬，医院的领导也陆陆续续地都病倒了，包括我们的⻔办主任，三 位副院⻓。医务科科⻓的⼥⼉也病了，他也在家⾥休息。所以基本上那⼀段时间是 没有⼈管你，你就在那⼉战⽃吧，就是那种感觉。\"></a>作为医⽣来说，特别是后⾯很多来⽀援的医⽣，根本⼼理上受不了，碰到这种情况 懵了，有的医⽣、护⼠就哭。⼀个是哭别⼈，再⼀个也是哭⾃⼰，因为每个⼈都不 知道什么时候就轮到⾃⼰感染。 ⼤概在 1 ⽉中下旬，医院的领导也陆陆续续地都病倒了，包括我们的⻔办主任，三 位副院⻓。医务科科⻓的⼥⼉也病了，他也在家⾥休息。所以基本上那⼀段时间是 没有⼈管你，你就在那⼉战⽃吧，就是那种感觉。</h5><h5 id=\"我身边的⼈也开始⼀个接⼀个地倒掉。1-⽉-18-⽇，早上-8-点半，我们倒的第⼀个医-⽣，他说主任我中招了，不烧，只做了-CT，肺部⼀⼤坨磨玻璃。不⼀会⼉，隔离病-房负责的⼀个责任护⼠，告诉我说他也倒了。晚上，我们的护⼠⻓也倒了。我当时-⾮常真实的第⼀感觉是——幸运，因为倒得早，可以早点下战场。\"><a href=\"#我身边的⼈也开始⼀个接⼀个地倒掉。1-⽉-18-⽇，早上-8-点半，我们倒的第⼀个医-⽣，他说主任我中招了，不烧，只做了-CT，肺部⼀⼤坨磨玻璃。不⼀会⼉，隔离病-房负责的⼀个责任护⼠，告诉我说他也倒了。晚上，我们的护⼠⻓也倒了。我当时-⾮常真实的第⼀感觉是——幸运，因为倒得早，可以早点下战场。\" class=\"headerlink\" title=\"我身边的⼈也开始⼀个接⼀个地倒掉。1 ⽉ 18 ⽇，早上 8 点半，我们倒的第⼀个医 ⽣，他说主任我中招了，不烧，只做了 CT，肺部⼀⼤坨磨玻璃。不⼀会⼉，隔离病 房负责的⼀个责任护⼠，告诉我说他也倒了。晚上，我们的护⼠⻓也倒了。我当时 ⾮常真实的第⼀感觉是——幸运，因为倒得早，可以早点下战场。\"></a>我身边的⼈也开始⼀个接⼀个地倒掉。1 ⽉ 18 ⽇，早上 8 点半，我们倒的第⼀个医 ⽣，他说主任我中招了，不烧，只做了 CT，肺部⼀⼤坨磨玻璃。不⼀会⼉，隔离病 房负责的⼀个责任护⼠，告诉我说他也倒了。晚上，我们的护⼠⻓也倒了。我当时 ⾮常真实的第⼀感觉是——幸运，因为倒得早，可以早点下战场。</h5><h5 id=\"这三个⼈我都密切接触过，我就是抱着必倒的信念每天在⼯作，结果⼀直没倒。全-院的⼈都觉得我是个奇迹。我⾃⼰分析了⼀下，可能是因为我本身有哮喘，在⽤⼀-些吸⼊性的激素，可能会抑制这些病毒在肺内沉积。-我总觉得我们做急诊的⼈都算是有情怀的⼈——在中国的医院，急诊科的地位在所-有科室当中应该是⽐较低的，因为⼤家觉得急诊，⽆⾮就是个通道，把病⼈收进去-就⾏了。这次抗疫中，这种忽视也⼀直都存在。\"><a href=\"#这三个⼈我都密切接触过，我就是抱着必倒的信念每天在⼯作，结果⼀直没倒。全-院的⼈都觉得我是个奇迹。我⾃⼰分析了⼀下，可能是因为我本身有哮喘，在⽤⼀-些吸⼊性的激素，可能会抑制这些病毒在肺内沉积。-我总觉得我们做急诊的⼈都算是有情怀的⼈——在中国的医院，急诊科的地位在所-有科室当中应该是⽐较低的，因为⼤家觉得急诊，⽆⾮就是个通道，把病⼈收进去-就⾏了。这次抗疫中，这种忽视也⼀直都存在。\" class=\"headerlink\" title=\"这三个⼈我都密切接触过，我就是抱着必倒的信念每天在⼯作，结果⼀直没倒。全 院的⼈都觉得我是个奇迹。我⾃⼰分析了⼀下，可能是因为我本身有哮喘，在⽤⼀ 些吸⼊性的激素，可能会抑制这些病毒在肺内沉积。 我总觉得我们做急诊的⼈都算是有情怀的⼈——在中国的医院，急诊科的地位在所 有科室当中应该是⽐较低的，因为⼤家觉得急诊，⽆⾮就是个通道，把病⼈收进去 就⾏了。这次抗疫中，这种忽视也⼀直都存在。\"></a>这三个⼈我都密切接触过，我就是抱着必倒的信念每天在⼯作，结果⼀直没倒。全 院的⼈都觉得我是个奇迹。我⾃⼰分析了⼀下，可能是因为我本身有哮喘，在⽤⼀ 些吸⼊性的激素，可能会抑制这些病毒在肺内沉积。 我总觉得我们做急诊的⼈都算是有情怀的⼈——在中国的医院，急诊科的地位在所 有科室当中应该是⽐较低的，因为⼤家觉得急诊，⽆⾮就是个通道，把病⼈收进去 就⾏了。这次抗疫中，这种忽视也⼀直都存在。</h5><h5 id=\"早期的时候，物资不够，有时候分给急诊科的防护服质量⾮常差，看到我们的护⼠-竟然穿着这种⾐服上班，我很⽣⽓，在周会群⾥⾯发脾⽓。后来还是好多主任把他-们⾃⼰科室藏的⾐服都给我了。-还有吃饭问题。病⼈多的时候管理混乱，他们根本想不到急诊科还差东⻄吃，很多-科室下班了都有吃的喝的，摆⼀⼤排，我们这⾥什么都没有，发热⻔诊的微信群-⾥，有医⽣抱怨，「我们急诊科只有纸尿裤……」我们在最前线战⽃，结果是这-样，有时候⼼⾥真的很⽓。\"><a href=\"#早期的时候，物资不够，有时候分给急诊科的防护服质量⾮常差，看到我们的护⼠-竟然穿着这种⾐服上班，我很⽣⽓，在周会群⾥⾯发脾⽓。后来还是好多主任把他-们⾃⼰科室藏的⾐服都给我了。-还有吃饭问题。病⼈多的时候管理混乱，他们根本想不到急诊科还差东⻄吃，很多-科室下班了都有吃的喝的，摆⼀⼤排，我们这⾥什么都没有，发热⻔诊的微信群-⾥，有医⽣抱怨，「我们急诊科只有纸尿裤……」我们在最前线战⽃，结果是这-样，有时候⼼⾥真的很⽓。\" class=\"headerlink\" title=\"早期的时候，物资不够，有时候分给急诊科的防护服质量⾮常差，看到我们的护⼠ 竟然穿着这种⾐服上班，我很⽣⽓，在周会群⾥⾯发脾⽓。后来还是好多主任把他 们⾃⼰科室藏的⾐服都给我了。 还有吃饭问题。病⼈多的时候管理混乱，他们根本想不到急诊科还差东⻄吃，很多 科室下班了都有吃的喝的，摆⼀⼤排，我们这⾥什么都没有，发热⻔诊的微信群 ⾥，有医⽣抱怨，「我们急诊科只有纸尿裤……」我们在最前线战⽃，结果是这 样，有时候⼼⾥真的很⽓。\"></a>早期的时候，物资不够，有时候分给急诊科的防护服质量⾮常差，看到我们的护⼠ 竟然穿着这种⾐服上班，我很⽣⽓，在周会群⾥⾯发脾⽓。后来还是好多主任把他 们⾃⼰科室藏的⾐服都给我了。 还有吃饭问题。病⼈多的时候管理混乱，他们根本想不到急诊科还差东⻄吃，很多 科室下班了都有吃的喝的，摆⼀⼤排，我们这⾥什么都没有，发热⻔诊的微信群 ⾥，有医⽣抱怨，「我们急诊科只有纸尿裤……」我们在最前线战⽃，结果是这 样，有时候⼼⾥真的很⽓。</h5><h5 id=\"我们这个集体真的是很好，⼤家都是只有⽣病了才下⽕线。这次，我们急诊科有-40-多个⼈感染了。我把所有⽣病的⼈建了⼀个群，本来叫「急诊⽣病群」，护⼠⻓说不吉利，改成「急诊加油群」。就是⽣病的⼈也没有很悲伤、很绝望、很抱怨的⼼-态，都是蛮积极的，就是⼤家互相帮助，共度难关那种⼼态。-这些孩⼦们、年轻⼈都⾮常好，就是跟着我受委屈了。我也希望这次疫情过后，国-家能加⼤对急诊科的投⼊，在很多国家的医疗体系中，急诊专业都是⾮常受重视-的。\"><a href=\"#我们这个集体真的是很好，⼤家都是只有⽣病了才下⽕线。这次，我们急诊科有-40-多个⼈感染了。我把所有⽣病的⼈建了⼀个群，本来叫「急诊⽣病群」，护⼠⻓说不吉利，改成「急诊加油群」。就是⽣病的⼈也没有很悲伤、很绝望、很抱怨的⼼-态，都是蛮积极的，就是⼤家互相帮助，共度难关那种⼼态。-这些孩⼦们、年轻⼈都⾮常好，就是跟着我受委屈了。我也希望这次疫情过后，国-家能加⼤对急诊科的投⼊，在很多国家的医疗体系中，急诊专业都是⾮常受重视-的。\" class=\"headerlink\" title=\"我们这个集体真的是很好，⼤家都是只有⽣病了才下⽕线。这次，我们急诊科有 40 多个⼈感染了。我把所有⽣病的⼈建了⼀个群，本来叫「急诊⽣病群」，护⼠⻓说不吉利，改成「急诊加油群」。就是⽣病的⼈也没有很悲伤、很绝望、很抱怨的⼼ 态，都是蛮积极的，就是⼤家互相帮助，共度难关那种⼼态。 这些孩⼦们、年轻⼈都⾮常好，就是跟着我受委屈了。我也希望这次疫情过后，国 家能加⼤对急诊科的投⼊，在很多国家的医疗体系中，急诊专业都是⾮常受重视 的。\"></a>我们这个集体真的是很好，⼤家都是只有⽣病了才下⽕线。这次，我们急诊科有 40 多个⼈感染了。我把所有⽣病的⼈建了⼀个群，本来叫「急诊⽣病群」，护⼠⻓说不吉利，改成「急诊加油群」。就是⽣病的⼈也没有很悲伤、很绝望、很抱怨的⼼ 态，都是蛮积极的，就是⼤家互相帮助，共度难关那种⼼态。 这些孩⼦们、年轻⼈都⾮常好，就是跟着我受委屈了。我也希望这次疫情过后，国 家能加⼤对急诊科的投⼊，在很多国家的医疗体系中，急诊专业都是⾮常受重视 的。</h5><p><img src=\"https://s1.ax1x.com/2020/03/12/8m0Ul8.png\" alt=\"8m0Ul8.png\"></p>\n<h2 id=\"不能达到的幸福\"><a href=\"#不能达到的幸福\" class=\"headerlink\" title=\"不能达到的幸福\"></a>不能达到的幸福</h2><h5 id=\"2-⽉-17-号，我收到了⼀条微信，是那个同济医院的同学发给我的，他跟我说「对不-起」，我说：幸好你传出去了，及时提醒了⼀部分⼈。他如果不传出去的话，可能-就没有李⽂亮他们这-8-个⼈，知道的⼈可能就会更少。\"><a href=\"#2-⽉-17-号，我收到了⼀条微信，是那个同济医院的同学发给我的，他跟我说「对不-起」，我说：幸好你传出去了，及时提醒了⼀部分⼈。他如果不传出去的话，可能-就没有李⽂亮他们这-8-个⼈，知道的⼈可能就会更少。\" class=\"headerlink\" title=\"2 ⽉ 17 号，我收到了⼀条微信，是那个同济医院的同学发给我的，他跟我说「对不 起」，我说：幸好你传出去了，及时提醒了⼀部分⼈。他如果不传出去的话，可能 就没有李⽂亮他们这 8 个⼈，知道的⼈可能就会更少。\"></a>2 ⽉ 17 号，我收到了⼀条微信，是那个同济医院的同学发给我的，他跟我说「对不 起」，我说：幸好你传出去了，及时提醒了⼀部分⼈。他如果不传出去的话，可能 就没有李⽂亮他们这 8 个⼈，知道的⼈可能就会更少。</h5><h5 id=\"这次，我们有三个⼥医⽣全家感染。两个⼥医⽣的公公、婆婆加⽼公感染，⼀个⼥-医⽣的爸爸、妈妈、姐姐、⽼公，加她⾃⼰-5-个⼈感染。⼤家都觉得这么早就发现-这个病毒，结果却是这样，造成这么⼤的损失，代价太惨重了。-这种代价体现在⽅⽅⾯⾯。除了去世的⼈，患病的⼈也在承受。-我们「急诊加油群」⾥，⼤家经常会交流身体状况，有⼈问⼼率总在-120-次-分，要-不要紧？那肯定要紧，⼀动就⼼慌，这对他们终身都会有影响的，以后年纪⼤了会不会⼼衰？这都不好说。以后别⼈可以去爬⼭，出去旅游，他们可能就不⾏，那都是有可能的。\"><a href=\"#这次，我们有三个⼥医⽣全家感染。两个⼥医⽣的公公、婆婆加⽼公感染，⼀个⼥-医⽣的爸爸、妈妈、姐姐、⽼公，加她⾃⼰-5-个⼈感染。⼤家都觉得这么早就发现-这个病毒，结果却是这样，造成这么⼤的损失，代价太惨重了。-这种代价体现在⽅⽅⾯⾯。除了去世的⼈，患病的⼈也在承受。-我们「急诊加油群」⾥，⼤家经常会交流身体状况，有⼈问⼼率总在-120-次-分，要-不要紧？那肯定要紧，⼀动就⼼慌，这对他们终身都会有影响的，以后年纪⼤了会不会⼼衰？这都不好说。以后别⼈可以去爬⼭，出去旅游，他们可能就不⾏，那都是有可能的。\" class=\"headerlink\" title=\"这次，我们有三个⼥医⽣全家感染。两个⼥医⽣的公公、婆婆加⽼公感染，⼀个⼥ 医⽣的爸爸、妈妈、姐姐、⽼公，加她⾃⼰ 5 个⼈感染。⼤家都觉得这么早就发现 这个病毒，结果却是这样，造成这么⼤的损失，代价太惨重了。 这种代价体现在⽅⽅⾯⾯。除了去世的⼈，患病的⼈也在承受。 我们「急诊加油群」⾥，⼤家经常会交流身体状况，有⼈问⼼率总在 120 次/分，要 不要紧？那肯定要紧，⼀动就⼼慌，这对他们终身都会有影响的，以后年纪⼤了会不会⼼衰？这都不好说。以后别⼈可以去爬⼭，出去旅游，他们可能就不⾏，那都是有可能的。\"></a>这次，我们有三个⼥医⽣全家感染。两个⼥医⽣的公公、婆婆加⽼公感染，⼀个⼥ 医⽣的爸爸、妈妈、姐姐、⽼公，加她⾃⼰ 5 个⼈感染。⼤家都觉得这么早就发现 这个病毒，结果却是这样，造成这么⼤的损失，代价太惨重了。 这种代价体现在⽅⽅⾯⾯。除了去世的⼈，患病的⼈也在承受。 我们「急诊加油群」⾥，⼤家经常会交流身体状况，有⼈问⼼率总在 120 次/分，要 不要紧？那肯定要紧，⼀动就⼼慌，这对他们终身都会有影响的，以后年纪⼤了会不会⼼衰？这都不好说。以后别⼈可以去爬⼭，出去旅游，他们可能就不⾏，那都是有可能的。</h5><h5 id=\"还有武汉。你说我们武汉是个多热闹的地⽅，现在⼀路上都是安安静静的，很多东-⻄买不到，还搞得全国都来⽀援。前⼏天⼴⻄的⼀个医疗队的护⼠在⼯作的时候突-然昏迷了，抢救，后来⼈⼼跳有了，但还是在昏迷。她如果不来的话，在家⾥可以-过得好好的，也不会出这种意外。所以，我觉得我们⽋⼤家的⼈情，真的是。\"><a href=\"#还有武汉。你说我们武汉是个多热闹的地⽅，现在⼀路上都是安安静静的，很多东-⻄买不到，还搞得全国都来⽀援。前⼏天⼴⻄的⼀个医疗队的护⼠在⼯作的时候突-然昏迷了，抢救，后来⼈⼼跳有了，但还是在昏迷。她如果不来的话，在家⾥可以-过得好好的，也不会出这种意外。所以，我觉得我们⽋⼤家的⼈情，真的是。\" class=\"headerlink\" title=\"还有武汉。你说我们武汉是个多热闹的地⽅，现在⼀路上都是安安静静的，很多东 ⻄买不到，还搞得全国都来⽀援。前⼏天⼴⻄的⼀个医疗队的护⼠在⼯作的时候突 然昏迷了，抢救，后来⼈⼼跳有了，但还是在昏迷。她如果不来的话，在家⾥可以 过得好好的，也不会出这种意外。所以，我觉得我们⽋⼤家的⼈情，真的是。\"></a>还有武汉。你说我们武汉是个多热闹的地⽅，现在⼀路上都是安安静静的，很多东 ⻄买不到，还搞得全国都来⽀援。前⼏天⼴⻄的⼀个医疗队的护⼠在⼯作的时候突 然昏迷了，抢救，后来⼈⼼跳有了，但还是在昏迷。她如果不来的话，在家⾥可以 过得好好的，也不会出这种意外。所以，我觉得我们⽋⼤家的⼈情，真的是。</h5><h5 id=\"经历过这次的疫情，对医院⾥很多⼈的打击都⾮常⼤。我下⾯好⼏个医务⼈员都有-了辞职的想法，包括⼀些⻣⼲。⼤家之前对于这个职业的那些观念、常识都难免有-点动摇——就是你这么努⼒⼯作到底对不对？就像江学庆⼀样，他⼯作太认真，太-对病⼈好，每⼀年的过年过节都在做⼿术。今天有⼈发⼀个江学庆⼥⼉写的微信，-说她爸爸的时间全部给了病⼈。-我⾃⼰也有过⽆数次的念头，是不是也回到家做个家庭主妇？疫情之后，我基本上-没回家，和我⽼公住在外⾯，我妹妹在家帮我照顾孩⼦。我的⼆宝都不认得我了，-他看视频对我没感觉，我很失落，我⽣这个⼆胎不容易，出⽣的时候他有-10-⽄，妊-娠糖尿病我也得了，原本我还⼀直喂奶的，这⼀次也断了奶——做这个决定的时-候，我有点难过，我⽼公就跟我说，他说⼈的⼀⽣能够遇到⼀件这样的事情，并且-你不光是参与者，你还要带⼀个团队去打这场仗，那也是⼀件很有意义的事情，等-将来⼀切都恢复正常以后⼤家再去回忆，也是⼀个很宝贵的经历。\"><a href=\"#经历过这次的疫情，对医院⾥很多⼈的打击都⾮常⼤。我下⾯好⼏个医务⼈员都有-了辞职的想法，包括⼀些⻣⼲。⼤家之前对于这个职业的那些观念、常识都难免有-点动摇——就是你这么努⼒⼯作到底对不对？就像江学庆⼀样，他⼯作太认真，太-对病⼈好，每⼀年的过年过节都在做⼿术。今天有⼈发⼀个江学庆⼥⼉写的微信，-说她爸爸的时间全部给了病⼈。-我⾃⼰也有过⽆数次的念头，是不是也回到家做个家庭主妇？疫情之后，我基本上-没回家，和我⽼公住在外⾯，我妹妹在家帮我照顾孩⼦。我的⼆宝都不认得我了，-他看视频对我没感觉，我很失落，我⽣这个⼆胎不容易，出⽣的时候他有-10-⽄，妊-娠糖尿病我也得了，原本我还⼀直喂奶的，这⼀次也断了奶——做这个决定的时-候，我有点难过，我⽼公就跟我说，他说⼈的⼀⽣能够遇到⼀件这样的事情，并且-你不光是参与者，你还要带⼀个团队去打这场仗，那也是⼀件很有意义的事情，等-将来⼀切都恢复正常以后⼤家再去回忆，也是⼀个很宝贵的经历。\" class=\"headerlink\" title=\"经历过这次的疫情，对医院⾥很多⼈的打击都⾮常⼤。我下⾯好⼏个医务⼈员都有 了辞职的想法，包括⼀些⻣⼲。⼤家之前对于这个职业的那些观念、常识都难免有 点动摇——就是你这么努⼒⼯作到底对不对？就像江学庆⼀样，他⼯作太认真，太 对病⼈好，每⼀年的过年过节都在做⼿术。今天有⼈发⼀个江学庆⼥⼉写的微信， 说她爸爸的时间全部给了病⼈。 我⾃⼰也有过⽆数次的念头，是不是也回到家做个家庭主妇？疫情之后，我基本上 没回家，和我⽼公住在外⾯，我妹妹在家帮我照顾孩⼦。我的⼆宝都不认得我了， 他看视频对我没感觉，我很失落，我⽣这个⼆胎不容易，出⽣的时候他有 10 ⽄，妊 娠糖尿病我也得了，原本我还⼀直喂奶的，这⼀次也断了奶——做这个决定的时 候，我有点难过，我⽼公就跟我说，他说⼈的⼀⽣能够遇到⼀件这样的事情，并且 你不光是参与者，你还要带⼀个团队去打这场仗，那也是⼀件很有意义的事情，等 将来⼀切都恢复正常以后⼤家再去回忆，也是⼀个很宝贵的经历。\"></a>经历过这次的疫情，对医院⾥很多⼈的打击都⾮常⼤。我下⾯好⼏个医务⼈员都有 了辞职的想法，包括⼀些⻣⼲。⼤家之前对于这个职业的那些观念、常识都难免有 点动摇——就是你这么努⼒⼯作到底对不对？就像江学庆⼀样，他⼯作太认真，太 对病⼈好，每⼀年的过年过节都在做⼿术。今天有⼈发⼀个江学庆⼥⼉写的微信， 说她爸爸的时间全部给了病⼈。 我⾃⼰也有过⽆数次的念头，是不是也回到家做个家庭主妇？疫情之后，我基本上 没回家，和我⽼公住在外⾯，我妹妹在家帮我照顾孩⼦。我的⼆宝都不认得我了， 他看视频对我没感觉，我很失落，我⽣这个⼆胎不容易，出⽣的时候他有 10 ⽄，妊 娠糖尿病我也得了，原本我还⼀直喂奶的，这⼀次也断了奶——做这个决定的时 候，我有点难过，我⽼公就跟我说，他说⼈的⼀⽣能够遇到⼀件这样的事情，并且 你不光是参与者，你还要带⼀个团队去打这场仗，那也是⼀件很有意义的事情，等 将来⼀切都恢复正常以后⼤家再去回忆，也是⼀个很宝贵的经历。</h5><h5 id=\"2-⽉-21-号早上领导和我谈话，其实我想问⼏个问题，⽐如有没有觉得那天批评我批-评错了？我希望能够给我⼀个道歉。但是我不敢问。没有⼈在任何场合跟我说表示-抱歉这句话。但我依然觉得，这次的事情更加说明了每个⼈还是要坚持⾃⼰独⽴的-思想，因为要有⼈站出来说真话，必须要有⼈，这个世界必须要有不同的声⾳，是-吧？作为武汉⼈，我们哪⼀个不热爱⾃⼰的城市？我们现在回想起来以前过得那种最普-通的⽣活，是多么奢侈的幸福。我现在觉得把宝宝抱着，陪他出去玩⼀下滑梯或者-跟⽼公出去看个电影，在以前再平常都不过，到现在来说都是⼀种幸福，都是不能-达到的幸福。\"><a href=\"#2-⽉-21-号早上领导和我谈话，其实我想问⼏个问题，⽐如有没有觉得那天批评我批-评错了？我希望能够给我⼀个道歉。但是我不敢问。没有⼈在任何场合跟我说表示-抱歉这句话。但我依然觉得，这次的事情更加说明了每个⼈还是要坚持⾃⼰独⽴的-思想，因为要有⼈站出来说真话，必须要有⼈，这个世界必须要有不同的声⾳，是-吧？作为武汉⼈，我们哪⼀个不热爱⾃⼰的城市？我们现在回想起来以前过得那种最普-通的⽣活，是多么奢侈的幸福。我现在觉得把宝宝抱着，陪他出去玩⼀下滑梯或者-跟⽼公出去看个电影，在以前再平常都不过，到现在来说都是⼀种幸福，都是不能-达到的幸福。\" class=\"headerlink\" title=\"2 ⽉ 21 号早上领导和我谈话，其实我想问⼏个问题，⽐如有没有觉得那天批评我批 评错了？我希望能够给我⼀个道歉。但是我不敢问。没有⼈在任何场合跟我说表示 抱歉这句话。但我依然觉得，这次的事情更加说明了每个⼈还是要坚持⾃⼰独⽴的 思想，因为要有⼈站出来说真话，必须要有⼈，这个世界必须要有不同的声⾳，是 吧？作为武汉⼈，我们哪⼀个不热爱⾃⼰的城市？我们现在回想起来以前过得那种最普 通的⽣活，是多么奢侈的幸福。我现在觉得把宝宝抱着，陪他出去玩⼀下滑梯或者 跟⽼公出去看个电影，在以前再平常都不过，到现在来说都是⼀种幸福，都是不能 达到的幸福。\"></a>2 ⽉ 21 号早上领导和我谈话，其实我想问⼏个问题，⽐如有没有觉得那天批评我批 评错了？我希望能够给我⼀个道歉。但是我不敢问。没有⼈在任何场合跟我说表示 抱歉这句话。但我依然觉得，这次的事情更加说明了每个⼈还是要坚持⾃⼰独⽴的 思想，因为要有⼈站出来说真话，必须要有⼈，这个世界必须要有不同的声⾳，是 吧？作为武汉⼈，我们哪⼀个不热爱⾃⼰的城市？我们现在回想起来以前过得那种最普 通的⽣活，是多么奢侈的幸福。我现在觉得把宝宝抱着，陪他出去玩⼀下滑梯或者 跟⽼公出去看个电影，在以前再平常都不过，到现在来说都是⼀种幸福，都是不能 达到的幸福。</h5><h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><blockquote>\n<p>这是我们所处的世界,无比真实却无可奈何,现在连说真话的权利都要被封杀,被和谐,我反反复复看了这篇文章,在此传播真实的声音,这篇文章不会被删除,希望大家能平安健康。</p>\n</blockquote>\n"},{"title":"Vuex框架原理与源码分析","date":"2017-08-24T07:50:00.000Z","_content":"\nVuex 是一个专为 Vue 服务，用于管理页面数据状态、提供统一数据操作的生态系统。它集中于 MVC 模式中的 Model 层，规定所有的数据操作必须通过  `action - mutation - state change`  的流程来进行，再结合 Vue 的数据视图双向绑定特性来实现页面的展示更新。统一的页面状态管理以及操作处理，可以让复杂的组件交互变得简单清晰，同时可在调试模式下进行时光机般的倒退前进操作，查看数据改变过程，使 code debug 更加方便。\n\n最近在开发的项目中用到了 Vuex 来管理整体页面状态，遇到了很多问题。决定研究下源码，在答疑解惑之外，能深入学习其实现原理。\n\n先将问题抛出来，使学习和研究更有针对性：\n\n1.  使用 Vuex 只需执行  `Vue.use(Vuex)`，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？\n2.  state 内部是如何实现支持模块配置和模块嵌套的？\n3.  在执行 dispatch 触发 action（commit 同理）的时候，只需传入（type, payload），action 执行函数中第一个参数 store 从哪里获取的？\n4.  如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？\n5.  调试时的“时空穿梭”功能是如何实现的？\n\n> 注：本文对有 Vuex 有实际使用经验的同学帮助更大，能更清晰理解 Vuex 的工作流程和原理，使用起来更得心应手。初次接触的同学，可以先参考 Vuex[官方文档](http://vuex.vuejs.org/)进行基础概念的学习。\n\n## 一、框架核心流程\n\n进行源码分析之前，先了解一下官方文档中提供的核心思想图，它也代表着整个 Vuex 框架的运行流程。  \n![vuex-core](http://www.jixiaokang.com/wp-content/uploads/2018/05/vuex.png)  \n如图示，Vuex 为 Vue Components 建立起了一个完整的生态圈，包括开发中的 API 调用一环。围绕这个生态圈，简要介绍一下各模块在核心流程中的主要功能：\n\n- Vue Components：Vue 组件。HTML 页面上，负责接收用户操作等交互行为，执行 dispatch 方法触发对应 action 进行回应。\n- dispatch：操作行为触发方法，是唯一能执行 action 的方法。\n- actions：操作行为处理模块。负责处理 Vue Components 接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台 API 请求的操作就在这个模块中进行，包括触发其他 action 以及提交 mutation 的操作。该模块提供了 Promise 的封装，以支持 action 的链式触发。\n- commit：状态改变提交操作方法。对 mutation 进行提交，是唯一能执行 mutation 的方法。\n- mutations：状态改变操作方法。是 Vuex 修改 state 的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些 hook 暴露出来，以进行 state 的监控等。\n- state：页面状态管理容器对象。集中存储 Vue components 中 data 对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用 Vue 的细粒度数据响应机制来进行高效的状态更新。\n- getters：state 对象读取方法。图中没有单独列出该模块，应该被包含在了 render 中，Vue Components 通过该方法读取全局 state 对象。\n\n> Vue 组件接收交互行为，调用 dispatch 方法触发 action 相关处理，若页面状态需要改变，则调用 commit 方法提交 mutation 修改 state，通过 getters 获取到 state 新值，重新渲染 Vue Components，界面随之更新。\n\n## 二、目录结构介绍\n\n打开 Vuex 项目，看下源码目录结构。\n\n![dir_structure](http://www.jixiaokang.com/wp-content/uploads/2018/05/vuex_src.jpg)\n\nVuex 提供了非常强大的状态管理功能，源码代码量却不多，目录结构划分也很清晰。先大体介绍下各个目录文件的功能：\n\n- module：提供 module 对象与 module 对象树的创建功能；\n- plugins：提供开发辅助插件，如“时光穿梭”功能，state 修改的日志记录功能等；\n- helpers.js：提供 action、mutations 以及 getters 的查找 API；\n- index.js：是源码主入口文件，提供 store 的各 module 构建安装；\n- mixin.js：提供了 store 在 Vue 实例上的装载注入；\n- util.js：提供了工具方法如 find、deepCopy、forEachValue 以及 assert 等方法。\n\n## 三、初始化装载与注入\n\n了解大概的目录及对应功能后，下面开始进行源码分析。[index.js](https://github.com/vuejs/vuex/blob/dev/src/index.js)中包含了所有的核心代码，从该文件入手进行分析。\n\n### 3.1 装载实例\n\n先看个简单的例子：\n\n    /**\n     *  store.js文件\n     *  创建store对象，配置state、action、mutation以及getter\n     *\n     **/\n\n    import Vue from 'vue'\n    import Vuex from 'vuex'\n\n    // install Vuex框架\n    Vue.use(Vuex)\n\n    // 创建并导出store对象。为了方便，不配置任何参数\n    export default new Vuex.Store()\n\nstore.js 文件中，加载 Vuex 框架，创建并导出一个空配置的 store 对象实例。\n\n    /**\n     *  vue-index.js文件\n     *\n     *\n     **/\n\n    import Vue from 'vue'\n    import App from './../pages/app.vue'\n    import store from './store.js'\n\n    new Vue({\n      el: '#root',\n      router,\n      store,\n      render: h => h(App)\n    })\n\n然后在 index.js 中，正常初始化一个页面根级别的 Vue 组件，传入这个自定义的 store 对象。\n\n如**问题 1**所述，以上实例除了 Vue 的初始化代码，只是多了一个 store 对象的传入。一起看下源码中的实现方式。\n\n### 3.2 装载分析\n\nindex.js 文件代码执行开头，定义局部 Vue 变量，用于判断是否已经装载和减少全局作用域查找。\n\n    let Vue\n\n然后判断若处于浏览器环境下且加载过 Vue，则执行 install 方法。\n\n    // auto install in dist mode\n    if (typeof window !== 'undefined' && window.Vue) {\n      install(window.Vue)\n    }\n\ninstall 方法将 Vuex 装载到 Vue 对象上，`Vue.use(Vuex)`  也是通过它执行，先看下 Vue.use 方法实现：\n\n    function (plugin: Function | Object) {\n      /* istanbul ignore if */\n      if (plugin.installed) {\n        return\n      }\n      // additional parameters\n      const args = toArray(arguments, 1)\n      args.unshift(this)\n      if (typeof plugin.install === 'function') {\n        // 实际执行插件的install方法\n        plugin.install.apply(plugin, args)\n      } else {\n        plugin.apply(null, args)\n      }\n      plugin.installed = true\n      return this\n    }\n\n若是首次加载，将局部 Vue 变量赋值为全局的 Vue 对象，并执行 applyMixin 方法，install 实现如下：\n\n    function install (_Vue) {\n      if (Vue) {\n        console.error(\n          '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n        )\n        return\n      }\n      Vue = _Vue\n      applyMixin(Vue)\n    }\n\n来看下 applyMixin 方法内部代码。如果是 2.x.x 以上版本，可以使用 hook 的形式进行注入，或使用封装并替换 Vue 对象原型的\\_init 方法，实现注入。\n\n    export default function (Vue) {\n      const version = Number(Vue.version.split('.')[0])\n\n      if (version >= 2) {\n        const usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1\n        Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit })\n      } else {\n        // override init and inject vuex init procedure\n        // for 1.x backwards compatibility.\n        const _init = Vue.prototype._init\n        Vue.prototype._init = function (options = {}) {\n          options.init = options.init\n            ? [vuexInit].concat(options.init)\n            : vuexInit\n          _init.call(this, options)\n        }\n      }\n\n具体实现：将初始化 Vue 根组件时传入的 store 设置到 this 对象的$store属性上，子组件从其父组件引用$store 属性，层层嵌套进行设置。在任意组件中执行  `this.$store`  都能找到装载的那个 store 对象，vuexInit 方法实现如下：\n\n    function vuexInit () {\n      const options = this.$options\n      // store injection\n      if (options.store) {\n        this.$store = options.store\n      } else if (options.parent && options.parent.$store) {\n        this.$store = options.parent.$store\n      }\n    }\n\n看个图例理解下 store 的传递。\n\n页面 Vue 结构图：  \n![cart_vue_structure](http://www.jixiaokang.com/wp-content/uploads/2018/05/shopping_cart_vue.jpg)\n\n对应 store 流向：  \n![cart_vue_structure](http://www.jixiaokang.com/wp-content/uploads/2018/05/store_flow2.jpg)\n\n## 四、store 对象构造\n\n上面对 Vuex 框架的装载以及注入自定义 store 对象进行分析，解决了**问题 1**。接下来详细分析 store 对象的内部功能和具体实现，来解答  **为什么 actions、getters、mutations 中能从 arguments\\[0\\]中拿到 store 的相关数据?**  等问题。\n\nstore 对象实现逻辑比较复杂，先看下构造方法的整体逻辑流程来帮助后面的理解：\n\n![cart_vue_structure](http://www.jixiaokang.com/wp-content/uploads/2018/05/4.5_flow.jpg)\n\n### 4.1 环境判断\n\n开始分析 store 的构造函数，分小节逐函数逐行的分析其功能。\n\n    constructor (options = {}) {\n      assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)\n      assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)\n\n在 store 构造函数中执行环境判断，以下都是 Vuex 工作的必要条件：\n\n1.  已经执行安装函数进行装载；\n2.  支持 Promise 语法。\n\nassert 函数是一个简单的断言函数的实现，一行代码即可实现。\n\n    function assert (condition, msg) {\n      if (!condition) throw new Error(`[vuex] ${msg}`)\n    }\n\n### 4.2 数据初始化、module 树构造\n\n环境判断后，根据 new 构造传入的 options 或默认值，初始化内部数据。\n\n    const {\n        state = {},\n        plugins = [],\n        strict = false\n    } = options\n\n    // store internal state\n    this._committing = false // 是否在进行提交状态标识\n    this._actions = Object.create(null) // acitons操作对象\n    this._mutations = Object.create(null) // mutations操作对象\n    this._wrappedGetters = Object.create(null) // 封装后的getters集合对象\n    this._modules = new ModuleCollection(options) // Vuex支持store分模块传入，存储分析后的modules\n    this._modulesNamespaceMap = Object.create(null) // 模块命名空间map\n    this._subscribers = [] // 订阅函数集合，Vuex提供了subscribe功能\n    this._watcherVM = new Vue() // Vue组件用于watch监视变化\n\n调用  `new Vuex.store(options)`  时传入的 options 对象，用于构造 ModuleCollection 类，下面看看其功能。\n\n    constructor (rawRootModule) {\n      // register root module (Vuex.Store options)\n      this.root = new Module(rawRootModule, false)\n\n      // register all nested modules\n      if (rawRootModule.modules) {\n        forEachValue(rawRootModule.modules, (rawModule, key) => {\n          this.register([key], rawModule, false)\n        })\n      }\n\nModuleCollection 主要将传入的 options 对象整个构造为一个 module 对象，并循环调用  `this.register([key], rawModule, false)`  为其中的 modules 属性进行模块注册，使其都成为 module 对象，最后 options 对象被构造成一个完整的组件树。ModuleCollection 类还提供了 modules 的更替功能，详细实现可以查看源文件[module-collection.js](https://github.com/vuejs/vuex/blob/dev/src/module/module-collection.js)。\n\n### 4.3 dispatch 与 commit 设置\n\n继续回到 store 的构造函数代码。\n\n    // bind commit and dispatch to self\n    const store = this\n    const { dispatch, commit } = this\n\n    this.dispatch = function boundDispatch (type, payload) {\n      return dispatch.call(store, type, payload)\n    }\n\n    this.commit = function boundCommit (type, payload, options) {\n      return commit.call(store, type, payload, options)\n    }\n\n封装替换原型中的 dispatch 和 commit 方法，将 this 指向当前 store 对象。dispatch 和 commit 方法具体实现如下：\n\n    dispatch (_type, _payload) {\n      // check object-style dispatch\n      const {\n          type,\n          payload\n      } = unifyObjectStyle(_type, _payload) // 配置参数处理\n\n      // 当前type下所有action处理函数集合\n      const entry = this._actions[type]\n      if (!entry) {\n        console.error(`[vuex] unknown action type: ${type}`)\n        return\n      }\n      return entry.length > 1\n          ? Promise.all(entry.map(handler => handler(payload)))\n          : entry[0](payload)\n    }\n\n前面提到，dispatch 的功能是触发并传递一些参数（payload）给对应 type 的 action。因为其支持 2 种调用方法，所以在 dispatch 中，先进行参数的适配处理，然后判断 action type 是否存在，若存在就逐个执行（注：上面代码中的`this._actions[type]`  以及 下面的  `this._mutations[type]`  均是处理过的函数集合，具体内容留到后面进行分析）。\n\ncommit 方法和 dispatch 相比虽然都是触发 type，但是对应的处理却相对复杂，代码如下。\n\n    commit (_type, _payload, _options) {\n      // check object-style commit\n      const {\n          type,\n          payload,\n          options\n      } = unifyObjectStyle(_type, _payload, _options)\n\n      const mutation = { type, payload }\n      const entry = this._mutations[type]\n      if (!entry) {\n        console.error(`[vuex] unknown mutation type: ${type}`)\n        return\n      }\n      // 专用修改state方法，其他修改state方法均是非法修改\n      this._withCommit(() => {\n        entry.forEach(function commitIterator (handler) {\n          handler(payload)\n        })\n      })\n\n      // 订阅者函数遍历执行，传入当前的mutation对象和当前的state\n      this._subscribers.forEach(sub => sub(mutation, this.state))\n\n      if (options && options.silent) {\n        console.warn(\n            `[vuex] mutation type: ${type}. Silent option has been removed. ` +\n            'Use the filter functionality in the vue-devtools'\n        )\n      }\n    }\n\n该方法同样支持 2 种调用方法。先进行参数适配，判断触发 mutation type，利用\\_withCommit 方法执行本次批量触发 mutation 处理函数，并传入 payload 参数。执行完成后，通知所有\\_subscribers（订阅函数）本次操作的 mutation 对象以及当前的 state 状态，如果传入了已经移除的 silent 选项则进行提示警告。\n\n### 4.4 state 修改方法\n\n\\_withCommit 是一个代理方法，所有触发 mutation 的进行 state 修改的操作都经过它，由此来统一管理监控 state 状态的修改。实现代码如下。\n\n    _withCommit (fn) {\n      // 保存之前的提交状态\n      const committing = this._committing\n\n      // 进行本次提交，若不设置为true，直接修改state，strict模式下，Vuex将会产生非法修改state的警告\n      this._committing = true\n\n      // 执行state的修改操作\n      fn()\n\n      // 修改完成，还原本次修改之前的状态\n      this._committing = committing\n    }\n\n缓存执行时的 committing 状态将当前状态设置为 true 后进行本次提交操作，待操作完毕后，将 committing 状态还原为之前的状态。\n\n### 4.5 module 安装\n\n绑定 dispatch 和 commit 方法之后，进行严格模式的设置，以及模块的安装（installModule）。由于占用资源较多影响页面性能，严格模式建议只在开发模式开启，上线后需要关闭。\n\n    // strict mode\n    this.strict = strict\n\n    // init root module.\n    // this also recursively registers all sub-modules\n    // and collects all module getters inside this._wrappedGetters\n    installModule(this, state, [], this._modules.root)\n\n#### 4.5.1 初始化 rootState\n\n上述代码的备注中，提到 installModule 方法初始化组件树根组件、注册所有子组件，并将其中所有的 getters 存储到 this.\\_wrappedGetters 属性中，让我们看看其中的代码实现。\n\n    function installModule (store, rootState, path, module, hot) {\n      const isRoot = !path.length\n      const namespace = store._modules.getNamespace(path)\n\n      // register in namespace map\n      if (namespace) {\n        store._modulesNamespaceMap[namespace] = module\n      }\n\n      // 非根组件设置 state 方法\n      if (!isRoot && !hot) {\n        const parentState = getNestedState(rootState, path.slice(0, -1))\n        const moduleName = path[path.length - 1]\n        store._withCommit(() => {\n          Vue.set(parentState, moduleName, module.state)\n        })\n      }\n\n      ······\n\n判断是否是根目录，以及是否设置了命名空间，若存在则在 namespace 中进行 module 的存储，在不是根组件且不是 hot 条件的情况下，通过 getNestedState 方法拿到该 module 父级的 state，拿到其所在的 moduleName ，调用  `Vue.set(parentState, moduleName, module.state)`  方法将其 state 设置到父级 state 对象的 moduleName 属性中，由此实现该模块的 state 注册（首次执行这里，因为是根目录注册，所以并不会执行该条件中的方法）。getNestedState 方法代码很简单，分析 path 拿到 state，如下。\n\n    function getNestedState (state, path) {\n      return path.length\n        ? path.reduce((state, key) => state[key], state)\n        : state\n    }\n\n#### 4.5.2 module 上下文环境设置\n\n    const local = module.context = makeLocalContext(store, namespace, path)\n\n命名空间和根目录条件判断完毕后，接下来定义 local 变量和 module.context 的值，执行 makeLocalContext 方法，为该 module 设置局部的 dispatch、commit 方法以及 getters 和 state（由于 namespace 的存在需要做兼容处理）。\n\n#### 4.5.3 mutations、actions 以及 getters 注册\n\n定义 local 环境后，循环注册我们在 options 中配置的 action 以及 mutation 等。逐个分析各注册函数之前，先看下模块间的逻辑关系流程图：\n\n![complete_flow](http://www.jixiaokang.com/wp-content/uploads/2018/05/complete_flow1.jpg)\n\n下面分析代码逻辑：\n\n    // 注册对应模块的mutation，供state修改使用\n    module.forEachMutation((mutation, key) => {\n      const namespacedType = namespace + key\n      registerMutation(store, namespacedType, mutation, local)\n    })\n\n    // 注册对应模块的action，供数据操作、提交mutation等异步操作使用\n    module.forEachAction((action, key) => {\n      const namespacedType = namespace + key\n      registerAction(store, namespacedType, action, local)\n    })\n\n    // 注册对应模块的getters，供state读取使用\n    module.forEachGetter((getter, key) => {\n      const namespacedType = namespace + key\n      registerGetter(store, namespacedType, getter, local)\n    })\n\nregisterMutation 方法中，获取 store 中的对应 mutation type 的处理函数集合，将新的处理函数 push 进去。这里将我们设置在 mutations type 上对应的 handler 进行了封装，给原函数传入了 state。在执行  `commit('xxx', payload)`  的时候，type 为 xxx 的 mutation 的所有 handler 都会接收到 state 以及 payload，这就是在 handler 里面拿到 state 的原因。\n\n    function registerMutation (store, type, handler, local) {\n      // 取出对应type的mutations-handler集合\n      const entry = store._mutations[type] || (store._mutations[type] = [])\n      // commit实际调用的不是我们传入的handler，而是经过封装的\n      entry.push(function wrappedMutationHandler (payload) {\n        // 调用handler并将state传入\n        handler(local.state, payload)\n      })\n    }\n\naction 和 getter 的注册也是同理的，看一下代码（注：前面提到的  `this.actions`  以及  `this.mutations`在此处进行设置）。\n\n    function registerAction (store, type, handler, local) {\n      // 取出对应type的actions-handler集合\n      const entry = store._actions[type] || (store._actions[type] = [])\n      // 存储新的封装过的action-handler\n      entry.push(function wrappedActionHandler (payload, cb) {\n        // 传入 state 等对象供我们原action-handler使用\n        let res = handler({\n          dispatch: local.dispatch,\n          commit: local.commit,\n          getters: local.getters,\n          state: local.state,\n          rootGetters: store.getters,\n          rootState: store.state\n        }, payload, cb)\n        // action需要支持promise进行链式调用，这里进行兼容处理\n        if (!isPromise(res)) {\n          res = Promise.resolve(res)\n        }\n        if (store._devtoolHook) {\n          return res.catch(err => {\n            store._devtoolHook.emit('vuex:error', err)\n            throw err\n          })\n        } else {\n          return res\n        }\n      })\n    }\n\n    function registerGetter (store, type, rawGetter, local) {\n      // getters只允许存在一个处理函数，若重复需要报错\n      if (store._wrappedGetters[type]) {\n        console.error(`[vuex] duplicate getter key: ${type}`)\n        return\n      }\n\n      // 存储封装过的getters处理函数\n      store._wrappedGetters[type] = function wrappedGetter (store) {\n        // 为原getters传入对应状态\n        return rawGetter(\n          local.state, // local state\n          local.getters, // local getters\n          store.state, // root state\n          store.getters // root getters\n        )\n      }\n    }\n\naction handler 比 mutation handler 以及 getter wrapper 多拿到 dispatch 和 commit 操作方法，因此 action 可以进行 dispatch action 和 commit mutation 操作。\n\n#### 4.5.4 子 module 安装\n\n注册完了根组件的 actions、mutations 以及 getters 后，递归调用自身，为子组件注册其 state，actions、mutations 以及 getters 等。\n\n    module.forEachChild((child, key) => {\n      installModule(store, rootState, path.concat(key), child, hot)\n    })\n\n#### 4.5.5 实例结合\n\n前面介绍了 dispatch 和 commit 方法以及 actions 等的实现，下面结合一个官方的[购物车](https://github.com/vuejs/vuex/tree/dev/examples/shopping-cart)实例中的部分代码来加深理解。\n\nVuex 配置代码：\n\n    /\n     *  store-index.js store配置文件\n     *\n     /\n\n    import Vue from 'vue'\n    import Vuex from 'vuex'\n    import * as actions from './actions'\n    import * as getters from './getters'\n    import cart from './modules/cart'\n    import products from './modules/products'\n    import createLogger from '../../../src/plugins/logger'\n\n    Vue.use(Vuex)\n\n    const debug = process.env.NODE_ENV !== 'production'\n\n    export default new Vuex.Store({\n      actions,\n      getters,\n      modules: {\n        cart,\n        products\n      },\n      strict: debug,\n      plugins: debug ? [createLogger()] : []\n    })\n\nVuex 组件 module 中各模块 state 配置代码部分：\n\n    /**\n     *  cart.js\n     *\n     **/\n\n    const state = {\n      added: [],\n      checkoutStatus: null\n    }\n\n    /**\n     *  products.js\n     *\n     **/\n\n    const state = {\n      all: []\n    }\n\n加载上述配置后，页面 state 结构如下图：\n\n![cart_state](http://www.jixiaokang.com/wp-content/uploads/2018/05/shopping_cart_state.jpg)\n\nstate 中的属性配置都是按照 option 配置中 module path 的规则来进行的，下面看 action 的操作实例。\n\nVuecart 组件代码部分：\n\n    /**\n     *  Cart.vue 省略template代码，只看script部分\n     *\n     **/\n\n    export default {\n      methods: {\n        // 购物车中的购买按钮，点击后会触发结算。源码中会调用 dispatch方法\n        checkout (products) {\n          this.$store.dispatch('checkout', products)\n        }\n      }\n    }\n\nVuexcart.js 组件 action 配置代码部分：\n\n    const actions = {\n      checkout ({ commit, state }, products) {\n        const savedCartItems = [...state.added] // 存储添加到购物车的商品\n        commit(types.CHECKOUT_REQUEST) // 设置提交结算状态\n        shop.buyProducts( // 提交api请求，并传入成功与失败的cb-func\n          products,\n          () => commit(types.CHECKOUT_SUCCESS), // 请求返回成功则设置提交成功状态\n          () => commit(types.CHECKOUT_FAILURE, { savedCartItems }) // 请求返回失败则设置提交失败状态\n        )\n      }\n    }\n\nVue 组件中点击购买执行当前 module 的 dispatch 方法，传入 type 值为 'checkout'，payload 值为 'products'，在源码中 dispatch 方法在所有注册过的 actions 中查找'checkout'的对应执行数组，取出循环执行。执行的是被封装过的被命名为 wrappedActionHandler 的方法，真正传入的 checkout 的执行函数在 wrappedActionHandler 这个方法中被执行，源码如下（注：前面贴过，这里再看一次）：\n\n    function wrappedActionHandler (payload, cb) {\n        let res = handler({\n          dispatch: local.dispatch,\n          commit: local.commit,\n          getters: local.getters,\n          state: local.state,\n          rootGetters: store.getters,\n          rootState: store.state\n        }, payload, cb)\n        if (!isPromise(res)) {\n          res = Promise.resolve(res)\n        }\n        if (store._devtoolHook) {\n          return res.catch(err => {\n            store._devtoolHook.emit('vuex:error', err)\n            throw err\n          })\n        } else {\n          return res\n        }\n      }\n\nhandler 在这里就是传入的 checkout 函数，其执行需要的 commit 以及 state 就是在这里被传入，payload 也传入了，在实例中对应接收的参数名为 products。commit 的执行也是同理的，实例中 checkout 还进行了一次 commit 操作，提交一次 type 值为 types.CHECKOUT_REQUEST 的修改，因为 mutation 名字是唯一的，这里进行了常量形式的调用，防止命名重复，执行跟源码分析中一致，调用  `function wrappedMutationHandler (payload) { handler(local.state, payload) }`  封装函数来实际调用配置的 mutation 方法。\n\n看到完源码分析和上面的小实例，应该能理解 dispatch action 和 commit mutation 的工作原理了。接着看源码，看看 getters 是如何实现 state 实时访问的。\n\n### 4.6 store.\\_vm 组件设置\n\n执行完各 module 的 install 后，执行 resetStoreVM 方法，进行 store 组件的初始化。\n\n    // initialize the store vm, which is responsible for the reactivity\n    // (also registers _wrappedGetters as computed properties)\n    resetStoreVM(this, state)\n\n综合前面的分析可以了解到，Vuex 其实构建的就是一个名为 store 的 vm 组件，所有配置的 state、actions、mutations 以及 getters 都是其组件的属性，所有的操作都是对这个 vm 组件进行的。\n\n一起看下 resetStoreVM 方法的内部实现。\n\n    function resetStoreVM (store, state) {\n      const oldVm = store._vm // 缓存前vm组件\n\n      // bind store public getters\n      store.getters = {}\n      const wrappedGetters = store._wrappedGetters\n      const computed = {}\n\n      // 循环所有处理过的getters，并新建computed对象进行存储，通过Object.defineProperty方法为getters对象建立属性，使得我们通过this.$store.getters.xxxgetter能够访问到该getters\n      forEachValue(wrappedGetters, (fn, key) => {\n        // use computed to leverage its lazy-caching mechanism\n        computed[key] = () => fn(store)\n        Object.defineProperty(store.getters, key, {\n          get: () => store._vm[key],\n          enumerable: true // for local getters\n        })\n      })\n\n      // use a Vue instance to store the state tree\n      // suppress warnings just in case the user has added\n      // some funky global mixins\n      const silent = Vue.config.silent\n\n      // 暂时将Vue设为静默模式，避免报出用户加载的某些插件触发的警告\n      Vue.config.silent = true\n      // 设置新的storeVm，将当前初始化的state以及getters作为computed属性（刚刚遍历生成的）\n      store._vm = new Vue({\n        data: { state },\n        computed\n      })\n\n      // 恢复Vue的模式\n      Vue.config.silent = silent\n\n      // enable strict mode for new vm\n      if (store.strict) {\n        // 该方法对state执行$watch以禁止从mutation外部修改state\n        enableStrictMode(store)\n      }\n\n      // 若不是初始化过程执行的该方法，将旧的组件state设置为null，强制更新所有监听者(watchers)，待更新生效，DOM更新完成后，执行vm组件的destroy方法进行销毁，减少内存的占用\n      if (oldVm) {\n        // dispatch changes in all subscribed watchers\n        // to force getter re-evaluation.\n        store._withCommit(() => {\n          oldVm.state = null\n        })\n        Vue.nextTick(() => oldVm.$destroy())\n      }\n    }\n\nresetStoreVm 方法创建了当前 store 实例的\\_vm 组件，至此 store 就创建完毕了。上面代码涉及到了严格模式的判断，看一下严格模式如何实现的。\n\n    function enableStrictMode (store) {\n      store._vm.$watch('state', () => {\n        assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`)\n      }, { deep: true, sync: true })\n    }\n\n很简单的应用，监视 state 的变化，如果没有通过  `this._withCommit()`  方法进行 state 修改，则报错。\n\n### 4.7 plugin 注入\n\n最后执行 plugin 的植入。\n\n    plugins.concat(devtoolPlugin).forEach(plugin => plugin(this))\n\ndevtoolPlugin 提供的功能有 3 个：\n\n    // 1. 触发Vuex组件初始化的hook\n    devtoolHook.emit('vuex:init', store)\n\n    // 2. 提供“时空穿梭”功能，即state操作的前进和倒退\n    devtoolHook.on('vuex:travel-to-state', targetState => {\n      store.replaceState(targetState)\n    })\n\n    // 3. mutation被执行时，触发hook，并提供被触发的mutation函数和当前的state状态\n    store.subscribe((mutation, state) => {\n      devtoolHook.emit('vuex:mutation', mutation, state)\n    })\n\n源码分析到这里，Vuex 框架的实现原理基本都已经分析完毕。\n\n## 五、总结\n\n最后我们回过来看文章开始提出的 5 个问题。\n\n1.  **问**：_使用 Vuex 只需执行  `Vue.use(Vuex)`，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？_\n\n> **答**：`Vue.use(Vuex)`  方法执行的是 install 方法，它实现了 Vue 实例对象的 init 方法封装和注入，使传入的 store 对象被设置到 Vue 上下文环境的\\$store 中。因此在 Vue Component 任意地方都能够通过`this.$store`访问到该 store。\n\n2.  **问**：_state 内部支持模块配置和模块嵌套，如何实现的？_\n\n> **答**：在 store 构造方法中有 makeLocalContext 方法，所有 module 都会有一个 local context，根据配置时的 path 进行匹配。所以执行如`dispatch('submitOrder', payload)`这类 action 时，默认的拿到都是 module 的 local state，如果要访问最外层或者是其他 module 的 state，只能从 rootState 按照 path 路径逐步进行访问。\n\n3.  **问**：_在执行 dispatch 触发 action(commit 同理)的时候，只需传入(type, payload)，action 执行函数中第一个参数 store 从哪里获取的？_\n\n> **答**：store 初始化时，所有配置的 action 和 mutation 以及 getters 均被封装过。在执行如`dispatch('submitOrder', payload)`的时候，actions 中 type 为 submitOrder 的所有处理方法都是被封装后的，其第一个参数为当前的 store 对象，所以能够获取到  `{ dispatch, commit, state, rootState }`  等数据。\n\n4.  **问**：_Vuex 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？_\n\n> **答**：Vuex 中修改 state 的唯一渠道就是执行  `commit('xx', payload)`  方法，其底层通过执行  `this._withCommit(fn)`  设置\\_committing 标志变量为 true，然后才能修改 state，修改完毕还需要还原\\_committing 变量。外部修改虽然能够直接修改 state，但是并没有修改\\_committing 标志位，所以只要 watch 一下 state，state change 时判断是否\\_committing 值为 true，即可判断修改的合法性。\n\n5.  **问**：_调试时的\"时空穿梭\"功能是如何实现的？_\n\n> **答**：devtoolPlugin 中提供了此功能。因为 dev 模式下所有的 state change 都会被记录下来，'时空穿梭' 功能其实就是将当前的 state 替换为记录中某个时刻的 state 状态，利用  `store.replaceState(targetState)`  方法将执行`this._vm.state = state`  实现。\n\n源码中还有一些工具函数类似 registerModule、unregisterModule、hotUpdate、watch 以及 subscribe 等，如有兴趣可以打开源码看看，这里不再细述。\n","source":"_posts/2017-08-24-Vuex框架原理与源码分析.md","raw":"---\ntitle: Vuex框架原理与源码分析\ntags:\n  - 技术\n  - vue\ndate: 2017-08-24 15:50:00\ncategories: 前端\n---\n\nVuex 是一个专为 Vue 服务，用于管理页面数据状态、提供统一数据操作的生态系统。它集中于 MVC 模式中的 Model 层，规定所有的数据操作必须通过  `action - mutation - state change`  的流程来进行，再结合 Vue 的数据视图双向绑定特性来实现页面的展示更新。统一的页面状态管理以及操作处理，可以让复杂的组件交互变得简单清晰，同时可在调试模式下进行时光机般的倒退前进操作，查看数据改变过程，使 code debug 更加方便。\n\n最近在开发的项目中用到了 Vuex 来管理整体页面状态，遇到了很多问题。决定研究下源码，在答疑解惑之外，能深入学习其实现原理。\n\n先将问题抛出来，使学习和研究更有针对性：\n\n1.  使用 Vuex 只需执行  `Vue.use(Vuex)`，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？\n2.  state 内部是如何实现支持模块配置和模块嵌套的？\n3.  在执行 dispatch 触发 action（commit 同理）的时候，只需传入（type, payload），action 执行函数中第一个参数 store 从哪里获取的？\n4.  如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？\n5.  调试时的“时空穿梭”功能是如何实现的？\n\n> 注：本文对有 Vuex 有实际使用经验的同学帮助更大，能更清晰理解 Vuex 的工作流程和原理，使用起来更得心应手。初次接触的同学，可以先参考 Vuex[官方文档](http://vuex.vuejs.org/)进行基础概念的学习。\n\n## 一、框架核心流程\n\n进行源码分析之前，先了解一下官方文档中提供的核心思想图，它也代表着整个 Vuex 框架的运行流程。  \n![vuex-core](http://www.jixiaokang.com/wp-content/uploads/2018/05/vuex.png)  \n如图示，Vuex 为 Vue Components 建立起了一个完整的生态圈，包括开发中的 API 调用一环。围绕这个生态圈，简要介绍一下各模块在核心流程中的主要功能：\n\n- Vue Components：Vue 组件。HTML 页面上，负责接收用户操作等交互行为，执行 dispatch 方法触发对应 action 进行回应。\n- dispatch：操作行为触发方法，是唯一能执行 action 的方法。\n- actions：操作行为处理模块。负责处理 Vue Components 接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台 API 请求的操作就在这个模块中进行，包括触发其他 action 以及提交 mutation 的操作。该模块提供了 Promise 的封装，以支持 action 的链式触发。\n- commit：状态改变提交操作方法。对 mutation 进行提交，是唯一能执行 mutation 的方法。\n- mutations：状态改变操作方法。是 Vuex 修改 state 的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些 hook 暴露出来，以进行 state 的监控等。\n- state：页面状态管理容器对象。集中存储 Vue components 中 data 对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用 Vue 的细粒度数据响应机制来进行高效的状态更新。\n- getters：state 对象读取方法。图中没有单独列出该模块，应该被包含在了 render 中，Vue Components 通过该方法读取全局 state 对象。\n\n> Vue 组件接收交互行为，调用 dispatch 方法触发 action 相关处理，若页面状态需要改变，则调用 commit 方法提交 mutation 修改 state，通过 getters 获取到 state 新值，重新渲染 Vue Components，界面随之更新。\n\n## 二、目录结构介绍\n\n打开 Vuex 项目，看下源码目录结构。\n\n![dir_structure](http://www.jixiaokang.com/wp-content/uploads/2018/05/vuex_src.jpg)\n\nVuex 提供了非常强大的状态管理功能，源码代码量却不多，目录结构划分也很清晰。先大体介绍下各个目录文件的功能：\n\n- module：提供 module 对象与 module 对象树的创建功能；\n- plugins：提供开发辅助插件，如“时光穿梭”功能，state 修改的日志记录功能等；\n- helpers.js：提供 action、mutations 以及 getters 的查找 API；\n- index.js：是源码主入口文件，提供 store 的各 module 构建安装；\n- mixin.js：提供了 store 在 Vue 实例上的装载注入；\n- util.js：提供了工具方法如 find、deepCopy、forEachValue 以及 assert 等方法。\n\n## 三、初始化装载与注入\n\n了解大概的目录及对应功能后，下面开始进行源码分析。[index.js](https://github.com/vuejs/vuex/blob/dev/src/index.js)中包含了所有的核心代码，从该文件入手进行分析。\n\n### 3.1 装载实例\n\n先看个简单的例子：\n\n    /**\n     *  store.js文件\n     *  创建store对象，配置state、action、mutation以及getter\n     *\n     **/\n\n    import Vue from 'vue'\n    import Vuex from 'vuex'\n\n    // install Vuex框架\n    Vue.use(Vuex)\n\n    // 创建并导出store对象。为了方便，不配置任何参数\n    export default new Vuex.Store()\n\nstore.js 文件中，加载 Vuex 框架，创建并导出一个空配置的 store 对象实例。\n\n    /**\n     *  vue-index.js文件\n     *\n     *\n     **/\n\n    import Vue from 'vue'\n    import App from './../pages/app.vue'\n    import store from './store.js'\n\n    new Vue({\n      el: '#root',\n      router,\n      store,\n      render: h => h(App)\n    })\n\n然后在 index.js 中，正常初始化一个页面根级别的 Vue 组件，传入这个自定义的 store 对象。\n\n如**问题 1**所述，以上实例除了 Vue 的初始化代码，只是多了一个 store 对象的传入。一起看下源码中的实现方式。\n\n### 3.2 装载分析\n\nindex.js 文件代码执行开头，定义局部 Vue 变量，用于判断是否已经装载和减少全局作用域查找。\n\n    let Vue\n\n然后判断若处于浏览器环境下且加载过 Vue，则执行 install 方法。\n\n    // auto install in dist mode\n    if (typeof window !== 'undefined' && window.Vue) {\n      install(window.Vue)\n    }\n\ninstall 方法将 Vuex 装载到 Vue 对象上，`Vue.use(Vuex)`  也是通过它执行，先看下 Vue.use 方法实现：\n\n    function (plugin: Function | Object) {\n      /* istanbul ignore if */\n      if (plugin.installed) {\n        return\n      }\n      // additional parameters\n      const args = toArray(arguments, 1)\n      args.unshift(this)\n      if (typeof plugin.install === 'function') {\n        // 实际执行插件的install方法\n        plugin.install.apply(plugin, args)\n      } else {\n        plugin.apply(null, args)\n      }\n      plugin.installed = true\n      return this\n    }\n\n若是首次加载，将局部 Vue 变量赋值为全局的 Vue 对象，并执行 applyMixin 方法，install 实现如下：\n\n    function install (_Vue) {\n      if (Vue) {\n        console.error(\n          '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n        )\n        return\n      }\n      Vue = _Vue\n      applyMixin(Vue)\n    }\n\n来看下 applyMixin 方法内部代码。如果是 2.x.x 以上版本，可以使用 hook 的形式进行注入，或使用封装并替换 Vue 对象原型的\\_init 方法，实现注入。\n\n    export default function (Vue) {\n      const version = Number(Vue.version.split('.')[0])\n\n      if (version >= 2) {\n        const usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1\n        Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit })\n      } else {\n        // override init and inject vuex init procedure\n        // for 1.x backwards compatibility.\n        const _init = Vue.prototype._init\n        Vue.prototype._init = function (options = {}) {\n          options.init = options.init\n            ? [vuexInit].concat(options.init)\n            : vuexInit\n          _init.call(this, options)\n        }\n      }\n\n具体实现：将初始化 Vue 根组件时传入的 store 设置到 this 对象的$store属性上，子组件从其父组件引用$store 属性，层层嵌套进行设置。在任意组件中执行  `this.$store`  都能找到装载的那个 store 对象，vuexInit 方法实现如下：\n\n    function vuexInit () {\n      const options = this.$options\n      // store injection\n      if (options.store) {\n        this.$store = options.store\n      } else if (options.parent && options.parent.$store) {\n        this.$store = options.parent.$store\n      }\n    }\n\n看个图例理解下 store 的传递。\n\n页面 Vue 结构图：  \n![cart_vue_structure](http://www.jixiaokang.com/wp-content/uploads/2018/05/shopping_cart_vue.jpg)\n\n对应 store 流向：  \n![cart_vue_structure](http://www.jixiaokang.com/wp-content/uploads/2018/05/store_flow2.jpg)\n\n## 四、store 对象构造\n\n上面对 Vuex 框架的装载以及注入自定义 store 对象进行分析，解决了**问题 1**。接下来详细分析 store 对象的内部功能和具体实现，来解答  **为什么 actions、getters、mutations 中能从 arguments\\[0\\]中拿到 store 的相关数据?**  等问题。\n\nstore 对象实现逻辑比较复杂，先看下构造方法的整体逻辑流程来帮助后面的理解：\n\n![cart_vue_structure](http://www.jixiaokang.com/wp-content/uploads/2018/05/4.5_flow.jpg)\n\n### 4.1 环境判断\n\n开始分析 store 的构造函数，分小节逐函数逐行的分析其功能。\n\n    constructor (options = {}) {\n      assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)\n      assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)\n\n在 store 构造函数中执行环境判断，以下都是 Vuex 工作的必要条件：\n\n1.  已经执行安装函数进行装载；\n2.  支持 Promise 语法。\n\nassert 函数是一个简单的断言函数的实现，一行代码即可实现。\n\n    function assert (condition, msg) {\n      if (!condition) throw new Error(`[vuex] ${msg}`)\n    }\n\n### 4.2 数据初始化、module 树构造\n\n环境判断后，根据 new 构造传入的 options 或默认值，初始化内部数据。\n\n    const {\n        state = {},\n        plugins = [],\n        strict = false\n    } = options\n\n    // store internal state\n    this._committing = false // 是否在进行提交状态标识\n    this._actions = Object.create(null) // acitons操作对象\n    this._mutations = Object.create(null) // mutations操作对象\n    this._wrappedGetters = Object.create(null) // 封装后的getters集合对象\n    this._modules = new ModuleCollection(options) // Vuex支持store分模块传入，存储分析后的modules\n    this._modulesNamespaceMap = Object.create(null) // 模块命名空间map\n    this._subscribers = [] // 订阅函数集合，Vuex提供了subscribe功能\n    this._watcherVM = new Vue() // Vue组件用于watch监视变化\n\n调用  `new Vuex.store(options)`  时传入的 options 对象，用于构造 ModuleCollection 类，下面看看其功能。\n\n    constructor (rawRootModule) {\n      // register root module (Vuex.Store options)\n      this.root = new Module(rawRootModule, false)\n\n      // register all nested modules\n      if (rawRootModule.modules) {\n        forEachValue(rawRootModule.modules, (rawModule, key) => {\n          this.register([key], rawModule, false)\n        })\n      }\n\nModuleCollection 主要将传入的 options 对象整个构造为一个 module 对象，并循环调用  `this.register([key], rawModule, false)`  为其中的 modules 属性进行模块注册，使其都成为 module 对象，最后 options 对象被构造成一个完整的组件树。ModuleCollection 类还提供了 modules 的更替功能，详细实现可以查看源文件[module-collection.js](https://github.com/vuejs/vuex/blob/dev/src/module/module-collection.js)。\n\n### 4.3 dispatch 与 commit 设置\n\n继续回到 store 的构造函数代码。\n\n    // bind commit and dispatch to self\n    const store = this\n    const { dispatch, commit } = this\n\n    this.dispatch = function boundDispatch (type, payload) {\n      return dispatch.call(store, type, payload)\n    }\n\n    this.commit = function boundCommit (type, payload, options) {\n      return commit.call(store, type, payload, options)\n    }\n\n封装替换原型中的 dispatch 和 commit 方法，将 this 指向当前 store 对象。dispatch 和 commit 方法具体实现如下：\n\n    dispatch (_type, _payload) {\n      // check object-style dispatch\n      const {\n          type,\n          payload\n      } = unifyObjectStyle(_type, _payload) // 配置参数处理\n\n      // 当前type下所有action处理函数集合\n      const entry = this._actions[type]\n      if (!entry) {\n        console.error(`[vuex] unknown action type: ${type}`)\n        return\n      }\n      return entry.length > 1\n          ? Promise.all(entry.map(handler => handler(payload)))\n          : entry[0](payload)\n    }\n\n前面提到，dispatch 的功能是触发并传递一些参数（payload）给对应 type 的 action。因为其支持 2 种调用方法，所以在 dispatch 中，先进行参数的适配处理，然后判断 action type 是否存在，若存在就逐个执行（注：上面代码中的`this._actions[type]`  以及 下面的  `this._mutations[type]`  均是处理过的函数集合，具体内容留到后面进行分析）。\n\ncommit 方法和 dispatch 相比虽然都是触发 type，但是对应的处理却相对复杂，代码如下。\n\n    commit (_type, _payload, _options) {\n      // check object-style commit\n      const {\n          type,\n          payload,\n          options\n      } = unifyObjectStyle(_type, _payload, _options)\n\n      const mutation = { type, payload }\n      const entry = this._mutations[type]\n      if (!entry) {\n        console.error(`[vuex] unknown mutation type: ${type}`)\n        return\n      }\n      // 专用修改state方法，其他修改state方法均是非法修改\n      this._withCommit(() => {\n        entry.forEach(function commitIterator (handler) {\n          handler(payload)\n        })\n      })\n\n      // 订阅者函数遍历执行，传入当前的mutation对象和当前的state\n      this._subscribers.forEach(sub => sub(mutation, this.state))\n\n      if (options && options.silent) {\n        console.warn(\n            `[vuex] mutation type: ${type}. Silent option has been removed. ` +\n            'Use the filter functionality in the vue-devtools'\n        )\n      }\n    }\n\n该方法同样支持 2 种调用方法。先进行参数适配，判断触发 mutation type，利用\\_withCommit 方法执行本次批量触发 mutation 处理函数，并传入 payload 参数。执行完成后，通知所有\\_subscribers（订阅函数）本次操作的 mutation 对象以及当前的 state 状态，如果传入了已经移除的 silent 选项则进行提示警告。\n\n### 4.4 state 修改方法\n\n\\_withCommit 是一个代理方法，所有触发 mutation 的进行 state 修改的操作都经过它，由此来统一管理监控 state 状态的修改。实现代码如下。\n\n    _withCommit (fn) {\n      // 保存之前的提交状态\n      const committing = this._committing\n\n      // 进行本次提交，若不设置为true，直接修改state，strict模式下，Vuex将会产生非法修改state的警告\n      this._committing = true\n\n      // 执行state的修改操作\n      fn()\n\n      // 修改完成，还原本次修改之前的状态\n      this._committing = committing\n    }\n\n缓存执行时的 committing 状态将当前状态设置为 true 后进行本次提交操作，待操作完毕后，将 committing 状态还原为之前的状态。\n\n### 4.5 module 安装\n\n绑定 dispatch 和 commit 方法之后，进行严格模式的设置，以及模块的安装（installModule）。由于占用资源较多影响页面性能，严格模式建议只在开发模式开启，上线后需要关闭。\n\n    // strict mode\n    this.strict = strict\n\n    // init root module.\n    // this also recursively registers all sub-modules\n    // and collects all module getters inside this._wrappedGetters\n    installModule(this, state, [], this._modules.root)\n\n#### 4.5.1 初始化 rootState\n\n上述代码的备注中，提到 installModule 方法初始化组件树根组件、注册所有子组件，并将其中所有的 getters 存储到 this.\\_wrappedGetters 属性中，让我们看看其中的代码实现。\n\n    function installModule (store, rootState, path, module, hot) {\n      const isRoot = !path.length\n      const namespace = store._modules.getNamespace(path)\n\n      // register in namespace map\n      if (namespace) {\n        store._modulesNamespaceMap[namespace] = module\n      }\n\n      // 非根组件设置 state 方法\n      if (!isRoot && !hot) {\n        const parentState = getNestedState(rootState, path.slice(0, -1))\n        const moduleName = path[path.length - 1]\n        store._withCommit(() => {\n          Vue.set(parentState, moduleName, module.state)\n        })\n      }\n\n      ······\n\n判断是否是根目录，以及是否设置了命名空间，若存在则在 namespace 中进行 module 的存储，在不是根组件且不是 hot 条件的情况下，通过 getNestedState 方法拿到该 module 父级的 state，拿到其所在的 moduleName ，调用  `Vue.set(parentState, moduleName, module.state)`  方法将其 state 设置到父级 state 对象的 moduleName 属性中，由此实现该模块的 state 注册（首次执行这里，因为是根目录注册，所以并不会执行该条件中的方法）。getNestedState 方法代码很简单，分析 path 拿到 state，如下。\n\n    function getNestedState (state, path) {\n      return path.length\n        ? path.reduce((state, key) => state[key], state)\n        : state\n    }\n\n#### 4.5.2 module 上下文环境设置\n\n    const local = module.context = makeLocalContext(store, namespace, path)\n\n命名空间和根目录条件判断完毕后，接下来定义 local 变量和 module.context 的值，执行 makeLocalContext 方法，为该 module 设置局部的 dispatch、commit 方法以及 getters 和 state（由于 namespace 的存在需要做兼容处理）。\n\n#### 4.5.3 mutations、actions 以及 getters 注册\n\n定义 local 环境后，循环注册我们在 options 中配置的 action 以及 mutation 等。逐个分析各注册函数之前，先看下模块间的逻辑关系流程图：\n\n![complete_flow](http://www.jixiaokang.com/wp-content/uploads/2018/05/complete_flow1.jpg)\n\n下面分析代码逻辑：\n\n    // 注册对应模块的mutation，供state修改使用\n    module.forEachMutation((mutation, key) => {\n      const namespacedType = namespace + key\n      registerMutation(store, namespacedType, mutation, local)\n    })\n\n    // 注册对应模块的action，供数据操作、提交mutation等异步操作使用\n    module.forEachAction((action, key) => {\n      const namespacedType = namespace + key\n      registerAction(store, namespacedType, action, local)\n    })\n\n    // 注册对应模块的getters，供state读取使用\n    module.forEachGetter((getter, key) => {\n      const namespacedType = namespace + key\n      registerGetter(store, namespacedType, getter, local)\n    })\n\nregisterMutation 方法中，获取 store 中的对应 mutation type 的处理函数集合，将新的处理函数 push 进去。这里将我们设置在 mutations type 上对应的 handler 进行了封装，给原函数传入了 state。在执行  `commit('xxx', payload)`  的时候，type 为 xxx 的 mutation 的所有 handler 都会接收到 state 以及 payload，这就是在 handler 里面拿到 state 的原因。\n\n    function registerMutation (store, type, handler, local) {\n      // 取出对应type的mutations-handler集合\n      const entry = store._mutations[type] || (store._mutations[type] = [])\n      // commit实际调用的不是我们传入的handler，而是经过封装的\n      entry.push(function wrappedMutationHandler (payload) {\n        // 调用handler并将state传入\n        handler(local.state, payload)\n      })\n    }\n\naction 和 getter 的注册也是同理的，看一下代码（注：前面提到的  `this.actions`  以及  `this.mutations`在此处进行设置）。\n\n    function registerAction (store, type, handler, local) {\n      // 取出对应type的actions-handler集合\n      const entry = store._actions[type] || (store._actions[type] = [])\n      // 存储新的封装过的action-handler\n      entry.push(function wrappedActionHandler (payload, cb) {\n        // 传入 state 等对象供我们原action-handler使用\n        let res = handler({\n          dispatch: local.dispatch,\n          commit: local.commit,\n          getters: local.getters,\n          state: local.state,\n          rootGetters: store.getters,\n          rootState: store.state\n        }, payload, cb)\n        // action需要支持promise进行链式调用，这里进行兼容处理\n        if (!isPromise(res)) {\n          res = Promise.resolve(res)\n        }\n        if (store._devtoolHook) {\n          return res.catch(err => {\n            store._devtoolHook.emit('vuex:error', err)\n            throw err\n          })\n        } else {\n          return res\n        }\n      })\n    }\n\n    function registerGetter (store, type, rawGetter, local) {\n      // getters只允许存在一个处理函数，若重复需要报错\n      if (store._wrappedGetters[type]) {\n        console.error(`[vuex] duplicate getter key: ${type}`)\n        return\n      }\n\n      // 存储封装过的getters处理函数\n      store._wrappedGetters[type] = function wrappedGetter (store) {\n        // 为原getters传入对应状态\n        return rawGetter(\n          local.state, // local state\n          local.getters, // local getters\n          store.state, // root state\n          store.getters // root getters\n        )\n      }\n    }\n\naction handler 比 mutation handler 以及 getter wrapper 多拿到 dispatch 和 commit 操作方法，因此 action 可以进行 dispatch action 和 commit mutation 操作。\n\n#### 4.5.4 子 module 安装\n\n注册完了根组件的 actions、mutations 以及 getters 后，递归调用自身，为子组件注册其 state，actions、mutations 以及 getters 等。\n\n    module.forEachChild((child, key) => {\n      installModule(store, rootState, path.concat(key), child, hot)\n    })\n\n#### 4.5.5 实例结合\n\n前面介绍了 dispatch 和 commit 方法以及 actions 等的实现，下面结合一个官方的[购物车](https://github.com/vuejs/vuex/tree/dev/examples/shopping-cart)实例中的部分代码来加深理解。\n\nVuex 配置代码：\n\n    /\n     *  store-index.js store配置文件\n     *\n     /\n\n    import Vue from 'vue'\n    import Vuex from 'vuex'\n    import * as actions from './actions'\n    import * as getters from './getters'\n    import cart from './modules/cart'\n    import products from './modules/products'\n    import createLogger from '../../../src/plugins/logger'\n\n    Vue.use(Vuex)\n\n    const debug = process.env.NODE_ENV !== 'production'\n\n    export default new Vuex.Store({\n      actions,\n      getters,\n      modules: {\n        cart,\n        products\n      },\n      strict: debug,\n      plugins: debug ? [createLogger()] : []\n    })\n\nVuex 组件 module 中各模块 state 配置代码部分：\n\n    /**\n     *  cart.js\n     *\n     **/\n\n    const state = {\n      added: [],\n      checkoutStatus: null\n    }\n\n    /**\n     *  products.js\n     *\n     **/\n\n    const state = {\n      all: []\n    }\n\n加载上述配置后，页面 state 结构如下图：\n\n![cart_state](http://www.jixiaokang.com/wp-content/uploads/2018/05/shopping_cart_state.jpg)\n\nstate 中的属性配置都是按照 option 配置中 module path 的规则来进行的，下面看 action 的操作实例。\n\nVuecart 组件代码部分：\n\n    /**\n     *  Cart.vue 省略template代码，只看script部分\n     *\n     **/\n\n    export default {\n      methods: {\n        // 购物车中的购买按钮，点击后会触发结算。源码中会调用 dispatch方法\n        checkout (products) {\n          this.$store.dispatch('checkout', products)\n        }\n      }\n    }\n\nVuexcart.js 组件 action 配置代码部分：\n\n    const actions = {\n      checkout ({ commit, state }, products) {\n        const savedCartItems = [...state.added] // 存储添加到购物车的商品\n        commit(types.CHECKOUT_REQUEST) // 设置提交结算状态\n        shop.buyProducts( // 提交api请求，并传入成功与失败的cb-func\n          products,\n          () => commit(types.CHECKOUT_SUCCESS), // 请求返回成功则设置提交成功状态\n          () => commit(types.CHECKOUT_FAILURE, { savedCartItems }) // 请求返回失败则设置提交失败状态\n        )\n      }\n    }\n\nVue 组件中点击购买执行当前 module 的 dispatch 方法，传入 type 值为 'checkout'，payload 值为 'products'，在源码中 dispatch 方法在所有注册过的 actions 中查找'checkout'的对应执行数组，取出循环执行。执行的是被封装过的被命名为 wrappedActionHandler 的方法，真正传入的 checkout 的执行函数在 wrappedActionHandler 这个方法中被执行，源码如下（注：前面贴过，这里再看一次）：\n\n    function wrappedActionHandler (payload, cb) {\n        let res = handler({\n          dispatch: local.dispatch,\n          commit: local.commit,\n          getters: local.getters,\n          state: local.state,\n          rootGetters: store.getters,\n          rootState: store.state\n        }, payload, cb)\n        if (!isPromise(res)) {\n          res = Promise.resolve(res)\n        }\n        if (store._devtoolHook) {\n          return res.catch(err => {\n            store._devtoolHook.emit('vuex:error', err)\n            throw err\n          })\n        } else {\n          return res\n        }\n      }\n\nhandler 在这里就是传入的 checkout 函数，其执行需要的 commit 以及 state 就是在这里被传入，payload 也传入了，在实例中对应接收的参数名为 products。commit 的执行也是同理的，实例中 checkout 还进行了一次 commit 操作，提交一次 type 值为 types.CHECKOUT_REQUEST 的修改，因为 mutation 名字是唯一的，这里进行了常量形式的调用，防止命名重复，执行跟源码分析中一致，调用  `function wrappedMutationHandler (payload) { handler(local.state, payload) }`  封装函数来实际调用配置的 mutation 方法。\n\n看到完源码分析和上面的小实例，应该能理解 dispatch action 和 commit mutation 的工作原理了。接着看源码，看看 getters 是如何实现 state 实时访问的。\n\n### 4.6 store.\\_vm 组件设置\n\n执行完各 module 的 install 后，执行 resetStoreVM 方法，进行 store 组件的初始化。\n\n    // initialize the store vm, which is responsible for the reactivity\n    // (also registers _wrappedGetters as computed properties)\n    resetStoreVM(this, state)\n\n综合前面的分析可以了解到，Vuex 其实构建的就是一个名为 store 的 vm 组件，所有配置的 state、actions、mutations 以及 getters 都是其组件的属性，所有的操作都是对这个 vm 组件进行的。\n\n一起看下 resetStoreVM 方法的内部实现。\n\n    function resetStoreVM (store, state) {\n      const oldVm = store._vm // 缓存前vm组件\n\n      // bind store public getters\n      store.getters = {}\n      const wrappedGetters = store._wrappedGetters\n      const computed = {}\n\n      // 循环所有处理过的getters，并新建computed对象进行存储，通过Object.defineProperty方法为getters对象建立属性，使得我们通过this.$store.getters.xxxgetter能够访问到该getters\n      forEachValue(wrappedGetters, (fn, key) => {\n        // use computed to leverage its lazy-caching mechanism\n        computed[key] = () => fn(store)\n        Object.defineProperty(store.getters, key, {\n          get: () => store._vm[key],\n          enumerable: true // for local getters\n        })\n      })\n\n      // use a Vue instance to store the state tree\n      // suppress warnings just in case the user has added\n      // some funky global mixins\n      const silent = Vue.config.silent\n\n      // 暂时将Vue设为静默模式，避免报出用户加载的某些插件触发的警告\n      Vue.config.silent = true\n      // 设置新的storeVm，将当前初始化的state以及getters作为computed属性（刚刚遍历生成的）\n      store._vm = new Vue({\n        data: { state },\n        computed\n      })\n\n      // 恢复Vue的模式\n      Vue.config.silent = silent\n\n      // enable strict mode for new vm\n      if (store.strict) {\n        // 该方法对state执行$watch以禁止从mutation外部修改state\n        enableStrictMode(store)\n      }\n\n      // 若不是初始化过程执行的该方法，将旧的组件state设置为null，强制更新所有监听者(watchers)，待更新生效，DOM更新完成后，执行vm组件的destroy方法进行销毁，减少内存的占用\n      if (oldVm) {\n        // dispatch changes in all subscribed watchers\n        // to force getter re-evaluation.\n        store._withCommit(() => {\n          oldVm.state = null\n        })\n        Vue.nextTick(() => oldVm.$destroy())\n      }\n    }\n\nresetStoreVm 方法创建了当前 store 实例的\\_vm 组件，至此 store 就创建完毕了。上面代码涉及到了严格模式的判断，看一下严格模式如何实现的。\n\n    function enableStrictMode (store) {\n      store._vm.$watch('state', () => {\n        assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`)\n      }, { deep: true, sync: true })\n    }\n\n很简单的应用，监视 state 的变化，如果没有通过  `this._withCommit()`  方法进行 state 修改，则报错。\n\n### 4.7 plugin 注入\n\n最后执行 plugin 的植入。\n\n    plugins.concat(devtoolPlugin).forEach(plugin => plugin(this))\n\ndevtoolPlugin 提供的功能有 3 个：\n\n    // 1. 触发Vuex组件初始化的hook\n    devtoolHook.emit('vuex:init', store)\n\n    // 2. 提供“时空穿梭”功能，即state操作的前进和倒退\n    devtoolHook.on('vuex:travel-to-state', targetState => {\n      store.replaceState(targetState)\n    })\n\n    // 3. mutation被执行时，触发hook，并提供被触发的mutation函数和当前的state状态\n    store.subscribe((mutation, state) => {\n      devtoolHook.emit('vuex:mutation', mutation, state)\n    })\n\n源码分析到这里，Vuex 框架的实现原理基本都已经分析完毕。\n\n## 五、总结\n\n最后我们回过来看文章开始提出的 5 个问题。\n\n1.  **问**：_使用 Vuex 只需执行  `Vue.use(Vuex)`，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？_\n\n> **答**：`Vue.use(Vuex)`  方法执行的是 install 方法，它实现了 Vue 实例对象的 init 方法封装和注入，使传入的 store 对象被设置到 Vue 上下文环境的\\$store 中。因此在 Vue Component 任意地方都能够通过`this.$store`访问到该 store。\n\n2.  **问**：_state 内部支持模块配置和模块嵌套，如何实现的？_\n\n> **答**：在 store 构造方法中有 makeLocalContext 方法，所有 module 都会有一个 local context，根据配置时的 path 进行匹配。所以执行如`dispatch('submitOrder', payload)`这类 action 时，默认的拿到都是 module 的 local state，如果要访问最外层或者是其他 module 的 state，只能从 rootState 按照 path 路径逐步进行访问。\n\n3.  **问**：_在执行 dispatch 触发 action(commit 同理)的时候，只需传入(type, payload)，action 执行函数中第一个参数 store 从哪里获取的？_\n\n> **答**：store 初始化时，所有配置的 action 和 mutation 以及 getters 均被封装过。在执行如`dispatch('submitOrder', payload)`的时候，actions 中 type 为 submitOrder 的所有处理方法都是被封装后的，其第一个参数为当前的 store 对象，所以能够获取到  `{ dispatch, commit, state, rootState }`  等数据。\n\n4.  **问**：_Vuex 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？_\n\n> **答**：Vuex 中修改 state 的唯一渠道就是执行  `commit('xx', payload)`  方法，其底层通过执行  `this._withCommit(fn)`  设置\\_committing 标志变量为 true，然后才能修改 state，修改完毕还需要还原\\_committing 变量。外部修改虽然能够直接修改 state，但是并没有修改\\_committing 标志位，所以只要 watch 一下 state，state change 时判断是否\\_committing 值为 true，即可判断修改的合法性。\n\n5.  **问**：_调试时的\"时空穿梭\"功能是如何实现的？_\n\n> **答**：devtoolPlugin 中提供了此功能。因为 dev 模式下所有的 state change 都会被记录下来，'时空穿梭' 功能其实就是将当前的 state 替换为记录中某个时刻的 state 状态，利用  `store.replaceState(targetState)`  方法将执行`this._vm.state = state`  实现。\n\n源码中还有一些工具函数类似 registerModule、unregisterModule、hotUpdate、watch 以及 subscribe 等，如有兴趣可以打开源码看看，这里不再细述。\n","slug":"2017-08-24-Vuex框架原理与源码分析","published":1,"updated":"2020-03-14T06:46:17.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvo800764k8y414k1n0e","content":"<p>Vuex 是一个专为 Vue 服务，用于管理页面数据状态、提供统一数据操作的生态系统。它集中于 MVC 模式中的 Model 层，规定所有的数据操作必须通过  <code>action - mutation - state change</code>  的流程来进行，再结合 Vue 的数据视图双向绑定特性来实现页面的展示更新。统一的页面状态管理以及操作处理，可以让复杂的组件交互变得简单清晰，同时可在调试模式下进行时光机般的倒退前进操作，查看数据改变过程，使 code debug 更加方便。</p>\n<p>最近在开发的项目中用到了 Vuex 来管理整体页面状态，遇到了很多问题。决定研究下源码，在答疑解惑之外，能深入学习其实现原理。</p>\n<p>先将问题抛出来，使学习和研究更有针对性：</p>\n<ol>\n<li>使用 Vuex 只需执行  <code>Vue.use(Vuex)</code>，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？</li>\n<li>state 内部是如何实现支持模块配置和模块嵌套的？</li>\n<li>在执行 dispatch 触发 action（commit 同理）的时候，只需传入（type, payload），action 执行函数中第一个参数 store 从哪里获取的？</li>\n<li>如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？</li>\n<li>调试时的“时空穿梭”功能是如何实现的？</li>\n</ol>\n<blockquote>\n<p>注：本文对有 Vuex 有实际使用经验的同学帮助更大，能更清晰理解 Vuex 的工作流程和原理，使用起来更得心应手。初次接触的同学，可以先参考 Vuex<a href=\"http://vuex.vuejs.org/\" target=\"_blank\" rel=\"noopener\">官方文档</a>进行基础概念的学习。</p>\n</blockquote>\n<h2 id=\"一、框架核心流程\"><a href=\"#一、框架核心流程\" class=\"headerlink\" title=\"一、框架核心流程\"></a>一、框架核心流程</h2><p>进行源码分析之前，先了解一下官方文档中提供的核心思想图，它也代表着整个 Vuex 框架的运行流程。<br><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/vuex.png\" alt=\"vuex-core\"><br>如图示，Vuex 为 Vue Components 建立起了一个完整的生态圈，包括开发中的 API 调用一环。围绕这个生态圈，简要介绍一下各模块在核心流程中的主要功能：</p>\n<ul>\n<li>Vue Components：Vue 组件。HTML 页面上，负责接收用户操作等交互行为，执行 dispatch 方法触发对应 action 进行回应。</li>\n<li>dispatch：操作行为触发方法，是唯一能执行 action 的方法。</li>\n<li>actions：操作行为处理模块。负责处理 Vue Components 接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台 API 请求的操作就在这个模块中进行，包括触发其他 action 以及提交 mutation 的操作。该模块提供了 Promise 的封装，以支持 action 的链式触发。</li>\n<li>commit：状态改变提交操作方法。对 mutation 进行提交，是唯一能执行 mutation 的方法。</li>\n<li>mutations：状态改变操作方法。是 Vuex 修改 state 的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些 hook 暴露出来，以进行 state 的监控等。</li>\n<li>state：页面状态管理容器对象。集中存储 Vue components 中 data 对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用 Vue 的细粒度数据响应机制来进行高效的状态更新。</li>\n<li>getters：state 对象读取方法。图中没有单独列出该模块，应该被包含在了 render 中，Vue Components 通过该方法读取全局 state 对象。</li>\n</ul>\n<blockquote>\n<p>Vue 组件接收交互行为，调用 dispatch 方法触发 action 相关处理，若页面状态需要改变，则调用 commit 方法提交 mutation 修改 state，通过 getters 获取到 state 新值，重新渲染 Vue Components，界面随之更新。</p>\n</blockquote>\n<h2 id=\"二、目录结构介绍\"><a href=\"#二、目录结构介绍\" class=\"headerlink\" title=\"二、目录结构介绍\"></a>二、目录结构介绍</h2><p>打开 Vuex 项目，看下源码目录结构。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/vuex_src.jpg\" alt=\"dir_structure\"></p>\n<p>Vuex 提供了非常强大的状态管理功能，源码代码量却不多，目录结构划分也很清晰。先大体介绍下各个目录文件的功能：</p>\n<ul>\n<li>module：提供 module 对象与 module 对象树的创建功能；</li>\n<li>plugins：提供开发辅助插件，如“时光穿梭”功能，state 修改的日志记录功能等；</li>\n<li>helpers.js：提供 action、mutations 以及 getters 的查找 API；</li>\n<li>index.js：是源码主入口文件，提供 store 的各 module 构建安装；</li>\n<li>mixin.js：提供了 store 在 Vue 实例上的装载注入；</li>\n<li>util.js：提供了工具方法如 find、deepCopy、forEachValue 以及 assert 等方法。</li>\n</ul>\n<h2 id=\"三、初始化装载与注入\"><a href=\"#三、初始化装载与注入\" class=\"headerlink\" title=\"三、初始化装载与注入\"></a>三、初始化装载与注入</h2><p>了解大概的目录及对应功能后，下面开始进行源码分析。<a href=\"https://github.com/vuejs/vuex/blob/dev/src/index.js\" target=\"_blank\" rel=\"noopener\">index.js</a>中包含了所有的核心代码，从该文件入手进行分析。</p>\n<h3 id=\"3-1-装载实例\"><a href=\"#3-1-装载实例\" class=\"headerlink\" title=\"3.1 装载实例\"></a>3.1 装载实例</h3><p>先看个简单的例子：</p>\n<pre><code>/**\n *  store.js文件\n *  创建store对象，配置state、action、mutation以及getter\n *\n **/\n\nimport Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;\n\n// install Vuex框架\nVue.use(Vuex)\n\n// 创建并导出store对象。为了方便，不配置任何参数\nexport default new Vuex.Store()</code></pre><p>store.js 文件中，加载 Vuex 框架，创建并导出一个空配置的 store 对象实例。</p>\n<pre><code>/**\n *  vue-index.js文件\n *\n *\n **/\n\nimport Vue from &#39;vue&#39;\nimport App from &#39;./../pages/app.vue&#39;\nimport store from &#39;./store.js&#39;\n\nnew Vue({\n  el: &#39;#root&#39;,\n  router,\n  store,\n  render: h =&gt; h(App)\n})</code></pre><p>然后在 index.js 中，正常初始化一个页面根级别的 Vue 组件，传入这个自定义的 store 对象。</p>\n<p>如<strong>问题 1</strong>所述，以上实例除了 Vue 的初始化代码，只是多了一个 store 对象的传入。一起看下源码中的实现方式。</p>\n<h3 id=\"3-2-装载分析\"><a href=\"#3-2-装载分析\" class=\"headerlink\" title=\"3.2 装载分析\"></a>3.2 装载分析</h3><p>index.js 文件代码执行开头，定义局部 Vue 变量，用于判断是否已经装载和减少全局作用域查找。</p>\n<pre><code>let Vue</code></pre><p>然后判断若处于浏览器环境下且加载过 Vue，则执行 install 方法。</p>\n<pre><code>// auto install in dist mode\nif (typeof window !== &#39;undefined&#39; &amp;&amp; window.Vue) {\n  install(window.Vue)\n}</code></pre><p>install 方法将 Vuex 装载到 Vue 对象上，<code>Vue.use(Vuex)</code>  也是通过它执行，先看下 Vue.use 方法实现：</p>\n<pre><code>function (plugin: Function | Object) {\n  /* istanbul ignore if */\n  if (plugin.installed) {\n    return\n  }\n  // additional parameters\n  const args = toArray(arguments, 1)\n  args.unshift(this)\n  if (typeof plugin.install === &#39;function&#39;) {\n    // 实际执行插件的install方法\n    plugin.install.apply(plugin, args)\n  } else {\n    plugin.apply(null, args)\n  }\n  plugin.installed = true\n  return this\n}</code></pre><p>若是首次加载，将局部 Vue 变量赋值为全局的 Vue 对象，并执行 applyMixin 方法，install 实现如下：</p>\n<pre><code>function install (_Vue) {\n  if (Vue) {\n    console.error(\n      &#39;[vuex] already installed. Vue.use(Vuex) should be called only once.&#39;\n    )\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}</code></pre><p>来看下 applyMixin 方法内部代码。如果是 2.x.x 以上版本，可以使用 hook 的形式进行注入，或使用封装并替换 Vue 对象原型的_init 方法，实现注入。</p>\n<pre><code>export default function (Vue) {\n  const version = Number(Vue.version.split(&#39;.&#39;)[0])\n\n  if (version &gt;= 2) {\n    const usesInit = Vue.config._lifecycleHooks.indexOf(&#39;init&#39;) &gt; -1\n    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit })\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    const _init = Vue.prototype._init\n    Vue.prototype._init = function (options = {}) {\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit\n      _init.call(this, options)\n    }\n  }</code></pre><p>具体实现：将初始化 Vue 根组件时传入的 store 设置到 this 对象的$store属性上，子组件从其父组件引用$store 属性，层层嵌套进行设置。在任意组件中执行  <code>this.$store</code>  都能找到装载的那个 store 对象，vuexInit 方法实现如下：</p>\n<pre><code>function vuexInit () {\n  const options = this.$options\n  // store injection\n  if (options.store) {\n    this.$store = options.store\n  } else if (options.parent &amp;&amp; options.parent.$store) {\n    this.$store = options.parent.$store\n  }\n}</code></pre><p>看个图例理解下 store 的传递。</p>\n<p>页面 Vue 结构图：<br><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/shopping_cart_vue.jpg\" alt=\"cart_vue_structure\"></p>\n<p>对应 store 流向：<br><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/store_flow2.jpg\" alt=\"cart_vue_structure\"></p>\n<h2 id=\"四、store-对象构造\"><a href=\"#四、store-对象构造\" class=\"headerlink\" title=\"四、store 对象构造\"></a>四、store 对象构造</h2><p>上面对 Vuex 框架的装载以及注入自定义 store 对象进行分析，解决了<strong>问题 1</strong>。接下来详细分析 store 对象的内部功能和具体实现，来解答  <strong>为什么 actions、getters、mutations 中能从 arguments[0]中拿到 store 的相关数据?</strong>  等问题。</p>\n<p>store 对象实现逻辑比较复杂，先看下构造方法的整体逻辑流程来帮助后面的理解：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/4.5_flow.jpg\" alt=\"cart_vue_structure\"></p>\n<h3 id=\"4-1-环境判断\"><a href=\"#4-1-环境判断\" class=\"headerlink\" title=\"4.1 环境判断\"></a>4.1 环境判断</h3><p>开始分析 store 的构造函数，分小节逐函数逐行的分析其功能。</p>\n<pre><code>constructor (options = {}) {\n  assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)\n  assert(typeof Promise !== &#39;undefined&#39;, `vuex requires a Promise polyfill in this browser.`)</code></pre><p>在 store 构造函数中执行环境判断，以下都是 Vuex 工作的必要条件：</p>\n<ol>\n<li>已经执行安装函数进行装载；</li>\n<li>支持 Promise 语法。</li>\n</ol>\n<p>assert 函数是一个简单的断言函数的实现，一行代码即可实现。</p>\n<pre><code>function assert (condition, msg) {\n  if (!condition) throw new Error(`[vuex] ${msg}`)\n}</code></pre><h3 id=\"4-2-数据初始化、module-树构造\"><a href=\"#4-2-数据初始化、module-树构造\" class=\"headerlink\" title=\"4.2 数据初始化、module 树构造\"></a>4.2 数据初始化、module 树构造</h3><p>环境判断后，根据 new 构造传入的 options 或默认值，初始化内部数据。</p>\n<pre><code>const {\n    state = {},\n    plugins = [],\n    strict = false\n} = options\n\n// store internal state\nthis._committing = false // 是否在进行提交状态标识\nthis._actions = Object.create(null) // acitons操作对象\nthis._mutations = Object.create(null) // mutations操作对象\nthis._wrappedGetters = Object.create(null) // 封装后的getters集合对象\nthis._modules = new ModuleCollection(options) // Vuex支持store分模块传入，存储分析后的modules\nthis._modulesNamespaceMap = Object.create(null) // 模块命名空间map\nthis._subscribers = [] // 订阅函数集合，Vuex提供了subscribe功能\nthis._watcherVM = new Vue() // Vue组件用于watch监视变化</code></pre><p>调用  <code>new Vuex.store(options)</code>  时传入的 options 对象，用于构造 ModuleCollection 类，下面看看其功能。</p>\n<pre><code>constructor (rawRootModule) {\n  // register root module (Vuex.Store options)\n  this.root = new Module(rawRootModule, false)\n\n  // register all nested modules\n  if (rawRootModule.modules) {\n    forEachValue(rawRootModule.modules, (rawModule, key) =&gt; {\n      this.register([key], rawModule, false)\n    })\n  }</code></pre><p>ModuleCollection 主要将传入的 options 对象整个构造为一个 module 对象，并循环调用  <code>this.register([key], rawModule, false)</code>  为其中的 modules 属性进行模块注册，使其都成为 module 对象，最后 options 对象被构造成一个完整的组件树。ModuleCollection 类还提供了 modules 的更替功能，详细实现可以查看源文件<a href=\"https://github.com/vuejs/vuex/blob/dev/src/module/module-collection.js\" target=\"_blank\" rel=\"noopener\">module-collection.js</a>。</p>\n<h3 id=\"4-3-dispatch-与-commit-设置\"><a href=\"#4-3-dispatch-与-commit-设置\" class=\"headerlink\" title=\"4.3 dispatch 与 commit 设置\"></a>4.3 dispatch 与 commit 设置</h3><p>继续回到 store 的构造函数代码。</p>\n<pre><code>// bind commit and dispatch to self\nconst store = this\nconst { dispatch, commit } = this\n\nthis.dispatch = function boundDispatch (type, payload) {\n  return dispatch.call(store, type, payload)\n}\n\nthis.commit = function boundCommit (type, payload, options) {\n  return commit.call(store, type, payload, options)\n}</code></pre><p>封装替换原型中的 dispatch 和 commit 方法，将 this 指向当前 store 对象。dispatch 和 commit 方法具体实现如下：</p>\n<pre><code>dispatch (_type, _payload) {\n  // check object-style dispatch\n  const {\n      type,\n      payload\n  } = unifyObjectStyle(_type, _payload) // 配置参数处理\n\n  // 当前type下所有action处理函数集合\n  const entry = this._actions[type]\n  if (!entry) {\n    console.error(`[vuex] unknown action type: ${type}`)\n    return\n  }\n  return entry.length &gt; 1\n      ? Promise.all(entry.map(handler =&gt; handler(payload)))\n      : entry[0](payload)\n}</code></pre><p>前面提到，dispatch 的功能是触发并传递一些参数（payload）给对应 type 的 action。因为其支持 2 种调用方法，所以在 dispatch 中，先进行参数的适配处理，然后判断 action type 是否存在，若存在就逐个执行（注：上面代码中的<code>this._actions[type]</code>  以及 下面的  <code>this._mutations[type]</code>  均是处理过的函数集合，具体内容留到后面进行分析）。</p>\n<p>commit 方法和 dispatch 相比虽然都是触发 type，但是对应的处理却相对复杂，代码如下。</p>\n<pre><code>commit (_type, _payload, _options) {\n  // check object-style commit\n  const {\n      type,\n      payload,\n      options\n  } = unifyObjectStyle(_type, _payload, _options)\n\n  const mutation = { type, payload }\n  const entry = this._mutations[type]\n  if (!entry) {\n    console.error(`[vuex] unknown mutation type: ${type}`)\n    return\n  }\n  // 专用修改state方法，其他修改state方法均是非法修改\n  this._withCommit(() =&gt; {\n    entry.forEach(function commitIterator (handler) {\n      handler(payload)\n    })\n  })\n\n  // 订阅者函数遍历执行，传入当前的mutation对象和当前的state\n  this._subscribers.forEach(sub =&gt; sub(mutation, this.state))\n\n  if (options &amp;&amp; options.silent) {\n    console.warn(\n        `[vuex] mutation type: ${type}. Silent option has been removed. ` +\n        &#39;Use the filter functionality in the vue-devtools&#39;\n    )\n  }\n}</code></pre><p>该方法同样支持 2 种调用方法。先进行参数适配，判断触发 mutation type，利用_withCommit 方法执行本次批量触发 mutation 处理函数，并传入 payload 参数。执行完成后，通知所有_subscribers（订阅函数）本次操作的 mutation 对象以及当前的 state 状态，如果传入了已经移除的 silent 选项则进行提示警告。</p>\n<h3 id=\"4-4-state-修改方法\"><a href=\"#4-4-state-修改方法\" class=\"headerlink\" title=\"4.4 state 修改方法\"></a>4.4 state 修改方法</h3><p>_withCommit 是一个代理方法，所有触发 mutation 的进行 state 修改的操作都经过它，由此来统一管理监控 state 状态的修改。实现代码如下。</p>\n<pre><code>_withCommit (fn) {\n  // 保存之前的提交状态\n  const committing = this._committing\n\n  // 进行本次提交，若不设置为true，直接修改state，strict模式下，Vuex将会产生非法修改state的警告\n  this._committing = true\n\n  // 执行state的修改操作\n  fn()\n\n  // 修改完成，还原本次修改之前的状态\n  this._committing = committing\n}</code></pre><p>缓存执行时的 committing 状态将当前状态设置为 true 后进行本次提交操作，待操作完毕后，将 committing 状态还原为之前的状态。</p>\n<h3 id=\"4-5-module-安装\"><a href=\"#4-5-module-安装\" class=\"headerlink\" title=\"4.5 module 安装\"></a>4.5 module 安装</h3><p>绑定 dispatch 和 commit 方法之后，进行严格模式的设置，以及模块的安装（installModule）。由于占用资源较多影响页面性能，严格模式建议只在开发模式开启，上线后需要关闭。</p>\n<pre><code>// strict mode\nthis.strict = strict\n\n// init root module.\n// this also recursively registers all sub-modules\n// and collects all module getters inside this._wrappedGetters\ninstallModule(this, state, [], this._modules.root)</code></pre><h4 id=\"4-5-1-初始化-rootState\"><a href=\"#4-5-1-初始化-rootState\" class=\"headerlink\" title=\"4.5.1 初始化 rootState\"></a>4.5.1 初始化 rootState</h4><p>上述代码的备注中，提到 installModule 方法初始化组件树根组件、注册所有子组件，并将其中所有的 getters 存储到 this._wrappedGetters 属性中，让我们看看其中的代码实现。</p>\n<pre><code>function installModule (store, rootState, path, module, hot) {\n  const isRoot = !path.length\n  const namespace = store._modules.getNamespace(path)\n\n  // register in namespace map\n  if (namespace) {\n    store._modulesNamespaceMap[namespace] = module\n  }\n\n  // 非根组件设置 state 方法\n  if (!isRoot &amp;&amp; !hot) {\n    const parentState = getNestedState(rootState, path.slice(0, -1))\n    const moduleName = path[path.length - 1]\n    store._withCommit(() =&gt; {\n      Vue.set(parentState, moduleName, module.state)\n    })\n  }\n\n  ······</code></pre><p>判断是否是根目录，以及是否设置了命名空间，若存在则在 namespace 中进行 module 的存储，在不是根组件且不是 hot 条件的情况下，通过 getNestedState 方法拿到该 module 父级的 state，拿到其所在的 moduleName ，调用  <code>Vue.set(parentState, moduleName, module.state)</code>  方法将其 state 设置到父级 state 对象的 moduleName 属性中，由此实现该模块的 state 注册（首次执行这里，因为是根目录注册，所以并不会执行该条件中的方法）。getNestedState 方法代码很简单，分析 path 拿到 state，如下。</p>\n<pre><code>function getNestedState (state, path) {\n  return path.length\n    ? path.reduce((state, key) =&gt; state[key], state)\n    : state\n}</code></pre><h4 id=\"4-5-2-module-上下文环境设置\"><a href=\"#4-5-2-module-上下文环境设置\" class=\"headerlink\" title=\"4.5.2 module 上下文环境设置\"></a>4.5.2 module 上下文环境设置</h4><pre><code>const local = module.context = makeLocalContext(store, namespace, path)</code></pre><p>命名空间和根目录条件判断完毕后，接下来定义 local 变量和 module.context 的值，执行 makeLocalContext 方法，为该 module 设置局部的 dispatch、commit 方法以及 getters 和 state（由于 namespace 的存在需要做兼容处理）。</p>\n<h4 id=\"4-5-3-mutations、actions-以及-getters-注册\"><a href=\"#4-5-3-mutations、actions-以及-getters-注册\" class=\"headerlink\" title=\"4.5.3 mutations、actions 以及 getters 注册\"></a>4.5.3 mutations、actions 以及 getters 注册</h4><p>定义 local 环境后，循环注册我们在 options 中配置的 action 以及 mutation 等。逐个分析各注册函数之前，先看下模块间的逻辑关系流程图：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/complete_flow1.jpg\" alt=\"complete_flow\"></p>\n<p>下面分析代码逻辑：</p>\n<pre><code>// 注册对应模块的mutation，供state修改使用\nmodule.forEachMutation((mutation, key) =&gt; {\n  const namespacedType = namespace + key\n  registerMutation(store, namespacedType, mutation, local)\n})\n\n// 注册对应模块的action，供数据操作、提交mutation等异步操作使用\nmodule.forEachAction((action, key) =&gt; {\n  const namespacedType = namespace + key\n  registerAction(store, namespacedType, action, local)\n})\n\n// 注册对应模块的getters，供state读取使用\nmodule.forEachGetter((getter, key) =&gt; {\n  const namespacedType = namespace + key\n  registerGetter(store, namespacedType, getter, local)\n})</code></pre><p>registerMutation 方法中，获取 store 中的对应 mutation type 的处理函数集合，将新的处理函数 push 进去。这里将我们设置在 mutations type 上对应的 handler 进行了封装，给原函数传入了 state。在执行  <code>commit(&#39;xxx&#39;, payload)</code>  的时候，type 为 xxx 的 mutation 的所有 handler 都会接收到 state 以及 payload，这就是在 handler 里面拿到 state 的原因。</p>\n<pre><code>function registerMutation (store, type, handler, local) {\n  // 取出对应type的mutations-handler集合\n  const entry = store._mutations[type] || (store._mutations[type] = [])\n  // commit实际调用的不是我们传入的handler，而是经过封装的\n  entry.push(function wrappedMutationHandler (payload) {\n    // 调用handler并将state传入\n    handler(local.state, payload)\n  })\n}</code></pre><p>action 和 getter 的注册也是同理的，看一下代码（注：前面提到的  <code>this.actions</code>  以及  <code>this.mutations</code>在此处进行设置）。</p>\n<pre><code>function registerAction (store, type, handler, local) {\n  // 取出对应type的actions-handler集合\n  const entry = store._actions[type] || (store._actions[type] = [])\n  // 存储新的封装过的action-handler\n  entry.push(function wrappedActionHandler (payload, cb) {\n    // 传入 state 等对象供我们原action-handler使用\n    let res = handler({\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb)\n    // action需要支持promise进行链式调用，这里进行兼容处理\n    if (!isPromise(res)) {\n      res = Promise.resolve(res)\n    }\n    if (store._devtoolHook) {\n      return res.catch(err =&gt; {\n        store._devtoolHook.emit(&#39;vuex:error&#39;, err)\n        throw err\n      })\n    } else {\n      return res\n    }\n  })\n}\n\nfunction registerGetter (store, type, rawGetter, local) {\n  // getters只允许存在一个处理函数，若重复需要报错\n  if (store._wrappedGetters[type]) {\n    console.error(`[vuex] duplicate getter key: ${type}`)\n    return\n  }\n\n  // 存储封装过的getters处理函数\n  store._wrappedGetters[type] = function wrappedGetter (store) {\n    // 为原getters传入对应状态\n    return rawGetter(\n      local.state, // local state\n      local.getters, // local getters\n      store.state, // root state\n      store.getters // root getters\n    )\n  }\n}</code></pre><p>action handler 比 mutation handler 以及 getter wrapper 多拿到 dispatch 和 commit 操作方法，因此 action 可以进行 dispatch action 和 commit mutation 操作。</p>\n<h4 id=\"4-5-4-子-module-安装\"><a href=\"#4-5-4-子-module-安装\" class=\"headerlink\" title=\"4.5.4 子 module 安装\"></a>4.5.4 子 module 安装</h4><p>注册完了根组件的 actions、mutations 以及 getters 后，递归调用自身，为子组件注册其 state，actions、mutations 以及 getters 等。</p>\n<pre><code>module.forEachChild((child, key) =&gt; {\n  installModule(store, rootState, path.concat(key), child, hot)\n})</code></pre><h4 id=\"4-5-5-实例结合\"><a href=\"#4-5-5-实例结合\" class=\"headerlink\" title=\"4.5.5 实例结合\"></a>4.5.5 实例结合</h4><p>前面介绍了 dispatch 和 commit 方法以及 actions 等的实现，下面结合一个官方的<a href=\"https://github.com/vuejs/vuex/tree/dev/examples/shopping-cart\" target=\"_blank\" rel=\"noopener\">购物车</a>实例中的部分代码来加深理解。</p>\n<p>Vuex 配置代码：</p>\n<pre><code>/\n *  store-index.js store配置文件\n *\n /\n\nimport Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;\nimport * as actions from &#39;./actions&#39;\nimport * as getters from &#39;./getters&#39;\nimport cart from &#39;./modules/cart&#39;\nimport products from &#39;./modules/products&#39;\nimport createLogger from &#39;../../../src/plugins/logger&#39;\n\nVue.use(Vuex)\n\nconst debug = process.env.NODE_ENV !== &#39;production&#39;\n\nexport default new Vuex.Store({\n  actions,\n  getters,\n  modules: {\n    cart,\n    products\n  },\n  strict: debug,\n  plugins: debug ? [createLogger()] : []\n})</code></pre><p>Vuex 组件 module 中各模块 state 配置代码部分：</p>\n<pre><code>/**\n *  cart.js\n *\n **/\n\nconst state = {\n  added: [],\n  checkoutStatus: null\n}\n\n/**\n *  products.js\n *\n **/\n\nconst state = {\n  all: []\n}</code></pre><p>加载上述配置后，页面 state 结构如下图：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/shopping_cart_state.jpg\" alt=\"cart_state\"></p>\n<p>state 中的属性配置都是按照 option 配置中 module path 的规则来进行的，下面看 action 的操作实例。</p>\n<p>Vuecart 组件代码部分：</p>\n<pre><code>/**\n *  Cart.vue 省略template代码，只看script部分\n *\n **/\n\nexport default {\n  methods: {\n    // 购物车中的购买按钮，点击后会触发结算。源码中会调用 dispatch方法\n    checkout (products) {\n      this.$store.dispatch(&#39;checkout&#39;, products)\n    }\n  }\n}</code></pre><p>Vuexcart.js 组件 action 配置代码部分：</p>\n<pre><code>const actions = {\n  checkout ({ commit, state }, products) {\n    const savedCartItems = [...state.added] // 存储添加到购物车的商品\n    commit(types.CHECKOUT_REQUEST) // 设置提交结算状态\n    shop.buyProducts( // 提交api请求，并传入成功与失败的cb-func\n      products,\n      () =&gt; commit(types.CHECKOUT_SUCCESS), // 请求返回成功则设置提交成功状态\n      () =&gt; commit(types.CHECKOUT_FAILURE, { savedCartItems }) // 请求返回失败则设置提交失败状态\n    )\n  }\n}</code></pre><p>Vue 组件中点击购买执行当前 module 的 dispatch 方法，传入 type 值为 ‘checkout’，payload 值为 ‘products’，在源码中 dispatch 方法在所有注册过的 actions 中查找’checkout’的对应执行数组，取出循环执行。执行的是被封装过的被命名为 wrappedActionHandler 的方法，真正传入的 checkout 的执行函数在 wrappedActionHandler 这个方法中被执行，源码如下（注：前面贴过，这里再看一次）：</p>\n<pre><code>function wrappedActionHandler (payload, cb) {\n    let res = handler({\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb)\n    if (!isPromise(res)) {\n      res = Promise.resolve(res)\n    }\n    if (store._devtoolHook) {\n      return res.catch(err =&gt; {\n        store._devtoolHook.emit(&#39;vuex:error&#39;, err)\n        throw err\n      })\n    } else {\n      return res\n    }\n  }</code></pre><p>handler 在这里就是传入的 checkout 函数，其执行需要的 commit 以及 state 就是在这里被传入，payload 也传入了，在实例中对应接收的参数名为 products。commit 的执行也是同理的，实例中 checkout 还进行了一次 commit 操作，提交一次 type 值为 types.CHECKOUT_REQUEST 的修改，因为 mutation 名字是唯一的，这里进行了常量形式的调用，防止命名重复，执行跟源码分析中一致，调用  <code>function wrappedMutationHandler (payload) { handler(local.state, payload) }</code>  封装函数来实际调用配置的 mutation 方法。</p>\n<p>看到完源码分析和上面的小实例，应该能理解 dispatch action 和 commit mutation 的工作原理了。接着看源码，看看 getters 是如何实现 state 实时访问的。</p>\n<h3 id=\"4-6-store-vm-组件设置\"><a href=\"#4-6-store-vm-组件设置\" class=\"headerlink\" title=\"4.6 store._vm 组件设置\"></a>4.6 store._vm 组件设置</h3><p>执行完各 module 的 install 后，执行 resetStoreVM 方法，进行 store 组件的初始化。</p>\n<pre><code>// initialize the store vm, which is responsible for the reactivity\n// (also registers _wrappedGetters as computed properties)\nresetStoreVM(this, state)</code></pre><p>综合前面的分析可以了解到，Vuex 其实构建的就是一个名为 store 的 vm 组件，所有配置的 state、actions、mutations 以及 getters 都是其组件的属性，所有的操作都是对这个 vm 组件进行的。</p>\n<p>一起看下 resetStoreVM 方法的内部实现。</p>\n<pre><code>function resetStoreVM (store, state) {\n  const oldVm = store._vm // 缓存前vm组件\n\n  // bind store public getters\n  store.getters = {}\n  const wrappedGetters = store._wrappedGetters\n  const computed = {}\n\n  // 循环所有处理过的getters，并新建computed对象进行存储，通过Object.defineProperty方法为getters对象建立属性，使得我们通过this.$store.getters.xxxgetter能够访问到该getters\n  forEachValue(wrappedGetters, (fn, key) =&gt; {\n    // use computed to leverage its lazy-caching mechanism\n    computed[key] = () =&gt; fn(store)\n    Object.defineProperty(store.getters, key, {\n      get: () =&gt; store._vm[key],\n      enumerable: true // for local getters\n    })\n  })\n\n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  const silent = Vue.config.silent\n\n  // 暂时将Vue设为静默模式，避免报出用户加载的某些插件触发的警告\n  Vue.config.silent = true\n  // 设置新的storeVm，将当前初始化的state以及getters作为computed属性（刚刚遍历生成的）\n  store._vm = new Vue({\n    data: { state },\n    computed\n  })\n\n  // 恢复Vue的模式\n  Vue.config.silent = silent\n\n  // enable strict mode for new vm\n  if (store.strict) {\n    // 该方法对state执行$watch以禁止从mutation外部修改state\n    enableStrictMode(store)\n  }\n\n  // 若不是初始化过程执行的该方法，将旧的组件state设置为null，强制更新所有监听者(watchers)，待更新生效，DOM更新完成后，执行vm组件的destroy方法进行销毁，减少内存的占用\n  if (oldVm) {\n    // dispatch changes in all subscribed watchers\n    // to force getter re-evaluation.\n    store._withCommit(() =&gt; {\n      oldVm.state = null\n    })\n    Vue.nextTick(() =&gt; oldVm.$destroy())\n  }\n}</code></pre><p>resetStoreVm 方法创建了当前 store 实例的_vm 组件，至此 store 就创建完毕了。上面代码涉及到了严格模式的判断，看一下严格模式如何实现的。</p>\n<pre><code>function enableStrictMode (store) {\n  store._vm.$watch(&#39;state&#39;, () =&gt; {\n    assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`)\n  }, { deep: true, sync: true })\n}</code></pre><p>很简单的应用，监视 state 的变化，如果没有通过  <code>this._withCommit()</code>  方法进行 state 修改，则报错。</p>\n<h3 id=\"4-7-plugin-注入\"><a href=\"#4-7-plugin-注入\" class=\"headerlink\" title=\"4.7 plugin 注入\"></a>4.7 plugin 注入</h3><p>最后执行 plugin 的植入。</p>\n<pre><code>plugins.concat(devtoolPlugin).forEach(plugin =&gt; plugin(this))</code></pre><p>devtoolPlugin 提供的功能有 3 个：</p>\n<pre><code>// 1. 触发Vuex组件初始化的hook\ndevtoolHook.emit(&#39;vuex:init&#39;, store)\n\n// 2. 提供“时空穿梭”功能，即state操作的前进和倒退\ndevtoolHook.on(&#39;vuex:travel-to-state&#39;, targetState =&gt; {\n  store.replaceState(targetState)\n})\n\n// 3. mutation被执行时，触发hook，并提供被触发的mutation函数和当前的state状态\nstore.subscribe((mutation, state) =&gt; {\n  devtoolHook.emit(&#39;vuex:mutation&#39;, mutation, state)\n})</code></pre><p>源码分析到这里，Vuex 框架的实现原理基本都已经分析完毕。</p>\n<h2 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h2><p>最后我们回过来看文章开始提出的 5 个问题。</p>\n<ol>\n<li><strong>问</strong>：<em>使用 Vuex 只需执行  <code>Vue.use(Vuex)</code>，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？</em></li>\n</ol>\n<blockquote>\n<p><strong>答</strong>：<code>Vue.use(Vuex)</code>  方法执行的是 install 方法，它实现了 Vue 实例对象的 init 方法封装和注入，使传入的 store 对象被设置到 Vue 上下文环境的$store 中。因此在 Vue Component 任意地方都能够通过<code>this.$store</code>访问到该 store。</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>问</strong>：<em>state 内部支持模块配置和模块嵌套，如何实现的？</em></li>\n</ol>\n<blockquote>\n<p><strong>答</strong>：在 store 构造方法中有 makeLocalContext 方法，所有 module 都会有一个 local context，根据配置时的 path 进行匹配。所以执行如<code>dispatch(&#39;submitOrder&#39;, payload)</code>这类 action 时，默认的拿到都是 module 的 local state，如果要访问最外层或者是其他 module 的 state，只能从 rootState 按照 path 路径逐步进行访问。</p>\n</blockquote>\n<ol start=\"3\">\n<li><strong>问</strong>：<em>在执行 dispatch 触发 action(commit 同理)的时候，只需传入(type, payload)，action 执行函数中第一个参数 store 从哪里获取的？</em></li>\n</ol>\n<blockquote>\n<p><strong>答</strong>：store 初始化时，所有配置的 action 和 mutation 以及 getters 均被封装过。在执行如<code>dispatch(&#39;submitOrder&#39;, payload)</code>的时候，actions 中 type 为 submitOrder 的所有处理方法都是被封装后的，其第一个参数为当前的 store 对象，所以能够获取到  <code>{ dispatch, commit, state, rootState }</code>  等数据。</p>\n</blockquote>\n<ol start=\"4\">\n<li><strong>问</strong>：<em>Vuex 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？</em></li>\n</ol>\n<blockquote>\n<p><strong>答</strong>：Vuex 中修改 state 的唯一渠道就是执行  <code>commit(&#39;xx&#39;, payload)</code>  方法，其底层通过执行  <code>this._withCommit(fn)</code>  设置_committing 标志变量为 true，然后才能修改 state，修改完毕还需要还原_committing 变量。外部修改虽然能够直接修改 state，但是并没有修改_committing 标志位，所以只要 watch 一下 state，state change 时判断是否_committing 值为 true，即可判断修改的合法性。</p>\n</blockquote>\n<ol start=\"5\">\n<li><strong>问</strong>：<em>调试时的”时空穿梭”功能是如何实现的？</em></li>\n</ol>\n<blockquote>\n<p><strong>答</strong>：devtoolPlugin 中提供了此功能。因为 dev 模式下所有的 state change 都会被记录下来，’时空穿梭’ 功能其实就是将当前的 state 替换为记录中某个时刻的 state 状态，利用  <code>store.replaceState(targetState)</code>  方法将执行<code>this._vm.state = state</code>  实现。</p>\n</blockquote>\n<p>源码中还有一些工具函数类似 registerModule、unregisterModule、hotUpdate、watch 以及 subscribe 等，如有兴趣可以打开源码看看，这里不再细述。</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<p>Vuex 是一个专为 Vue 服务，用于管理页面数据状态、提供统一数据操作的生态系统。它集中于 MVC 模式中的 Model 层，规定所有的数据操作必须通过  <code>action - mutation - state change</code>  的流程来进行，再结合 Vue 的数据视图双向绑定特性来实现页面的展示更新。统一的页面状态管理以及操作处理，可以让复杂的组件交互变得简单清晰，同时可在调试模式下进行时光机般的倒退前进操作，查看数据改变过程，使 code debug 更加方便。</p>\n<p>最近在开发的项目中用到了 Vuex 来管理整体页面状态，遇到了很多问题。决定研究下源码，在答疑解惑之外，能深入学习其实现原理。</p>\n<p>先将问题抛出来，使学习和研究更有针对性：</p>\n<ol>\n<li>使用 Vuex 只需执行  <code>Vue.use(Vuex)</code>，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？</li>\n<li>state 内部是如何实现支持模块配置和模块嵌套的？</li>\n<li>在执行 dispatch 触发 action（commit 同理）的时候，只需传入（type, payload），action 执行函数中第一个参数 store 从哪里获取的？</li>\n<li>如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？</li>\n<li>调试时的“时空穿梭”功能是如何实现的？</li>\n</ol>\n<blockquote>\n<p>注：本文对有 Vuex 有实际使用经验的同学帮助更大，能更清晰理解 Vuex 的工作流程和原理，使用起来更得心应手。初次接触的同学，可以先参考 Vuex<a href=\"http://vuex.vuejs.org/\" target=\"_blank\" rel=\"noopener\">官方文档</a>进行基础概念的学习。</p>\n</blockquote>\n<h2 id=\"一、框架核心流程\"><a href=\"#一、框架核心流程\" class=\"headerlink\" title=\"一、框架核心流程\"></a>一、框架核心流程</h2><p>进行源码分析之前，先了解一下官方文档中提供的核心思想图，它也代表着整个 Vuex 框架的运行流程。<br><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/vuex.png\" alt=\"vuex-core\"><br>如图示，Vuex 为 Vue Components 建立起了一个完整的生态圈，包括开发中的 API 调用一环。围绕这个生态圈，简要介绍一下各模块在核心流程中的主要功能：</p>\n<ul>\n<li>Vue Components：Vue 组件。HTML 页面上，负责接收用户操作等交互行为，执行 dispatch 方法触发对应 action 进行回应。</li>\n<li>dispatch：操作行为触发方法，是唯一能执行 action 的方法。</li>\n<li>actions：操作行为处理模块。负责处理 Vue Components 接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台 API 请求的操作就在这个模块中进行，包括触发其他 action 以及提交 mutation 的操作。该模块提供了 Promise 的封装，以支持 action 的链式触发。</li>\n<li>commit：状态改变提交操作方法。对 mutation 进行提交，是唯一能执行 mutation 的方法。</li>\n<li>mutations：状态改变操作方法。是 Vuex 修改 state 的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些 hook 暴露出来，以进行 state 的监控等。</li>\n<li>state：页面状态管理容器对象。集中存储 Vue components 中 data 对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用 Vue 的细粒度数据响应机制来进行高效的状态更新。</li>\n<li>getters：state 对象读取方法。图中没有单独列出该模块，应该被包含在了 render 中，Vue Components 通过该方法读取全局 state 对象。</li>\n</ul>\n<blockquote>\n<p>Vue 组件接收交互行为，调用 dispatch 方法触发 action 相关处理，若页面状态需要改变，则调用 commit 方法提交 mutation 修改 state，通过 getters 获取到 state 新值，重新渲染 Vue Components，界面随之更新。</p>\n</blockquote>\n<h2 id=\"二、目录结构介绍\"><a href=\"#二、目录结构介绍\" class=\"headerlink\" title=\"二、目录结构介绍\"></a>二、目录结构介绍</h2><p>打开 Vuex 项目，看下源码目录结构。</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/vuex_src.jpg\" alt=\"dir_structure\"></p>\n<p>Vuex 提供了非常强大的状态管理功能，源码代码量却不多，目录结构划分也很清晰。先大体介绍下各个目录文件的功能：</p>\n<ul>\n<li>module：提供 module 对象与 module 对象树的创建功能；</li>\n<li>plugins：提供开发辅助插件，如“时光穿梭”功能，state 修改的日志记录功能等；</li>\n<li>helpers.js：提供 action、mutations 以及 getters 的查找 API；</li>\n<li>index.js：是源码主入口文件，提供 store 的各 module 构建安装；</li>\n<li>mixin.js：提供了 store 在 Vue 实例上的装载注入；</li>\n<li>util.js：提供了工具方法如 find、deepCopy、forEachValue 以及 assert 等方法。</li>\n</ul>\n<h2 id=\"三、初始化装载与注入\"><a href=\"#三、初始化装载与注入\" class=\"headerlink\" title=\"三、初始化装载与注入\"></a>三、初始化装载与注入</h2><p>了解大概的目录及对应功能后，下面开始进行源码分析。<a href=\"https://github.com/vuejs/vuex/blob/dev/src/index.js\" target=\"_blank\" rel=\"noopener\">index.js</a>中包含了所有的核心代码，从该文件入手进行分析。</p>\n<h3 id=\"3-1-装载实例\"><a href=\"#3-1-装载实例\" class=\"headerlink\" title=\"3.1 装载实例\"></a>3.1 装载实例</h3><p>先看个简单的例子：</p>\n<pre><code>/**\n *  store.js文件\n *  创建store对象，配置state、action、mutation以及getter\n *\n **/\n\nimport Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;\n\n// install Vuex框架\nVue.use(Vuex)\n\n// 创建并导出store对象。为了方便，不配置任何参数\nexport default new Vuex.Store()</code></pre><p>store.js 文件中，加载 Vuex 框架，创建并导出一个空配置的 store 对象实例。</p>\n<pre><code>/**\n *  vue-index.js文件\n *\n *\n **/\n\nimport Vue from &#39;vue&#39;\nimport App from &#39;./../pages/app.vue&#39;\nimport store from &#39;./store.js&#39;\n\nnew Vue({\n  el: &#39;#root&#39;,\n  router,\n  store,\n  render: h =&gt; h(App)\n})</code></pre><p>然后在 index.js 中，正常初始化一个页面根级别的 Vue 组件，传入这个自定义的 store 对象。</p>\n<p>如<strong>问题 1</strong>所述，以上实例除了 Vue 的初始化代码，只是多了一个 store 对象的传入。一起看下源码中的实现方式。</p>\n<h3 id=\"3-2-装载分析\"><a href=\"#3-2-装载分析\" class=\"headerlink\" title=\"3.2 装载分析\"></a>3.2 装载分析</h3><p>index.js 文件代码执行开头，定义局部 Vue 变量，用于判断是否已经装载和减少全局作用域查找。</p>\n<pre><code>let Vue</code></pre><p>然后判断若处于浏览器环境下且加载过 Vue，则执行 install 方法。</p>\n<pre><code>// auto install in dist mode\nif (typeof window !== &#39;undefined&#39; &amp;&amp; window.Vue) {\n  install(window.Vue)\n}</code></pre><p>install 方法将 Vuex 装载到 Vue 对象上，<code>Vue.use(Vuex)</code>  也是通过它执行，先看下 Vue.use 方法实现：</p>\n<pre><code>function (plugin: Function | Object) {\n  /* istanbul ignore if */\n  if (plugin.installed) {\n    return\n  }\n  // additional parameters\n  const args = toArray(arguments, 1)\n  args.unshift(this)\n  if (typeof plugin.install === &#39;function&#39;) {\n    // 实际执行插件的install方法\n    plugin.install.apply(plugin, args)\n  } else {\n    plugin.apply(null, args)\n  }\n  plugin.installed = true\n  return this\n}</code></pre><p>若是首次加载，将局部 Vue 变量赋值为全局的 Vue 对象，并执行 applyMixin 方法，install 实现如下：</p>\n<pre><code>function install (_Vue) {\n  if (Vue) {\n    console.error(\n      &#39;[vuex] already installed. Vue.use(Vuex) should be called only once.&#39;\n    )\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}</code></pre><p>来看下 applyMixin 方法内部代码。如果是 2.x.x 以上版本，可以使用 hook 的形式进行注入，或使用封装并替换 Vue 对象原型的_init 方法，实现注入。</p>\n<pre><code>export default function (Vue) {\n  const version = Number(Vue.version.split(&#39;.&#39;)[0])\n\n  if (version &gt;= 2) {\n    const usesInit = Vue.config._lifecycleHooks.indexOf(&#39;init&#39;) &gt; -1\n    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit })\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    const _init = Vue.prototype._init\n    Vue.prototype._init = function (options = {}) {\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit\n      _init.call(this, options)\n    }\n  }</code></pre><p>具体实现：将初始化 Vue 根组件时传入的 store 设置到 this 对象的$store属性上，子组件从其父组件引用$store 属性，层层嵌套进行设置。在任意组件中执行  <code>this.$store</code>  都能找到装载的那个 store 对象，vuexInit 方法实现如下：</p>\n<pre><code>function vuexInit () {\n  const options = this.$options\n  // store injection\n  if (options.store) {\n    this.$store = options.store\n  } else if (options.parent &amp;&amp; options.parent.$store) {\n    this.$store = options.parent.$store\n  }\n}</code></pre><p>看个图例理解下 store 的传递。</p>\n<p>页面 Vue 结构图：<br><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/shopping_cart_vue.jpg\" alt=\"cart_vue_structure\"></p>\n<p>对应 store 流向：<br><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/store_flow2.jpg\" alt=\"cart_vue_structure\"></p>\n<h2 id=\"四、store-对象构造\"><a href=\"#四、store-对象构造\" class=\"headerlink\" title=\"四、store 对象构造\"></a>四、store 对象构造</h2><p>上面对 Vuex 框架的装载以及注入自定义 store 对象进行分析，解决了<strong>问题 1</strong>。接下来详细分析 store 对象的内部功能和具体实现，来解答  <strong>为什么 actions、getters、mutations 中能从 arguments[0]中拿到 store 的相关数据?</strong>  等问题。</p>\n<p>store 对象实现逻辑比较复杂，先看下构造方法的整体逻辑流程来帮助后面的理解：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/4.5_flow.jpg\" alt=\"cart_vue_structure\"></p>\n<h3 id=\"4-1-环境判断\"><a href=\"#4-1-环境判断\" class=\"headerlink\" title=\"4.1 环境判断\"></a>4.1 环境判断</h3><p>开始分析 store 的构造函数，分小节逐函数逐行的分析其功能。</p>\n<pre><code>constructor (options = {}) {\n  assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)\n  assert(typeof Promise !== &#39;undefined&#39;, `vuex requires a Promise polyfill in this browser.`)</code></pre><p>在 store 构造函数中执行环境判断，以下都是 Vuex 工作的必要条件：</p>\n<ol>\n<li>已经执行安装函数进行装载；</li>\n<li>支持 Promise 语法。</li>\n</ol>\n<p>assert 函数是一个简单的断言函数的实现，一行代码即可实现。</p>\n<pre><code>function assert (condition, msg) {\n  if (!condition) throw new Error(`[vuex] ${msg}`)\n}</code></pre><h3 id=\"4-2-数据初始化、module-树构造\"><a href=\"#4-2-数据初始化、module-树构造\" class=\"headerlink\" title=\"4.2 数据初始化、module 树构造\"></a>4.2 数据初始化、module 树构造</h3><p>环境判断后，根据 new 构造传入的 options 或默认值，初始化内部数据。</p>\n<pre><code>const {\n    state = {},\n    plugins = [],\n    strict = false\n} = options\n\n// store internal state\nthis._committing = false // 是否在进行提交状态标识\nthis._actions = Object.create(null) // acitons操作对象\nthis._mutations = Object.create(null) // mutations操作对象\nthis._wrappedGetters = Object.create(null) // 封装后的getters集合对象\nthis._modules = new ModuleCollection(options) // Vuex支持store分模块传入，存储分析后的modules\nthis._modulesNamespaceMap = Object.create(null) // 模块命名空间map\nthis._subscribers = [] // 订阅函数集合，Vuex提供了subscribe功能\nthis._watcherVM = new Vue() // Vue组件用于watch监视变化</code></pre><p>调用  <code>new Vuex.store(options)</code>  时传入的 options 对象，用于构造 ModuleCollection 类，下面看看其功能。</p>\n<pre><code>constructor (rawRootModule) {\n  // register root module (Vuex.Store options)\n  this.root = new Module(rawRootModule, false)\n\n  // register all nested modules\n  if (rawRootModule.modules) {\n    forEachValue(rawRootModule.modules, (rawModule, key) =&gt; {\n      this.register([key], rawModule, false)\n    })\n  }</code></pre><p>ModuleCollection 主要将传入的 options 对象整个构造为一个 module 对象，并循环调用  <code>this.register([key], rawModule, false)</code>  为其中的 modules 属性进行模块注册，使其都成为 module 对象，最后 options 对象被构造成一个完整的组件树。ModuleCollection 类还提供了 modules 的更替功能，详细实现可以查看源文件<a href=\"https://github.com/vuejs/vuex/blob/dev/src/module/module-collection.js\" target=\"_blank\" rel=\"noopener\">module-collection.js</a>。</p>\n<h3 id=\"4-3-dispatch-与-commit-设置\"><a href=\"#4-3-dispatch-与-commit-设置\" class=\"headerlink\" title=\"4.3 dispatch 与 commit 设置\"></a>4.3 dispatch 与 commit 设置</h3><p>继续回到 store 的构造函数代码。</p>\n<pre><code>// bind commit and dispatch to self\nconst store = this\nconst { dispatch, commit } = this\n\nthis.dispatch = function boundDispatch (type, payload) {\n  return dispatch.call(store, type, payload)\n}\n\nthis.commit = function boundCommit (type, payload, options) {\n  return commit.call(store, type, payload, options)\n}</code></pre><p>封装替换原型中的 dispatch 和 commit 方法，将 this 指向当前 store 对象。dispatch 和 commit 方法具体实现如下：</p>\n<pre><code>dispatch (_type, _payload) {\n  // check object-style dispatch\n  const {\n      type,\n      payload\n  } = unifyObjectStyle(_type, _payload) // 配置参数处理\n\n  // 当前type下所有action处理函数集合\n  const entry = this._actions[type]\n  if (!entry) {\n    console.error(`[vuex] unknown action type: ${type}`)\n    return\n  }\n  return entry.length &gt; 1\n      ? Promise.all(entry.map(handler =&gt; handler(payload)))\n      : entry[0](payload)\n}</code></pre><p>前面提到，dispatch 的功能是触发并传递一些参数（payload）给对应 type 的 action。因为其支持 2 种调用方法，所以在 dispatch 中，先进行参数的适配处理，然后判断 action type 是否存在，若存在就逐个执行（注：上面代码中的<code>this._actions[type]</code>  以及 下面的  <code>this._mutations[type]</code>  均是处理过的函数集合，具体内容留到后面进行分析）。</p>\n<p>commit 方法和 dispatch 相比虽然都是触发 type，但是对应的处理却相对复杂，代码如下。</p>\n<pre><code>commit (_type, _payload, _options) {\n  // check object-style commit\n  const {\n      type,\n      payload,\n      options\n  } = unifyObjectStyle(_type, _payload, _options)\n\n  const mutation = { type, payload }\n  const entry = this._mutations[type]\n  if (!entry) {\n    console.error(`[vuex] unknown mutation type: ${type}`)\n    return\n  }\n  // 专用修改state方法，其他修改state方法均是非法修改\n  this._withCommit(() =&gt; {\n    entry.forEach(function commitIterator (handler) {\n      handler(payload)\n    })\n  })\n\n  // 订阅者函数遍历执行，传入当前的mutation对象和当前的state\n  this._subscribers.forEach(sub =&gt; sub(mutation, this.state))\n\n  if (options &amp;&amp; options.silent) {\n    console.warn(\n        `[vuex] mutation type: ${type}. Silent option has been removed. ` +\n        &#39;Use the filter functionality in the vue-devtools&#39;\n    )\n  }\n}</code></pre><p>该方法同样支持 2 种调用方法。先进行参数适配，判断触发 mutation type，利用_withCommit 方法执行本次批量触发 mutation 处理函数，并传入 payload 参数。执行完成后，通知所有_subscribers（订阅函数）本次操作的 mutation 对象以及当前的 state 状态，如果传入了已经移除的 silent 选项则进行提示警告。</p>\n<h3 id=\"4-4-state-修改方法\"><a href=\"#4-4-state-修改方法\" class=\"headerlink\" title=\"4.4 state 修改方法\"></a>4.4 state 修改方法</h3><p>_withCommit 是一个代理方法，所有触发 mutation 的进行 state 修改的操作都经过它，由此来统一管理监控 state 状态的修改。实现代码如下。</p>\n<pre><code>_withCommit (fn) {\n  // 保存之前的提交状态\n  const committing = this._committing\n\n  // 进行本次提交，若不设置为true，直接修改state，strict模式下，Vuex将会产生非法修改state的警告\n  this._committing = true\n\n  // 执行state的修改操作\n  fn()\n\n  // 修改完成，还原本次修改之前的状态\n  this._committing = committing\n}</code></pre><p>缓存执行时的 committing 状态将当前状态设置为 true 后进行本次提交操作，待操作完毕后，将 committing 状态还原为之前的状态。</p>\n<h3 id=\"4-5-module-安装\"><a href=\"#4-5-module-安装\" class=\"headerlink\" title=\"4.5 module 安装\"></a>4.5 module 安装</h3><p>绑定 dispatch 和 commit 方法之后，进行严格模式的设置，以及模块的安装（installModule）。由于占用资源较多影响页面性能，严格模式建议只在开发模式开启，上线后需要关闭。</p>\n<pre><code>// strict mode\nthis.strict = strict\n\n// init root module.\n// this also recursively registers all sub-modules\n// and collects all module getters inside this._wrappedGetters\ninstallModule(this, state, [], this._modules.root)</code></pre><h4 id=\"4-5-1-初始化-rootState\"><a href=\"#4-5-1-初始化-rootState\" class=\"headerlink\" title=\"4.5.1 初始化 rootState\"></a>4.5.1 初始化 rootState</h4><p>上述代码的备注中，提到 installModule 方法初始化组件树根组件、注册所有子组件，并将其中所有的 getters 存储到 this._wrappedGetters 属性中，让我们看看其中的代码实现。</p>\n<pre><code>function installModule (store, rootState, path, module, hot) {\n  const isRoot = !path.length\n  const namespace = store._modules.getNamespace(path)\n\n  // register in namespace map\n  if (namespace) {\n    store._modulesNamespaceMap[namespace] = module\n  }\n\n  // 非根组件设置 state 方法\n  if (!isRoot &amp;&amp; !hot) {\n    const parentState = getNestedState(rootState, path.slice(0, -1))\n    const moduleName = path[path.length - 1]\n    store._withCommit(() =&gt; {\n      Vue.set(parentState, moduleName, module.state)\n    })\n  }\n\n  ······</code></pre><p>判断是否是根目录，以及是否设置了命名空间，若存在则在 namespace 中进行 module 的存储，在不是根组件且不是 hot 条件的情况下，通过 getNestedState 方法拿到该 module 父级的 state，拿到其所在的 moduleName ，调用  <code>Vue.set(parentState, moduleName, module.state)</code>  方法将其 state 设置到父级 state 对象的 moduleName 属性中，由此实现该模块的 state 注册（首次执行这里，因为是根目录注册，所以并不会执行该条件中的方法）。getNestedState 方法代码很简单，分析 path 拿到 state，如下。</p>\n<pre><code>function getNestedState (state, path) {\n  return path.length\n    ? path.reduce((state, key) =&gt; state[key], state)\n    : state\n}</code></pre><h4 id=\"4-5-2-module-上下文环境设置\"><a href=\"#4-5-2-module-上下文环境设置\" class=\"headerlink\" title=\"4.5.2 module 上下文环境设置\"></a>4.5.2 module 上下文环境设置</h4><pre><code>const local = module.context = makeLocalContext(store, namespace, path)</code></pre><p>命名空间和根目录条件判断完毕后，接下来定义 local 变量和 module.context 的值，执行 makeLocalContext 方法，为该 module 设置局部的 dispatch、commit 方法以及 getters 和 state（由于 namespace 的存在需要做兼容处理）。</p>\n<h4 id=\"4-5-3-mutations、actions-以及-getters-注册\"><a href=\"#4-5-3-mutations、actions-以及-getters-注册\" class=\"headerlink\" title=\"4.5.3 mutations、actions 以及 getters 注册\"></a>4.5.3 mutations、actions 以及 getters 注册</h4><p>定义 local 环境后，循环注册我们在 options 中配置的 action 以及 mutation 等。逐个分析各注册函数之前，先看下模块间的逻辑关系流程图：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/complete_flow1.jpg\" alt=\"complete_flow\"></p>\n<p>下面分析代码逻辑：</p>\n<pre><code>// 注册对应模块的mutation，供state修改使用\nmodule.forEachMutation((mutation, key) =&gt; {\n  const namespacedType = namespace + key\n  registerMutation(store, namespacedType, mutation, local)\n})\n\n// 注册对应模块的action，供数据操作、提交mutation等异步操作使用\nmodule.forEachAction((action, key) =&gt; {\n  const namespacedType = namespace + key\n  registerAction(store, namespacedType, action, local)\n})\n\n// 注册对应模块的getters，供state读取使用\nmodule.forEachGetter((getter, key) =&gt; {\n  const namespacedType = namespace + key\n  registerGetter(store, namespacedType, getter, local)\n})</code></pre><p>registerMutation 方法中，获取 store 中的对应 mutation type 的处理函数集合，将新的处理函数 push 进去。这里将我们设置在 mutations type 上对应的 handler 进行了封装，给原函数传入了 state。在执行  <code>commit(&#39;xxx&#39;, payload)</code>  的时候，type 为 xxx 的 mutation 的所有 handler 都会接收到 state 以及 payload，这就是在 handler 里面拿到 state 的原因。</p>\n<pre><code>function registerMutation (store, type, handler, local) {\n  // 取出对应type的mutations-handler集合\n  const entry = store._mutations[type] || (store._mutations[type] = [])\n  // commit实际调用的不是我们传入的handler，而是经过封装的\n  entry.push(function wrappedMutationHandler (payload) {\n    // 调用handler并将state传入\n    handler(local.state, payload)\n  })\n}</code></pre><p>action 和 getter 的注册也是同理的，看一下代码（注：前面提到的  <code>this.actions</code>  以及  <code>this.mutations</code>在此处进行设置）。</p>\n<pre><code>function registerAction (store, type, handler, local) {\n  // 取出对应type的actions-handler集合\n  const entry = store._actions[type] || (store._actions[type] = [])\n  // 存储新的封装过的action-handler\n  entry.push(function wrappedActionHandler (payload, cb) {\n    // 传入 state 等对象供我们原action-handler使用\n    let res = handler({\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb)\n    // action需要支持promise进行链式调用，这里进行兼容处理\n    if (!isPromise(res)) {\n      res = Promise.resolve(res)\n    }\n    if (store._devtoolHook) {\n      return res.catch(err =&gt; {\n        store._devtoolHook.emit(&#39;vuex:error&#39;, err)\n        throw err\n      })\n    } else {\n      return res\n    }\n  })\n}\n\nfunction registerGetter (store, type, rawGetter, local) {\n  // getters只允许存在一个处理函数，若重复需要报错\n  if (store._wrappedGetters[type]) {\n    console.error(`[vuex] duplicate getter key: ${type}`)\n    return\n  }\n\n  // 存储封装过的getters处理函数\n  store._wrappedGetters[type] = function wrappedGetter (store) {\n    // 为原getters传入对应状态\n    return rawGetter(\n      local.state, // local state\n      local.getters, // local getters\n      store.state, // root state\n      store.getters // root getters\n    )\n  }\n}</code></pre><p>action handler 比 mutation handler 以及 getter wrapper 多拿到 dispatch 和 commit 操作方法，因此 action 可以进行 dispatch action 和 commit mutation 操作。</p>\n<h4 id=\"4-5-4-子-module-安装\"><a href=\"#4-5-4-子-module-安装\" class=\"headerlink\" title=\"4.5.4 子 module 安装\"></a>4.5.4 子 module 安装</h4><p>注册完了根组件的 actions、mutations 以及 getters 后，递归调用自身，为子组件注册其 state，actions、mutations 以及 getters 等。</p>\n<pre><code>module.forEachChild((child, key) =&gt; {\n  installModule(store, rootState, path.concat(key), child, hot)\n})</code></pre><h4 id=\"4-5-5-实例结合\"><a href=\"#4-5-5-实例结合\" class=\"headerlink\" title=\"4.5.5 实例结合\"></a>4.5.5 实例结合</h4><p>前面介绍了 dispatch 和 commit 方法以及 actions 等的实现，下面结合一个官方的<a href=\"https://github.com/vuejs/vuex/tree/dev/examples/shopping-cart\" target=\"_blank\" rel=\"noopener\">购物车</a>实例中的部分代码来加深理解。</p>\n<p>Vuex 配置代码：</p>\n<pre><code>/\n *  store-index.js store配置文件\n *\n /\n\nimport Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;\nimport * as actions from &#39;./actions&#39;\nimport * as getters from &#39;./getters&#39;\nimport cart from &#39;./modules/cart&#39;\nimport products from &#39;./modules/products&#39;\nimport createLogger from &#39;../../../src/plugins/logger&#39;\n\nVue.use(Vuex)\n\nconst debug = process.env.NODE_ENV !== &#39;production&#39;\n\nexport default new Vuex.Store({\n  actions,\n  getters,\n  modules: {\n    cart,\n    products\n  },\n  strict: debug,\n  plugins: debug ? [createLogger()] : []\n})</code></pre><p>Vuex 组件 module 中各模块 state 配置代码部分：</p>\n<pre><code>/**\n *  cart.js\n *\n **/\n\nconst state = {\n  added: [],\n  checkoutStatus: null\n}\n\n/**\n *  products.js\n *\n **/\n\nconst state = {\n  all: []\n}</code></pre><p>加载上述配置后，页面 state 结构如下图：</p>\n<p><img src=\"http://www.jixiaokang.com/wp-content/uploads/2018/05/shopping_cart_state.jpg\" alt=\"cart_state\"></p>\n<p>state 中的属性配置都是按照 option 配置中 module path 的规则来进行的，下面看 action 的操作实例。</p>\n<p>Vuecart 组件代码部分：</p>\n<pre><code>/**\n *  Cart.vue 省略template代码，只看script部分\n *\n **/\n\nexport default {\n  methods: {\n    // 购物车中的购买按钮，点击后会触发结算。源码中会调用 dispatch方法\n    checkout (products) {\n      this.$store.dispatch(&#39;checkout&#39;, products)\n    }\n  }\n}</code></pre><p>Vuexcart.js 组件 action 配置代码部分：</p>\n<pre><code>const actions = {\n  checkout ({ commit, state }, products) {\n    const savedCartItems = [...state.added] // 存储添加到购物车的商品\n    commit(types.CHECKOUT_REQUEST) // 设置提交结算状态\n    shop.buyProducts( // 提交api请求，并传入成功与失败的cb-func\n      products,\n      () =&gt; commit(types.CHECKOUT_SUCCESS), // 请求返回成功则设置提交成功状态\n      () =&gt; commit(types.CHECKOUT_FAILURE, { savedCartItems }) // 请求返回失败则设置提交失败状态\n    )\n  }\n}</code></pre><p>Vue 组件中点击购买执行当前 module 的 dispatch 方法，传入 type 值为 ‘checkout’，payload 值为 ‘products’，在源码中 dispatch 方法在所有注册过的 actions 中查找’checkout’的对应执行数组，取出循环执行。执行的是被封装过的被命名为 wrappedActionHandler 的方法，真正传入的 checkout 的执行函数在 wrappedActionHandler 这个方法中被执行，源码如下（注：前面贴过，这里再看一次）：</p>\n<pre><code>function wrappedActionHandler (payload, cb) {\n    let res = handler({\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb)\n    if (!isPromise(res)) {\n      res = Promise.resolve(res)\n    }\n    if (store._devtoolHook) {\n      return res.catch(err =&gt; {\n        store._devtoolHook.emit(&#39;vuex:error&#39;, err)\n        throw err\n      })\n    } else {\n      return res\n    }\n  }</code></pre><p>handler 在这里就是传入的 checkout 函数，其执行需要的 commit 以及 state 就是在这里被传入，payload 也传入了，在实例中对应接收的参数名为 products。commit 的执行也是同理的，实例中 checkout 还进行了一次 commit 操作，提交一次 type 值为 types.CHECKOUT_REQUEST 的修改，因为 mutation 名字是唯一的，这里进行了常量形式的调用，防止命名重复，执行跟源码分析中一致，调用  <code>function wrappedMutationHandler (payload) { handler(local.state, payload) }</code>  封装函数来实际调用配置的 mutation 方法。</p>\n<p>看到完源码分析和上面的小实例，应该能理解 dispatch action 和 commit mutation 的工作原理了。接着看源码，看看 getters 是如何实现 state 实时访问的。</p>\n<h3 id=\"4-6-store-vm-组件设置\"><a href=\"#4-6-store-vm-组件设置\" class=\"headerlink\" title=\"4.6 store._vm 组件设置\"></a>4.6 store._vm 组件设置</h3><p>执行完各 module 的 install 后，执行 resetStoreVM 方法，进行 store 组件的初始化。</p>\n<pre><code>// initialize the store vm, which is responsible for the reactivity\n// (also registers _wrappedGetters as computed properties)\nresetStoreVM(this, state)</code></pre><p>综合前面的分析可以了解到，Vuex 其实构建的就是一个名为 store 的 vm 组件，所有配置的 state、actions、mutations 以及 getters 都是其组件的属性，所有的操作都是对这个 vm 组件进行的。</p>\n<p>一起看下 resetStoreVM 方法的内部实现。</p>\n<pre><code>function resetStoreVM (store, state) {\n  const oldVm = store._vm // 缓存前vm组件\n\n  // bind store public getters\n  store.getters = {}\n  const wrappedGetters = store._wrappedGetters\n  const computed = {}\n\n  // 循环所有处理过的getters，并新建computed对象进行存储，通过Object.defineProperty方法为getters对象建立属性，使得我们通过this.$store.getters.xxxgetter能够访问到该getters\n  forEachValue(wrappedGetters, (fn, key) =&gt; {\n    // use computed to leverage its lazy-caching mechanism\n    computed[key] = () =&gt; fn(store)\n    Object.defineProperty(store.getters, key, {\n      get: () =&gt; store._vm[key],\n      enumerable: true // for local getters\n    })\n  })\n\n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  const silent = Vue.config.silent\n\n  // 暂时将Vue设为静默模式，避免报出用户加载的某些插件触发的警告\n  Vue.config.silent = true\n  // 设置新的storeVm，将当前初始化的state以及getters作为computed属性（刚刚遍历生成的）\n  store._vm = new Vue({\n    data: { state },\n    computed\n  })\n\n  // 恢复Vue的模式\n  Vue.config.silent = silent\n\n  // enable strict mode for new vm\n  if (store.strict) {\n    // 该方法对state执行$watch以禁止从mutation外部修改state\n    enableStrictMode(store)\n  }\n\n  // 若不是初始化过程执行的该方法，将旧的组件state设置为null，强制更新所有监听者(watchers)，待更新生效，DOM更新完成后，执行vm组件的destroy方法进行销毁，减少内存的占用\n  if (oldVm) {\n    // dispatch changes in all subscribed watchers\n    // to force getter re-evaluation.\n    store._withCommit(() =&gt; {\n      oldVm.state = null\n    })\n    Vue.nextTick(() =&gt; oldVm.$destroy())\n  }\n}</code></pre><p>resetStoreVm 方法创建了当前 store 实例的_vm 组件，至此 store 就创建完毕了。上面代码涉及到了严格模式的判断，看一下严格模式如何实现的。</p>\n<pre><code>function enableStrictMode (store) {\n  store._vm.$watch(&#39;state&#39;, () =&gt; {\n    assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`)\n  }, { deep: true, sync: true })\n}</code></pre><p>很简单的应用，监视 state 的变化，如果没有通过  <code>this._withCommit()</code>  方法进行 state 修改，则报错。</p>\n<h3 id=\"4-7-plugin-注入\"><a href=\"#4-7-plugin-注入\" class=\"headerlink\" title=\"4.7 plugin 注入\"></a>4.7 plugin 注入</h3><p>最后执行 plugin 的植入。</p>\n<pre><code>plugins.concat(devtoolPlugin).forEach(plugin =&gt; plugin(this))</code></pre><p>devtoolPlugin 提供的功能有 3 个：</p>\n<pre><code>// 1. 触发Vuex组件初始化的hook\ndevtoolHook.emit(&#39;vuex:init&#39;, store)\n\n// 2. 提供“时空穿梭”功能，即state操作的前进和倒退\ndevtoolHook.on(&#39;vuex:travel-to-state&#39;, targetState =&gt; {\n  store.replaceState(targetState)\n})\n\n// 3. mutation被执行时，触发hook，并提供被触发的mutation函数和当前的state状态\nstore.subscribe((mutation, state) =&gt; {\n  devtoolHook.emit(&#39;vuex:mutation&#39;, mutation, state)\n})</code></pre><p>源码分析到这里，Vuex 框架的实现原理基本都已经分析完毕。</p>\n<h2 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h2><p>最后我们回过来看文章开始提出的 5 个问题。</p>\n<ol>\n<li><strong>问</strong>：<em>使用 Vuex 只需执行  <code>Vue.use(Vuex)</code>，并在 Vue 的配置中传入一个 store 对象的示例，store 是如何实现注入的？</em></li>\n</ol>\n<blockquote>\n<p><strong>答</strong>：<code>Vue.use(Vuex)</code>  方法执行的是 install 方法，它实现了 Vue 实例对象的 init 方法封装和注入，使传入的 store 对象被设置到 Vue 上下文环境的$store 中。因此在 Vue Component 任意地方都能够通过<code>this.$store</code>访问到该 store。</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>问</strong>：<em>state 内部支持模块配置和模块嵌套，如何实现的？</em></li>\n</ol>\n<blockquote>\n<p><strong>答</strong>：在 store 构造方法中有 makeLocalContext 方法，所有 module 都会有一个 local context，根据配置时的 path 进行匹配。所以执行如<code>dispatch(&#39;submitOrder&#39;, payload)</code>这类 action 时，默认的拿到都是 module 的 local state，如果要访问最外层或者是其他 module 的 state，只能从 rootState 按照 path 路径逐步进行访问。</p>\n</blockquote>\n<ol start=\"3\">\n<li><strong>问</strong>：<em>在执行 dispatch 触发 action(commit 同理)的时候，只需传入(type, payload)，action 执行函数中第一个参数 store 从哪里获取的？</em></li>\n</ol>\n<blockquote>\n<p><strong>答</strong>：store 初始化时，所有配置的 action 和 mutation 以及 getters 均被封装过。在执行如<code>dispatch(&#39;submitOrder&#39;, payload)</code>的时候，actions 中 type 为 submitOrder 的所有处理方法都是被封装后的，其第一个参数为当前的 store 对象，所以能够获取到  <code>{ dispatch, commit, state, rootState }</code>  等数据。</p>\n</blockquote>\n<ol start=\"4\">\n<li><strong>问</strong>：<em>Vuex 如何区分 state 是外部直接修改，还是通过 mutation 方法修改的？</em></li>\n</ol>\n<blockquote>\n<p><strong>答</strong>：Vuex 中修改 state 的唯一渠道就是执行  <code>commit(&#39;xx&#39;, payload)</code>  方法，其底层通过执行  <code>this._withCommit(fn)</code>  设置_committing 标志变量为 true，然后才能修改 state，修改完毕还需要还原_committing 变量。外部修改虽然能够直接修改 state，但是并没有修改_committing 标志位，所以只要 watch 一下 state，state change 时判断是否_committing 值为 true，即可判断修改的合法性。</p>\n</blockquote>\n<ol start=\"5\">\n<li><strong>问</strong>：<em>调试时的”时空穿梭”功能是如何实现的？</em></li>\n</ol>\n<blockquote>\n<p><strong>答</strong>：devtoolPlugin 中提供了此功能。因为 dev 模式下所有的 state change 都会被记录下来，’时空穿梭’ 功能其实就是将当前的 state 替换为记录中某个时刻的 state 状态，利用  <code>store.replaceState(targetState)</code>  方法将执行<code>this._vm.state = state</code>  实现。</p>\n</blockquote>\n<p>源码中还有一些工具函数类似 registerModule、unregisterModule、hotUpdate、watch 以及 subscribe 等，如有兴趣可以打开源码看看，这里不再细述。</p>\n"},{"title":"ESLint 配置","date":"2018-03-12T22:58:00.000Z","_content":"\n# ESLint 配置\n\nESlint 被设计为完全可配置的，这意味着你可以关闭每一个规则而只运行基本语法验证，或混合和匹配 ESLint 默认绑定的规则和你的自定义规则，以让 ESLint 更适合你的项目。有两种主要的方式来配置 ESLint：\n\n1.  **Configuration Comments** \\- 使用 JavaScript 注释把配置信息直接嵌入到一个代码源文件中。\n2.  **Configuration Files** \\- 使用 JavaScript、JSON 或者 YAML 文件为整个目录和它的子目录指定配置信息。可以配置一个独立的 [.eslintrc.\\*](https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/configuring#configuration-file-formats) 文件，或者直接在 [`package.json`](https://link.jianshu.com?t=https://docs.npmjs.com/files/package.json) 文件里的 `eslintConfig` 字段指定配置，ESLint 会查找和自动读取它们，再者，你可以在[命令行](https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface)运行时指定一个任意的配置文件。\n\n有很多信息可以配置：\n\n- **Environments** \\- 指定脚本的运行环境。每种环境都会有一组特定的预定义全局变量。\n- **Globals** \\- 脚本在执行期间访问的额外的全局变量。\n- **Rules** \\- 启用的规则及其各自的错误级别。\n\n所有这些选项让你可以细粒度地控制 ESLint 如何对待你的代码。\n\n## 指定解析器选项\n\nESLint 允许你指定你想要支持的 JavaScript 语言选项。默认情况下，ESLint 支持 ECMAScript 5 语法。你可以覆盖该设置，以启用对 ECMAScript 其它版本和 JSX 的支持。\n\n请注意，对 JSX 语法的支持不用于对 React 的支持。React 使用了一些特定的 ESLint 无法识别的 JSX 语法。如果你正在使用 React 并且想要 React 语义支持，我们推荐你使用 [eslint-plugin-react](https://link.jianshu.com?t=https://github.com/yannickcr/eslint-plugin-react)。\n\n同样的，支持 ES6 语法并不意味着同时支持新的 ES6 全局变量或类型（比如 `Set` 等新类型）。使用 `{ \"parserOptions\": { \"ecmaVersion\": 6 } }` 来启用 ES6 语法支持；要额外支持新的 ES6 全局变量，使用 `{ \"env\":{ \"es6\": true } }`(这个设置会同时自动启用 ES6 语法支持)。\n\n解析器选项可以在 `.eslintrc.*` 文件使用 `parserOptions` 属性设置。可用的选项有：\n\n- `ecmaVersion` \\- 默认设置为 5， 你可以使用 3、5、6、7 或 8 来指定你想要使用的 ECMAScript 版本。你也可以用使用年份命名的版本号指定为 2015（同 6），2016（同 7），或 2017（同 8）\n- `sourceType` \\- 设置为 `\"script\"` (默认) 或 `\"module\"`（如果你的代码是 ECMAScript 模块)。\n- `ecmaFeatures` \\- 这是个对象，表示你想使用的额外的语言特性:`globalReturn` \\- 允许在全局作用域下使用 `return` 语句`impliedStrict` \\- 启用全局 [strict mode](https://link.jianshu.com?t=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) (如果 `ecmaVersion` 是 5 或更高)`jsx` \\- 启用 [JSX](https://link.jianshu.com?t=http://facebook.github.io/jsx/)`experimentalObjectRestSpread` \\- 启用实验性的 [object rest/spread properties](https://link.jianshu.com?t=https://github.com/sebmarkbage/ecmascript-rest-spread) 支持。(**重要：**这是一个实验性的功能,在未来可能会有明显改变。 建议你写的规则 **不要** 依赖该功能，除非当它发生改变时你愿意承担维护成本。)\n\n`.eslintrc.json` 文件示例：\n\n    {\n        \"parserOptions\": {\n            \"ecmaVersion\": 6,\n            \"sourceType\": \"module\",\n            \"ecmaFeatures\": {\n                \"jsx\": true\n            }\n        },\n        \"rules\": {\n            \"semi\": 2\n        }\n    }\n\n设置解析器选项能帮助 ESLint 确定什么是解析错误，所有语言选项默认都是 `false`。\n\n## 指定解析器\n\nESLint 默认使用[Espree](https://link.jianshu.com?t=https://github.com/eslint/espree)作为其解析器，你可以在配置文件中指定一个不同的解析器，只要该解析器符合下列要求：\n\n1.  它必须是本地安装的一个 npm 模块。\n2.  它必须有兼容 Esprima 的接口（它必须输出一个 `parse()` 方法）\n3.  它必须产出兼容 Esprima 的 AST 和 token 对象。\n\n注意，即使满足这些兼容性要求，也不能保证一个外部解析器可以与 ESLint 正常配合工作，ESLint 也不会修复与其它解析器不兼容的相关 bug。\n\n为了表明使用该 npm 模块作为你的解析器，你需要在你的 `.eslintrc` 文件里指定 `parser` 选项。例如，下面的配置指定了 Esprima 作为解析器：\n\n    {\n        \"parser\": \"esprima\",\n        \"rules\": {\n            \"semi\": \"error\"\n        }\n    }\n\n以下解析器与 ESLint 兼容：\n\n- [Esprima](https://link.jianshu.com?t=https://npmjs.com/package/esprima)\n- [Babel-ESLint](https://link.jianshu.com?t=https://npmjs.com/package/babel-eslint) \\- 一个对[Babel](https://link.jianshu.com?t=http://babeljs.io/)解析器的包装，使其能够与 ESLint 兼容。\n- [typescript-eslint-parser(实验)](https://link.jianshu.com?t=https://npmjs.com/package/typescript-eslint-parser) \\- 一个把 TypeScript 转换为 ESTree 兼容格式的解析器，这样它就可以在 ESLint 中使用了。这样做的目的是通过 ESLint 来解析 TypeScript 文件（尽管不一定必须通过所有的 ESLint 规则）。\n\n注意，在使用自定义解析器时，为了让 ESLint 在处理非 ECMAScript 5 特性时正常工作，配置属性 `parserOptions` 仍然是必须的。解析器会被传入 `parserOptions`，但是不一定会使用它们来决定功能特性的开关。\n\n## 指定环境\n\n一个“环境”定义了一组预定义的全局变量。可用的环境包括：\n\n- `browser` \\- 浏览器环境中的全局变量。\n- `node` \\- Node.js 全局变量和 Node.js 作用域。\n- `commonjs` \\- CommonJS 全局变量和 CommonJS 作用域 (一般用于 Browserify/WebPack 打包的只在浏览器中运行的代码)。\n- `shared-node-browser` \\- Node 和 Browser 通用全局变量。\n- `es6` \\- 启用除了 modules 以外的所有 ECMAScript 6 特性（该选项会自动设置 `ecmaVersion` 解析器选项为 6）。\n- `worker` \\- Web Workers 全局变量。\n- `amd` \\- 将 `require()` 和 `define()` 定义为像 [amd](https://link.jianshu.com?t=https://github.com/amdjs/amdjs-api/wiki/AMD) 一样的全局变量。\n- `mocha` \\- 添加所有的 Mocha 测试全局变量。\n- `jasmine` \\- 添加所有的 Jasmine 版本 1.3 和 2.0 的测试全局变量。\n- `jest` \\- Jest 全局变量。\n- `phantomjs` \\- PhantomJS 全局变量。\n- `protractor` \\- Protractor 全局变量。\n- `qunit` \\- QUnit 全局变量。\n- `jquery` \\- jQuery 全局变量。\n- `prototypejs` \\- Prototype.js 全局变量。\n- `shelljs` \\- ShellJS 全局变量。\n- `meteor` \\- Meteor 全局变量。\n- `mongo` \\- MongoDB 全局变量。\n- `applescript` \\- AppleScript 全局变量。\n- `nashorn` \\- Java 8 Nashorn 全局变量。\n- `serviceworker` \\- Service Worker 全局变量。\n- `atomtest` \\- Atom 测试全局变量。\n- `embertest` \\- Ember 测试全局变量。\n- `webextensions` \\- WebExtensions 全局变量。\n- `greasemonkey` \\- GreaseMonkey 全局变量。\n\n这些环境并不是互斥的，所以你可以同时定义多个。\n\n可以在源文件里、在配置文件中或使用 [命令行](https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface) 的 `--env` 选项来指定环境。\n\n要在你的 JavaScript 文件中使用注释来指定环境，格式如下：\n\n    /* eslint-env node, mocha */\n\n该设置启用了 Node.js 和 Mocha 环境。\n\n要在配置文件里指定环境，使用 `env` 关键字指定你想启用的环境，并设置它们为 `true`。例如，以下示例启用了 browser 和 Node.js 的环境：\n\n    {\n        \"env\": {\n            \"browser\": true,\n            \"node\": true\n        }\n    }\n\n或在 `package.json` 文件中：\n\n    {\n        \"name\": \"mypackage\",\n        \"version\": \"0.0.1\",\n        \"eslintConfig\": {\n            \"env\": {\n                \"browser\": true,\n                \"node\": true\n            }\n        }\n    }\n\n在 YAML 文件中：\n\n    ---\n      env:\n        browser: true\n        node: true\n\n如果你想在一个特定的插件中使用一种环境，确保提前在 `plugins` 数组里指定了插件名，然后在 env 配置中不带前缀的插件名后跟一个 `/` ，紧随着环境名。例如：\n\n    {\n        \"plugins\": [\"example\"],\n        \"env\": {\n            \"example/custom\": true\n        }\n    }\n\n或在 `package.json` 文件中\n\n    {\n        \"name\": \"mypackage\",\n        \"version\": \"0.0.1\",\n        \"eslintConfig\": {\n            \"plugins\": [\"example\"],\n            \"env\": {\n                \"example/custom\": true\n            }\n        }\n    }\n\n在 YAML 文件中：\n\n    ---\n      plugins:\n        - example\n      env:\n        example/custom: true\n\n## 指定全局变量\n\n当访问当前源文件内未定义的变量时，[no-undef](https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/no-undef) 规则将发出警告。如果你想在一个源文件里使用全局变量，推荐你在 ESLint 中定义这些全局变量，这样 ESLint 就不会发出警告了。你可以使用注释或在配置文件中定义全局变量。\n\n要在你的 JavaScript 文件中，用注释指定全局变量，格式如下：\n\n    /* global var1, var2 */\n\n这里定义了两个全局变量：`var1` 和 `var2`。如果你想指定这些变量不应被重写（只读），你可以将它们设置为 `false`：\n\n    /* global var1:false, var2:false */\n\n在配置文件里配置全局变量时，使用 `globals` 指出你要使用的全局变量。将变量设置为 `true` 将允许变量被重写，或 `false` 将不允许被重写。比如：\n\n    {\n        \"globals\": {\n            \"var1\": true,\n            \"var2\": false\n        }\n    }\n\n在 YAML 中：\n\n    ---\n      globals:\n        var1: true\n        var2: false\n\n在这些例子中 `var1` 允许被重写，`var2` 不允许被重写。\n\n**注意：** 要启用[no-global-assign](https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/no-global-assign)规则来禁止对只读的全局变量进行修改。\n\n## 配置插件\n\nESLint 支持使用第三方插件。在使用插件之前，你必须使用 npm 安装它。\n\n在配置文件里配置插件时，可以使用 `plugins` 关键字来存放插件名字的列表。插件名称可以省略 `eslint-plugin-` 前缀。\n\n    {\n        \"plugins\": [\n            \"plugin1\",\n            \"eslint-plugin-plugin2\"\n        ]\n    }\n\n在 YAML 中：\n\n    ---\n      plugins:\n        - plugin1\n        - eslint-plugin-plugin2\n\n**注意：**全局安装的 ESLint 只能使用全局安装的插件。本地安装的 ESLint 不仅可以使用本地安装的插件，也可以使用全局安装的插件。\n\n## 配置规则\n\nESLint 附带有大量的规则。你可以使用注释或配置文件修改你项目中要使用的规则。要改变一个规则设置，你必须将规则 ID 设置为下列值之一：\n\n- `\"off\"` 或 `0` \\- 关闭规则\n- `\"warn\"` 或 `1` \\- 开启规则，使用警告级别的错误：`warn` (不会导致程序退出)\n- `\"error\"` 或 `2` \\- 开启规则，使用错误级别的错误：`error` (当被触发的时候，程序会退出)\n\n为了在文件注释里配置规则，使用以下格式的注释：\n\n    /* eslint eqeqeq: \"off\", curly: \"error\" */\n\n在这个例子里，[`eqeqeq`](https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/eqeqeq) 规则被关闭，[`curly`](https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/curly) 规则被打开，定义为错误级别。你也可以使用对应的数字定义规则严重程度：\n\n    /* eslint eqeqeq: 0, curly: 2 */\n\n这个例子和上个例子是一样的，只不过它是用的数字而不是字符串。`eqeqeq` 规则是关闭的，`curly` 规则被设置为错误级别。\n\n如果一个规则有额外的选项，你可以使用数组字面量指定它们，比如：\n\n    /* eslint quotes: [\"error\", \"double\"], curly: 2 */\n\n这条注释为规则 [`quotes`](https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/quotes) 指定了 “double”选项。数组的第一项总是规则的严重程度（数字或字符串）。\n\n还可以使用 `rules` 连同错误级别和任何你想使用的选项，在配置文件中进行规则配置。例如：\n\n    {\n        \"rules\": {\n            \"eqeqeq\": \"off\",\n            \"curly\": \"error\",\n            \"quotes\": [\"error\", \"double\"]\n        }\n    }\n\n在 YAML 中：\n\n    ---\n    rules:\n      eqeqeq: off\n      curly: error\n      quotes:\n        - error\n        - double\n\n配置定义在插件中的一个规则的时候，你必须使用 `插件名/规则ID` 的形式。比如：\n\n    {\n        \"plugins\": [\n            \"plugin1\"\n        ],\n        \"rules\": {\n            \"eqeqeq\": \"off\",\n            \"curly\": \"error\",\n            \"quotes\": [\"error\", \"double\"],\n            \"plugin1/rule1\": \"error\"\n        }\n    }\n\n在 YAML 中：\n\n    ---\n    plugins:\n      - plugin1\n    rules:\n      eqeqeq: 0\n      curly: error\n      quotes:\n        - error\n        - \"double\"\n      plugin1/rule1: error\n\n在这些配置文件中，规则 `plugin1/rule1` 表示来自插件 `plugin1` 的 `rule1` 规则。你也可以使用这种格式的注释配置，比如：\n\n    /* eslint \"plugin1/rule1\": \"error\" */\n\n**注意：**当指定来自插件的规则时，确保删除 `eslint-plugin-` 前缀。ESLint 在内部只使用没有前缀的名称去定位规则。\n\n## 使用行注释禁用规则\n\n可以在你的文件中使用以下格式的块注释来临时禁止规则出现警告：\n\n    /* eslint-disable */\n\n    alert('foo');\n\n    /* eslint-enable */\n\n你也可以对指定的规则启用或禁用警告:\n\n    /* eslint-disable no-alert, no-console */\n\n    alert('foo');\n    console.log('bar');\n\n    /* eslint-enable no-alert, no-console */\n\n如果在整个文件范围内禁止规则出现警告，将 `/* eslint-disable */` 块注释放在文件顶部：\n\n    /* eslint-disable */\n\n    alert('foo');\n\n你也可以对整个文件启用或禁用警告:\n\n    /* eslint-disable no-alert */\n\n    // Disables no-alert for the rest of the file\n    alert('foo');\n\n可以在你的文件中使用以下格式的行注释在某一特定的行上禁用所有规则：\n\n    alert('foo'); // eslint-disable-line\n\n    // eslint-disable-next-line\n    alert('foo');\n\n在某一特定的行上禁用某个指定的规则：\n\n    alert('foo'); // eslint-disable-line no-alert\n\n    // eslint-disable-next-line no-alert\n    alert('foo');\n\n在某个特定的行上禁用多个规则：\n\n    alert('foo'); // eslint-disable-line no-alert, quotes, semi\n\n    // eslint-disable-next-line no-alert, quotes, semi\n    alert('foo');\n\n上面的所有方法同样适用于插件规则。例如，禁止 `eslint-plugin-example` 的 `rule-name` 规则，把插件名（`example`）和规则名（`rule-name`）结合为 `example/rule-name`：\n\n    foo(); // eslint-disable-line example/rule-name\n\n**注意：**为文件的某部分禁用警告的注释，告诉 ESLint 不要对禁用的代码报告规则的冲突。ESLint 仍解析整个文件，然而，禁用的代码仍需要是有效的 JavaScript 语法。\n\n## 添加分享配置\n\nESLint 支持在配置文件添加共享设置。你可以添加 `settings` 对象到配置文件，它将提供给每一个将被执行的规则。如果你想添加的自定义规则而且使它们可以访问到相同的信息，这将会很有用，并且很容易配置。\n\n在 JSON 中：\n\n    {\n        \"settings\": {\n            \"sharedData\": \"Hello\"\n        }\n    }\n\n在 YAML 中：\n\n    ---\n      settings:\n        sharedData: \"Hello\"\n\n## 使用配置文件\n\n有两种方式可以使用配置文件。第一种是将文件保存到你喜欢的地方，然后将它的位置使用 `-c` 选项传递命令行，比如：\n\n    eslint -c myconfig.json myfiletotest.js\n\n第二种方式是通过 `.eslintrc.*` 和 `package.json`。ESLint 将自动在要检测的文件目录里寻找它们，紧接着是父级目录，一直到文件系统的根目录。当你想对一个项目的不同部分的使用不同配置，或当你希望别人能够直接使用 ESLint，而无需记住要在配置文件中传递什么，这种方式就很有用。\n\n每种情况，配置文件都会覆盖默认设置。\n\n## 配置文件文件格式\n\nESLint 支持几种格式的配置文件：\n\n- **JavaScript** \\- 使用 `.eslintrc.js` 然后输出一个配置对象。\n- **YAML** \\- 使用 `.eslintrc.yaml` 或 `.eslintrc.yml` 去定义配置的结构。\n- **JSON** \\- 使用 `.eslintrc.json` 去定义配置的结构，ESLint 的 JSON 文件允许 JavaScript 风格的注释。\n- **(不推荐)** \\- 使用 `.eslintrc`，可以使 JSON 也可以是 YAML。\n- **package.json** \\- 在 `package.json` 里创建一个 `eslintConfig`属性，在那里定义你的配置。\n\n如果同一个目录下有多个配置文件，ESLint 只会使用一个。优先级顺序如下：\n\n1.  `.eslintrc.js`\n2.  `.eslintrc.yaml`\n3.  `.eslintrc.yml`\n4.  `.eslintrc.json`\n5.  `.eslintrc`\n6.  `package.json`\n\n## 配置的层级和继承\n\n当使用 `.eslintrc.*` 和 `package.json`文件的配置时，你可以利用层叠配置。例如，假如你有以下结构：\n\n    your-project\n    ├── .eslintrc\n    ├── lib\n    │ └── source.js\n    └─┬ tests\n      ├── .eslintrc\n      └── test.js\n\n层叠配置使用离要检测的文件最近的 `.eslintrc`文件作为最高优先级，然后才是父目录里的配置文件，等等。当你在这个项目中允许 ESLint 时，`lib/`下面的所有文件将使用项目根目录里的 `.eslintrc` 文件作为它的配置文件。当 ESLint 遍历到 `test/` 目录，`your-project/.eslintrc` 之外，它还会用到 `your-project/tests/.eslintrc`。所以 `your-project/tests/test.js` 是基于它的目录层次结构中的两个`.eslintrc` 文件的组合，并且离的最近的一个优先。通过这种方式，你可以有项目级 ESLint 设置，也有覆盖特定目录的 ESLint 设置。\n\n同样的，如果在根目录的 `package.json` 文件中有一个 `eslintConfig` 字段，其中的配置将使用于所有子目录，但是当 `tests` 目录下的 `.eslintrc` 文件中的规则与之发生冲突时，就会覆盖它。\n\n    your-project\n    ├── package.json\n    ├── lib\n    │ └── source.js\n    └─┬ tests\n      ├── .eslintrc\n      └── test.js\n\n如果同一目录下 `.eslintrc` 和 `package.json` 同时存在，`.eslintrc` 优先级高会被使用，`package.json` 文件将不会被使用。\n\n**注意：**如果在你的主目录下有一个自定义的配置文件 (`~/.eslintrc`) ，如果没有其它配置文件时它才会被使用。因为个人配置将适用于用户目录下的所有目录和文件，包括第三方的代码，当 ESLint 运行时可能会导致问题。\n\n默认情况下，ESLint 会在所有父级目录里寻找配置文件，一直到根目录。如果你想要你所有项目都遵循一个特定的约定时，这将会很有用，但有时候会导致意想不到的结果。为了将 ESLint 限制到一个特定的项目，在你项目根目录下的 `package.json` 文件或者 `.eslintrc.*` 文件里的 `eslintConfig` 字段下设置 `\"root\": true`。ESLint 一旦发现配置文件中有 `\"root\": true`，它就会停止在父级目录中寻找。\n\n    {\n        \"root\": true\n    }\n\n在 YAML 中：\n\n    ---\n      root: true\n\n例如，`projectA` 的 `lib/` 目录下的 `.eslintrc` 文件中设置了 `\"root\": true`。这种情况下，当检测 `main.js` 时，`lib/` 下的配置将会被使用，`projectA/` 下的 `.eslintrc` 将不会被使用。\n\n    home\n    └── user\n        ├── .eslintrc <- Always skipped if other configs present\n        └── projectA\n            ├── .eslintrc  <- Not used\n            └── lib\n                ├── .eslintrc  <- { \"root\": true }\n                └── main.js\n\n完整的配置层次结构，从最高优先级最低的优先级，如下:\n\n1.  行内配置\n    1.  `/*eslint-disable*/` 和 `/*eslint-enable*/`\n    2.  `/*global*/`\n    3.  `/*eslint*/`\n    4.  `/*eslint-env*/`\n2.  命令行选项：\n    1.  `--global`\n    2.  `--rule`\n    3.  `--env`\n    4.  `-c`、`--config`\n3.  项目级配置：\n    1.  与要检测的文件在同一目录下的 `.eslintrc.*` 或 `package.json` 文件\n    2.  继续在父级目录寻找 `.eslintrc` 或 `package.json`文件，直到根目录（包括根目录）或直到发现一个有`\"root\": true`的配置。\n    3.  如果不是（1）到（3）中的任何一种情况，退回到 `~/.eslintrc` 中自定义的默认配置。\n\n## 扩展配置文件\n\n一个配置文件可以被基础配置中的已启用的规则继承。\n\n`extends` 属性值可以是：\n\n- 在配置中指定的一个字符串\n- 字符串数组：每个配置继承它前面的配置\n\nESLint 递归地进行扩展配置，所以一个基础的配置也可以有一个 `extends` 属性。\n\n`rules` 属性可以做下面的任何事情以扩展（或覆盖）规则：\n\n- 启用额外的规则\n- 改变继承的规则级别而不改变它的选项：\n  - 基础配置：`\"eqeqeq\": [\"error\", \"allow-null\"]`\n  - 派生的配置：`\"eqeqeq\": \"warn\"`\n  - 最后生成的配置：`\"eqeqeq\": [\"warn\", \"allow-null\"]`\n- 覆盖基础配置中的规则的选项\n  - 基础配置：`\"quotes\": [\"error\", \"single\", \"avoid-escape\"]`\n  - 派生的配置：`\"quotes\": [\"error\", \"single\"]`\n  - 最后生成的配置：`\"quotes\": [\"error\", \"single\"]`\n\n### 使用 eslint:recommended\n\n值为 `\"eslint:recommended\"` 的 `extends` 属性启用一系列核心规则，这些规则报告一些常见问题，在 [规则页面](https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/) 中被标记为 。这个推荐的子集只能在 ESLint 主要版本进行更新。\n\n如果你的配置集成了推荐的规则：在你升级到 ESLint 新的主版本之后，在你使用[命令行](https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface#fix)的 `--fix` 选项之前，检查一下报告的问题，这样你就知道一个新的可修复的推荐的规则将更改代码。\n\n`eslint --init` 命令可以创建一个配置，这样你就可以继承推荐的规则。\n\nJavaScript 格式的一个配置文件的例子：\n\n    module.exports = {\n        \"extends\": \"eslint:recommended\",\n        \"rules\": {\n            // enable additional rules\n            \"indent\": [\"error\", 4],\n            \"linebreak-style\": [\"error\", \"unix\"],\n            \"quotes\": [\"error\", \"double\"],\n            \"semi\": [\"error\", \"always\"],\n\n            // override default options for rules from base configurations\n            \"comma-dangle\": [\"error\", \"always\"],\n            \"no-cond-assign\": [\"error\", \"always\"],\n\n            // disable rules from base configurations\n            \"no-console\": \"off\",\n        }\n    }\n\n### 使用可共享的配置包\n\n[可共享的配置](https://link.jianshu.com?t=https://cn.eslint.org/docs/developer-guide/shareable-configs) 是一个 npm 包，它输出一个配置对象。要确保这个包安装在 ESLint 能请求到的目录下。\n\n`extends` 属性值可以省略包名的前缀 `eslint-config-`。\n\n`eslint --init` 命令可以创建一个配置，这样你就可以扩展一个流行的风格指南（比如，`eslint-config-standard`）。\n\nYAML 格式的一个配置文件的例子：\n\n    extends: standard\n    rules:\n      comma-dangle:\n        - error\n        - always\n      no-empty: warn\n\n### 使用插件中的配置\n\n[插件](https://link.jianshu.com?t=https://cn.eslint.org/docs/developer-guide/working-with-plugins) 是一个 npm 包，通常输出规则。一些插件也可以输出一个或多个命名的 [配置](https://link.jianshu.com?t=https://cn.eslint.org/docs/developer-guide/working-with-plugins#configs-in-plugins)。要确保这个包安装在 ESLint 能请求到的目录下。\n\n`plugins` [属性值](https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/configuring#configuring-plugins) 可以省略包名的前缀 `eslint-plugin-`。\n\n`extends` 属性值可以由以下组成：\n\n- `plugin:`\n- 包名 (省略了前缀，比如，`react`)\n- `/`\n- 配置名称 (比如 `recommended`)\n\nJSON 格式的一个配置文件的例子：\n\n    {\n        \"plugins\": [\n            \"react\"\n        ],\n        \"extends\": [\n            \"eslint:recommended\",\n            \"plugin:react/recommended\"\n        ],\n        \"rules\": {\n           \"no-set-state\": \"off\"\n        }\n    }\n\n### 使用一个配置文件\n\n`extends` 属性值可以是基本[配置文件](https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/configuring#using-configuration-files)的绝对路径或相对路径。\n\nESLint 解析基本配置文件的相对路径相对你你使用的配置文件，**除非**那个文件在你的主目录或非 ESLint 安装目录的父级目录。在这些情况下，ESLint 解析基本配合文件的相对路径相对于被检测的 **项目**目录（尤其是当前工作目录）。\n\nJSON 格式的一个配置文件的例子：\n\n    {\n        \"extends\": [\n            \"./node_modules/coding-standard/eslintDefaults.js\",\n            \"./node_modules/coding-standard/.eslintrc-es6\",\n            \"./node_modules/coding-standard/.eslintrc-jsx\"\n        ],\n        \"rules\": {\n            \"eqeqeq\": \"warn\"\n        }\n    }\n\n### 使用 eslint:all\n\n`extends` 属性值可以是 `\"eslint:all\"`，启用当前安装的 ESLint 中所有的核心规则。这些规则可以在 ESLint 的任何版本进行更改。\n\n**重要：**这些配置 **不推荐在产品中使用**，因为它随着 ESLint 版本进行更改。使用的话，请自己承担风险。\n\n如果你配置 ESLint 升级时自动地启用新规则，当源码没有任何改变时，ESLint 可以报告新问题，因此任何 ESLint 的新的小版本好像有破坏性的更改。\n\n当你决定在一个项目上使用的规则和选项，尤其是如果你很少覆盖选项或禁用规则，你可能启用所有核心规则作为一种快捷方式使用。规则的默认选项并不是 ESLint 推荐的（例如，`quotes` 规则的默认选项并不意味着双引号要比单引号好）。\n\n如果你的配置扩展了所有的核心规则：在你升级到一个新的大或小的 ESLint 版本，在你使用[命令行](https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface#fix)的 `--fix` 选项之前，检查一下报告的问题，这样你就知道一个新的可修复的规则将更改代码。\n\nJavaScript 格式的一个配置文件的例子：\n\n    module.exports = {\n        \"extends\": \"eslint:all\",\n        \"rules\": {\n            // override default options\n            \"comma-dangle\": [\"error\", \"always\"],\n            \"indent\": [\"error\", 2],\n            \"no-cond-assign\": [\"error\", \"always\"],\n\n            // disable now, but enable in the future\n            \"one-var\": \"off\", // [\"error\", \"never\"]\n\n            // disable\n            \"init-declarations\": \"off\",\n            \"no-console\": \"off\",\n            \"no-inline-comments\": \"off\",\n        }\n    }\n\n## 基于 glob 模式的配置\n\n有时，你可能需要更精细的配置，比如，如果同一个目录下的文件需要有不同的配置。因此，你可以在配置中使用 `overrides` 键，它只适用于匹配特定的 glob 模式的文件，使用你在命令行上传递的格式 (e.g., `app/**/*.test.js`)。\n\n### 怎么工作\n\n- Glob 模式覆盖只能在配置文件 (`.eslintrc.*` 或 `package.json`) 中进行配置。\n- 模式应用于相对于配置文件的目录的文件路径。 比如，如果你的配置文件的路径为 `/Users/john/workspace/any-project/.eslintrc.js` 而你要检测的路径为 `/Users/john/workspace/any-project/lib/util.js`，那么你在 `.eslintrc.js` 中提供的模式是相对于 `lib/util.js` 来执行的.\n- 在相同的配置文件中，Glob 模式覆盖比其他常规配置具有更高的优先级。 同一个配置中的多个覆盖将按顺序被应用。也就是说，配置文件中的最后一个覆盖会有最高优先级。\n- 一个 glob 特定的配置几乎与 ESLint 的其他配置相同。覆盖块可以包含常规配置中的除了 `extends`、`overrides` 和 `root` 之外的其他任何有效配置选项，\n- 可以在单个覆盖块中提供多个 glob 模式。一个文件必须匹配至少一个配置中提供的模式。\n- 覆盖块也可以指定从匹配中排除的模式。如果一个文件匹配了任何一个排除模式，该配置将不再被应用。\n\n### 相对 glob 模式\n\n    project-root\n    ├── app\n    │   ├── lib\n    │   │   ├── foo.js\n    │   │   ├── fooSpec.js\n    │   ├── components\n    │   │   ├── bar.js\n    │   │   ├── barSpec.js\n    │   ├── .eslintrc.json\n    ├── server\n    │   ├── server.js\n    │   ├── serverSpec.js\n    ├── .eslintrc.json\n\n`app/.eslintrc.json` 文件中的配置定义了 glob 模式 `**/*Spec.js`。该模式是相对 `app/.eslintrc.json` 的基本目录的。因此，该模式将匹配 `app/lib/fooSpec.js` 和 `app/components/barSpec.js` 但 **不匹配** `server/serverSpec.js`。如果你在项目根目录下的 `.eslintrc.json` 文件中定义了同样的模式，它将匹配这三个 `*Spec` 文件。\n\n### 配置示例\n\n在你的 `.eslintrc.json` 文件中：\n\n    {\n      \"rules\": {\n        \"quotes\": [ 2, \"double\" ]\n      },\n\n      \"overrides\": [\n        {\n          \"files\": [ \"bin/*.js\", \"lib/*.js\" ],\n          \"excludedFiles\": \"*.test.js\",\n          \"rules\": {\n            \"quotes\": [ 2, \"single\" ]\n          }\n        }\n      ]\n    }\n\n## 在配置文件中注释\n\nJSON 和 YAML 配置文件格式都支持注释 ( `package.json` 文件不应该包括注释)。你可以在其他类型的文件中使用 JavaScript 风格的注释或使用 YAML 风格的注释，ESLint 会忽略它们。这允许你的配置更加人性化。例如：\n\n    {\n        \"env\": {\n            \"browser\": true\n        },\n        \"rules\": {\n            // Override our default settings just for this directory\n            \"eqeqeq\": \"warn\",\n            \"strict\": \"off\"\n        }\n    }\n\n## 指定需要检查的文件扩展名\n\n目前，告诉 ESLint 哪个文件扩展名要检测的唯一方法是使用 [`--ext`](https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface#ext) 命令行选项指定一个逗号分隔的扩展名列表。注意，该标记只在与目录一起使用时有效，如果使用文件名或 glob 模式，它将会被忽略。\n\n## 忽略文件和目录\n\n你可以通过在项目根目录创建一个 `.eslintignore` 文件告诉 ESLint 去忽略特定的文件和目录。`.eslintignore` 文件是一个纯文本文件，其中的每一行都是一个 glob 模式表明哪些路径应该忽略检测。例如，以下将忽略所有的 JavaScript 文件：\n\n    **/*.js\n\n当 ESLint 运行时，在确定哪些文件要检测之前，它会在当前工作目录中查找一个 `.eslintignore` 文件。如果发现了这个文件，当遍历目录时，将会应用这些偏好设置。一次只有一个 `.eslintignore` 文件会被使用，所以，不是当前工作目录下的 `.eslintignore` 文件将不会被用到。\n\nGlobs 匹配使用 [node-ignore](https://link.jianshu.com?t=https://github.com/kaelzhang/node-ignore)，所以大量可用的特性有：\n\n- 以 `#` 开头的行被当作注释，不影响忽略模式。\n- 路径是相对于 `.eslintignore` 的位置或当前工作目录。这也会影响通过 `--ignore-pattern`传递的路径。\n- 忽略模式同 `.gitignore` [规范](https://link.jianshu.com?t=http://git-scm.com/docs/gitignore)\n- 以 `!` 开头的行是否定模式，它将会重新包含一个之前被忽略的模式。\n\n除了 `.eslintignore` 文件中的模式，ESLint 总是忽略 `/node_modules/*` 和 `/bower_components/*` 中的文件。\n\n例如：把下面 `.eslintignore` 文件放到当前工作目录里，将忽略 `node_modules`，`bower_components` 以及 `build/` 目录下除了 `build/index.js` 的所有文件。\n\n    # /node_modules/* and /bower_components/* ignored by default\n\n    # Ignore built files except build/index.js\n    build/*\n    !build/index.js\n\n### 使用备用文件\n\n如果相比于当前工作目录下 `.eslintignore` 文件，你更想使用一个不同的文件，你可以在命令行使用 `--ignore-path` 选项指定它。例如，你可以使用 `.jshintignore` 文件，因为它有相同的格式：\n\n    eslint --ignore-path .jshintignore file.js\n\n你也可以使用你的 `.gitignore` 文件：\n\n    eslint --ignore-path .gitignore file.js\n\n任何文件只要满足标准忽略文件格式都可以用。记住，指定 `--ignore-path` 意味着任何现有的 `.eslintignore` 文件将不被使用。请注意，`.eslintignore` 中的匹配规则比 `.gitignore` 中的更严格。\n\n### 在 package.json 中使用 eslintConfig\n\n    {\n      \"name\": \"mypackage\",\n      \"version\": \"0.0.1\",\n      \"eslintConfig\": {\n          \"env\": {\n              \"browser\": true,\n              \"node\": true\n          }\n      },\n      \"eslintIgnore\": [\"hello.js\", \"world.js\"]\n    }\n\n### 忽略文件告警\n\n当您将目录传递给 ESLint 时，文件和目录将被忽略。如果将特定文件传递给 ESLint，则会看到一条警告，指示该文件已被跳过。例如，假设你有一个 `.eslintignore` 文件，如下所示：\n\n    foo.js\n\n然后，您执行：\n\n    eslint foo.js\n\n您将会看到以下告警：\n\n    foo.js\n      0:0  warning  File ignored because of your .eslintignore file. Use --no-ignore to override.\n\n    ✖ 1 problem (0 errors, 1 warning)\n\n发生此消息是因为 ESLint 不确定是否要检查该文件。如消息所示，您可以使用 `--no-ignore` 省略使用忽略规则。\n","source":"_posts/2018-03-13-ESLint 配置.md","raw":"---\ntitle: ESLint 配置\ntags:\n  - 技术\ndate: 2018-03-13 06:58:00\ncategories: 教程\n---\n\n# ESLint 配置\n\nESlint 被设计为完全可配置的，这意味着你可以关闭每一个规则而只运行基本语法验证，或混合和匹配 ESLint 默认绑定的规则和你的自定义规则，以让 ESLint 更适合你的项目。有两种主要的方式来配置 ESLint：\n\n1.  **Configuration Comments** \\- 使用 JavaScript 注释把配置信息直接嵌入到一个代码源文件中。\n2.  **Configuration Files** \\- 使用 JavaScript、JSON 或者 YAML 文件为整个目录和它的子目录指定配置信息。可以配置一个独立的 [.eslintrc.\\*](https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/configuring#configuration-file-formats) 文件，或者直接在 [`package.json`](https://link.jianshu.com?t=https://docs.npmjs.com/files/package.json) 文件里的 `eslintConfig` 字段指定配置，ESLint 会查找和自动读取它们，再者，你可以在[命令行](https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface)运行时指定一个任意的配置文件。\n\n有很多信息可以配置：\n\n- **Environments** \\- 指定脚本的运行环境。每种环境都会有一组特定的预定义全局变量。\n- **Globals** \\- 脚本在执行期间访问的额外的全局变量。\n- **Rules** \\- 启用的规则及其各自的错误级别。\n\n所有这些选项让你可以细粒度地控制 ESLint 如何对待你的代码。\n\n## 指定解析器选项\n\nESLint 允许你指定你想要支持的 JavaScript 语言选项。默认情况下，ESLint 支持 ECMAScript 5 语法。你可以覆盖该设置，以启用对 ECMAScript 其它版本和 JSX 的支持。\n\n请注意，对 JSX 语法的支持不用于对 React 的支持。React 使用了一些特定的 ESLint 无法识别的 JSX 语法。如果你正在使用 React 并且想要 React 语义支持，我们推荐你使用 [eslint-plugin-react](https://link.jianshu.com?t=https://github.com/yannickcr/eslint-plugin-react)。\n\n同样的，支持 ES6 语法并不意味着同时支持新的 ES6 全局变量或类型（比如 `Set` 等新类型）。使用 `{ \"parserOptions\": { \"ecmaVersion\": 6 } }` 来启用 ES6 语法支持；要额外支持新的 ES6 全局变量，使用 `{ \"env\":{ \"es6\": true } }`(这个设置会同时自动启用 ES6 语法支持)。\n\n解析器选项可以在 `.eslintrc.*` 文件使用 `parserOptions` 属性设置。可用的选项有：\n\n- `ecmaVersion` \\- 默认设置为 5， 你可以使用 3、5、6、7 或 8 来指定你想要使用的 ECMAScript 版本。你也可以用使用年份命名的版本号指定为 2015（同 6），2016（同 7），或 2017（同 8）\n- `sourceType` \\- 设置为 `\"script\"` (默认) 或 `\"module\"`（如果你的代码是 ECMAScript 模块)。\n- `ecmaFeatures` \\- 这是个对象，表示你想使用的额外的语言特性:`globalReturn` \\- 允许在全局作用域下使用 `return` 语句`impliedStrict` \\- 启用全局 [strict mode](https://link.jianshu.com?t=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) (如果 `ecmaVersion` 是 5 或更高)`jsx` \\- 启用 [JSX](https://link.jianshu.com?t=http://facebook.github.io/jsx/)`experimentalObjectRestSpread` \\- 启用实验性的 [object rest/spread properties](https://link.jianshu.com?t=https://github.com/sebmarkbage/ecmascript-rest-spread) 支持。(**重要：**这是一个实验性的功能,在未来可能会有明显改变。 建议你写的规则 **不要** 依赖该功能，除非当它发生改变时你愿意承担维护成本。)\n\n`.eslintrc.json` 文件示例：\n\n    {\n        \"parserOptions\": {\n            \"ecmaVersion\": 6,\n            \"sourceType\": \"module\",\n            \"ecmaFeatures\": {\n                \"jsx\": true\n            }\n        },\n        \"rules\": {\n            \"semi\": 2\n        }\n    }\n\n设置解析器选项能帮助 ESLint 确定什么是解析错误，所有语言选项默认都是 `false`。\n\n## 指定解析器\n\nESLint 默认使用[Espree](https://link.jianshu.com?t=https://github.com/eslint/espree)作为其解析器，你可以在配置文件中指定一个不同的解析器，只要该解析器符合下列要求：\n\n1.  它必须是本地安装的一个 npm 模块。\n2.  它必须有兼容 Esprima 的接口（它必须输出一个 `parse()` 方法）\n3.  它必须产出兼容 Esprima 的 AST 和 token 对象。\n\n注意，即使满足这些兼容性要求，也不能保证一个外部解析器可以与 ESLint 正常配合工作，ESLint 也不会修复与其它解析器不兼容的相关 bug。\n\n为了表明使用该 npm 模块作为你的解析器，你需要在你的 `.eslintrc` 文件里指定 `parser` 选项。例如，下面的配置指定了 Esprima 作为解析器：\n\n    {\n        \"parser\": \"esprima\",\n        \"rules\": {\n            \"semi\": \"error\"\n        }\n    }\n\n以下解析器与 ESLint 兼容：\n\n- [Esprima](https://link.jianshu.com?t=https://npmjs.com/package/esprima)\n- [Babel-ESLint](https://link.jianshu.com?t=https://npmjs.com/package/babel-eslint) \\- 一个对[Babel](https://link.jianshu.com?t=http://babeljs.io/)解析器的包装，使其能够与 ESLint 兼容。\n- [typescript-eslint-parser(实验)](https://link.jianshu.com?t=https://npmjs.com/package/typescript-eslint-parser) \\- 一个把 TypeScript 转换为 ESTree 兼容格式的解析器，这样它就可以在 ESLint 中使用了。这样做的目的是通过 ESLint 来解析 TypeScript 文件（尽管不一定必须通过所有的 ESLint 规则）。\n\n注意，在使用自定义解析器时，为了让 ESLint 在处理非 ECMAScript 5 特性时正常工作，配置属性 `parserOptions` 仍然是必须的。解析器会被传入 `parserOptions`，但是不一定会使用它们来决定功能特性的开关。\n\n## 指定环境\n\n一个“环境”定义了一组预定义的全局变量。可用的环境包括：\n\n- `browser` \\- 浏览器环境中的全局变量。\n- `node` \\- Node.js 全局变量和 Node.js 作用域。\n- `commonjs` \\- CommonJS 全局变量和 CommonJS 作用域 (一般用于 Browserify/WebPack 打包的只在浏览器中运行的代码)。\n- `shared-node-browser` \\- Node 和 Browser 通用全局变量。\n- `es6` \\- 启用除了 modules 以外的所有 ECMAScript 6 特性（该选项会自动设置 `ecmaVersion` 解析器选项为 6）。\n- `worker` \\- Web Workers 全局变量。\n- `amd` \\- 将 `require()` 和 `define()` 定义为像 [amd](https://link.jianshu.com?t=https://github.com/amdjs/amdjs-api/wiki/AMD) 一样的全局变量。\n- `mocha` \\- 添加所有的 Mocha 测试全局变量。\n- `jasmine` \\- 添加所有的 Jasmine 版本 1.3 和 2.0 的测试全局变量。\n- `jest` \\- Jest 全局变量。\n- `phantomjs` \\- PhantomJS 全局变量。\n- `protractor` \\- Protractor 全局变量。\n- `qunit` \\- QUnit 全局变量。\n- `jquery` \\- jQuery 全局变量。\n- `prototypejs` \\- Prototype.js 全局变量。\n- `shelljs` \\- ShellJS 全局变量。\n- `meteor` \\- Meteor 全局变量。\n- `mongo` \\- MongoDB 全局变量。\n- `applescript` \\- AppleScript 全局变量。\n- `nashorn` \\- Java 8 Nashorn 全局变量。\n- `serviceworker` \\- Service Worker 全局变量。\n- `atomtest` \\- Atom 测试全局变量。\n- `embertest` \\- Ember 测试全局变量。\n- `webextensions` \\- WebExtensions 全局变量。\n- `greasemonkey` \\- GreaseMonkey 全局变量。\n\n这些环境并不是互斥的，所以你可以同时定义多个。\n\n可以在源文件里、在配置文件中或使用 [命令行](https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface) 的 `--env` 选项来指定环境。\n\n要在你的 JavaScript 文件中使用注释来指定环境，格式如下：\n\n    /* eslint-env node, mocha */\n\n该设置启用了 Node.js 和 Mocha 环境。\n\n要在配置文件里指定环境，使用 `env` 关键字指定你想启用的环境，并设置它们为 `true`。例如，以下示例启用了 browser 和 Node.js 的环境：\n\n    {\n        \"env\": {\n            \"browser\": true,\n            \"node\": true\n        }\n    }\n\n或在 `package.json` 文件中：\n\n    {\n        \"name\": \"mypackage\",\n        \"version\": \"0.0.1\",\n        \"eslintConfig\": {\n            \"env\": {\n                \"browser\": true,\n                \"node\": true\n            }\n        }\n    }\n\n在 YAML 文件中：\n\n    ---\n      env:\n        browser: true\n        node: true\n\n如果你想在一个特定的插件中使用一种环境，确保提前在 `plugins` 数组里指定了插件名，然后在 env 配置中不带前缀的插件名后跟一个 `/` ，紧随着环境名。例如：\n\n    {\n        \"plugins\": [\"example\"],\n        \"env\": {\n            \"example/custom\": true\n        }\n    }\n\n或在 `package.json` 文件中\n\n    {\n        \"name\": \"mypackage\",\n        \"version\": \"0.0.1\",\n        \"eslintConfig\": {\n            \"plugins\": [\"example\"],\n            \"env\": {\n                \"example/custom\": true\n            }\n        }\n    }\n\n在 YAML 文件中：\n\n    ---\n      plugins:\n        - example\n      env:\n        example/custom: true\n\n## 指定全局变量\n\n当访问当前源文件内未定义的变量时，[no-undef](https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/no-undef) 规则将发出警告。如果你想在一个源文件里使用全局变量，推荐你在 ESLint 中定义这些全局变量，这样 ESLint 就不会发出警告了。你可以使用注释或在配置文件中定义全局变量。\n\n要在你的 JavaScript 文件中，用注释指定全局变量，格式如下：\n\n    /* global var1, var2 */\n\n这里定义了两个全局变量：`var1` 和 `var2`。如果你想指定这些变量不应被重写（只读），你可以将它们设置为 `false`：\n\n    /* global var1:false, var2:false */\n\n在配置文件里配置全局变量时，使用 `globals` 指出你要使用的全局变量。将变量设置为 `true` 将允许变量被重写，或 `false` 将不允许被重写。比如：\n\n    {\n        \"globals\": {\n            \"var1\": true,\n            \"var2\": false\n        }\n    }\n\n在 YAML 中：\n\n    ---\n      globals:\n        var1: true\n        var2: false\n\n在这些例子中 `var1` 允许被重写，`var2` 不允许被重写。\n\n**注意：** 要启用[no-global-assign](https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/no-global-assign)规则来禁止对只读的全局变量进行修改。\n\n## 配置插件\n\nESLint 支持使用第三方插件。在使用插件之前，你必须使用 npm 安装它。\n\n在配置文件里配置插件时，可以使用 `plugins` 关键字来存放插件名字的列表。插件名称可以省略 `eslint-plugin-` 前缀。\n\n    {\n        \"plugins\": [\n            \"plugin1\",\n            \"eslint-plugin-plugin2\"\n        ]\n    }\n\n在 YAML 中：\n\n    ---\n      plugins:\n        - plugin1\n        - eslint-plugin-plugin2\n\n**注意：**全局安装的 ESLint 只能使用全局安装的插件。本地安装的 ESLint 不仅可以使用本地安装的插件，也可以使用全局安装的插件。\n\n## 配置规则\n\nESLint 附带有大量的规则。你可以使用注释或配置文件修改你项目中要使用的规则。要改变一个规则设置，你必须将规则 ID 设置为下列值之一：\n\n- `\"off\"` 或 `0` \\- 关闭规则\n- `\"warn\"` 或 `1` \\- 开启规则，使用警告级别的错误：`warn` (不会导致程序退出)\n- `\"error\"` 或 `2` \\- 开启规则，使用错误级别的错误：`error` (当被触发的时候，程序会退出)\n\n为了在文件注释里配置规则，使用以下格式的注释：\n\n    /* eslint eqeqeq: \"off\", curly: \"error\" */\n\n在这个例子里，[`eqeqeq`](https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/eqeqeq) 规则被关闭，[`curly`](https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/curly) 规则被打开，定义为错误级别。你也可以使用对应的数字定义规则严重程度：\n\n    /* eslint eqeqeq: 0, curly: 2 */\n\n这个例子和上个例子是一样的，只不过它是用的数字而不是字符串。`eqeqeq` 规则是关闭的，`curly` 规则被设置为错误级别。\n\n如果一个规则有额外的选项，你可以使用数组字面量指定它们，比如：\n\n    /* eslint quotes: [\"error\", \"double\"], curly: 2 */\n\n这条注释为规则 [`quotes`](https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/quotes) 指定了 “double”选项。数组的第一项总是规则的严重程度（数字或字符串）。\n\n还可以使用 `rules` 连同错误级别和任何你想使用的选项，在配置文件中进行规则配置。例如：\n\n    {\n        \"rules\": {\n            \"eqeqeq\": \"off\",\n            \"curly\": \"error\",\n            \"quotes\": [\"error\", \"double\"]\n        }\n    }\n\n在 YAML 中：\n\n    ---\n    rules:\n      eqeqeq: off\n      curly: error\n      quotes:\n        - error\n        - double\n\n配置定义在插件中的一个规则的时候，你必须使用 `插件名/规则ID` 的形式。比如：\n\n    {\n        \"plugins\": [\n            \"plugin1\"\n        ],\n        \"rules\": {\n            \"eqeqeq\": \"off\",\n            \"curly\": \"error\",\n            \"quotes\": [\"error\", \"double\"],\n            \"plugin1/rule1\": \"error\"\n        }\n    }\n\n在 YAML 中：\n\n    ---\n    plugins:\n      - plugin1\n    rules:\n      eqeqeq: 0\n      curly: error\n      quotes:\n        - error\n        - \"double\"\n      plugin1/rule1: error\n\n在这些配置文件中，规则 `plugin1/rule1` 表示来自插件 `plugin1` 的 `rule1` 规则。你也可以使用这种格式的注释配置，比如：\n\n    /* eslint \"plugin1/rule1\": \"error\" */\n\n**注意：**当指定来自插件的规则时，确保删除 `eslint-plugin-` 前缀。ESLint 在内部只使用没有前缀的名称去定位规则。\n\n## 使用行注释禁用规则\n\n可以在你的文件中使用以下格式的块注释来临时禁止规则出现警告：\n\n    /* eslint-disable */\n\n    alert('foo');\n\n    /* eslint-enable */\n\n你也可以对指定的规则启用或禁用警告:\n\n    /* eslint-disable no-alert, no-console */\n\n    alert('foo');\n    console.log('bar');\n\n    /* eslint-enable no-alert, no-console */\n\n如果在整个文件范围内禁止规则出现警告，将 `/* eslint-disable */` 块注释放在文件顶部：\n\n    /* eslint-disable */\n\n    alert('foo');\n\n你也可以对整个文件启用或禁用警告:\n\n    /* eslint-disable no-alert */\n\n    // Disables no-alert for the rest of the file\n    alert('foo');\n\n可以在你的文件中使用以下格式的行注释在某一特定的行上禁用所有规则：\n\n    alert('foo'); // eslint-disable-line\n\n    // eslint-disable-next-line\n    alert('foo');\n\n在某一特定的行上禁用某个指定的规则：\n\n    alert('foo'); // eslint-disable-line no-alert\n\n    // eslint-disable-next-line no-alert\n    alert('foo');\n\n在某个特定的行上禁用多个规则：\n\n    alert('foo'); // eslint-disable-line no-alert, quotes, semi\n\n    // eslint-disable-next-line no-alert, quotes, semi\n    alert('foo');\n\n上面的所有方法同样适用于插件规则。例如，禁止 `eslint-plugin-example` 的 `rule-name` 规则，把插件名（`example`）和规则名（`rule-name`）结合为 `example/rule-name`：\n\n    foo(); // eslint-disable-line example/rule-name\n\n**注意：**为文件的某部分禁用警告的注释，告诉 ESLint 不要对禁用的代码报告规则的冲突。ESLint 仍解析整个文件，然而，禁用的代码仍需要是有效的 JavaScript 语法。\n\n## 添加分享配置\n\nESLint 支持在配置文件添加共享设置。你可以添加 `settings` 对象到配置文件，它将提供给每一个将被执行的规则。如果你想添加的自定义规则而且使它们可以访问到相同的信息，这将会很有用，并且很容易配置。\n\n在 JSON 中：\n\n    {\n        \"settings\": {\n            \"sharedData\": \"Hello\"\n        }\n    }\n\n在 YAML 中：\n\n    ---\n      settings:\n        sharedData: \"Hello\"\n\n## 使用配置文件\n\n有两种方式可以使用配置文件。第一种是将文件保存到你喜欢的地方，然后将它的位置使用 `-c` 选项传递命令行，比如：\n\n    eslint -c myconfig.json myfiletotest.js\n\n第二种方式是通过 `.eslintrc.*` 和 `package.json`。ESLint 将自动在要检测的文件目录里寻找它们，紧接着是父级目录，一直到文件系统的根目录。当你想对一个项目的不同部分的使用不同配置，或当你希望别人能够直接使用 ESLint，而无需记住要在配置文件中传递什么，这种方式就很有用。\n\n每种情况，配置文件都会覆盖默认设置。\n\n## 配置文件文件格式\n\nESLint 支持几种格式的配置文件：\n\n- **JavaScript** \\- 使用 `.eslintrc.js` 然后输出一个配置对象。\n- **YAML** \\- 使用 `.eslintrc.yaml` 或 `.eslintrc.yml` 去定义配置的结构。\n- **JSON** \\- 使用 `.eslintrc.json` 去定义配置的结构，ESLint 的 JSON 文件允许 JavaScript 风格的注释。\n- **(不推荐)** \\- 使用 `.eslintrc`，可以使 JSON 也可以是 YAML。\n- **package.json** \\- 在 `package.json` 里创建一个 `eslintConfig`属性，在那里定义你的配置。\n\n如果同一个目录下有多个配置文件，ESLint 只会使用一个。优先级顺序如下：\n\n1.  `.eslintrc.js`\n2.  `.eslintrc.yaml`\n3.  `.eslintrc.yml`\n4.  `.eslintrc.json`\n5.  `.eslintrc`\n6.  `package.json`\n\n## 配置的层级和继承\n\n当使用 `.eslintrc.*` 和 `package.json`文件的配置时，你可以利用层叠配置。例如，假如你有以下结构：\n\n    your-project\n    ├── .eslintrc\n    ├── lib\n    │ └── source.js\n    └─┬ tests\n      ├── .eslintrc\n      └── test.js\n\n层叠配置使用离要检测的文件最近的 `.eslintrc`文件作为最高优先级，然后才是父目录里的配置文件，等等。当你在这个项目中允许 ESLint 时，`lib/`下面的所有文件将使用项目根目录里的 `.eslintrc` 文件作为它的配置文件。当 ESLint 遍历到 `test/` 目录，`your-project/.eslintrc` 之外，它还会用到 `your-project/tests/.eslintrc`。所以 `your-project/tests/test.js` 是基于它的目录层次结构中的两个`.eslintrc` 文件的组合，并且离的最近的一个优先。通过这种方式，你可以有项目级 ESLint 设置，也有覆盖特定目录的 ESLint 设置。\n\n同样的，如果在根目录的 `package.json` 文件中有一个 `eslintConfig` 字段，其中的配置将使用于所有子目录，但是当 `tests` 目录下的 `.eslintrc` 文件中的规则与之发生冲突时，就会覆盖它。\n\n    your-project\n    ├── package.json\n    ├── lib\n    │ └── source.js\n    └─┬ tests\n      ├── .eslintrc\n      └── test.js\n\n如果同一目录下 `.eslintrc` 和 `package.json` 同时存在，`.eslintrc` 优先级高会被使用，`package.json` 文件将不会被使用。\n\n**注意：**如果在你的主目录下有一个自定义的配置文件 (`~/.eslintrc`) ，如果没有其它配置文件时它才会被使用。因为个人配置将适用于用户目录下的所有目录和文件，包括第三方的代码，当 ESLint 运行时可能会导致问题。\n\n默认情况下，ESLint 会在所有父级目录里寻找配置文件，一直到根目录。如果你想要你所有项目都遵循一个特定的约定时，这将会很有用，但有时候会导致意想不到的结果。为了将 ESLint 限制到一个特定的项目，在你项目根目录下的 `package.json` 文件或者 `.eslintrc.*` 文件里的 `eslintConfig` 字段下设置 `\"root\": true`。ESLint 一旦发现配置文件中有 `\"root\": true`，它就会停止在父级目录中寻找。\n\n    {\n        \"root\": true\n    }\n\n在 YAML 中：\n\n    ---\n      root: true\n\n例如，`projectA` 的 `lib/` 目录下的 `.eslintrc` 文件中设置了 `\"root\": true`。这种情况下，当检测 `main.js` 时，`lib/` 下的配置将会被使用，`projectA/` 下的 `.eslintrc` 将不会被使用。\n\n    home\n    └── user\n        ├── .eslintrc <- Always skipped if other configs present\n        └── projectA\n            ├── .eslintrc  <- Not used\n            └── lib\n                ├── .eslintrc  <- { \"root\": true }\n                └── main.js\n\n完整的配置层次结构，从最高优先级最低的优先级，如下:\n\n1.  行内配置\n    1.  `/*eslint-disable*/` 和 `/*eslint-enable*/`\n    2.  `/*global*/`\n    3.  `/*eslint*/`\n    4.  `/*eslint-env*/`\n2.  命令行选项：\n    1.  `--global`\n    2.  `--rule`\n    3.  `--env`\n    4.  `-c`、`--config`\n3.  项目级配置：\n    1.  与要检测的文件在同一目录下的 `.eslintrc.*` 或 `package.json` 文件\n    2.  继续在父级目录寻找 `.eslintrc` 或 `package.json`文件，直到根目录（包括根目录）或直到发现一个有`\"root\": true`的配置。\n    3.  如果不是（1）到（3）中的任何一种情况，退回到 `~/.eslintrc` 中自定义的默认配置。\n\n## 扩展配置文件\n\n一个配置文件可以被基础配置中的已启用的规则继承。\n\n`extends` 属性值可以是：\n\n- 在配置中指定的一个字符串\n- 字符串数组：每个配置继承它前面的配置\n\nESLint 递归地进行扩展配置，所以一个基础的配置也可以有一个 `extends` 属性。\n\n`rules` 属性可以做下面的任何事情以扩展（或覆盖）规则：\n\n- 启用额外的规则\n- 改变继承的规则级别而不改变它的选项：\n  - 基础配置：`\"eqeqeq\": [\"error\", \"allow-null\"]`\n  - 派生的配置：`\"eqeqeq\": \"warn\"`\n  - 最后生成的配置：`\"eqeqeq\": [\"warn\", \"allow-null\"]`\n- 覆盖基础配置中的规则的选项\n  - 基础配置：`\"quotes\": [\"error\", \"single\", \"avoid-escape\"]`\n  - 派生的配置：`\"quotes\": [\"error\", \"single\"]`\n  - 最后生成的配置：`\"quotes\": [\"error\", \"single\"]`\n\n### 使用 eslint:recommended\n\n值为 `\"eslint:recommended\"` 的 `extends` 属性启用一系列核心规则，这些规则报告一些常见问题，在 [规则页面](https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/) 中被标记为 。这个推荐的子集只能在 ESLint 主要版本进行更新。\n\n如果你的配置集成了推荐的规则：在你升级到 ESLint 新的主版本之后，在你使用[命令行](https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface#fix)的 `--fix` 选项之前，检查一下报告的问题，这样你就知道一个新的可修复的推荐的规则将更改代码。\n\n`eslint --init` 命令可以创建一个配置，这样你就可以继承推荐的规则。\n\nJavaScript 格式的一个配置文件的例子：\n\n    module.exports = {\n        \"extends\": \"eslint:recommended\",\n        \"rules\": {\n            // enable additional rules\n            \"indent\": [\"error\", 4],\n            \"linebreak-style\": [\"error\", \"unix\"],\n            \"quotes\": [\"error\", \"double\"],\n            \"semi\": [\"error\", \"always\"],\n\n            // override default options for rules from base configurations\n            \"comma-dangle\": [\"error\", \"always\"],\n            \"no-cond-assign\": [\"error\", \"always\"],\n\n            // disable rules from base configurations\n            \"no-console\": \"off\",\n        }\n    }\n\n### 使用可共享的配置包\n\n[可共享的配置](https://link.jianshu.com?t=https://cn.eslint.org/docs/developer-guide/shareable-configs) 是一个 npm 包，它输出一个配置对象。要确保这个包安装在 ESLint 能请求到的目录下。\n\n`extends` 属性值可以省略包名的前缀 `eslint-config-`。\n\n`eslint --init` 命令可以创建一个配置，这样你就可以扩展一个流行的风格指南（比如，`eslint-config-standard`）。\n\nYAML 格式的一个配置文件的例子：\n\n    extends: standard\n    rules:\n      comma-dangle:\n        - error\n        - always\n      no-empty: warn\n\n### 使用插件中的配置\n\n[插件](https://link.jianshu.com?t=https://cn.eslint.org/docs/developer-guide/working-with-plugins) 是一个 npm 包，通常输出规则。一些插件也可以输出一个或多个命名的 [配置](https://link.jianshu.com?t=https://cn.eslint.org/docs/developer-guide/working-with-plugins#configs-in-plugins)。要确保这个包安装在 ESLint 能请求到的目录下。\n\n`plugins` [属性值](https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/configuring#configuring-plugins) 可以省略包名的前缀 `eslint-plugin-`。\n\n`extends` 属性值可以由以下组成：\n\n- `plugin:`\n- 包名 (省略了前缀，比如，`react`)\n- `/`\n- 配置名称 (比如 `recommended`)\n\nJSON 格式的一个配置文件的例子：\n\n    {\n        \"plugins\": [\n            \"react\"\n        ],\n        \"extends\": [\n            \"eslint:recommended\",\n            \"plugin:react/recommended\"\n        ],\n        \"rules\": {\n           \"no-set-state\": \"off\"\n        }\n    }\n\n### 使用一个配置文件\n\n`extends` 属性值可以是基本[配置文件](https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/configuring#using-configuration-files)的绝对路径或相对路径。\n\nESLint 解析基本配置文件的相对路径相对你你使用的配置文件，**除非**那个文件在你的主目录或非 ESLint 安装目录的父级目录。在这些情况下，ESLint 解析基本配合文件的相对路径相对于被检测的 **项目**目录（尤其是当前工作目录）。\n\nJSON 格式的一个配置文件的例子：\n\n    {\n        \"extends\": [\n            \"./node_modules/coding-standard/eslintDefaults.js\",\n            \"./node_modules/coding-standard/.eslintrc-es6\",\n            \"./node_modules/coding-standard/.eslintrc-jsx\"\n        ],\n        \"rules\": {\n            \"eqeqeq\": \"warn\"\n        }\n    }\n\n### 使用 eslint:all\n\n`extends` 属性值可以是 `\"eslint:all\"`，启用当前安装的 ESLint 中所有的核心规则。这些规则可以在 ESLint 的任何版本进行更改。\n\n**重要：**这些配置 **不推荐在产品中使用**，因为它随着 ESLint 版本进行更改。使用的话，请自己承担风险。\n\n如果你配置 ESLint 升级时自动地启用新规则，当源码没有任何改变时，ESLint 可以报告新问题，因此任何 ESLint 的新的小版本好像有破坏性的更改。\n\n当你决定在一个项目上使用的规则和选项，尤其是如果你很少覆盖选项或禁用规则，你可能启用所有核心规则作为一种快捷方式使用。规则的默认选项并不是 ESLint 推荐的（例如，`quotes` 规则的默认选项并不意味着双引号要比单引号好）。\n\n如果你的配置扩展了所有的核心规则：在你升级到一个新的大或小的 ESLint 版本，在你使用[命令行](https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface#fix)的 `--fix` 选项之前，检查一下报告的问题，这样你就知道一个新的可修复的规则将更改代码。\n\nJavaScript 格式的一个配置文件的例子：\n\n    module.exports = {\n        \"extends\": \"eslint:all\",\n        \"rules\": {\n            // override default options\n            \"comma-dangle\": [\"error\", \"always\"],\n            \"indent\": [\"error\", 2],\n            \"no-cond-assign\": [\"error\", \"always\"],\n\n            // disable now, but enable in the future\n            \"one-var\": \"off\", // [\"error\", \"never\"]\n\n            // disable\n            \"init-declarations\": \"off\",\n            \"no-console\": \"off\",\n            \"no-inline-comments\": \"off\",\n        }\n    }\n\n## 基于 glob 模式的配置\n\n有时，你可能需要更精细的配置，比如，如果同一个目录下的文件需要有不同的配置。因此，你可以在配置中使用 `overrides` 键，它只适用于匹配特定的 glob 模式的文件，使用你在命令行上传递的格式 (e.g., `app/**/*.test.js`)。\n\n### 怎么工作\n\n- Glob 模式覆盖只能在配置文件 (`.eslintrc.*` 或 `package.json`) 中进行配置。\n- 模式应用于相对于配置文件的目录的文件路径。 比如，如果你的配置文件的路径为 `/Users/john/workspace/any-project/.eslintrc.js` 而你要检测的路径为 `/Users/john/workspace/any-project/lib/util.js`，那么你在 `.eslintrc.js` 中提供的模式是相对于 `lib/util.js` 来执行的.\n- 在相同的配置文件中，Glob 模式覆盖比其他常规配置具有更高的优先级。 同一个配置中的多个覆盖将按顺序被应用。也就是说，配置文件中的最后一个覆盖会有最高优先级。\n- 一个 glob 特定的配置几乎与 ESLint 的其他配置相同。覆盖块可以包含常规配置中的除了 `extends`、`overrides` 和 `root` 之外的其他任何有效配置选项，\n- 可以在单个覆盖块中提供多个 glob 模式。一个文件必须匹配至少一个配置中提供的模式。\n- 覆盖块也可以指定从匹配中排除的模式。如果一个文件匹配了任何一个排除模式，该配置将不再被应用。\n\n### 相对 glob 模式\n\n    project-root\n    ├── app\n    │   ├── lib\n    │   │   ├── foo.js\n    │   │   ├── fooSpec.js\n    │   ├── components\n    │   │   ├── bar.js\n    │   │   ├── barSpec.js\n    │   ├── .eslintrc.json\n    ├── server\n    │   ├── server.js\n    │   ├── serverSpec.js\n    ├── .eslintrc.json\n\n`app/.eslintrc.json` 文件中的配置定义了 glob 模式 `**/*Spec.js`。该模式是相对 `app/.eslintrc.json` 的基本目录的。因此，该模式将匹配 `app/lib/fooSpec.js` 和 `app/components/barSpec.js` 但 **不匹配** `server/serverSpec.js`。如果你在项目根目录下的 `.eslintrc.json` 文件中定义了同样的模式，它将匹配这三个 `*Spec` 文件。\n\n### 配置示例\n\n在你的 `.eslintrc.json` 文件中：\n\n    {\n      \"rules\": {\n        \"quotes\": [ 2, \"double\" ]\n      },\n\n      \"overrides\": [\n        {\n          \"files\": [ \"bin/*.js\", \"lib/*.js\" ],\n          \"excludedFiles\": \"*.test.js\",\n          \"rules\": {\n            \"quotes\": [ 2, \"single\" ]\n          }\n        }\n      ]\n    }\n\n## 在配置文件中注释\n\nJSON 和 YAML 配置文件格式都支持注释 ( `package.json` 文件不应该包括注释)。你可以在其他类型的文件中使用 JavaScript 风格的注释或使用 YAML 风格的注释，ESLint 会忽略它们。这允许你的配置更加人性化。例如：\n\n    {\n        \"env\": {\n            \"browser\": true\n        },\n        \"rules\": {\n            // Override our default settings just for this directory\n            \"eqeqeq\": \"warn\",\n            \"strict\": \"off\"\n        }\n    }\n\n## 指定需要检查的文件扩展名\n\n目前，告诉 ESLint 哪个文件扩展名要检测的唯一方法是使用 [`--ext`](https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface#ext) 命令行选项指定一个逗号分隔的扩展名列表。注意，该标记只在与目录一起使用时有效，如果使用文件名或 glob 模式，它将会被忽略。\n\n## 忽略文件和目录\n\n你可以通过在项目根目录创建一个 `.eslintignore` 文件告诉 ESLint 去忽略特定的文件和目录。`.eslintignore` 文件是一个纯文本文件，其中的每一行都是一个 glob 模式表明哪些路径应该忽略检测。例如，以下将忽略所有的 JavaScript 文件：\n\n    **/*.js\n\n当 ESLint 运行时，在确定哪些文件要检测之前，它会在当前工作目录中查找一个 `.eslintignore` 文件。如果发现了这个文件，当遍历目录时，将会应用这些偏好设置。一次只有一个 `.eslintignore` 文件会被使用，所以，不是当前工作目录下的 `.eslintignore` 文件将不会被用到。\n\nGlobs 匹配使用 [node-ignore](https://link.jianshu.com?t=https://github.com/kaelzhang/node-ignore)，所以大量可用的特性有：\n\n- 以 `#` 开头的行被当作注释，不影响忽略模式。\n- 路径是相对于 `.eslintignore` 的位置或当前工作目录。这也会影响通过 `--ignore-pattern`传递的路径。\n- 忽略模式同 `.gitignore` [规范](https://link.jianshu.com?t=http://git-scm.com/docs/gitignore)\n- 以 `!` 开头的行是否定模式，它将会重新包含一个之前被忽略的模式。\n\n除了 `.eslintignore` 文件中的模式，ESLint 总是忽略 `/node_modules/*` 和 `/bower_components/*` 中的文件。\n\n例如：把下面 `.eslintignore` 文件放到当前工作目录里，将忽略 `node_modules`，`bower_components` 以及 `build/` 目录下除了 `build/index.js` 的所有文件。\n\n    # /node_modules/* and /bower_components/* ignored by default\n\n    # Ignore built files except build/index.js\n    build/*\n    !build/index.js\n\n### 使用备用文件\n\n如果相比于当前工作目录下 `.eslintignore` 文件，你更想使用一个不同的文件，你可以在命令行使用 `--ignore-path` 选项指定它。例如，你可以使用 `.jshintignore` 文件，因为它有相同的格式：\n\n    eslint --ignore-path .jshintignore file.js\n\n你也可以使用你的 `.gitignore` 文件：\n\n    eslint --ignore-path .gitignore file.js\n\n任何文件只要满足标准忽略文件格式都可以用。记住，指定 `--ignore-path` 意味着任何现有的 `.eslintignore` 文件将不被使用。请注意，`.eslintignore` 中的匹配规则比 `.gitignore` 中的更严格。\n\n### 在 package.json 中使用 eslintConfig\n\n    {\n      \"name\": \"mypackage\",\n      \"version\": \"0.0.1\",\n      \"eslintConfig\": {\n          \"env\": {\n              \"browser\": true,\n              \"node\": true\n          }\n      },\n      \"eslintIgnore\": [\"hello.js\", \"world.js\"]\n    }\n\n### 忽略文件告警\n\n当您将目录传递给 ESLint 时，文件和目录将被忽略。如果将特定文件传递给 ESLint，则会看到一条警告，指示该文件已被跳过。例如，假设你有一个 `.eslintignore` 文件，如下所示：\n\n    foo.js\n\n然后，您执行：\n\n    eslint foo.js\n\n您将会看到以下告警：\n\n    foo.js\n      0:0  warning  File ignored because of your .eslintignore file. Use --no-ignore to override.\n\n    ✖ 1 problem (0 errors, 1 warning)\n\n发生此消息是因为 ESLint 不确定是否要检查该文件。如消息所示，您可以使用 `--no-ignore` 省略使用忽略规则。\n","slug":"2018-03-13-ESLint 配置","published":1,"updated":"2020-03-14T06:50:35.857Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7u2pvo900774k8yhoz8bgxh","content":"<h1 id=\"ESLint-配置\"><a href=\"#ESLint-配置\" class=\"headerlink\" title=\"ESLint 配置\"></a>ESLint 配置</h1><p>ESlint 被设计为完全可配置的，这意味着你可以关闭每一个规则而只运行基本语法验证，或混合和匹配 ESLint 默认绑定的规则和你的自定义规则，以让 ESLint 更适合你的项目。有两种主要的方式来配置 ESLint：</p>\n<ol>\n<li><strong>Configuration Comments</strong> - 使用 JavaScript 注释把配置信息直接嵌入到一个代码源文件中。</li>\n<li><strong>Configuration Files</strong> - 使用 JavaScript、JSON 或者 YAML 文件为整个目录和它的子目录指定配置信息。可以配置一个独立的 <a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/configuring#configuration-file-formats\" target=\"_blank\" rel=\"noopener\">.eslintrc.*</a> 文件，或者直接在 <a href=\"https://link.jianshu.com?t=https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"noopener\"><code>package.json</code></a> 文件里的 <code>eslintConfig</code> 字段指定配置，ESLint 会查找和自动读取它们，再者，你可以在<a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface\" target=\"_blank\" rel=\"noopener\">命令行</a>运行时指定一个任意的配置文件。</li>\n</ol>\n<p>有很多信息可以配置：</p>\n<ul>\n<li><strong>Environments</strong> - 指定脚本的运行环境。每种环境都会有一组特定的预定义全局变量。</li>\n<li><strong>Globals</strong> - 脚本在执行期间访问的额外的全局变量。</li>\n<li><strong>Rules</strong> - 启用的规则及其各自的错误级别。</li>\n</ul>\n<p>所有这些选项让你可以细粒度地控制 ESLint 如何对待你的代码。</p>\n<h2 id=\"指定解析器选项\"><a href=\"#指定解析器选项\" class=\"headerlink\" title=\"指定解析器选项\"></a>指定解析器选项</h2><p>ESLint 允许你指定你想要支持的 JavaScript 语言选项。默认情况下，ESLint 支持 ECMAScript 5 语法。你可以覆盖该设置，以启用对 ECMAScript 其它版本和 JSX 的支持。</p>\n<p>请注意，对 JSX 语法的支持不用于对 React 的支持。React 使用了一些特定的 ESLint 无法识别的 JSX 语法。如果你正在使用 React 并且想要 React 语义支持，我们推荐你使用 <a href=\"https://link.jianshu.com?t=https://github.com/yannickcr/eslint-plugin-react\" target=\"_blank\" rel=\"noopener\">eslint-plugin-react</a>。</p>\n<p>同样的，支持 ES6 语法并不意味着同时支持新的 ES6 全局变量或类型（比如 <code>Set</code> 等新类型）。使用 <code>{ &quot;parserOptions&quot;: { &quot;ecmaVersion&quot;: 6 } }</code> 来启用 ES6 语法支持；要额外支持新的 ES6 全局变量，使用 <code>{ &quot;env&quot;:{ &quot;es6&quot;: true } }</code>(这个设置会同时自动启用 ES6 语法支持)。</p>\n<p>解析器选项可以在 <code>.eslintrc.*</code> 文件使用 <code>parserOptions</code> 属性设置。可用的选项有：</p>\n<ul>\n<li><code>ecmaVersion</code> - 默认设置为 5， 你可以使用 3、5、6、7 或 8 来指定你想要使用的 ECMAScript 版本。你也可以用使用年份命名的版本号指定为 2015（同 6），2016（同 7），或 2017（同 8）</li>\n<li><code>sourceType</code> - 设置为 <code>&quot;script&quot;</code> (默认) 或 <code>&quot;module&quot;</code>（如果你的代码是 ECMAScript 模块)。</li>\n<li><code>ecmaFeatures</code> - 这是个对象，表示你想使用的额外的语言特性:<code>globalReturn</code> - 允许在全局作用域下使用 <code>return</code> 语句<code>impliedStrict</code> - 启用全局 <a href=\"https://link.jianshu.com?t=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode\" target=\"_blank\" rel=\"noopener\">strict mode</a> (如果 <code>ecmaVersion</code> 是 5 或更高)<code>jsx</code> - 启用 <a href=\"https://link.jianshu.com?t=http://facebook.github.io/jsx/\" target=\"_blank\" rel=\"noopener\">JSX</a><code>experimentalObjectRestSpread</code> - 启用实验性的 <a href=\"https://link.jianshu.com?t=https://github.com/sebmarkbage/ecmascript-rest-spread\" target=\"_blank\" rel=\"noopener\">object rest/spread properties</a> 支持。(<strong>重要：</strong>这是一个实验性的功能,在未来可能会有明显改变。 建议你写的规则 <strong>不要</strong> 依赖该功能，除非当它发生改变时你愿意承担维护成本。)</li>\n</ul>\n<p><code>.eslintrc.json</code> 文件示例：</p>\n<pre><code>{\n    &quot;parserOptions&quot;: {\n        &quot;ecmaVersion&quot;: 6,\n        &quot;sourceType&quot;: &quot;module&quot;,\n        &quot;ecmaFeatures&quot;: {\n            &quot;jsx&quot;: true\n        }\n    },\n    &quot;rules&quot;: {\n        &quot;semi&quot;: 2\n    }\n}</code></pre><p>设置解析器选项能帮助 ESLint 确定什么是解析错误，所有语言选项默认都是 <code>false</code>。</p>\n<h2 id=\"指定解析器\"><a href=\"#指定解析器\" class=\"headerlink\" title=\"指定解析器\"></a>指定解析器</h2><p>ESLint 默认使用<a href=\"https://link.jianshu.com?t=https://github.com/eslint/espree\" target=\"_blank\" rel=\"noopener\">Espree</a>作为其解析器，你可以在配置文件中指定一个不同的解析器，只要该解析器符合下列要求：</p>\n<ol>\n<li>它必须是本地安装的一个 npm 模块。</li>\n<li>它必须有兼容 Esprima 的接口（它必须输出一个 <code>parse()</code> 方法）</li>\n<li>它必须产出兼容 Esprima 的 AST 和 token 对象。</li>\n</ol>\n<p>注意，即使满足这些兼容性要求，也不能保证一个外部解析器可以与 ESLint 正常配合工作，ESLint 也不会修复与其它解析器不兼容的相关 bug。</p>\n<p>为了表明使用该 npm 模块作为你的解析器，你需要在你的 <code>.eslintrc</code> 文件里指定 <code>parser</code> 选项。例如，下面的配置指定了 Esprima 作为解析器：</p>\n<pre><code>{\n    &quot;parser&quot;: &quot;esprima&quot;,\n    &quot;rules&quot;: {\n        &quot;semi&quot;: &quot;error&quot;\n    }\n}</code></pre><p>以下解析器与 ESLint 兼容：</p>\n<ul>\n<li><a href=\"https://link.jianshu.com?t=https://npmjs.com/package/esprima\" target=\"_blank\" rel=\"noopener\">Esprima</a></li>\n<li><a href=\"https://link.jianshu.com?t=https://npmjs.com/package/babel-eslint\" target=\"_blank\" rel=\"noopener\">Babel-ESLint</a> - 一个对<a href=\"https://link.jianshu.com?t=http://babeljs.io/\" target=\"_blank\" rel=\"noopener\">Babel</a>解析器的包装，使其能够与 ESLint 兼容。</li>\n<li><a href=\"https://link.jianshu.com?t=https://npmjs.com/package/typescript-eslint-parser\" target=\"_blank\" rel=\"noopener\">typescript-eslint-parser(实验)</a> - 一个把 TypeScript 转换为 ESTree 兼容格式的解析器，这样它就可以在 ESLint 中使用了。这样做的目的是通过 ESLint 来解析 TypeScript 文件（尽管不一定必须通过所有的 ESLint 规则）。</li>\n</ul>\n<p>注意，在使用自定义解析器时，为了让 ESLint 在处理非 ECMAScript 5 特性时正常工作，配置属性 <code>parserOptions</code> 仍然是必须的。解析器会被传入 <code>parserOptions</code>，但是不一定会使用它们来决定功能特性的开关。</p>\n<h2 id=\"指定环境\"><a href=\"#指定环境\" class=\"headerlink\" title=\"指定环境\"></a>指定环境</h2><p>一个“环境”定义了一组预定义的全局变量。可用的环境包括：</p>\n<ul>\n<li><code>browser</code> - 浏览器环境中的全局变量。</li>\n<li><code>node</code> - Node.js 全局变量和 Node.js 作用域。</li>\n<li><code>commonjs</code> - CommonJS 全局变量和 CommonJS 作用域 (一般用于 Browserify/WebPack 打包的只在浏览器中运行的代码)。</li>\n<li><code>shared-node-browser</code> - Node 和 Browser 通用全局变量。</li>\n<li><code>es6</code> - 启用除了 modules 以外的所有 ECMAScript 6 特性（该选项会自动设置 <code>ecmaVersion</code> 解析器选项为 6）。</li>\n<li><code>worker</code> - Web Workers 全局变量。</li>\n<li><code>amd</code> - 将 <code>require()</code> 和 <code>define()</code> 定义为像 <a href=\"https://link.jianshu.com?t=https://github.com/amdjs/amdjs-api/wiki/AMD\" target=\"_blank\" rel=\"noopener\">amd</a> 一样的全局变量。</li>\n<li><code>mocha</code> - 添加所有的 Mocha 测试全局变量。</li>\n<li><code>jasmine</code> - 添加所有的 Jasmine 版本 1.3 和 2.0 的测试全局变量。</li>\n<li><code>jest</code> - Jest 全局变量。</li>\n<li><code>phantomjs</code> - PhantomJS 全局变量。</li>\n<li><code>protractor</code> - Protractor 全局变量。</li>\n<li><code>qunit</code> - QUnit 全局变量。</li>\n<li><code>jquery</code> - jQuery 全局变量。</li>\n<li><code>prototypejs</code> - Prototype.js 全局变量。</li>\n<li><code>shelljs</code> - ShellJS 全局变量。</li>\n<li><code>meteor</code> - Meteor 全局变量。</li>\n<li><code>mongo</code> - MongoDB 全局变量。</li>\n<li><code>applescript</code> - AppleScript 全局变量。</li>\n<li><code>nashorn</code> - Java 8 Nashorn 全局变量。</li>\n<li><code>serviceworker</code> - Service Worker 全局变量。</li>\n<li><code>atomtest</code> - Atom 测试全局变量。</li>\n<li><code>embertest</code> - Ember 测试全局变量。</li>\n<li><code>webextensions</code> - WebExtensions 全局变量。</li>\n<li><code>greasemonkey</code> - GreaseMonkey 全局变量。</li>\n</ul>\n<p>这些环境并不是互斥的，所以你可以同时定义多个。</p>\n<p>可以在源文件里、在配置文件中或使用 <a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface\" target=\"_blank\" rel=\"noopener\">命令行</a> 的 <code>--env</code> 选项来指定环境。</p>\n<p>要在你的 JavaScript 文件中使用注释来指定环境，格式如下：</p>\n<pre><code>/* eslint-env node, mocha */</code></pre><p>该设置启用了 Node.js 和 Mocha 环境。</p>\n<p>要在配置文件里指定环境，使用 <code>env</code> 关键字指定你想启用的环境，并设置它们为 <code>true</code>。例如，以下示例启用了 browser 和 Node.js 的环境：</p>\n<pre><code>{\n    &quot;env&quot;: {\n        &quot;browser&quot;: true,\n        &quot;node&quot;: true\n    }\n}</code></pre><p>或在 <code>package.json</code> 文件中：</p>\n<pre><code>{\n    &quot;name&quot;: &quot;mypackage&quot;,\n    &quot;version&quot;: &quot;0.0.1&quot;,\n    &quot;eslintConfig&quot;: {\n        &quot;env&quot;: {\n            &quot;browser&quot;: true,\n            &quot;node&quot;: true\n        }\n    }\n}</code></pre><p>在 YAML 文件中：</p>\n<pre><code>---\n  env:\n    browser: true\n    node: true</code></pre><p>如果你想在一个特定的插件中使用一种环境，确保提前在 <code>plugins</code> 数组里指定了插件名，然后在 env 配置中不带前缀的插件名后跟一个 <code>/</code> ，紧随着环境名。例如：</p>\n<pre><code>{\n    &quot;plugins&quot;: [&quot;example&quot;],\n    &quot;env&quot;: {\n        &quot;example/custom&quot;: true\n    }\n}</code></pre><p>或在 <code>package.json</code> 文件中</p>\n<pre><code>{\n    &quot;name&quot;: &quot;mypackage&quot;,\n    &quot;version&quot;: &quot;0.0.1&quot;,\n    &quot;eslintConfig&quot;: {\n        &quot;plugins&quot;: [&quot;example&quot;],\n        &quot;env&quot;: {\n            &quot;example/custom&quot;: true\n        }\n    }\n}</code></pre><p>在 YAML 文件中：</p>\n<pre><code>---\n  plugins:\n    - example\n  env:\n    example/custom: true</code></pre><h2 id=\"指定全局变量\"><a href=\"#指定全局变量\" class=\"headerlink\" title=\"指定全局变量\"></a>指定全局变量</h2><p>当访问当前源文件内未定义的变量时，<a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/no-undef\" target=\"_blank\" rel=\"noopener\">no-undef</a> 规则将发出警告。如果你想在一个源文件里使用全局变量，推荐你在 ESLint 中定义这些全局变量，这样 ESLint 就不会发出警告了。你可以使用注释或在配置文件中定义全局变量。</p>\n<p>要在你的 JavaScript 文件中，用注释指定全局变量，格式如下：</p>\n<pre><code>/* global var1, var2 */</code></pre><p>这里定义了两个全局变量：<code>var1</code> 和 <code>var2</code>。如果你想指定这些变量不应被重写（只读），你可以将它们设置为 <code>false</code>：</p>\n<pre><code>/* global var1:false, var2:false */</code></pre><p>在配置文件里配置全局变量时，使用 <code>globals</code> 指出你要使用的全局变量。将变量设置为 <code>true</code> 将允许变量被重写，或 <code>false</code> 将不允许被重写。比如：</p>\n<pre><code>{\n    &quot;globals&quot;: {\n        &quot;var1&quot;: true,\n        &quot;var2&quot;: false\n    }\n}</code></pre><p>在 YAML 中：</p>\n<pre><code>---\n  globals:\n    var1: true\n    var2: false</code></pre><p>在这些例子中 <code>var1</code> 允许被重写，<code>var2</code> 不允许被重写。</p>\n<p><strong>注意：</strong> 要启用<a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/no-global-assign\" target=\"_blank\" rel=\"noopener\">no-global-assign</a>规则来禁止对只读的全局变量进行修改。</p>\n<h2 id=\"配置插件\"><a href=\"#配置插件\" class=\"headerlink\" title=\"配置插件\"></a>配置插件</h2><p>ESLint 支持使用第三方插件。在使用插件之前，你必须使用 npm 安装它。</p>\n<p>在配置文件里配置插件时，可以使用 <code>plugins</code> 关键字来存放插件名字的列表。插件名称可以省略 <code>eslint-plugin-</code> 前缀。</p>\n<pre><code>{\n    &quot;plugins&quot;: [\n        &quot;plugin1&quot;,\n        &quot;eslint-plugin-plugin2&quot;\n    ]\n}</code></pre><p>在 YAML 中：</p>\n<pre><code>---\n  plugins:\n    - plugin1\n    - eslint-plugin-plugin2</code></pre><p><strong>注意：</strong>全局安装的 ESLint 只能使用全局安装的插件。本地安装的 ESLint 不仅可以使用本地安装的插件，也可以使用全局安装的插件。</p>\n<h2 id=\"配置规则\"><a href=\"#配置规则\" class=\"headerlink\" title=\"配置规则\"></a>配置规则</h2><p>ESLint 附带有大量的规则。你可以使用注释或配置文件修改你项目中要使用的规则。要改变一个规则设置，你必须将规则 ID 设置为下列值之一：</p>\n<ul>\n<li><code>&quot;off&quot;</code> 或 <code>0</code> - 关闭规则</li>\n<li><code>&quot;warn&quot;</code> 或 <code>1</code> - 开启规则，使用警告级别的错误：<code>warn</code> (不会导致程序退出)</li>\n<li><code>&quot;error&quot;</code> 或 <code>2</code> - 开启规则，使用错误级别的错误：<code>error</code> (当被触发的时候，程序会退出)</li>\n</ul>\n<p>为了在文件注释里配置规则，使用以下格式的注释：</p>\n<pre><code>/* eslint eqeqeq: &quot;off&quot;, curly: &quot;error&quot; */</code></pre><p>在这个例子里，<a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/eqeqeq\" target=\"_blank\" rel=\"noopener\"><code>eqeqeq</code></a> 规则被关闭，<a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/curly\" target=\"_blank\" rel=\"noopener\"><code>curly</code></a> 规则被打开，定义为错误级别。你也可以使用对应的数字定义规则严重程度：</p>\n<pre><code>/* eslint eqeqeq: 0, curly: 2 */</code></pre><p>这个例子和上个例子是一样的，只不过它是用的数字而不是字符串。<code>eqeqeq</code> 规则是关闭的，<code>curly</code> 规则被设置为错误级别。</p>\n<p>如果一个规则有额外的选项，你可以使用数组字面量指定它们，比如：</p>\n<pre><code>/* eslint quotes: [&quot;error&quot;, &quot;double&quot;], curly: 2 */</code></pre><p>这条注释为规则 <a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/quotes\" target=\"_blank\" rel=\"noopener\"><code>quotes</code></a> 指定了 “double”选项。数组的第一项总是规则的严重程度（数字或字符串）。</p>\n<p>还可以使用 <code>rules</code> 连同错误级别和任何你想使用的选项，在配置文件中进行规则配置。例如：</p>\n<pre><code>{\n    &quot;rules&quot;: {\n        &quot;eqeqeq&quot;: &quot;off&quot;,\n        &quot;curly&quot;: &quot;error&quot;,\n        &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;]\n    }\n}</code></pre><p>在 YAML 中：</p>\n<pre><code>---\nrules:\n  eqeqeq: off\n  curly: error\n  quotes:\n    - error\n    - double</code></pre><p>配置定义在插件中的一个规则的时候，你必须使用 <code>插件名/规则ID</code> 的形式。比如：</p>\n<pre><code>{\n    &quot;plugins&quot;: [\n        &quot;plugin1&quot;\n    ],\n    &quot;rules&quot;: {\n        &quot;eqeqeq&quot;: &quot;off&quot;,\n        &quot;curly&quot;: &quot;error&quot;,\n        &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;],\n        &quot;plugin1/rule1&quot;: &quot;error&quot;\n    }\n}</code></pre><p>在 YAML 中：</p>\n<pre><code>---\nplugins:\n  - plugin1\nrules:\n  eqeqeq: 0\n  curly: error\n  quotes:\n    - error\n    - &quot;double&quot;\n  plugin1/rule1: error</code></pre><p>在这些配置文件中，规则 <code>plugin1/rule1</code> 表示来自插件 <code>plugin1</code> 的 <code>rule1</code> 规则。你也可以使用这种格式的注释配置，比如：</p>\n<pre><code>/* eslint &quot;plugin1/rule1&quot;: &quot;error&quot; */</code></pre><p><strong>注意：</strong>当指定来自插件的规则时，确保删除 <code>eslint-plugin-</code> 前缀。ESLint 在内部只使用没有前缀的名称去定位规则。</p>\n<h2 id=\"使用行注释禁用规则\"><a href=\"#使用行注释禁用规则\" class=\"headerlink\" title=\"使用行注释禁用规则\"></a>使用行注释禁用规则</h2><p>可以在你的文件中使用以下格式的块注释来临时禁止规则出现警告：</p>\n<pre><code>/* eslint-disable */\n\nalert(&#39;foo&#39;);\n\n/* eslint-enable */</code></pre><p>你也可以对指定的规则启用或禁用警告:</p>\n<pre><code>/* eslint-disable no-alert, no-console */\n\nalert(&#39;foo&#39;);\nconsole.log(&#39;bar&#39;);\n\n/* eslint-enable no-alert, no-console */</code></pre><p>如果在整个文件范围内禁止规则出现警告，将 <code>/* eslint-disable */</code> 块注释放在文件顶部：</p>\n<pre><code>/* eslint-disable */\n\nalert(&#39;foo&#39;);</code></pre><p>你也可以对整个文件启用或禁用警告:</p>\n<pre><code>/* eslint-disable no-alert */\n\n// Disables no-alert for the rest of the file\nalert(&#39;foo&#39;);</code></pre><p>可以在你的文件中使用以下格式的行注释在某一特定的行上禁用所有规则：</p>\n<pre><code>alert(&#39;foo&#39;); // eslint-disable-line\n\n// eslint-disable-next-line\nalert(&#39;foo&#39;);</code></pre><p>在某一特定的行上禁用某个指定的规则：</p>\n<pre><code>alert(&#39;foo&#39;); // eslint-disable-line no-alert\n\n// eslint-disable-next-line no-alert\nalert(&#39;foo&#39;);</code></pre><p>在某个特定的行上禁用多个规则：</p>\n<pre><code>alert(&#39;foo&#39;); // eslint-disable-line no-alert, quotes, semi\n\n// eslint-disable-next-line no-alert, quotes, semi\nalert(&#39;foo&#39;);</code></pre><p>上面的所有方法同样适用于插件规则。例如，禁止 <code>eslint-plugin-example</code> 的 <code>rule-name</code> 规则，把插件名（<code>example</code>）和规则名（<code>rule-name</code>）结合为 <code>example/rule-name</code>：</p>\n<pre><code>foo(); // eslint-disable-line example/rule-name</code></pre><p><strong>注意：</strong>为文件的某部分禁用警告的注释，告诉 ESLint 不要对禁用的代码报告规则的冲突。ESLint 仍解析整个文件，然而，禁用的代码仍需要是有效的 JavaScript 语法。</p>\n<h2 id=\"添加分享配置\"><a href=\"#添加分享配置\" class=\"headerlink\" title=\"添加分享配置\"></a>添加分享配置</h2><p>ESLint 支持在配置文件添加共享设置。你可以添加 <code>settings</code> 对象到配置文件，它将提供给每一个将被执行的规则。如果你想添加的自定义规则而且使它们可以访问到相同的信息，这将会很有用，并且很容易配置。</p>\n<p>在 JSON 中：</p>\n<pre><code>{\n    &quot;settings&quot;: {\n        &quot;sharedData&quot;: &quot;Hello&quot;\n    }\n}</code></pre><p>在 YAML 中：</p>\n<pre><code>---\n  settings:\n    sharedData: &quot;Hello&quot;</code></pre><h2 id=\"使用配置文件\"><a href=\"#使用配置文件\" class=\"headerlink\" title=\"使用配置文件\"></a>使用配置文件</h2><p>有两种方式可以使用配置文件。第一种是将文件保存到你喜欢的地方，然后将它的位置使用 <code>-c</code> 选项传递命令行，比如：</p>\n<pre><code>eslint -c myconfig.json myfiletotest.js</code></pre><p>第二种方式是通过 <code>.eslintrc.*</code> 和 <code>package.json</code>。ESLint 将自动在要检测的文件目录里寻找它们，紧接着是父级目录，一直到文件系统的根目录。当你想对一个项目的不同部分的使用不同配置，或当你希望别人能够直接使用 ESLint，而无需记住要在配置文件中传递什么，这种方式就很有用。</p>\n<p>每种情况，配置文件都会覆盖默认设置。</p>\n<h2 id=\"配置文件文件格式\"><a href=\"#配置文件文件格式\" class=\"headerlink\" title=\"配置文件文件格式\"></a>配置文件文件格式</h2><p>ESLint 支持几种格式的配置文件：</p>\n<ul>\n<li><strong>JavaScript</strong> - 使用 <code>.eslintrc.js</code> 然后输出一个配置对象。</li>\n<li><strong>YAML</strong> - 使用 <code>.eslintrc.yaml</code> 或 <code>.eslintrc.yml</code> 去定义配置的结构。</li>\n<li><strong>JSON</strong> - 使用 <code>.eslintrc.json</code> 去定义配置的结构，ESLint 的 JSON 文件允许 JavaScript 风格的注释。</li>\n<li><strong>(不推荐)</strong> - 使用 <code>.eslintrc</code>，可以使 JSON 也可以是 YAML。</li>\n<li><strong>package.json</strong> - 在 <code>package.json</code> 里创建一个 <code>eslintConfig</code>属性，在那里定义你的配置。</li>\n</ul>\n<p>如果同一个目录下有多个配置文件，ESLint 只会使用一个。优先级顺序如下：</p>\n<ol>\n<li><code>.eslintrc.js</code></li>\n<li><code>.eslintrc.yaml</code></li>\n<li><code>.eslintrc.yml</code></li>\n<li><code>.eslintrc.json</code></li>\n<li><code>.eslintrc</code></li>\n<li><code>package.json</code></li>\n</ol>\n<h2 id=\"配置的层级和继承\"><a href=\"#配置的层级和继承\" class=\"headerlink\" title=\"配置的层级和继承\"></a>配置的层级和继承</h2><p>当使用 <code>.eslintrc.*</code> 和 <code>package.json</code>文件的配置时，你可以利用层叠配置。例如，假如你有以下结构：</p>\n<pre><code>your-project\n├── .eslintrc\n├── lib\n│ └── source.js\n└─┬ tests\n  ├── .eslintrc\n  └── test.js</code></pre><p>层叠配置使用离要检测的文件最近的 <code>.eslintrc</code>文件作为最高优先级，然后才是父目录里的配置文件，等等。当你在这个项目中允许 ESLint 时，<code>lib/</code>下面的所有文件将使用项目根目录里的 <code>.eslintrc</code> 文件作为它的配置文件。当 ESLint 遍历到 <code>test/</code> 目录，<code>your-project/.eslintrc</code> 之外，它还会用到 <code>your-project/tests/.eslintrc</code>。所以 <code>your-project/tests/test.js</code> 是基于它的目录层次结构中的两个<code>.eslintrc</code> 文件的组合，并且离的最近的一个优先。通过这种方式，你可以有项目级 ESLint 设置，也有覆盖特定目录的 ESLint 设置。</p>\n<p>同样的，如果在根目录的 <code>package.json</code> 文件中有一个 <code>eslintConfig</code> 字段，其中的配置将使用于所有子目录，但是当 <code>tests</code> 目录下的 <code>.eslintrc</code> 文件中的规则与之发生冲突时，就会覆盖它。</p>\n<pre><code>your-project\n├── package.json\n├── lib\n│ └── source.js\n└─┬ tests\n  ├── .eslintrc\n  └── test.js</code></pre><p>如果同一目录下 <code>.eslintrc</code> 和 <code>package.json</code> 同时存在，<code>.eslintrc</code> 优先级高会被使用，<code>package.json</code> 文件将不会被使用。</p>\n<p><strong>注意：</strong>如果在你的主目录下有一个自定义的配置文件 (<code>~/.eslintrc</code>) ，如果没有其它配置文件时它才会被使用。因为个人配置将适用于用户目录下的所有目录和文件，包括第三方的代码，当 ESLint 运行时可能会导致问题。</p>\n<p>默认情况下，ESLint 会在所有父级目录里寻找配置文件，一直到根目录。如果你想要你所有项目都遵循一个特定的约定时，这将会很有用，但有时候会导致意想不到的结果。为了将 ESLint 限制到一个特定的项目，在你项目根目录下的 <code>package.json</code> 文件或者 <code>.eslintrc.*</code> 文件里的 <code>eslintConfig</code> 字段下设置 <code>&quot;root&quot;: true</code>。ESLint 一旦发现配置文件中有 <code>&quot;root&quot;: true</code>，它就会停止在父级目录中寻找。</p>\n<pre><code>{\n    &quot;root&quot;: true\n}</code></pre><p>在 YAML 中：</p>\n<pre><code>---\n  root: true</code></pre><p>例如，<code>projectA</code> 的 <code>lib/</code> 目录下的 <code>.eslintrc</code> 文件中设置了 <code>&quot;root&quot;: true</code>。这种情况下，当检测 <code>main.js</code> 时，<code>lib/</code> 下的配置将会被使用，<code>projectA/</code> 下的 <code>.eslintrc</code> 将不会被使用。</p>\n<pre><code>home\n└── user\n    ├── .eslintrc &lt;- Always skipped if other configs present\n    └── projectA\n        ├── .eslintrc  &lt;- Not used\n        └── lib\n            ├── .eslintrc  &lt;- { &quot;root&quot;: true }\n            └── main.js</code></pre><p>完整的配置层次结构，从最高优先级最低的优先级，如下:</p>\n<ol>\n<li>行内配置<ol>\n<li><code>/*eslint-disable*/</code> 和 <code>/*eslint-enable*/</code></li>\n<li><code>/*global*/</code></li>\n<li><code>/*eslint*/</code></li>\n<li><code>/*eslint-env*/</code></li>\n</ol>\n</li>\n<li>命令行选项：<ol>\n<li><code>--global</code></li>\n<li><code>--rule</code></li>\n<li><code>--env</code></li>\n<li><code>-c</code>、<code>--config</code></li>\n</ol>\n</li>\n<li>项目级配置：<ol>\n<li>与要检测的文件在同一目录下的 <code>.eslintrc.*</code> 或 <code>package.json</code> 文件</li>\n<li>继续在父级目录寻找 <code>.eslintrc</code> 或 <code>package.json</code>文件，直到根目录（包括根目录）或直到发现一个有<code>&quot;root&quot;: true</code>的配置。</li>\n<li>如果不是（1）到（3）中的任何一种情况，退回到 <code>~/.eslintrc</code> 中自定义的默认配置。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"扩展配置文件\"><a href=\"#扩展配置文件\" class=\"headerlink\" title=\"扩展配置文件\"></a>扩展配置文件</h2><p>一个配置文件可以被基础配置中的已启用的规则继承。</p>\n<p><code>extends</code> 属性值可以是：</p>\n<ul>\n<li>在配置中指定的一个字符串</li>\n<li>字符串数组：每个配置继承它前面的配置</li>\n</ul>\n<p>ESLint 递归地进行扩展配置，所以一个基础的配置也可以有一个 <code>extends</code> 属性。</p>\n<p><code>rules</code> 属性可以做下面的任何事情以扩展（或覆盖）规则：</p>\n<ul>\n<li>启用额外的规则</li>\n<li>改变继承的规则级别而不改变它的选项：<ul>\n<li>基础配置：<code>&quot;eqeqeq&quot;: [&quot;error&quot;, &quot;allow-null&quot;]</code></li>\n<li>派生的配置：<code>&quot;eqeqeq&quot;: &quot;warn&quot;</code></li>\n<li>最后生成的配置：<code>&quot;eqeqeq&quot;: [&quot;warn&quot;, &quot;allow-null&quot;]</code></li>\n</ul>\n</li>\n<li>覆盖基础配置中的规则的选项<ul>\n<li>基础配置：<code>&quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;, &quot;avoid-escape&quot;]</code></li>\n<li>派生的配置：<code>&quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;]</code></li>\n<li>最后生成的配置：<code>&quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;]</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"使用-eslint-recommended\"><a href=\"#使用-eslint-recommended\" class=\"headerlink\" title=\"使用 eslint:recommended\"></a>使用 eslint:recommended</h3><p>值为 <code>&quot;eslint:recommended&quot;</code> 的 <code>extends</code> 属性启用一系列核心规则，这些规则报告一些常见问题，在 <a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/\" target=\"_blank\" rel=\"noopener\">规则页面</a> 中被标记为 。这个推荐的子集只能在 ESLint 主要版本进行更新。</p>\n<p>如果你的配置集成了推荐的规则：在你升级到 ESLint 新的主版本之后，在你使用<a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface#fix\" target=\"_blank\" rel=\"noopener\">命令行</a>的 <code>--fix</code> 选项之前，检查一下报告的问题，这样你就知道一个新的可修复的推荐的规则将更改代码。</p>\n<p><code>eslint --init</code> 命令可以创建一个配置，这样你就可以继承推荐的规则。</p>\n<p>JavaScript 格式的一个配置文件的例子：</p>\n<pre><code>module.exports = {\n    &quot;extends&quot;: &quot;eslint:recommended&quot;,\n    &quot;rules&quot;: {\n        // enable additional rules\n        &quot;indent&quot;: [&quot;error&quot;, 4],\n        &quot;linebreak-style&quot;: [&quot;error&quot;, &quot;unix&quot;],\n        &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;],\n        &quot;semi&quot;: [&quot;error&quot;, &quot;always&quot;],\n\n        // override default options for rules from base configurations\n        &quot;comma-dangle&quot;: [&quot;error&quot;, &quot;always&quot;],\n        &quot;no-cond-assign&quot;: [&quot;error&quot;, &quot;always&quot;],\n\n        // disable rules from base configurations\n        &quot;no-console&quot;: &quot;off&quot;,\n    }\n}</code></pre><h3 id=\"使用可共享的配置包\"><a href=\"#使用可共享的配置包\" class=\"headerlink\" title=\"使用可共享的配置包\"></a>使用可共享的配置包</h3><p><a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/developer-guide/shareable-configs\" target=\"_blank\" rel=\"noopener\">可共享的配置</a> 是一个 npm 包，它输出一个配置对象。要确保这个包安装在 ESLint 能请求到的目录下。</p>\n<p><code>extends</code> 属性值可以省略包名的前缀 <code>eslint-config-</code>。</p>\n<p><code>eslint --init</code> 命令可以创建一个配置，这样你就可以扩展一个流行的风格指南（比如，<code>eslint-config-standard</code>）。</p>\n<p>YAML 格式的一个配置文件的例子：</p>\n<pre><code>extends: standard\nrules:\n  comma-dangle:\n    - error\n    - always\n  no-empty: warn</code></pre><h3 id=\"使用插件中的配置\"><a href=\"#使用插件中的配置\" class=\"headerlink\" title=\"使用插件中的配置\"></a>使用插件中的配置</h3><p><a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/developer-guide/working-with-plugins\" target=\"_blank\" rel=\"noopener\">插件</a> 是一个 npm 包，通常输出规则。一些插件也可以输出一个或多个命名的 <a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/developer-guide/working-with-plugins#configs-in-plugins\" target=\"_blank\" rel=\"noopener\">配置</a>。要确保这个包安装在 ESLint 能请求到的目录下。</p>\n<p><code>plugins</code> <a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/configuring#configuring-plugins\" target=\"_blank\" rel=\"noopener\">属性值</a> 可以省略包名的前缀 <code>eslint-plugin-</code>。</p>\n<p><code>extends</code> 属性值可以由以下组成：</p>\n<ul>\n<li><code>plugin:</code></li>\n<li>包名 (省略了前缀，比如，<code>react</code>)</li>\n<li><code>/</code></li>\n<li>配置名称 (比如 <code>recommended</code>)</li>\n</ul>\n<p>JSON 格式的一个配置文件的例子：</p>\n<pre><code>{\n    &quot;plugins&quot;: [\n        &quot;react&quot;\n    ],\n    &quot;extends&quot;: [\n        &quot;eslint:recommended&quot;,\n        &quot;plugin:react/recommended&quot;\n    ],\n    &quot;rules&quot;: {\n       &quot;no-set-state&quot;: &quot;off&quot;\n    }\n}</code></pre><h3 id=\"使用一个配置文件\"><a href=\"#使用一个配置文件\" class=\"headerlink\" title=\"使用一个配置文件\"></a>使用一个配置文件</h3><p><code>extends</code> 属性值可以是基本<a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/configuring#using-configuration-files\" target=\"_blank\" rel=\"noopener\">配置文件</a>的绝对路径或相对路径。</p>\n<p>ESLint 解析基本配置文件的相对路径相对你你使用的配置文件，<strong>除非</strong>那个文件在你的主目录或非 ESLint 安装目录的父级目录。在这些情况下，ESLint 解析基本配合文件的相对路径相对于被检测的 <strong>项目</strong>目录（尤其是当前工作目录）。</p>\n<p>JSON 格式的一个配置文件的例子：</p>\n<pre><code>{\n    &quot;extends&quot;: [\n        &quot;./node_modules/coding-standard/eslintDefaults.js&quot;,\n        &quot;./node_modules/coding-standard/.eslintrc-es6&quot;,\n        &quot;./node_modules/coding-standard/.eslintrc-jsx&quot;\n    ],\n    &quot;rules&quot;: {\n        &quot;eqeqeq&quot;: &quot;warn&quot;\n    }\n}</code></pre><h3 id=\"使用-eslint-all\"><a href=\"#使用-eslint-all\" class=\"headerlink\" title=\"使用 eslint:all\"></a>使用 eslint:all</h3><p><code>extends</code> 属性值可以是 <code>&quot;eslint:all&quot;</code>，启用当前安装的 ESLint 中所有的核心规则。这些规则可以在 ESLint 的任何版本进行更改。</p>\n<p><strong>重要：</strong>这些配置 <strong>不推荐在产品中使用</strong>，因为它随着 ESLint 版本进行更改。使用的话，请自己承担风险。</p>\n<p>如果你配置 ESLint 升级时自动地启用新规则，当源码没有任何改变时，ESLint 可以报告新问题，因此任何 ESLint 的新的小版本好像有破坏性的更改。</p>\n<p>当你决定在一个项目上使用的规则和选项，尤其是如果你很少覆盖选项或禁用规则，你可能启用所有核心规则作为一种快捷方式使用。规则的默认选项并不是 ESLint 推荐的（例如，<code>quotes</code> 规则的默认选项并不意味着双引号要比单引号好）。</p>\n<p>如果你的配置扩展了所有的核心规则：在你升级到一个新的大或小的 ESLint 版本，在你使用<a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface#fix\" target=\"_blank\" rel=\"noopener\">命令行</a>的 <code>--fix</code> 选项之前，检查一下报告的问题，这样你就知道一个新的可修复的规则将更改代码。</p>\n<p>JavaScript 格式的一个配置文件的例子：</p>\n<pre><code>module.exports = {\n    &quot;extends&quot;: &quot;eslint:all&quot;,\n    &quot;rules&quot;: {\n        // override default options\n        &quot;comma-dangle&quot;: [&quot;error&quot;, &quot;always&quot;],\n        &quot;indent&quot;: [&quot;error&quot;, 2],\n        &quot;no-cond-assign&quot;: [&quot;error&quot;, &quot;always&quot;],\n\n        // disable now, but enable in the future\n        &quot;one-var&quot;: &quot;off&quot;, // [&quot;error&quot;, &quot;never&quot;]\n\n        // disable\n        &quot;init-declarations&quot;: &quot;off&quot;,\n        &quot;no-console&quot;: &quot;off&quot;,\n        &quot;no-inline-comments&quot;: &quot;off&quot;,\n    }\n}</code></pre><h2 id=\"基于-glob-模式的配置\"><a href=\"#基于-glob-模式的配置\" class=\"headerlink\" title=\"基于 glob 模式的配置\"></a>基于 glob 模式的配置</h2><p>有时，你可能需要更精细的配置，比如，如果同一个目录下的文件需要有不同的配置。因此，你可以在配置中使用 <code>overrides</code> 键，它只适用于匹配特定的 glob 模式的文件，使用你在命令行上传递的格式 (e.g., <code>app/**/*.test.js</code>)。</p>\n<h3 id=\"怎么工作\"><a href=\"#怎么工作\" class=\"headerlink\" title=\"怎么工作\"></a>怎么工作</h3><ul>\n<li>Glob 模式覆盖只能在配置文件 (<code>.eslintrc.*</code> 或 <code>package.json</code>) 中进行配置。</li>\n<li>模式应用于相对于配置文件的目录的文件路径。 比如，如果你的配置文件的路径为 <code>/Users/john/workspace/any-project/.eslintrc.js</code> 而你要检测的路径为 <code>/Users/john/workspace/any-project/lib/util.js</code>，那么你在 <code>.eslintrc.js</code> 中提供的模式是相对于 <code>lib/util.js</code> 来执行的.</li>\n<li>在相同的配置文件中，Glob 模式覆盖比其他常规配置具有更高的优先级。 同一个配置中的多个覆盖将按顺序被应用。也就是说，配置文件中的最后一个覆盖会有最高优先级。</li>\n<li>一个 glob 特定的配置几乎与 ESLint 的其他配置相同。覆盖块可以包含常规配置中的除了 <code>extends</code>、<code>overrides</code> 和 <code>root</code> 之外的其他任何有效配置选项，</li>\n<li>可以在单个覆盖块中提供多个 glob 模式。一个文件必须匹配至少一个配置中提供的模式。</li>\n<li>覆盖块也可以指定从匹配中排除的模式。如果一个文件匹配了任何一个排除模式，该配置将不再被应用。</li>\n</ul>\n<h3 id=\"相对-glob-模式\"><a href=\"#相对-glob-模式\" class=\"headerlink\" title=\"相对 glob 模式\"></a>相对 glob 模式</h3><pre><code>project-root\n├── app\n│   ├── lib\n│   │   ├── foo.js\n│   │   ├── fooSpec.js\n│   ├── components\n│   │   ├── bar.js\n│   │   ├── barSpec.js\n│   ├── .eslintrc.json\n├── server\n│   ├── server.js\n│   ├── serverSpec.js\n├── .eslintrc.json</code></pre><p><code>app/.eslintrc.json</code> 文件中的配置定义了 glob 模式 <code>**/*Spec.js</code>。该模式是相对 <code>app/.eslintrc.json</code> 的基本目录的。因此，该模式将匹配 <code>app/lib/fooSpec.js</code> 和 <code>app/components/barSpec.js</code> 但 <strong>不匹配</strong> <code>server/serverSpec.js</code>。如果你在项目根目录下的 <code>.eslintrc.json</code> 文件中定义了同样的模式，它将匹配这三个 <code>*Spec</code> 文件。</p>\n<h3 id=\"配置示例\"><a href=\"#配置示例\" class=\"headerlink\" title=\"配置示例\"></a>配置示例</h3><p>在你的 <code>.eslintrc.json</code> 文件中：</p>\n<pre><code>{\n  &quot;rules&quot;: {\n    &quot;quotes&quot;: [ 2, &quot;double&quot; ]\n  },\n\n  &quot;overrides&quot;: [\n    {\n      &quot;files&quot;: [ &quot;bin/*.js&quot;, &quot;lib/*.js&quot; ],\n      &quot;excludedFiles&quot;: &quot;*.test.js&quot;,\n      &quot;rules&quot;: {\n        &quot;quotes&quot;: [ 2, &quot;single&quot; ]\n      }\n    }\n  ]\n}</code></pre><h2 id=\"在配置文件中注释\"><a href=\"#在配置文件中注释\" class=\"headerlink\" title=\"在配置文件中注释\"></a>在配置文件中注释</h2><p>JSON 和 YAML 配置文件格式都支持注释 ( <code>package.json</code> 文件不应该包括注释)。你可以在其他类型的文件中使用 JavaScript 风格的注释或使用 YAML 风格的注释，ESLint 会忽略它们。这允许你的配置更加人性化。例如：</p>\n<pre><code>{\n    &quot;env&quot;: {\n        &quot;browser&quot;: true\n    },\n    &quot;rules&quot;: {\n        // Override our default settings just for this directory\n        &quot;eqeqeq&quot;: &quot;warn&quot;,\n        &quot;strict&quot;: &quot;off&quot;\n    }\n}</code></pre><h2 id=\"指定需要检查的文件扩展名\"><a href=\"#指定需要检查的文件扩展名\" class=\"headerlink\" title=\"指定需要检查的文件扩展名\"></a>指定需要检查的文件扩展名</h2><p>目前，告诉 ESLint 哪个文件扩展名要检测的唯一方法是使用 <a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface#ext\" target=\"_blank\" rel=\"noopener\"><code>--ext</code></a> 命令行选项指定一个逗号分隔的扩展名列表。注意，该标记只在与目录一起使用时有效，如果使用文件名或 glob 模式，它将会被忽略。</p>\n<h2 id=\"忽略文件和目录\"><a href=\"#忽略文件和目录\" class=\"headerlink\" title=\"忽略文件和目录\"></a>忽略文件和目录</h2><p>你可以通过在项目根目录创建一个 <code>.eslintignore</code> 文件告诉 ESLint 去忽略特定的文件和目录。<code>.eslintignore</code> 文件是一个纯文本文件，其中的每一行都是一个 glob 模式表明哪些路径应该忽略检测。例如，以下将忽略所有的 JavaScript 文件：</p>\n<pre><code>**/*.js</code></pre><p>当 ESLint 运行时，在确定哪些文件要检测之前，它会在当前工作目录中查找一个 <code>.eslintignore</code> 文件。如果发现了这个文件，当遍历目录时，将会应用这些偏好设置。一次只有一个 <code>.eslintignore</code> 文件会被使用，所以，不是当前工作目录下的 <code>.eslintignore</code> 文件将不会被用到。</p>\n<p>Globs 匹配使用 <a href=\"https://link.jianshu.com?t=https://github.com/kaelzhang/node-ignore\" target=\"_blank\" rel=\"noopener\">node-ignore</a>，所以大量可用的特性有：</p>\n<ul>\n<li>以 <code>#</code> 开头的行被当作注释，不影响忽略模式。</li>\n<li>路径是相对于 <code>.eslintignore</code> 的位置或当前工作目录。这也会影响通过 <code>--ignore-pattern</code>传递的路径。</li>\n<li>忽略模式同 <code>.gitignore</code> <a href=\"https://link.jianshu.com?t=http://git-scm.com/docs/gitignore\" target=\"_blank\" rel=\"noopener\">规范</a></li>\n<li>以 <code>!</code> 开头的行是否定模式，它将会重新包含一个之前被忽略的模式。</li>\n</ul>\n<p>除了 <code>.eslintignore</code> 文件中的模式，ESLint 总是忽略 <code>/node_modules/*</code> 和 <code>/bower_components/*</code> 中的文件。</p>\n<p>例如：把下面 <code>.eslintignore</code> 文件放到当前工作目录里，将忽略 <code>node_modules</code>，<code>bower_components</code> 以及 <code>build/</code> 目录下除了 <code>build/index.js</code> 的所有文件。</p>\n<pre><code># /node_modules/* and /bower_components/* ignored by default\n\n# Ignore built files except build/index.js\nbuild/*\n!build/index.js</code></pre><h3 id=\"使用备用文件\"><a href=\"#使用备用文件\" class=\"headerlink\" title=\"使用备用文件\"></a>使用备用文件</h3><p>如果相比于当前工作目录下 <code>.eslintignore</code> 文件，你更想使用一个不同的文件，你可以在命令行使用 <code>--ignore-path</code> 选项指定它。例如，你可以使用 <code>.jshintignore</code> 文件，因为它有相同的格式：</p>\n<pre><code>eslint --ignore-path .jshintignore file.js</code></pre><p>你也可以使用你的 <code>.gitignore</code> 文件：</p>\n<pre><code>eslint --ignore-path .gitignore file.js</code></pre><p>任何文件只要满足标准忽略文件格式都可以用。记住，指定 <code>--ignore-path</code> 意味着任何现有的 <code>.eslintignore</code> 文件将不被使用。请注意，<code>.eslintignore</code> 中的匹配规则比 <code>.gitignore</code> 中的更严格。</p>\n<h3 id=\"在-package-json-中使用-eslintConfig\"><a href=\"#在-package-json-中使用-eslintConfig\" class=\"headerlink\" title=\"在 package.json 中使用 eslintConfig\"></a>在 package.json 中使用 eslintConfig</h3><pre><code>{\n  &quot;name&quot;: &quot;mypackage&quot;,\n  &quot;version&quot;: &quot;0.0.1&quot;,\n  &quot;eslintConfig&quot;: {\n      &quot;env&quot;: {\n          &quot;browser&quot;: true,\n          &quot;node&quot;: true\n      }\n  },\n  &quot;eslintIgnore&quot;: [&quot;hello.js&quot;, &quot;world.js&quot;]\n}</code></pre><h3 id=\"忽略文件告警\"><a href=\"#忽略文件告警\" class=\"headerlink\" title=\"忽略文件告警\"></a>忽略文件告警</h3><p>当您将目录传递给 ESLint 时，文件和目录将被忽略。如果将特定文件传递给 ESLint，则会看到一条警告，指示该文件已被跳过。例如，假设你有一个 <code>.eslintignore</code> 文件，如下所示：</p>\n<pre><code>foo.js</code></pre><p>然后，您执行：</p>\n<pre><code>eslint foo.js</code></pre><p>您将会看到以下告警：</p>\n<pre><code>foo.js\n  0:0  warning  File ignored because of your .eslintignore file. Use --no-ignore to override.\n\n✖ 1 problem (0 errors, 1 warning)</code></pre><p>发生此消息是因为 ESLint 不确定是否要检查该文件。如消息所示，您可以使用 <code>--no-ignore</code> 省略使用忽略规则。</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h1 id=\"ESLint-配置\"><a href=\"#ESLint-配置\" class=\"headerlink\" title=\"ESLint 配置\"></a>ESLint 配置</h1><p>ESlint 被设计为完全可配置的，这意味着你可以关闭每一个规则而只运行基本语法验证，或混合和匹配 ESLint 默认绑定的规则和你的自定义规则，以让 ESLint 更适合你的项目。有两种主要的方式来配置 ESLint：</p>\n<ol>\n<li><strong>Configuration Comments</strong> - 使用 JavaScript 注释把配置信息直接嵌入到一个代码源文件中。</li>\n<li><strong>Configuration Files</strong> - 使用 JavaScript、JSON 或者 YAML 文件为整个目录和它的子目录指定配置信息。可以配置一个独立的 <a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/configuring#configuration-file-formats\" target=\"_blank\" rel=\"noopener\">.eslintrc.*</a> 文件，或者直接在 <a href=\"https://link.jianshu.com?t=https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"noopener\"><code>package.json</code></a> 文件里的 <code>eslintConfig</code> 字段指定配置，ESLint 会查找和自动读取它们，再者，你可以在<a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface\" target=\"_blank\" rel=\"noopener\">命令行</a>运行时指定一个任意的配置文件。</li>\n</ol>\n<p>有很多信息可以配置：</p>\n<ul>\n<li><strong>Environments</strong> - 指定脚本的运行环境。每种环境都会有一组特定的预定义全局变量。</li>\n<li><strong>Globals</strong> - 脚本在执行期间访问的额外的全局变量。</li>\n<li><strong>Rules</strong> - 启用的规则及其各自的错误级别。</li>\n</ul>\n<p>所有这些选项让你可以细粒度地控制 ESLint 如何对待你的代码。</p>\n<h2 id=\"指定解析器选项\"><a href=\"#指定解析器选项\" class=\"headerlink\" title=\"指定解析器选项\"></a>指定解析器选项</h2><p>ESLint 允许你指定你想要支持的 JavaScript 语言选项。默认情况下，ESLint 支持 ECMAScript 5 语法。你可以覆盖该设置，以启用对 ECMAScript 其它版本和 JSX 的支持。</p>\n<p>请注意，对 JSX 语法的支持不用于对 React 的支持。React 使用了一些特定的 ESLint 无法识别的 JSX 语法。如果你正在使用 React 并且想要 React 语义支持，我们推荐你使用 <a href=\"https://link.jianshu.com?t=https://github.com/yannickcr/eslint-plugin-react\" target=\"_blank\" rel=\"noopener\">eslint-plugin-react</a>。</p>\n<p>同样的，支持 ES6 语法并不意味着同时支持新的 ES6 全局变量或类型（比如 <code>Set</code> 等新类型）。使用 <code>{ &quot;parserOptions&quot;: { &quot;ecmaVersion&quot;: 6 } }</code> 来启用 ES6 语法支持；要额外支持新的 ES6 全局变量，使用 <code>{ &quot;env&quot;:{ &quot;es6&quot;: true } }</code>(这个设置会同时自动启用 ES6 语法支持)。</p>\n<p>解析器选项可以在 <code>.eslintrc.*</code> 文件使用 <code>parserOptions</code> 属性设置。可用的选项有：</p>\n<ul>\n<li><code>ecmaVersion</code> - 默认设置为 5， 你可以使用 3、5、6、7 或 8 来指定你想要使用的 ECMAScript 版本。你也可以用使用年份命名的版本号指定为 2015（同 6），2016（同 7），或 2017（同 8）</li>\n<li><code>sourceType</code> - 设置为 <code>&quot;script&quot;</code> (默认) 或 <code>&quot;module&quot;</code>（如果你的代码是 ECMAScript 模块)。</li>\n<li><code>ecmaFeatures</code> - 这是个对象，表示你想使用的额外的语言特性:<code>globalReturn</code> - 允许在全局作用域下使用 <code>return</code> 语句<code>impliedStrict</code> - 启用全局 <a href=\"https://link.jianshu.com?t=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode\" target=\"_blank\" rel=\"noopener\">strict mode</a> (如果 <code>ecmaVersion</code> 是 5 或更高)<code>jsx</code> - 启用 <a href=\"https://link.jianshu.com?t=http://facebook.github.io/jsx/\" target=\"_blank\" rel=\"noopener\">JSX</a><code>experimentalObjectRestSpread</code> - 启用实验性的 <a href=\"https://link.jianshu.com?t=https://github.com/sebmarkbage/ecmascript-rest-spread\" target=\"_blank\" rel=\"noopener\">object rest/spread properties</a> 支持。(<strong>重要：</strong>这是一个实验性的功能,在未来可能会有明显改变。 建议你写的规则 <strong>不要</strong> 依赖该功能，除非当它发生改变时你愿意承担维护成本。)</li>\n</ul>\n<p><code>.eslintrc.json</code> 文件示例：</p>\n<pre><code>{\n    &quot;parserOptions&quot;: {\n        &quot;ecmaVersion&quot;: 6,\n        &quot;sourceType&quot;: &quot;module&quot;,\n        &quot;ecmaFeatures&quot;: {\n            &quot;jsx&quot;: true\n        }\n    },\n    &quot;rules&quot;: {\n        &quot;semi&quot;: 2\n    }\n}</code></pre><p>设置解析器选项能帮助 ESLint 确定什么是解析错误，所有语言选项默认都是 <code>false</code>。</p>\n<h2 id=\"指定解析器\"><a href=\"#指定解析器\" class=\"headerlink\" title=\"指定解析器\"></a>指定解析器</h2><p>ESLint 默认使用<a href=\"https://link.jianshu.com?t=https://github.com/eslint/espree\" target=\"_blank\" rel=\"noopener\">Espree</a>作为其解析器，你可以在配置文件中指定一个不同的解析器，只要该解析器符合下列要求：</p>\n<ol>\n<li>它必须是本地安装的一个 npm 模块。</li>\n<li>它必须有兼容 Esprima 的接口（它必须输出一个 <code>parse()</code> 方法）</li>\n<li>它必须产出兼容 Esprima 的 AST 和 token 对象。</li>\n</ol>\n<p>注意，即使满足这些兼容性要求，也不能保证一个外部解析器可以与 ESLint 正常配合工作，ESLint 也不会修复与其它解析器不兼容的相关 bug。</p>\n<p>为了表明使用该 npm 模块作为你的解析器，你需要在你的 <code>.eslintrc</code> 文件里指定 <code>parser</code> 选项。例如，下面的配置指定了 Esprima 作为解析器：</p>\n<pre><code>{\n    &quot;parser&quot;: &quot;esprima&quot;,\n    &quot;rules&quot;: {\n        &quot;semi&quot;: &quot;error&quot;\n    }\n}</code></pre><p>以下解析器与 ESLint 兼容：</p>\n<ul>\n<li><a href=\"https://link.jianshu.com?t=https://npmjs.com/package/esprima\" target=\"_blank\" rel=\"noopener\">Esprima</a></li>\n<li><a href=\"https://link.jianshu.com?t=https://npmjs.com/package/babel-eslint\" target=\"_blank\" rel=\"noopener\">Babel-ESLint</a> - 一个对<a href=\"https://link.jianshu.com?t=http://babeljs.io/\" target=\"_blank\" rel=\"noopener\">Babel</a>解析器的包装，使其能够与 ESLint 兼容。</li>\n<li><a href=\"https://link.jianshu.com?t=https://npmjs.com/package/typescript-eslint-parser\" target=\"_blank\" rel=\"noopener\">typescript-eslint-parser(实验)</a> - 一个把 TypeScript 转换为 ESTree 兼容格式的解析器，这样它就可以在 ESLint 中使用了。这样做的目的是通过 ESLint 来解析 TypeScript 文件（尽管不一定必须通过所有的 ESLint 规则）。</li>\n</ul>\n<p>注意，在使用自定义解析器时，为了让 ESLint 在处理非 ECMAScript 5 特性时正常工作，配置属性 <code>parserOptions</code> 仍然是必须的。解析器会被传入 <code>parserOptions</code>，但是不一定会使用它们来决定功能特性的开关。</p>\n<h2 id=\"指定环境\"><a href=\"#指定环境\" class=\"headerlink\" title=\"指定环境\"></a>指定环境</h2><p>一个“环境”定义了一组预定义的全局变量。可用的环境包括：</p>\n<ul>\n<li><code>browser</code> - 浏览器环境中的全局变量。</li>\n<li><code>node</code> - Node.js 全局变量和 Node.js 作用域。</li>\n<li><code>commonjs</code> - CommonJS 全局变量和 CommonJS 作用域 (一般用于 Browserify/WebPack 打包的只在浏览器中运行的代码)。</li>\n<li><code>shared-node-browser</code> - Node 和 Browser 通用全局变量。</li>\n<li><code>es6</code> - 启用除了 modules 以外的所有 ECMAScript 6 特性（该选项会自动设置 <code>ecmaVersion</code> 解析器选项为 6）。</li>\n<li><code>worker</code> - Web Workers 全局变量。</li>\n<li><code>amd</code> - 将 <code>require()</code> 和 <code>define()</code> 定义为像 <a href=\"https://link.jianshu.com?t=https://github.com/amdjs/amdjs-api/wiki/AMD\" target=\"_blank\" rel=\"noopener\">amd</a> 一样的全局变量。</li>\n<li><code>mocha</code> - 添加所有的 Mocha 测试全局变量。</li>\n<li><code>jasmine</code> - 添加所有的 Jasmine 版本 1.3 和 2.0 的测试全局变量。</li>\n<li><code>jest</code> - Jest 全局变量。</li>\n<li><code>phantomjs</code> - PhantomJS 全局变量。</li>\n<li><code>protractor</code> - Protractor 全局变量。</li>\n<li><code>qunit</code> - QUnit 全局变量。</li>\n<li><code>jquery</code> - jQuery 全局变量。</li>\n<li><code>prototypejs</code> - Prototype.js 全局变量。</li>\n<li><code>shelljs</code> - ShellJS 全局变量。</li>\n<li><code>meteor</code> - Meteor 全局变量。</li>\n<li><code>mongo</code> - MongoDB 全局变量。</li>\n<li><code>applescript</code> - AppleScript 全局变量。</li>\n<li><code>nashorn</code> - Java 8 Nashorn 全局变量。</li>\n<li><code>serviceworker</code> - Service Worker 全局变量。</li>\n<li><code>atomtest</code> - Atom 测试全局变量。</li>\n<li><code>embertest</code> - Ember 测试全局变量。</li>\n<li><code>webextensions</code> - WebExtensions 全局变量。</li>\n<li><code>greasemonkey</code> - GreaseMonkey 全局变量。</li>\n</ul>\n<p>这些环境并不是互斥的，所以你可以同时定义多个。</p>\n<p>可以在源文件里、在配置文件中或使用 <a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface\" target=\"_blank\" rel=\"noopener\">命令行</a> 的 <code>--env</code> 选项来指定环境。</p>\n<p>要在你的 JavaScript 文件中使用注释来指定环境，格式如下：</p>\n<pre><code>/* eslint-env node, mocha */</code></pre><p>该设置启用了 Node.js 和 Mocha 环境。</p>\n<p>要在配置文件里指定环境，使用 <code>env</code> 关键字指定你想启用的环境，并设置它们为 <code>true</code>。例如，以下示例启用了 browser 和 Node.js 的环境：</p>\n<pre><code>{\n    &quot;env&quot;: {\n        &quot;browser&quot;: true,\n        &quot;node&quot;: true\n    }\n}</code></pre><p>或在 <code>package.json</code> 文件中：</p>\n<pre><code>{\n    &quot;name&quot;: &quot;mypackage&quot;,\n    &quot;version&quot;: &quot;0.0.1&quot;,\n    &quot;eslintConfig&quot;: {\n        &quot;env&quot;: {\n            &quot;browser&quot;: true,\n            &quot;node&quot;: true\n        }\n    }\n}</code></pre><p>在 YAML 文件中：</p>\n<pre><code>---\n  env:\n    browser: true\n    node: true</code></pre><p>如果你想在一个特定的插件中使用一种环境，确保提前在 <code>plugins</code> 数组里指定了插件名，然后在 env 配置中不带前缀的插件名后跟一个 <code>/</code> ，紧随着环境名。例如：</p>\n<pre><code>{\n    &quot;plugins&quot;: [&quot;example&quot;],\n    &quot;env&quot;: {\n        &quot;example/custom&quot;: true\n    }\n}</code></pre><p>或在 <code>package.json</code> 文件中</p>\n<pre><code>{\n    &quot;name&quot;: &quot;mypackage&quot;,\n    &quot;version&quot;: &quot;0.0.1&quot;,\n    &quot;eslintConfig&quot;: {\n        &quot;plugins&quot;: [&quot;example&quot;],\n        &quot;env&quot;: {\n            &quot;example/custom&quot;: true\n        }\n    }\n}</code></pre><p>在 YAML 文件中：</p>\n<pre><code>---\n  plugins:\n    - example\n  env:\n    example/custom: true</code></pre><h2 id=\"指定全局变量\"><a href=\"#指定全局变量\" class=\"headerlink\" title=\"指定全局变量\"></a>指定全局变量</h2><p>当访问当前源文件内未定义的变量时，<a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/no-undef\" target=\"_blank\" rel=\"noopener\">no-undef</a> 规则将发出警告。如果你想在一个源文件里使用全局变量，推荐你在 ESLint 中定义这些全局变量，这样 ESLint 就不会发出警告了。你可以使用注释或在配置文件中定义全局变量。</p>\n<p>要在你的 JavaScript 文件中，用注释指定全局变量，格式如下：</p>\n<pre><code>/* global var1, var2 */</code></pre><p>这里定义了两个全局变量：<code>var1</code> 和 <code>var2</code>。如果你想指定这些变量不应被重写（只读），你可以将它们设置为 <code>false</code>：</p>\n<pre><code>/* global var1:false, var2:false */</code></pre><p>在配置文件里配置全局变量时，使用 <code>globals</code> 指出你要使用的全局变量。将变量设置为 <code>true</code> 将允许变量被重写，或 <code>false</code> 将不允许被重写。比如：</p>\n<pre><code>{\n    &quot;globals&quot;: {\n        &quot;var1&quot;: true,\n        &quot;var2&quot;: false\n    }\n}</code></pre><p>在 YAML 中：</p>\n<pre><code>---\n  globals:\n    var1: true\n    var2: false</code></pre><p>在这些例子中 <code>var1</code> 允许被重写，<code>var2</code> 不允许被重写。</p>\n<p><strong>注意：</strong> 要启用<a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/no-global-assign\" target=\"_blank\" rel=\"noopener\">no-global-assign</a>规则来禁止对只读的全局变量进行修改。</p>\n<h2 id=\"配置插件\"><a href=\"#配置插件\" class=\"headerlink\" title=\"配置插件\"></a>配置插件</h2><p>ESLint 支持使用第三方插件。在使用插件之前，你必须使用 npm 安装它。</p>\n<p>在配置文件里配置插件时，可以使用 <code>plugins</code> 关键字来存放插件名字的列表。插件名称可以省略 <code>eslint-plugin-</code> 前缀。</p>\n<pre><code>{\n    &quot;plugins&quot;: [\n        &quot;plugin1&quot;,\n        &quot;eslint-plugin-plugin2&quot;\n    ]\n}</code></pre><p>在 YAML 中：</p>\n<pre><code>---\n  plugins:\n    - plugin1\n    - eslint-plugin-plugin2</code></pre><p><strong>注意：</strong>全局安装的 ESLint 只能使用全局安装的插件。本地安装的 ESLint 不仅可以使用本地安装的插件，也可以使用全局安装的插件。</p>\n<h2 id=\"配置规则\"><a href=\"#配置规则\" class=\"headerlink\" title=\"配置规则\"></a>配置规则</h2><p>ESLint 附带有大量的规则。你可以使用注释或配置文件修改你项目中要使用的规则。要改变一个规则设置，你必须将规则 ID 设置为下列值之一：</p>\n<ul>\n<li><code>&quot;off&quot;</code> 或 <code>0</code> - 关闭规则</li>\n<li><code>&quot;warn&quot;</code> 或 <code>1</code> - 开启规则，使用警告级别的错误：<code>warn</code> (不会导致程序退出)</li>\n<li><code>&quot;error&quot;</code> 或 <code>2</code> - 开启规则，使用错误级别的错误：<code>error</code> (当被触发的时候，程序会退出)</li>\n</ul>\n<p>为了在文件注释里配置规则，使用以下格式的注释：</p>\n<pre><code>/* eslint eqeqeq: &quot;off&quot;, curly: &quot;error&quot; */</code></pre><p>在这个例子里，<a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/eqeqeq\" target=\"_blank\" rel=\"noopener\"><code>eqeqeq</code></a> 规则被关闭，<a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/curly\" target=\"_blank\" rel=\"noopener\"><code>curly</code></a> 规则被打开，定义为错误级别。你也可以使用对应的数字定义规则严重程度：</p>\n<pre><code>/* eslint eqeqeq: 0, curly: 2 */</code></pre><p>这个例子和上个例子是一样的，只不过它是用的数字而不是字符串。<code>eqeqeq</code> 规则是关闭的，<code>curly</code> 规则被设置为错误级别。</p>\n<p>如果一个规则有额外的选项，你可以使用数组字面量指定它们，比如：</p>\n<pre><code>/* eslint quotes: [&quot;error&quot;, &quot;double&quot;], curly: 2 */</code></pre><p>这条注释为规则 <a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/quotes\" target=\"_blank\" rel=\"noopener\"><code>quotes</code></a> 指定了 “double”选项。数组的第一项总是规则的严重程度（数字或字符串）。</p>\n<p>还可以使用 <code>rules</code> 连同错误级别和任何你想使用的选项，在配置文件中进行规则配置。例如：</p>\n<pre><code>{\n    &quot;rules&quot;: {\n        &quot;eqeqeq&quot;: &quot;off&quot;,\n        &quot;curly&quot;: &quot;error&quot;,\n        &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;]\n    }\n}</code></pre><p>在 YAML 中：</p>\n<pre><code>---\nrules:\n  eqeqeq: off\n  curly: error\n  quotes:\n    - error\n    - double</code></pre><p>配置定义在插件中的一个规则的时候，你必须使用 <code>插件名/规则ID</code> 的形式。比如：</p>\n<pre><code>{\n    &quot;plugins&quot;: [\n        &quot;plugin1&quot;\n    ],\n    &quot;rules&quot;: {\n        &quot;eqeqeq&quot;: &quot;off&quot;,\n        &quot;curly&quot;: &quot;error&quot;,\n        &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;],\n        &quot;plugin1/rule1&quot;: &quot;error&quot;\n    }\n}</code></pre><p>在 YAML 中：</p>\n<pre><code>---\nplugins:\n  - plugin1\nrules:\n  eqeqeq: 0\n  curly: error\n  quotes:\n    - error\n    - &quot;double&quot;\n  plugin1/rule1: error</code></pre><p>在这些配置文件中，规则 <code>plugin1/rule1</code> 表示来自插件 <code>plugin1</code> 的 <code>rule1</code> 规则。你也可以使用这种格式的注释配置，比如：</p>\n<pre><code>/* eslint &quot;plugin1/rule1&quot;: &quot;error&quot; */</code></pre><p><strong>注意：</strong>当指定来自插件的规则时，确保删除 <code>eslint-plugin-</code> 前缀。ESLint 在内部只使用没有前缀的名称去定位规则。</p>\n<h2 id=\"使用行注释禁用规则\"><a href=\"#使用行注释禁用规则\" class=\"headerlink\" title=\"使用行注释禁用规则\"></a>使用行注释禁用规则</h2><p>可以在你的文件中使用以下格式的块注释来临时禁止规则出现警告：</p>\n<pre><code>/* eslint-disable */\n\nalert(&#39;foo&#39;);\n\n/* eslint-enable */</code></pre><p>你也可以对指定的规则启用或禁用警告:</p>\n<pre><code>/* eslint-disable no-alert, no-console */\n\nalert(&#39;foo&#39;);\nconsole.log(&#39;bar&#39;);\n\n/* eslint-enable no-alert, no-console */</code></pre><p>如果在整个文件范围内禁止规则出现警告，将 <code>/* eslint-disable */</code> 块注释放在文件顶部：</p>\n<pre><code>/* eslint-disable */\n\nalert(&#39;foo&#39;);</code></pre><p>你也可以对整个文件启用或禁用警告:</p>\n<pre><code>/* eslint-disable no-alert */\n\n// Disables no-alert for the rest of the file\nalert(&#39;foo&#39;);</code></pre><p>可以在你的文件中使用以下格式的行注释在某一特定的行上禁用所有规则：</p>\n<pre><code>alert(&#39;foo&#39;); // eslint-disable-line\n\n// eslint-disable-next-line\nalert(&#39;foo&#39;);</code></pre><p>在某一特定的行上禁用某个指定的规则：</p>\n<pre><code>alert(&#39;foo&#39;); // eslint-disable-line no-alert\n\n// eslint-disable-next-line no-alert\nalert(&#39;foo&#39;);</code></pre><p>在某个特定的行上禁用多个规则：</p>\n<pre><code>alert(&#39;foo&#39;); // eslint-disable-line no-alert, quotes, semi\n\n// eslint-disable-next-line no-alert, quotes, semi\nalert(&#39;foo&#39;);</code></pre><p>上面的所有方法同样适用于插件规则。例如，禁止 <code>eslint-plugin-example</code> 的 <code>rule-name</code> 规则，把插件名（<code>example</code>）和规则名（<code>rule-name</code>）结合为 <code>example/rule-name</code>：</p>\n<pre><code>foo(); // eslint-disable-line example/rule-name</code></pre><p><strong>注意：</strong>为文件的某部分禁用警告的注释，告诉 ESLint 不要对禁用的代码报告规则的冲突。ESLint 仍解析整个文件，然而，禁用的代码仍需要是有效的 JavaScript 语法。</p>\n<h2 id=\"添加分享配置\"><a href=\"#添加分享配置\" class=\"headerlink\" title=\"添加分享配置\"></a>添加分享配置</h2><p>ESLint 支持在配置文件添加共享设置。你可以添加 <code>settings</code> 对象到配置文件，它将提供给每一个将被执行的规则。如果你想添加的自定义规则而且使它们可以访问到相同的信息，这将会很有用，并且很容易配置。</p>\n<p>在 JSON 中：</p>\n<pre><code>{\n    &quot;settings&quot;: {\n        &quot;sharedData&quot;: &quot;Hello&quot;\n    }\n}</code></pre><p>在 YAML 中：</p>\n<pre><code>---\n  settings:\n    sharedData: &quot;Hello&quot;</code></pre><h2 id=\"使用配置文件\"><a href=\"#使用配置文件\" class=\"headerlink\" title=\"使用配置文件\"></a>使用配置文件</h2><p>有两种方式可以使用配置文件。第一种是将文件保存到你喜欢的地方，然后将它的位置使用 <code>-c</code> 选项传递命令行，比如：</p>\n<pre><code>eslint -c myconfig.json myfiletotest.js</code></pre><p>第二种方式是通过 <code>.eslintrc.*</code> 和 <code>package.json</code>。ESLint 将自动在要检测的文件目录里寻找它们，紧接着是父级目录，一直到文件系统的根目录。当你想对一个项目的不同部分的使用不同配置，或当你希望别人能够直接使用 ESLint，而无需记住要在配置文件中传递什么，这种方式就很有用。</p>\n<p>每种情况，配置文件都会覆盖默认设置。</p>\n<h2 id=\"配置文件文件格式\"><a href=\"#配置文件文件格式\" class=\"headerlink\" title=\"配置文件文件格式\"></a>配置文件文件格式</h2><p>ESLint 支持几种格式的配置文件：</p>\n<ul>\n<li><strong>JavaScript</strong> - 使用 <code>.eslintrc.js</code> 然后输出一个配置对象。</li>\n<li><strong>YAML</strong> - 使用 <code>.eslintrc.yaml</code> 或 <code>.eslintrc.yml</code> 去定义配置的结构。</li>\n<li><strong>JSON</strong> - 使用 <code>.eslintrc.json</code> 去定义配置的结构，ESLint 的 JSON 文件允许 JavaScript 风格的注释。</li>\n<li><strong>(不推荐)</strong> - 使用 <code>.eslintrc</code>，可以使 JSON 也可以是 YAML。</li>\n<li><strong>package.json</strong> - 在 <code>package.json</code> 里创建一个 <code>eslintConfig</code>属性，在那里定义你的配置。</li>\n</ul>\n<p>如果同一个目录下有多个配置文件，ESLint 只会使用一个。优先级顺序如下：</p>\n<ol>\n<li><code>.eslintrc.js</code></li>\n<li><code>.eslintrc.yaml</code></li>\n<li><code>.eslintrc.yml</code></li>\n<li><code>.eslintrc.json</code></li>\n<li><code>.eslintrc</code></li>\n<li><code>package.json</code></li>\n</ol>\n<h2 id=\"配置的层级和继承\"><a href=\"#配置的层级和继承\" class=\"headerlink\" title=\"配置的层级和继承\"></a>配置的层级和继承</h2><p>当使用 <code>.eslintrc.*</code> 和 <code>package.json</code>文件的配置时，你可以利用层叠配置。例如，假如你有以下结构：</p>\n<pre><code>your-project\n├── .eslintrc\n├── lib\n│ └── source.js\n└─┬ tests\n  ├── .eslintrc\n  └── test.js</code></pre><p>层叠配置使用离要检测的文件最近的 <code>.eslintrc</code>文件作为最高优先级，然后才是父目录里的配置文件，等等。当你在这个项目中允许 ESLint 时，<code>lib/</code>下面的所有文件将使用项目根目录里的 <code>.eslintrc</code> 文件作为它的配置文件。当 ESLint 遍历到 <code>test/</code> 目录，<code>your-project/.eslintrc</code> 之外，它还会用到 <code>your-project/tests/.eslintrc</code>。所以 <code>your-project/tests/test.js</code> 是基于它的目录层次结构中的两个<code>.eslintrc</code> 文件的组合，并且离的最近的一个优先。通过这种方式，你可以有项目级 ESLint 设置，也有覆盖特定目录的 ESLint 设置。</p>\n<p>同样的，如果在根目录的 <code>package.json</code> 文件中有一个 <code>eslintConfig</code> 字段，其中的配置将使用于所有子目录，但是当 <code>tests</code> 目录下的 <code>.eslintrc</code> 文件中的规则与之发生冲突时，就会覆盖它。</p>\n<pre><code>your-project\n├── package.json\n├── lib\n│ └── source.js\n└─┬ tests\n  ├── .eslintrc\n  └── test.js</code></pre><p>如果同一目录下 <code>.eslintrc</code> 和 <code>package.json</code> 同时存在，<code>.eslintrc</code> 优先级高会被使用，<code>package.json</code> 文件将不会被使用。</p>\n<p><strong>注意：</strong>如果在你的主目录下有一个自定义的配置文件 (<code>~/.eslintrc</code>) ，如果没有其它配置文件时它才会被使用。因为个人配置将适用于用户目录下的所有目录和文件，包括第三方的代码，当 ESLint 运行时可能会导致问题。</p>\n<p>默认情况下，ESLint 会在所有父级目录里寻找配置文件，一直到根目录。如果你想要你所有项目都遵循一个特定的约定时，这将会很有用，但有时候会导致意想不到的结果。为了将 ESLint 限制到一个特定的项目，在你项目根目录下的 <code>package.json</code> 文件或者 <code>.eslintrc.*</code> 文件里的 <code>eslintConfig</code> 字段下设置 <code>&quot;root&quot;: true</code>。ESLint 一旦发现配置文件中有 <code>&quot;root&quot;: true</code>，它就会停止在父级目录中寻找。</p>\n<pre><code>{\n    &quot;root&quot;: true\n}</code></pre><p>在 YAML 中：</p>\n<pre><code>---\n  root: true</code></pre><p>例如，<code>projectA</code> 的 <code>lib/</code> 目录下的 <code>.eslintrc</code> 文件中设置了 <code>&quot;root&quot;: true</code>。这种情况下，当检测 <code>main.js</code> 时，<code>lib/</code> 下的配置将会被使用，<code>projectA/</code> 下的 <code>.eslintrc</code> 将不会被使用。</p>\n<pre><code>home\n└── user\n    ├── .eslintrc &lt;- Always skipped if other configs present\n    └── projectA\n        ├── .eslintrc  &lt;- Not used\n        └── lib\n            ├── .eslintrc  &lt;- { &quot;root&quot;: true }\n            └── main.js</code></pre><p>完整的配置层次结构，从最高优先级最低的优先级，如下:</p>\n<ol>\n<li>行内配置<ol>\n<li><code>/*eslint-disable*/</code> 和 <code>/*eslint-enable*/</code></li>\n<li><code>/*global*/</code></li>\n<li><code>/*eslint*/</code></li>\n<li><code>/*eslint-env*/</code></li>\n</ol>\n</li>\n<li>命令行选项：<ol>\n<li><code>--global</code></li>\n<li><code>--rule</code></li>\n<li><code>--env</code></li>\n<li><code>-c</code>、<code>--config</code></li>\n</ol>\n</li>\n<li>项目级配置：<ol>\n<li>与要检测的文件在同一目录下的 <code>.eslintrc.*</code> 或 <code>package.json</code> 文件</li>\n<li>继续在父级目录寻找 <code>.eslintrc</code> 或 <code>package.json</code>文件，直到根目录（包括根目录）或直到发现一个有<code>&quot;root&quot;: true</code>的配置。</li>\n<li>如果不是（1）到（3）中的任何一种情况，退回到 <code>~/.eslintrc</code> 中自定义的默认配置。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"扩展配置文件\"><a href=\"#扩展配置文件\" class=\"headerlink\" title=\"扩展配置文件\"></a>扩展配置文件</h2><p>一个配置文件可以被基础配置中的已启用的规则继承。</p>\n<p><code>extends</code> 属性值可以是：</p>\n<ul>\n<li>在配置中指定的一个字符串</li>\n<li>字符串数组：每个配置继承它前面的配置</li>\n</ul>\n<p>ESLint 递归地进行扩展配置，所以一个基础的配置也可以有一个 <code>extends</code> 属性。</p>\n<p><code>rules</code> 属性可以做下面的任何事情以扩展（或覆盖）规则：</p>\n<ul>\n<li>启用额外的规则</li>\n<li>改变继承的规则级别而不改变它的选项：<ul>\n<li>基础配置：<code>&quot;eqeqeq&quot;: [&quot;error&quot;, &quot;allow-null&quot;]</code></li>\n<li>派生的配置：<code>&quot;eqeqeq&quot;: &quot;warn&quot;</code></li>\n<li>最后生成的配置：<code>&quot;eqeqeq&quot;: [&quot;warn&quot;, &quot;allow-null&quot;]</code></li>\n</ul>\n</li>\n<li>覆盖基础配置中的规则的选项<ul>\n<li>基础配置：<code>&quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;, &quot;avoid-escape&quot;]</code></li>\n<li>派生的配置：<code>&quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;]</code></li>\n<li>最后生成的配置：<code>&quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;]</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"使用-eslint-recommended\"><a href=\"#使用-eslint-recommended\" class=\"headerlink\" title=\"使用 eslint:recommended\"></a>使用 eslint:recommended</h3><p>值为 <code>&quot;eslint:recommended&quot;</code> 的 <code>extends</code> 属性启用一系列核心规则，这些规则报告一些常见问题，在 <a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/rules/\" target=\"_blank\" rel=\"noopener\">规则页面</a> 中被标记为 。这个推荐的子集只能在 ESLint 主要版本进行更新。</p>\n<p>如果你的配置集成了推荐的规则：在你升级到 ESLint 新的主版本之后，在你使用<a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface#fix\" target=\"_blank\" rel=\"noopener\">命令行</a>的 <code>--fix</code> 选项之前，检查一下报告的问题，这样你就知道一个新的可修复的推荐的规则将更改代码。</p>\n<p><code>eslint --init</code> 命令可以创建一个配置，这样你就可以继承推荐的规则。</p>\n<p>JavaScript 格式的一个配置文件的例子：</p>\n<pre><code>module.exports = {\n    &quot;extends&quot;: &quot;eslint:recommended&quot;,\n    &quot;rules&quot;: {\n        // enable additional rules\n        &quot;indent&quot;: [&quot;error&quot;, 4],\n        &quot;linebreak-style&quot;: [&quot;error&quot;, &quot;unix&quot;],\n        &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;],\n        &quot;semi&quot;: [&quot;error&quot;, &quot;always&quot;],\n\n        // override default options for rules from base configurations\n        &quot;comma-dangle&quot;: [&quot;error&quot;, &quot;always&quot;],\n        &quot;no-cond-assign&quot;: [&quot;error&quot;, &quot;always&quot;],\n\n        // disable rules from base configurations\n        &quot;no-console&quot;: &quot;off&quot;,\n    }\n}</code></pre><h3 id=\"使用可共享的配置包\"><a href=\"#使用可共享的配置包\" class=\"headerlink\" title=\"使用可共享的配置包\"></a>使用可共享的配置包</h3><p><a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/developer-guide/shareable-configs\" target=\"_blank\" rel=\"noopener\">可共享的配置</a> 是一个 npm 包，它输出一个配置对象。要确保这个包安装在 ESLint 能请求到的目录下。</p>\n<p><code>extends</code> 属性值可以省略包名的前缀 <code>eslint-config-</code>。</p>\n<p><code>eslint --init</code> 命令可以创建一个配置，这样你就可以扩展一个流行的风格指南（比如，<code>eslint-config-standard</code>）。</p>\n<p>YAML 格式的一个配置文件的例子：</p>\n<pre><code>extends: standard\nrules:\n  comma-dangle:\n    - error\n    - always\n  no-empty: warn</code></pre><h3 id=\"使用插件中的配置\"><a href=\"#使用插件中的配置\" class=\"headerlink\" title=\"使用插件中的配置\"></a>使用插件中的配置</h3><p><a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/developer-guide/working-with-plugins\" target=\"_blank\" rel=\"noopener\">插件</a> 是一个 npm 包，通常输出规则。一些插件也可以输出一个或多个命名的 <a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/developer-guide/working-with-plugins#configs-in-plugins\" target=\"_blank\" rel=\"noopener\">配置</a>。要确保这个包安装在 ESLint 能请求到的目录下。</p>\n<p><code>plugins</code> <a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/configuring#configuring-plugins\" target=\"_blank\" rel=\"noopener\">属性值</a> 可以省略包名的前缀 <code>eslint-plugin-</code>。</p>\n<p><code>extends</code> 属性值可以由以下组成：</p>\n<ul>\n<li><code>plugin:</code></li>\n<li>包名 (省略了前缀，比如，<code>react</code>)</li>\n<li><code>/</code></li>\n<li>配置名称 (比如 <code>recommended</code>)</li>\n</ul>\n<p>JSON 格式的一个配置文件的例子：</p>\n<pre><code>{\n    &quot;plugins&quot;: [\n        &quot;react&quot;\n    ],\n    &quot;extends&quot;: [\n        &quot;eslint:recommended&quot;,\n        &quot;plugin:react/recommended&quot;\n    ],\n    &quot;rules&quot;: {\n       &quot;no-set-state&quot;: &quot;off&quot;\n    }\n}</code></pre><h3 id=\"使用一个配置文件\"><a href=\"#使用一个配置文件\" class=\"headerlink\" title=\"使用一个配置文件\"></a>使用一个配置文件</h3><p><code>extends</code> 属性值可以是基本<a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/configuring#using-configuration-files\" target=\"_blank\" rel=\"noopener\">配置文件</a>的绝对路径或相对路径。</p>\n<p>ESLint 解析基本配置文件的相对路径相对你你使用的配置文件，<strong>除非</strong>那个文件在你的主目录或非 ESLint 安装目录的父级目录。在这些情况下，ESLint 解析基本配合文件的相对路径相对于被检测的 <strong>项目</strong>目录（尤其是当前工作目录）。</p>\n<p>JSON 格式的一个配置文件的例子：</p>\n<pre><code>{\n    &quot;extends&quot;: [\n        &quot;./node_modules/coding-standard/eslintDefaults.js&quot;,\n        &quot;./node_modules/coding-standard/.eslintrc-es6&quot;,\n        &quot;./node_modules/coding-standard/.eslintrc-jsx&quot;\n    ],\n    &quot;rules&quot;: {\n        &quot;eqeqeq&quot;: &quot;warn&quot;\n    }\n}</code></pre><h3 id=\"使用-eslint-all\"><a href=\"#使用-eslint-all\" class=\"headerlink\" title=\"使用 eslint:all\"></a>使用 eslint:all</h3><p><code>extends</code> 属性值可以是 <code>&quot;eslint:all&quot;</code>，启用当前安装的 ESLint 中所有的核心规则。这些规则可以在 ESLint 的任何版本进行更改。</p>\n<p><strong>重要：</strong>这些配置 <strong>不推荐在产品中使用</strong>，因为它随着 ESLint 版本进行更改。使用的话，请自己承担风险。</p>\n<p>如果你配置 ESLint 升级时自动地启用新规则，当源码没有任何改变时，ESLint 可以报告新问题，因此任何 ESLint 的新的小版本好像有破坏性的更改。</p>\n<p>当你决定在一个项目上使用的规则和选项，尤其是如果你很少覆盖选项或禁用规则，你可能启用所有核心规则作为一种快捷方式使用。规则的默认选项并不是 ESLint 推荐的（例如，<code>quotes</code> 规则的默认选项并不意味着双引号要比单引号好）。</p>\n<p>如果你的配置扩展了所有的核心规则：在你升级到一个新的大或小的 ESLint 版本，在你使用<a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface#fix\" target=\"_blank\" rel=\"noopener\">命令行</a>的 <code>--fix</code> 选项之前，检查一下报告的问题，这样你就知道一个新的可修复的规则将更改代码。</p>\n<p>JavaScript 格式的一个配置文件的例子：</p>\n<pre><code>module.exports = {\n    &quot;extends&quot;: &quot;eslint:all&quot;,\n    &quot;rules&quot;: {\n        // override default options\n        &quot;comma-dangle&quot;: [&quot;error&quot;, &quot;always&quot;],\n        &quot;indent&quot;: [&quot;error&quot;, 2],\n        &quot;no-cond-assign&quot;: [&quot;error&quot;, &quot;always&quot;],\n\n        // disable now, but enable in the future\n        &quot;one-var&quot;: &quot;off&quot;, // [&quot;error&quot;, &quot;never&quot;]\n\n        // disable\n        &quot;init-declarations&quot;: &quot;off&quot;,\n        &quot;no-console&quot;: &quot;off&quot;,\n        &quot;no-inline-comments&quot;: &quot;off&quot;,\n    }\n}</code></pre><h2 id=\"基于-glob-模式的配置\"><a href=\"#基于-glob-模式的配置\" class=\"headerlink\" title=\"基于 glob 模式的配置\"></a>基于 glob 模式的配置</h2><p>有时，你可能需要更精细的配置，比如，如果同一个目录下的文件需要有不同的配置。因此，你可以在配置中使用 <code>overrides</code> 键，它只适用于匹配特定的 glob 模式的文件，使用你在命令行上传递的格式 (e.g., <code>app/**/*.test.js</code>)。</p>\n<h3 id=\"怎么工作\"><a href=\"#怎么工作\" class=\"headerlink\" title=\"怎么工作\"></a>怎么工作</h3><ul>\n<li>Glob 模式覆盖只能在配置文件 (<code>.eslintrc.*</code> 或 <code>package.json</code>) 中进行配置。</li>\n<li>模式应用于相对于配置文件的目录的文件路径。 比如，如果你的配置文件的路径为 <code>/Users/john/workspace/any-project/.eslintrc.js</code> 而你要检测的路径为 <code>/Users/john/workspace/any-project/lib/util.js</code>，那么你在 <code>.eslintrc.js</code> 中提供的模式是相对于 <code>lib/util.js</code> 来执行的.</li>\n<li>在相同的配置文件中，Glob 模式覆盖比其他常规配置具有更高的优先级。 同一个配置中的多个覆盖将按顺序被应用。也就是说，配置文件中的最后一个覆盖会有最高优先级。</li>\n<li>一个 glob 特定的配置几乎与 ESLint 的其他配置相同。覆盖块可以包含常规配置中的除了 <code>extends</code>、<code>overrides</code> 和 <code>root</code> 之外的其他任何有效配置选项，</li>\n<li>可以在单个覆盖块中提供多个 glob 模式。一个文件必须匹配至少一个配置中提供的模式。</li>\n<li>覆盖块也可以指定从匹配中排除的模式。如果一个文件匹配了任何一个排除模式，该配置将不再被应用。</li>\n</ul>\n<h3 id=\"相对-glob-模式\"><a href=\"#相对-glob-模式\" class=\"headerlink\" title=\"相对 glob 模式\"></a>相对 glob 模式</h3><pre><code>project-root\n├── app\n│   ├── lib\n│   │   ├── foo.js\n│   │   ├── fooSpec.js\n│   ├── components\n│   │   ├── bar.js\n│   │   ├── barSpec.js\n│   ├── .eslintrc.json\n├── server\n│   ├── server.js\n│   ├── serverSpec.js\n├── .eslintrc.json</code></pre><p><code>app/.eslintrc.json</code> 文件中的配置定义了 glob 模式 <code>**/*Spec.js</code>。该模式是相对 <code>app/.eslintrc.json</code> 的基本目录的。因此，该模式将匹配 <code>app/lib/fooSpec.js</code> 和 <code>app/components/barSpec.js</code> 但 <strong>不匹配</strong> <code>server/serverSpec.js</code>。如果你在项目根目录下的 <code>.eslintrc.json</code> 文件中定义了同样的模式，它将匹配这三个 <code>*Spec</code> 文件。</p>\n<h3 id=\"配置示例\"><a href=\"#配置示例\" class=\"headerlink\" title=\"配置示例\"></a>配置示例</h3><p>在你的 <code>.eslintrc.json</code> 文件中：</p>\n<pre><code>{\n  &quot;rules&quot;: {\n    &quot;quotes&quot;: [ 2, &quot;double&quot; ]\n  },\n\n  &quot;overrides&quot;: [\n    {\n      &quot;files&quot;: [ &quot;bin/*.js&quot;, &quot;lib/*.js&quot; ],\n      &quot;excludedFiles&quot;: &quot;*.test.js&quot;,\n      &quot;rules&quot;: {\n        &quot;quotes&quot;: [ 2, &quot;single&quot; ]\n      }\n    }\n  ]\n}</code></pre><h2 id=\"在配置文件中注释\"><a href=\"#在配置文件中注释\" class=\"headerlink\" title=\"在配置文件中注释\"></a>在配置文件中注释</h2><p>JSON 和 YAML 配置文件格式都支持注释 ( <code>package.json</code> 文件不应该包括注释)。你可以在其他类型的文件中使用 JavaScript 风格的注释或使用 YAML 风格的注释，ESLint 会忽略它们。这允许你的配置更加人性化。例如：</p>\n<pre><code>{\n    &quot;env&quot;: {\n        &quot;browser&quot;: true\n    },\n    &quot;rules&quot;: {\n        // Override our default settings just for this directory\n        &quot;eqeqeq&quot;: &quot;warn&quot;,\n        &quot;strict&quot;: &quot;off&quot;\n    }\n}</code></pre><h2 id=\"指定需要检查的文件扩展名\"><a href=\"#指定需要检查的文件扩展名\" class=\"headerlink\" title=\"指定需要检查的文件扩展名\"></a>指定需要检查的文件扩展名</h2><p>目前，告诉 ESLint 哪个文件扩展名要检测的唯一方法是使用 <a href=\"https://link.jianshu.com?t=https://cn.eslint.org/docs/user-guide/command-line-interface#ext\" target=\"_blank\" rel=\"noopener\"><code>--ext</code></a> 命令行选项指定一个逗号分隔的扩展名列表。注意，该标记只在与目录一起使用时有效，如果使用文件名或 glob 模式，它将会被忽略。</p>\n<h2 id=\"忽略文件和目录\"><a href=\"#忽略文件和目录\" class=\"headerlink\" title=\"忽略文件和目录\"></a>忽略文件和目录</h2><p>你可以通过在项目根目录创建一个 <code>.eslintignore</code> 文件告诉 ESLint 去忽略特定的文件和目录。<code>.eslintignore</code> 文件是一个纯文本文件，其中的每一行都是一个 glob 模式表明哪些路径应该忽略检测。例如，以下将忽略所有的 JavaScript 文件：</p>\n<pre><code>**/*.js</code></pre><p>当 ESLint 运行时，在确定哪些文件要检测之前，它会在当前工作目录中查找一个 <code>.eslintignore</code> 文件。如果发现了这个文件，当遍历目录时，将会应用这些偏好设置。一次只有一个 <code>.eslintignore</code> 文件会被使用，所以，不是当前工作目录下的 <code>.eslintignore</code> 文件将不会被用到。</p>\n<p>Globs 匹配使用 <a href=\"https://link.jianshu.com?t=https://github.com/kaelzhang/node-ignore\" target=\"_blank\" rel=\"noopener\">node-ignore</a>，所以大量可用的特性有：</p>\n<ul>\n<li>以 <code>#</code> 开头的行被当作注释，不影响忽略模式。</li>\n<li>路径是相对于 <code>.eslintignore</code> 的位置或当前工作目录。这也会影响通过 <code>--ignore-pattern</code>传递的路径。</li>\n<li>忽略模式同 <code>.gitignore</code> <a href=\"https://link.jianshu.com?t=http://git-scm.com/docs/gitignore\" target=\"_blank\" rel=\"noopener\">规范</a></li>\n<li>以 <code>!</code> 开头的行是否定模式，它将会重新包含一个之前被忽略的模式。</li>\n</ul>\n<p>除了 <code>.eslintignore</code> 文件中的模式，ESLint 总是忽略 <code>/node_modules/*</code> 和 <code>/bower_components/*</code> 中的文件。</p>\n<p>例如：把下面 <code>.eslintignore</code> 文件放到当前工作目录里，将忽略 <code>node_modules</code>，<code>bower_components</code> 以及 <code>build/</code> 目录下除了 <code>build/index.js</code> 的所有文件。</p>\n<pre><code># /node_modules/* and /bower_components/* ignored by default\n\n# Ignore built files except build/index.js\nbuild/*\n!build/index.js</code></pre><h3 id=\"使用备用文件\"><a href=\"#使用备用文件\" class=\"headerlink\" title=\"使用备用文件\"></a>使用备用文件</h3><p>如果相比于当前工作目录下 <code>.eslintignore</code> 文件，你更想使用一个不同的文件，你可以在命令行使用 <code>--ignore-path</code> 选项指定它。例如，你可以使用 <code>.jshintignore</code> 文件，因为它有相同的格式：</p>\n<pre><code>eslint --ignore-path .jshintignore file.js</code></pre><p>你也可以使用你的 <code>.gitignore</code> 文件：</p>\n<pre><code>eslint --ignore-path .gitignore file.js</code></pre><p>任何文件只要满足标准忽略文件格式都可以用。记住，指定 <code>--ignore-path</code> 意味着任何现有的 <code>.eslintignore</code> 文件将不被使用。请注意，<code>.eslintignore</code> 中的匹配规则比 <code>.gitignore</code> 中的更严格。</p>\n<h3 id=\"在-package-json-中使用-eslintConfig\"><a href=\"#在-package-json-中使用-eslintConfig\" class=\"headerlink\" title=\"在 package.json 中使用 eslintConfig\"></a>在 package.json 中使用 eslintConfig</h3><pre><code>{\n  &quot;name&quot;: &quot;mypackage&quot;,\n  &quot;version&quot;: &quot;0.0.1&quot;,\n  &quot;eslintConfig&quot;: {\n      &quot;env&quot;: {\n          &quot;browser&quot;: true,\n          &quot;node&quot;: true\n      }\n  },\n  &quot;eslintIgnore&quot;: [&quot;hello.js&quot;, &quot;world.js&quot;]\n}</code></pre><h3 id=\"忽略文件告警\"><a href=\"#忽略文件告警\" class=\"headerlink\" title=\"忽略文件告警\"></a>忽略文件告警</h3><p>当您将目录传递给 ESLint 时，文件和目录将被忽略。如果将特定文件传递给 ESLint，则会看到一条警告，指示该文件已被跳过。例如，假设你有一个 <code>.eslintignore</code> 文件，如下所示：</p>\n<pre><code>foo.js</code></pre><p>然后，您执行：</p>\n<pre><code>eslint foo.js</code></pre><p>您将会看到以下告警：</p>\n<pre><code>foo.js\n  0:0  warning  File ignored because of your .eslintignore file. Use --no-ignore to override.\n\n✖ 1 problem (0 errors, 1 warning)</code></pre><p>发生此消息是因为 ESLint 不确定是否要检查该文件。如消息所示，您可以使用 <code>--no-ignore</code> 省略使用忽略规则。</p>\n"},{"layout":"post","title":"前端面试之HTTP","date":"2020-03-22T08:22:06.000Z","_content":"\n## HTTP 有哪些方法？\n\n- HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法\n- HTTP1.1 新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT\n\n## 这些方法的具体作用是什么？\n\n- GET: 通常用于请求服务器发送某些资源\n- HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获\n- 取其大小再决定是否要下载, 以此可以节约带宽资源\n- OPTIONS: 用于获取目的资源所支持的通信选项\n- POST: 发送数据给服务器\n- PUT: 用于新增资源或者使用请求中的有效负载替换目标资源的表现形式\n- DELETE: 用于删除指定的资源\n- PATCH: 用于对资源进行部分修改\n- CONNECT: HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器\n- TRACE: 回显服务器收到的请求，主要用于测试或诊断\n\n## GET 和 POST 有什么区别？\n","source":"_posts/2020-03-22-前端面试之HTTP.md","raw":"---\nlayout: post\ntitle: 前端面试之HTTP\ndate: 2020-03-22 16:22:06\ntags: [面试, HTTP]\ncategories: 面试\n---\n\n## HTTP 有哪些方法？\n\n- HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法\n- HTTP1.1 新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT\n\n## 这些方法的具体作用是什么？\n\n- GET: 通常用于请求服务器发送某些资源\n- HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获\n- 取其大小再决定是否要下载, 以此可以节约带宽资源\n- OPTIONS: 用于获取目的资源所支持的通信选项\n- POST: 发送数据给服务器\n- PUT: 用于新增资源或者使用请求中的有效负载替换目标资源的表现形式\n- DELETE: 用于删除指定的资源\n- PATCH: 用于对资源进行部分修改\n- CONNECT: HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器\n- TRACE: 回显服务器收到的请求，主要用于测试或诊断\n\n## GET 和 POST 有什么区别？\n","slug":"2020-03-22-前端面试之HTTP","published":1,"updated":"2020-03-22T08:48:58.911Z","_id":"ck82s23on0000ss8y7w338fc6","comments":1,"photos":[],"link":"","content":"<h2 id=\"HTTP-有哪些方法？\"><a href=\"#HTTP-有哪些方法？\" class=\"headerlink\" title=\"HTTP 有哪些方法？\"></a>HTTP 有哪些方法？</h2><ul>\n<li>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法</li>\n<li>HTTP1.1 新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT</li>\n</ul>\n<h2 id=\"这些方法的具体作用是什么？\"><a href=\"#这些方法的具体作用是什么？\" class=\"headerlink\" title=\"这些方法的具体作用是什么？\"></a>这些方法的具体作用是什么？</h2><ul>\n<li>GET: 通常用于请求服务器发送某些资源</li>\n<li>HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获</li>\n<li>取其大小再决定是否要下载, 以此可以节约带宽资源</li>\n<li>OPTIONS: 用于获取目的资源所支持的通信选项</li>\n<li>POST: 发送数据给服务器</li>\n<li>PUT: 用于新增资源或者使用请求中的有效负载替换目标资源的表现形式</li>\n<li>DELETE: 用于删除指定的资源</li>\n<li>PATCH: 用于对资源进行部分修改</li>\n<li>CONNECT: HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器</li>\n<li>TRACE: 回显服务器收到的请求，主要用于测试或诊断</li>\n</ul>\n<h2 id=\"GET-和-POST-有什么区别？\"><a href=\"#GET-和-POST-有什么区别？\" class=\"headerlink\" title=\"GET 和 POST 有什么区别？\"></a>GET 和 POST 有什么区别？</h2>","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h2 id=\"HTTP-有哪些方法？\"><a href=\"#HTTP-有哪些方法？\" class=\"headerlink\" title=\"HTTP 有哪些方法？\"></a>HTTP 有哪些方法？</h2><ul>\n<li>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法</li>\n<li>HTTP1.1 新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT</li>\n</ul>\n<h2 id=\"这些方法的具体作用是什么？\"><a href=\"#这些方法的具体作用是什么？\" class=\"headerlink\" title=\"这些方法的具体作用是什么？\"></a>这些方法的具体作用是什么？</h2><ul>\n<li>GET: 通常用于请求服务器发送某些资源</li>\n<li>HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获</li>\n<li>取其大小再决定是否要下载, 以此可以节约带宽资源</li>\n<li>OPTIONS: 用于获取目的资源所支持的通信选项</li>\n<li>POST: 发送数据给服务器</li>\n<li>PUT: 用于新增资源或者使用请求中的有效负载替换目标资源的表现形式</li>\n<li>DELETE: 用于删除指定的资源</li>\n<li>PATCH: 用于对资源进行部分修改</li>\n<li>CONNECT: HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器</li>\n<li>TRACE: 回显服务器收到的请求，主要用于测试或诊断</li>\n</ul>\n<h2 id=\"GET-和-POST-有什么区别？\"><a href=\"#GET-和-POST-有什么区别？\" class=\"headerlink\" title=\"GET 和 POST 有什么区别？\"></a>GET 和 POST 有什么区别？</h2>"},{"layout":"post","title":"浅拷贝和深拷贝","date":"2020-04-06T14:39:12.000Z","_content":"\n## 前言\n\n实现一个深克隆是面试中常见的问题的,可是绝大多数面试者的答案都是不完整的,甚至是错误的,这个时候面试官会不断追问,看看你到底理解不理解深克隆的原理,很多情况下一些一知半解的面试者就原形毕漏了.\n\n我们就来看一下如何实现一个深克隆,当然面试中没有让你完整实现的时候,但是你一定要搞清楚其中的坑在哪里,才可以轻松应对面试官的追问.\n\n- JavaScript 原始类型: Undefined、Null、Boolean、Number、String、Symbol\n- JavaScript 引用类型:Object\n\n## 浅克隆\n\n> 浅克隆之所以被称为浅克隆，是因为对象只会被克隆最外部的一层,至于更深层的对象,则依然是通过引用指向同一块堆内存.\n\n```js\n// 浅克隆函数\nfunction shallowClone(o) {\n  const obj = {};\n  for (let i in o) {\n    obj[i] = o[i];\n  }\n  return obj;\n}\n// 被克隆对象\nconst oldObj = {\n  a: 1,\n  b: [\"e\", \"f\", \"g\"],\n  c: { h: { i: 2 } },\n};\n\nconst newObj = shallowClone(oldObj);\nconsole.log(newObj.c.h, oldObj.c.h); // { i: 2 } { i: 2 }\nconsole.log(oldObj.c.h === newObj.c.h); // true\n```\n\n我们可以看到,很明显虽然 oldObj.c.h 被克隆了,但是它还与 oldObj.c.h 相等,这表明他们依然指向同一段堆内存,这就造成了如果对 newObj.c.h 进行修改,也会影响 oldObj.c.h,这就不是一版好的克隆.\n\n```js\nnewObj.c.h.i = \"change\";\nconsole.log(newObj.c.h, oldObj.c.h); // { i: 'change' } { i: 'change' }\n```\n\n我们改变了 newObj.c.h.i 的值,oldObj.c.h.i 也被改变了,这就是浅克隆的问题所在.\n\n当然有一个新的 apiObject.assign()也可以实现浅复制,但是效果跟上面没有差别,所以我们不再细说了.\n\n## 深克隆\n\n### JSON.parse 方法\n\n前几年微博上流传着一个传说中最便捷实现深克隆的方法, JSON 对象 parse 方法可以将 JSON 字符串反序列化成 JS 对象，stringify 方法可以将 JS 对象序列化成 JSON 字符串,这两个方法结合起来就能产生一个便捷的深克隆.\n\n```js\nconst newObj = JSON.parse(JSON.stringify(oldObj));\n```\n\n果然,这是一个实现深克隆的好方法,但是这个解决办法是不是太过简单了.\n\n确实,这个方法虽然可以解决绝大部分是使用场景,但是却有很多坑.\n\n- 他无法实现对函数 、RegExp 等特殊对象的克隆\n- 会抛弃对象的 constructor,所有的构造函数会指向 Object\n- 对象有循环引用,会报错\n  主要的坑就是以上几点,我们一一测试下：\n\n```js\n// 构造函数\nfunction person(pname) {\n  this.name = pname;\n}\n\nconst Messi = new person(\"Messi\");\n\n// 函数\nfunction say() {\n  console.log(\"hi\");\n}\n\nconst oldObj = {\n  a: say,\n  b: new Array(1),\n  c: new RegExp(\"ab+c\", \"i\"),\n  d: Messi,\n};\n\nconst newObj = JSON.parse(JSON.stringify(oldObj));\n\n// 无法复制函数\nconsole.log(newObj.a, oldObj.a); // undefined [Function: say]\n// 稀疏数组复制错误\nconsole.log(newObj.b[0], oldObj.b[0]); // null undefined\n// 无法复制正则对象\nconsole.log(newObj.c, oldObj.c); // {} /ab+c/i\n// 构造函数指向错误\nconsole.log(newObj.d.constructor, oldObj.d.constructor); // [Function: Object] [Function: person]\n```\n\n我们可以看到在对函数、正则对象、稀疏数组等对象克隆时会发生意外，构造函数指向也会发生错误。\n\n```js\nconst oldObj = {};\n\noldObj.a = oldObj;\n\nconst newObj = JSON.parse(JSON.stringify(oldObj));\nconsole.log(newObj.a, oldObj.a); // TypeError: Converting circular structure to JSON\n```\n\n### 构造一个深克隆函数\n\n我们知道要想实现一个靠谱的深克隆方法,上一节提到的序列/反序列是不可能了,而通常教程里提到的方法也是不靠谱的,他们存在的问题跟上一届序列反序列操作中凸显的问题是一致的. (这个方法也会出现上一节提到的问题)\n\n由于要面对不同的对象(正则、数组、Date 等)要采用不同的处理方式，我们需要实现一个对象类型判断函数\n\n```js\nconst isType = (obj, type) => {\n  if (typeof obj !== \"object\") return false;\n  const typeString = Object.prototype.toString.call(obj);\n  let flag;\n  switch (type) {\n    case \"Array\":\n      flag = typeString === \"[object Array]\";\n      break;\n    case \"Date\":\n      flag = typeString === \"[object Date]\";\n      break;\n    case \"RegExp\":\n      flag = typeString === \"[object RegExp]\";\n      break;\n    default:\n      flag = false;\n  }\n  return flag;\n};\n```\n\n这样我们就可以对特殊对象进行类型判断了,从而采用针对性的克隆策略.\n\n```js\nconst arr = Array.of(3, 4, 5, 2);\n\nconsole.log(isType(arr, \"Array\")); // true\n```\n\n对于正则对象,我们在处理之前要先补充一点新知识.\n\n我们需要通过正则的扩展了解到 flags 属性等等,因此我们需要实现一个提取 flags 的函数.\n\n```js\nconst getRegExp = (re) => {\n  var flags = \"\";\n  if (re.global) flags += \"g\";\n  if (re.ignoreCase) flags += \"i\";\n  if (re.multiline) flags += \"m\";\n  return flags;\n};\n```\n\n做好了这些准备工作,我们就可以进行深克隆的实现了.\n\n```js\n/**\n * deep clone\n * @param  {[type]} parent object 需要进行克隆的对象\n * @return {[type]}        深克隆后的对象\n */\nconst clone = (parent) => {\n  // 维护两个储存循环引用的数组\n  const parents = [];\n  const children = [];\n\n  const _clone = (parent) => {\n    if (parent === null) return null;\n    if (typeof parent !== \"object\") return parent;\n\n    let child, proto;\n\n    if (isType(parent, \"Array\")) {\n      // 对数组做特殊处理\n      child = [];\n    } else if (isType(parent, \"RegExp\")) {\n      // 对正则对象做特殊处理\n      child = new RegExp(parent.source, getRegExp(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (isType(parent, \"Date\")) {\n      // 对Date对象做特殊处理\n      child = new Date(parent.getTime());\n    } else {\n      // 处理对象原型\n      proto = Object.getPrototypeOf(parent);\n      // 利用Object.create切断原型链\n      child = Object.create(proto);\n    }\n\n    // 处理循环引用\n    const index = parents.indexOf(parent);\n\n    if (index != -1) {\n      // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象\n      return children[index];\n    }\n    parents.push(parent);\n    children.push(child);\n\n    for (let i in parent) {\n      // 递归\n      child[i] = _clone(parent[i]);\n    }\n\n    return child;\n  };\n  return _clone(parent);\n};\n```\n\n我们做一下测试\n\n```js\nfunction person(pname) {\n  this.name = pname;\n}\n\nconst Messi = new person(\"Messi\");\n\nfunction say() {\n  console.log(\"hi\");\n}\n\nconst oldObj = {\n  a: say,\n  c: new RegExp(\"ab+c\", \"i\"),\n  d: Messi,\n};\n\noldObj.b = oldObj;\n\nconst newObj = clone(oldObj);\nconsole.log(newObj.a, oldObj.a); // [Function: say] [Function: say]\nconsole.log(newObj.b, oldObj.b); // { a: [Function: say], c: /ab+c/i, d: person { name: 'Messi' }, b: [Circular] } { a: [Function: say], c: /ab+c/i, d: person { name: 'Messi' }, b: [Circular] }\nconsole.log(newObj.c, oldObj.c); // /ab+c/i /ab+c/i\nconsole.log(newObj.d.constructor, oldObj.d.constructor); // [Function: person] [Function: person]\n```\n\n当然,我们这个深克隆还不算完美,例如 Buffer 对象、Promise、Set、Map 可能都需要我们做特殊处理，另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间，不过一个基本的深克隆函数我们已经实现了。\n\n## 总结\n\n实现一个完整的深克隆是由许多坑要踩的,npm 上一些库的实现也不够完整,在生产环境中最好用 lodash 的深克隆实现.\n\n在面试过程中,我们上面提到的众多坑是面试官很可能追问你的,要知道坑在哪里,能答出来才是你的加分项,在面试过程中必须要有一两个闪光点,如果只知道序列/反序列这种投机取巧的方法,在追问下不仅拿不到分,很可能造成只懂个皮毛的印象,毕竟,面试面得就是你知识的深度.\n","source":"_posts/2020-04-06浅拷贝和深拷贝.md","raw":"---\nlayout: post\ntitle: 浅拷贝和深拷贝\ndate: 2020-04-06 22:39:12\ntags: [面试, js]\ncategories: 面试\n---\n\n## 前言\n\n实现一个深克隆是面试中常见的问题的,可是绝大多数面试者的答案都是不完整的,甚至是错误的,这个时候面试官会不断追问,看看你到底理解不理解深克隆的原理,很多情况下一些一知半解的面试者就原形毕漏了.\n\n我们就来看一下如何实现一个深克隆,当然面试中没有让你完整实现的时候,但是你一定要搞清楚其中的坑在哪里,才可以轻松应对面试官的追问.\n\n- JavaScript 原始类型: Undefined、Null、Boolean、Number、String、Symbol\n- JavaScript 引用类型:Object\n\n## 浅克隆\n\n> 浅克隆之所以被称为浅克隆，是因为对象只会被克隆最外部的一层,至于更深层的对象,则依然是通过引用指向同一块堆内存.\n\n```js\n// 浅克隆函数\nfunction shallowClone(o) {\n  const obj = {};\n  for (let i in o) {\n    obj[i] = o[i];\n  }\n  return obj;\n}\n// 被克隆对象\nconst oldObj = {\n  a: 1,\n  b: [\"e\", \"f\", \"g\"],\n  c: { h: { i: 2 } },\n};\n\nconst newObj = shallowClone(oldObj);\nconsole.log(newObj.c.h, oldObj.c.h); // { i: 2 } { i: 2 }\nconsole.log(oldObj.c.h === newObj.c.h); // true\n```\n\n我们可以看到,很明显虽然 oldObj.c.h 被克隆了,但是它还与 oldObj.c.h 相等,这表明他们依然指向同一段堆内存,这就造成了如果对 newObj.c.h 进行修改,也会影响 oldObj.c.h,这就不是一版好的克隆.\n\n```js\nnewObj.c.h.i = \"change\";\nconsole.log(newObj.c.h, oldObj.c.h); // { i: 'change' } { i: 'change' }\n```\n\n我们改变了 newObj.c.h.i 的值,oldObj.c.h.i 也被改变了,这就是浅克隆的问题所在.\n\n当然有一个新的 apiObject.assign()也可以实现浅复制,但是效果跟上面没有差别,所以我们不再细说了.\n\n## 深克隆\n\n### JSON.parse 方法\n\n前几年微博上流传着一个传说中最便捷实现深克隆的方法, JSON 对象 parse 方法可以将 JSON 字符串反序列化成 JS 对象，stringify 方法可以将 JS 对象序列化成 JSON 字符串,这两个方法结合起来就能产生一个便捷的深克隆.\n\n```js\nconst newObj = JSON.parse(JSON.stringify(oldObj));\n```\n\n果然,这是一个实现深克隆的好方法,但是这个解决办法是不是太过简单了.\n\n确实,这个方法虽然可以解决绝大部分是使用场景,但是却有很多坑.\n\n- 他无法实现对函数 、RegExp 等特殊对象的克隆\n- 会抛弃对象的 constructor,所有的构造函数会指向 Object\n- 对象有循环引用,会报错\n  主要的坑就是以上几点,我们一一测试下：\n\n```js\n// 构造函数\nfunction person(pname) {\n  this.name = pname;\n}\n\nconst Messi = new person(\"Messi\");\n\n// 函数\nfunction say() {\n  console.log(\"hi\");\n}\n\nconst oldObj = {\n  a: say,\n  b: new Array(1),\n  c: new RegExp(\"ab+c\", \"i\"),\n  d: Messi,\n};\n\nconst newObj = JSON.parse(JSON.stringify(oldObj));\n\n// 无法复制函数\nconsole.log(newObj.a, oldObj.a); // undefined [Function: say]\n// 稀疏数组复制错误\nconsole.log(newObj.b[0], oldObj.b[0]); // null undefined\n// 无法复制正则对象\nconsole.log(newObj.c, oldObj.c); // {} /ab+c/i\n// 构造函数指向错误\nconsole.log(newObj.d.constructor, oldObj.d.constructor); // [Function: Object] [Function: person]\n```\n\n我们可以看到在对函数、正则对象、稀疏数组等对象克隆时会发生意外，构造函数指向也会发生错误。\n\n```js\nconst oldObj = {};\n\noldObj.a = oldObj;\n\nconst newObj = JSON.parse(JSON.stringify(oldObj));\nconsole.log(newObj.a, oldObj.a); // TypeError: Converting circular structure to JSON\n```\n\n### 构造一个深克隆函数\n\n我们知道要想实现一个靠谱的深克隆方法,上一节提到的序列/反序列是不可能了,而通常教程里提到的方法也是不靠谱的,他们存在的问题跟上一届序列反序列操作中凸显的问题是一致的. (这个方法也会出现上一节提到的问题)\n\n由于要面对不同的对象(正则、数组、Date 等)要采用不同的处理方式，我们需要实现一个对象类型判断函数\n\n```js\nconst isType = (obj, type) => {\n  if (typeof obj !== \"object\") return false;\n  const typeString = Object.prototype.toString.call(obj);\n  let flag;\n  switch (type) {\n    case \"Array\":\n      flag = typeString === \"[object Array]\";\n      break;\n    case \"Date\":\n      flag = typeString === \"[object Date]\";\n      break;\n    case \"RegExp\":\n      flag = typeString === \"[object RegExp]\";\n      break;\n    default:\n      flag = false;\n  }\n  return flag;\n};\n```\n\n这样我们就可以对特殊对象进行类型判断了,从而采用针对性的克隆策略.\n\n```js\nconst arr = Array.of(3, 4, 5, 2);\n\nconsole.log(isType(arr, \"Array\")); // true\n```\n\n对于正则对象,我们在处理之前要先补充一点新知识.\n\n我们需要通过正则的扩展了解到 flags 属性等等,因此我们需要实现一个提取 flags 的函数.\n\n```js\nconst getRegExp = (re) => {\n  var flags = \"\";\n  if (re.global) flags += \"g\";\n  if (re.ignoreCase) flags += \"i\";\n  if (re.multiline) flags += \"m\";\n  return flags;\n};\n```\n\n做好了这些准备工作,我们就可以进行深克隆的实现了.\n\n```js\n/**\n * deep clone\n * @param  {[type]} parent object 需要进行克隆的对象\n * @return {[type]}        深克隆后的对象\n */\nconst clone = (parent) => {\n  // 维护两个储存循环引用的数组\n  const parents = [];\n  const children = [];\n\n  const _clone = (parent) => {\n    if (parent === null) return null;\n    if (typeof parent !== \"object\") return parent;\n\n    let child, proto;\n\n    if (isType(parent, \"Array\")) {\n      // 对数组做特殊处理\n      child = [];\n    } else if (isType(parent, \"RegExp\")) {\n      // 对正则对象做特殊处理\n      child = new RegExp(parent.source, getRegExp(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (isType(parent, \"Date\")) {\n      // 对Date对象做特殊处理\n      child = new Date(parent.getTime());\n    } else {\n      // 处理对象原型\n      proto = Object.getPrototypeOf(parent);\n      // 利用Object.create切断原型链\n      child = Object.create(proto);\n    }\n\n    // 处理循环引用\n    const index = parents.indexOf(parent);\n\n    if (index != -1) {\n      // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象\n      return children[index];\n    }\n    parents.push(parent);\n    children.push(child);\n\n    for (let i in parent) {\n      // 递归\n      child[i] = _clone(parent[i]);\n    }\n\n    return child;\n  };\n  return _clone(parent);\n};\n```\n\n我们做一下测试\n\n```js\nfunction person(pname) {\n  this.name = pname;\n}\n\nconst Messi = new person(\"Messi\");\n\nfunction say() {\n  console.log(\"hi\");\n}\n\nconst oldObj = {\n  a: say,\n  c: new RegExp(\"ab+c\", \"i\"),\n  d: Messi,\n};\n\noldObj.b = oldObj;\n\nconst newObj = clone(oldObj);\nconsole.log(newObj.a, oldObj.a); // [Function: say] [Function: say]\nconsole.log(newObj.b, oldObj.b); // { a: [Function: say], c: /ab+c/i, d: person { name: 'Messi' }, b: [Circular] } { a: [Function: say], c: /ab+c/i, d: person { name: 'Messi' }, b: [Circular] }\nconsole.log(newObj.c, oldObj.c); // /ab+c/i /ab+c/i\nconsole.log(newObj.d.constructor, oldObj.d.constructor); // [Function: person] [Function: person]\n```\n\n当然,我们这个深克隆还不算完美,例如 Buffer 对象、Promise、Set、Map 可能都需要我们做特殊处理，另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间，不过一个基本的深克隆函数我们已经实现了。\n\n## 总结\n\n实现一个完整的深克隆是由许多坑要踩的,npm 上一些库的实现也不够完整,在生产环境中最好用 lodash 的深克隆实现.\n\n在面试过程中,我们上面提到的众多坑是面试官很可能追问你的,要知道坑在哪里,能答出来才是你的加分项,在面试过程中必须要有一两个闪光点,如果只知道序列/反序列这种投机取巧的方法,在追问下不仅拿不到分,很可能造成只懂个皮毛的印象,毕竟,面试面得就是你知识的深度.\n","slug":"2020-04-06浅拷贝和深拷贝","published":1,"updated":"2020-04-06T14:48:47.054Z","comments":1,"photos":[],"link":"","_id":"ck98g1t4c00000w8y21rr4pc8","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>实现一个深克隆是面试中常见的问题的,可是绝大多数面试者的答案都是不完整的,甚至是错误的,这个时候面试官会不断追问,看看你到底理解不理解深克隆的原理,很多情况下一些一知半解的面试者就原形毕漏了.</p>\n<p>我们就来看一下如何实现一个深克隆,当然面试中没有让你完整实现的时候,但是你一定要搞清楚其中的坑在哪里,才可以轻松应对面试官的追问.</p>\n<ul>\n<li>JavaScript 原始类型: Undefined、Null、Boolean、Number、String、Symbol</li>\n<li>JavaScript 引用类型:Object</li>\n</ul>\n<h2 id=\"浅克隆\"><a href=\"#浅克隆\" class=\"headerlink\" title=\"浅克隆\"></a>浅克隆</h2><blockquote>\n<p>浅克隆之所以被称为浅克隆，是因为对象只会被克隆最外部的一层,至于更深层的对象,则依然是通过引用指向同一块堆内存.</p>\n</blockquote>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 浅克隆函数</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">shallowClone</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token keyword\">in</span> o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    obj<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> o<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> obj<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 被克隆对象</span>\n<span class=\"token keyword\">const</span> oldObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  a<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n  b<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"e\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"f\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"g\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  c<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> h<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> i<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> newObj <span class=\"token operator\">=</span> <span class=\"token function\">shallowClone</span><span class=\"token punctuation\">(</span>oldObj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>newObj<span class=\"token punctuation\">.</span>c<span class=\"token punctuation\">.</span>h<span class=\"token punctuation\">,</span> oldObj<span class=\"token punctuation\">.</span>c<span class=\"token punctuation\">.</span>h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// { i: 2 } { i: 2 }</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>oldObj<span class=\"token punctuation\">.</span>c<span class=\"token punctuation\">.</span>h <span class=\"token operator\">===</span> newObj<span class=\"token punctuation\">.</span>c<span class=\"token punctuation\">.</span>h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span></code></pre>\n<p>我们可以看到,很明显虽然 oldObj.c.h 被克隆了,但是它还与 oldObj.c.h 相等,这表明他们依然指向同一段堆内存,这就造成了如果对 newObj.c.h 进行修改,也会影响 oldObj.c.h,这就不是一版好的克隆.</p>\n<pre class=\" language-js\"><code class=\"language-js\">newObj<span class=\"token punctuation\">.</span>c<span class=\"token punctuation\">.</span>h<span class=\"token punctuation\">.</span>i <span class=\"token operator\">=</span> <span class=\"token string\">\"change\"</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>newObj<span class=\"token punctuation\">.</span>c<span class=\"token punctuation\">.</span>h<span class=\"token punctuation\">,</span> oldObj<span class=\"token punctuation\">.</span>c<span class=\"token punctuation\">.</span>h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// { i: 'change' } { i: 'change' }</span></code></pre>\n<p>我们改变了 newObj.c.h.i 的值,oldObj.c.h.i 也被改变了,这就是浅克隆的问题所在.</p>\n<p>当然有一个新的 apiObject.assign()也可以实现浅复制,但是效果跟上面没有差别,所以我们不再细说了.</p>\n<h2 id=\"深克隆\"><a href=\"#深克隆\" class=\"headerlink\" title=\"深克隆\"></a>深克隆</h2><h3 id=\"JSON-parse-方法\"><a href=\"#JSON-parse-方法\" class=\"headerlink\" title=\"JSON.parse 方法\"></a>JSON.parse 方法</h3><p>前几年微博上流传着一个传说中最便捷实现深克隆的方法, JSON 对象 parse 方法可以将 JSON 字符串反序列化成 JS 对象，stringify 方法可以将 JS 对象序列化成 JSON 字符串,这两个方法结合起来就能产生一个便捷的深克隆.</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> newObj <span class=\"token operator\">=</span> JSON<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>JSON<span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>oldObj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>果然,这是一个实现深克隆的好方法,但是这个解决办法是不是太过简单了.</p>\n<p>确实,这个方法虽然可以解决绝大部分是使用场景,但是却有很多坑.</p>\n<ul>\n<li>他无法实现对函数 、RegExp 等特殊对象的克隆</li>\n<li>会抛弃对象的 constructor,所有的构造函数会指向 Object</li>\n<li>对象有循环引用,会报错<br>主要的坑就是以上几点,我们一一测试下：</li>\n</ul>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 构造函数</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">person</span><span class=\"token punctuation\">(</span>pname<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> pname<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> Messi <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Messi\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 函数</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">say</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hi\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> oldObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  a<span class=\"token punctuation\">:</span> say<span class=\"token punctuation\">,</span>\n  b<span class=\"token punctuation\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  c<span class=\"token punctuation\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ab+c\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"i\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  d<span class=\"token punctuation\">:</span> Messi<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> newObj <span class=\"token operator\">=</span> JSON<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>JSON<span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>oldObj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 无法复制函数</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>newObj<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">,</span> oldObj<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// undefined [Function: say]</span>\n<span class=\"token comment\" spellcheck=\"true\">// 稀疏数组复制错误</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>newObj<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> oldObj<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// null undefined</span>\n<span class=\"token comment\" spellcheck=\"true\">// 无法复制正则对象</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>newObj<span class=\"token punctuation\">.</span>c<span class=\"token punctuation\">,</span> oldObj<span class=\"token punctuation\">.</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// {} /ab+c/i</span>\n<span class=\"token comment\" spellcheck=\"true\">// 构造函数指向错误</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>newObj<span class=\"token punctuation\">.</span>d<span class=\"token punctuation\">.</span>constructor<span class=\"token punctuation\">,</span> oldObj<span class=\"token punctuation\">.</span>d<span class=\"token punctuation\">.</span>constructor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [Function: Object] [Function: person]</span></code></pre>\n<p>我们可以看到在对函数、正则对象、稀疏数组等对象克隆时会发生意外，构造函数指向也会发生错误。</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> oldObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\noldObj<span class=\"token punctuation\">.</span>a <span class=\"token operator\">=</span> oldObj<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> newObj <span class=\"token operator\">=</span> JSON<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>JSON<span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>oldObj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>newObj<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">,</span> oldObj<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// TypeError: Converting circular structure to JSON</span></code></pre>\n<h3 id=\"构造一个深克隆函数\"><a href=\"#构造一个深克隆函数\" class=\"headerlink\" title=\"构造一个深克隆函数\"></a>构造一个深克隆函数</h3><p>我们知道要想实现一个靠谱的深克隆方法,上一节提到的序列/反序列是不可能了,而通常教程里提到的方法也是不靠谱的,他们存在的问题跟上一届序列反序列操作中凸显的问题是一致的. (这个方法也会出现上一节提到的问题)</p>\n<p>由于要面对不同的对象(正则、数组、Date 等)要采用不同的处理方式，我们需要实现一个对象类型判断函数</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> isType <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> obj <span class=\"token operator\">!==</span> <span class=\"token string\">\"object\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> typeString <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> flag<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"Array\"</span><span class=\"token punctuation\">:</span>\n      flag <span class=\"token operator\">=</span> typeString <span class=\"token operator\">===</span> <span class=\"token string\">\"[object Array]\"</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"Date\"</span><span class=\"token punctuation\">:</span>\n      flag <span class=\"token operator\">=</span> typeString <span class=\"token operator\">===</span> <span class=\"token string\">\"[object Date]\"</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> <span class=\"token string\">\"RegExp\"</span><span class=\"token punctuation\">:</span>\n      flag <span class=\"token operator\">=</span> typeString <span class=\"token operator\">===</span> <span class=\"token string\">\"[object RegExp]\"</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n      flag <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> flag<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre>\n<p>这样我们就可以对特殊对象进行类型判断了,从而采用针对性的克隆策略.</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token keyword\">of</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">isType</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Array\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// true</span></code></pre>\n<p>对于正则对象,我们在处理之前要先补充一点新知识.</p>\n<p>我们需要通过正则的扩展了解到 flags 属性等等,因此我们需要实现一个提取 flags 的函数.</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> getRegExp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>re<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> flags <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>re<span class=\"token punctuation\">.</span>global<span class=\"token punctuation\">)</span> flags <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token string\">\"g\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>re<span class=\"token punctuation\">.</span>ignoreCase<span class=\"token punctuation\">)</span> flags <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token string\">\"i\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>re<span class=\"token punctuation\">.</span>multiline<span class=\"token punctuation\">)</span> flags <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token string\">\"m\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> flags<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre>\n<p>做好了这些准备工作,我们就可以进行深克隆的实现了.</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">/**\n * deep clone\n * @param  {[type]} parent object 需要进行克隆的对象\n * @return {[type]}        深克隆后的对象\n */</span>\n<span class=\"token keyword\">const</span> clone <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 维护两个储存循环引用的数组</span>\n  <span class=\"token keyword\">const</span> parents <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> children <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> _clone <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parent <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> parent <span class=\"token operator\">!==</span> <span class=\"token string\">\"object\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> parent<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">let</span> child<span class=\"token punctuation\">,</span> proto<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isType</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Array\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 对数组做特殊处理</span>\n      child <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isType</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> <span class=\"token string\">\"RegExp\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 对正则对象做特殊处理</span>\n      child <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">.</span>source<span class=\"token punctuation\">,</span> <span class=\"token function\">getRegExp</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">.</span>lastIndex<span class=\"token punctuation\">)</span> child<span class=\"token punctuation\">.</span>lastIndex <span class=\"token operator\">=</span> parent<span class=\"token punctuation\">.</span>lastIndex<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isType</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Date\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 对Date对象做特殊处理</span>\n      child <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">.</span><span class=\"token function\">getTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 处理对象原型</span>\n      proto <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">getPrototypeOf</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 利用Object.create切断原型链</span>\n      child <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>proto<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 处理循环引用</span>\n    <span class=\"token keyword\">const</span> index <span class=\"token operator\">=</span> parents<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象</span>\n      <span class=\"token keyword\">return</span> children<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    parents<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    children<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token keyword\">in</span> parent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 递归</span>\n      child<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">_clone</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> child<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">_clone</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre>\n<p>我们做一下测试</p>\n<pre class=\" language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">person</span><span class=\"token punctuation\">(</span>pname<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> pname<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> Messi <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">person</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Messi\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">say</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hi\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> oldObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  a<span class=\"token punctuation\">:</span> say<span class=\"token punctuation\">,</span>\n  c<span class=\"token punctuation\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ab+c\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"i\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  d<span class=\"token punctuation\">:</span> Messi<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\noldObj<span class=\"token punctuation\">.</span>b <span class=\"token operator\">=</span> oldObj<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> newObj <span class=\"token operator\">=</span> <span class=\"token function\">clone</span><span class=\"token punctuation\">(</span>oldObj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>newObj<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">,</span> oldObj<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [Function: say] [Function: say]</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>newObj<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">,</span> oldObj<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// { a: [Function: say], c: /ab+c/i, d: person { name: 'Messi' }, b: [Circular] } { a: [Function: say], c: /ab+c/i, d: person { name: 'Messi' }, b: [Circular] }</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>newObj<span class=\"token punctuation\">.</span>c<span class=\"token punctuation\">,</span> oldObj<span class=\"token punctuation\">.</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// /ab+c/i /ab+c/i</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>newObj<span class=\"token punctuation\">.</span>d<span class=\"token punctuation\">.</span>constructor<span class=\"token punctuation\">,</span> oldObj<span class=\"token punctuation\">.</span>d<span class=\"token punctuation\">.</span>constructor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [Function: person] [Function: person]</span></code></pre>\n<p>当然,我们这个深克隆还不算完美,例如 Buffer 对象、Promise、Set、Map 可能都需要我们做特殊处理，另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间，不过一个基本的深克隆函数我们已经实现了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>实现一个完整的深克隆是由许多坑要踩的,npm 上一些库的实现也不够完整,在生产环境中最好用 lodash 的深克隆实现.</p>\n<p>在面试过程中,我们上面提到的众多坑是面试官很可能追问你的,要知道坑在哪里,能答出来才是你的加分项,在面试过程中必须要有一两个闪光点,如果只知道序列/反序列这种投机取巧的方法,在追问下不仅拿不到分,很可能造成只懂个皮毛的印象,毕竟,面试面得就是你知识的深度.</p>\n","site":{"data":{"friends":[{"avatar":"https://s1.ax1x.com/2020/03/13/8nIuY6.png","name":"小康之家","introduction":"輕云薄霧，不似秋光","url":"https://jixiaokang.com/","title":"前端日常"},{"avatar":"https://public-links.todu.top/images/blog/me.jpg","name":"杜龙少","introduction":"知识的积累，思想的火花","url":"https://todu.top/","title":"杜龙少的博客"}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>实现一个深克隆是面试中常见的问题的,可是绝大多数面试者的答案都是不完整的,甚至是错误的,这个时候面试官会不断追问,看看你到底理解不理解深克隆的原理,很多情况下一些一知半解的面试者就原形毕漏了.</p>\n<p>我们就来看一下如何实现一个深克隆,当然面试中没有让你完整实现的时候,但是你一定要搞清楚其中的坑在哪里,才可以轻松应对面试官的追问.</p>\n<ul>\n<li>JavaScript 原始类型: Undefined、Null、Boolean、Number、String、Symbol</li>\n<li>JavaScript 引用类型:Object</li>\n</ul>\n<h2 id=\"浅克隆\"><a href=\"#浅克隆\" class=\"headerlink\" title=\"浅克隆\"></a>浅克隆</h2><blockquote>\n<p>浅克隆之所以被称为浅克隆，是因为对象只会被克隆最外部的一层,至于更深层的对象,则依然是通过引用指向同一块堆内存.</p>\n</blockquote>\n<pre><code class=\"js\">// 浅克隆函数\nfunction shallowClone(o) {\n  const obj = {};\n  for (let i in o) {\n    obj[i] = o[i];\n  }\n  return obj;\n}\n// 被克隆对象\nconst oldObj = {\n  a: 1,\n  b: [&quot;e&quot;, &quot;f&quot;, &quot;g&quot;],\n  c: { h: { i: 2 } },\n};\n\nconst newObj = shallowClone(oldObj);\nconsole.log(newObj.c.h, oldObj.c.h); // { i: 2 } { i: 2 }\nconsole.log(oldObj.c.h === newObj.c.h); // true</code></pre>\n<p>我们可以看到,很明显虽然 oldObj.c.h 被克隆了,但是它还与 oldObj.c.h 相等,这表明他们依然指向同一段堆内存,这就造成了如果对 newObj.c.h 进行修改,也会影响 oldObj.c.h,这就不是一版好的克隆.</p>\n<pre><code class=\"js\">newObj.c.h.i = &quot;change&quot;;\nconsole.log(newObj.c.h, oldObj.c.h); // { i: &#39;change&#39; } { i: &#39;change&#39; }</code></pre>\n<p>我们改变了 newObj.c.h.i 的值,oldObj.c.h.i 也被改变了,这就是浅克隆的问题所在.</p>\n<p>当然有一个新的 apiObject.assign()也可以实现浅复制,但是效果跟上面没有差别,所以我们不再细说了.</p>\n<h2 id=\"深克隆\"><a href=\"#深克隆\" class=\"headerlink\" title=\"深克隆\"></a>深克隆</h2><h3 id=\"JSON-parse-方法\"><a href=\"#JSON-parse-方法\" class=\"headerlink\" title=\"JSON.parse 方法\"></a>JSON.parse 方法</h3><p>前几年微博上流传着一个传说中最便捷实现深克隆的方法, JSON 对象 parse 方法可以将 JSON 字符串反序列化成 JS 对象，stringify 方法可以将 JS 对象序列化成 JSON 字符串,这两个方法结合起来就能产生一个便捷的深克隆.</p>\n<pre><code class=\"js\">const newObj = JSON.parse(JSON.stringify(oldObj));</code></pre>\n<p>果然,这是一个实现深克隆的好方法,但是这个解决办法是不是太过简单了.</p>\n<p>确实,这个方法虽然可以解决绝大部分是使用场景,但是却有很多坑.</p>\n<ul>\n<li>他无法实现对函数 、RegExp 等特殊对象的克隆</li>\n<li>会抛弃对象的 constructor,所有的构造函数会指向 Object</li>\n<li>对象有循环引用,会报错<br>主要的坑就是以上几点,我们一一测试下：</li>\n</ul>\n<pre><code class=\"js\">// 构造函数\nfunction person(pname) {\n  this.name = pname;\n}\n\nconst Messi = new person(&quot;Messi&quot;);\n\n// 函数\nfunction say() {\n  console.log(&quot;hi&quot;);\n}\n\nconst oldObj = {\n  a: say,\n  b: new Array(1),\n  c: new RegExp(&quot;ab+c&quot;, &quot;i&quot;),\n  d: Messi,\n};\n\nconst newObj = JSON.parse(JSON.stringify(oldObj));\n\n// 无法复制函数\nconsole.log(newObj.a, oldObj.a); // undefined [Function: say]\n// 稀疏数组复制错误\nconsole.log(newObj.b[0], oldObj.b[0]); // null undefined\n// 无法复制正则对象\nconsole.log(newObj.c, oldObj.c); // {} /ab+c/i\n// 构造函数指向错误\nconsole.log(newObj.d.constructor, oldObj.d.constructor); // [Function: Object] [Function: person]</code></pre>\n<p>我们可以看到在对函数、正则对象、稀疏数组等对象克隆时会发生意外，构造函数指向也会发生错误。</p>\n<pre><code class=\"js\">const oldObj = {};\n\noldObj.a = oldObj;\n\nconst newObj = JSON.parse(JSON.stringify(oldObj));\nconsole.log(newObj.a, oldObj.a); // TypeError: Converting circular structure to JSON</code></pre>\n<h3 id=\"构造一个深克隆函数\"><a href=\"#构造一个深克隆函数\" class=\"headerlink\" title=\"构造一个深克隆函数\"></a>构造一个深克隆函数</h3><p>我们知道要想实现一个靠谱的深克隆方法,上一节提到的序列/反序列是不可能了,而通常教程里提到的方法也是不靠谱的,他们存在的问题跟上一届序列反序列操作中凸显的问题是一致的. (这个方法也会出现上一节提到的问题)</p>\n<p>由于要面对不同的对象(正则、数组、Date 等)要采用不同的处理方式，我们需要实现一个对象类型判断函数</p>\n<pre><code class=\"js\">const isType = (obj, type) =&gt; {\n  if (typeof obj !== &quot;object&quot;) return false;\n  const typeString = Object.prototype.toString.call(obj);\n  let flag;\n  switch (type) {\n    case &quot;Array&quot;:\n      flag = typeString === &quot;[object Array]&quot;;\n      break;\n    case &quot;Date&quot;:\n      flag = typeString === &quot;[object Date]&quot;;\n      break;\n    case &quot;RegExp&quot;:\n      flag = typeString === &quot;[object RegExp]&quot;;\n      break;\n    default:\n      flag = false;\n  }\n  return flag;\n};</code></pre>\n<p>这样我们就可以对特殊对象进行类型判断了,从而采用针对性的克隆策略.</p>\n<pre><code class=\"js\">const arr = Array.of(3, 4, 5, 2);\n\nconsole.log(isType(arr, &quot;Array&quot;)); // true</code></pre>\n<p>对于正则对象,我们在处理之前要先补充一点新知识.</p>\n<p>我们需要通过正则的扩展了解到 flags 属性等等,因此我们需要实现一个提取 flags 的函数.</p>\n<pre><code class=\"js\">const getRegExp = (re) =&gt; {\n  var flags = &quot;&quot;;\n  if (re.global) flags += &quot;g&quot;;\n  if (re.ignoreCase) flags += &quot;i&quot;;\n  if (re.multiline) flags += &quot;m&quot;;\n  return flags;\n};</code></pre>\n<p>做好了这些准备工作,我们就可以进行深克隆的实现了.</p>\n<pre><code class=\"js\">/**\n * deep clone\n * @param  {[type]} parent object 需要进行克隆的对象\n * @return {[type]}        深克隆后的对象\n */\nconst clone = (parent) =&gt; {\n  // 维护两个储存循环引用的数组\n  const parents = [];\n  const children = [];\n\n  const _clone = (parent) =&gt; {\n    if (parent === null) return null;\n    if (typeof parent !== &quot;object&quot;) return parent;\n\n    let child, proto;\n\n    if (isType(parent, &quot;Array&quot;)) {\n      // 对数组做特殊处理\n      child = [];\n    } else if (isType(parent, &quot;RegExp&quot;)) {\n      // 对正则对象做特殊处理\n      child = new RegExp(parent.source, getRegExp(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (isType(parent, &quot;Date&quot;)) {\n      // 对Date对象做特殊处理\n      child = new Date(parent.getTime());\n    } else {\n      // 处理对象原型\n      proto = Object.getPrototypeOf(parent);\n      // 利用Object.create切断原型链\n      child = Object.create(proto);\n    }\n\n    // 处理循环引用\n    const index = parents.indexOf(parent);\n\n    if (index != -1) {\n      // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象\n      return children[index];\n    }\n    parents.push(parent);\n    children.push(child);\n\n    for (let i in parent) {\n      // 递归\n      child[i] = _clone(parent[i]);\n    }\n\n    return child;\n  };\n  return _clone(parent);\n};</code></pre>\n<p>我们做一下测试</p>\n<pre><code class=\"js\">function person(pname) {\n  this.name = pname;\n}\n\nconst Messi = new person(&quot;Messi&quot;);\n\nfunction say() {\n  console.log(&quot;hi&quot;);\n}\n\nconst oldObj = {\n  a: say,\n  c: new RegExp(&quot;ab+c&quot;, &quot;i&quot;),\n  d: Messi,\n};\n\noldObj.b = oldObj;\n\nconst newObj = clone(oldObj);\nconsole.log(newObj.a, oldObj.a); // [Function: say] [Function: say]\nconsole.log(newObj.b, oldObj.b); // { a: [Function: say], c: /ab+c/i, d: person { name: &#39;Messi&#39; }, b: [Circular] } { a: [Function: say], c: /ab+c/i, d: person { name: &#39;Messi&#39; }, b: [Circular] }\nconsole.log(newObj.c, oldObj.c); // /ab+c/i /ab+c/i\nconsole.log(newObj.d.constructor, oldObj.d.constructor); // [Function: person] [Function: person]</code></pre>\n<p>当然,我们这个深克隆还不算完美,例如 Buffer 对象、Promise、Set、Map 可能都需要我们做特殊处理，另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间，不过一个基本的深克隆函数我们已经实现了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>实现一个完整的深克隆是由许多坑要踩的,npm 上一些库的实现也不够完整,在生产环境中最好用 lodash 的深克隆实现.</p>\n<p>在面试过程中,我们上面提到的众多坑是面试官很可能追问你的,要知道坑在哪里,能答出来才是你的加分项,在面试过程中必须要有一两个闪光点,如果只知道序列/反序列这种投机取巧的方法,在追问下不仅拿不到分,很可能造成只懂个皮毛的印象,毕竟,面试面得就是你知识的深度.</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck7u2pvj200004k8y12ox6u1n","category_id":"ck7u2pvji00044k8ybsqqbmkf","_id":"ck7u2pvjt000g4k8y0ug64ssm"},{"post_id":"ck7u2pvjp000e4k8y4fzc1pjp","category_id":"ck7u2pvjn000b4k8yani676jc","_id":"ck7u2pvjx000l4k8y5ry9dzvu"},{"post_id":"ck7u2pvjf00024k8y5j1y5n2r","category_id":"ck7u2pvjn000b4k8yani676jc","_id":"ck7u2pvk0000q4k8ybb4z3ih2"},{"post_id":"ck7u2pvju000j4k8y93b99707","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvk2000t4k8ybws8bt4u"},{"post_id":"ck7u2pvjk00064k8ye9lta5ar","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvk4000y4k8y48s62oql"},{"post_id":"ck7u2pvjz000p4k8ygkm2etna","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvk600114k8yhz2b6hjd"},{"post_id":"ck7u2pvjl00084k8y4bp020he","category_id":"ck7u2pvjn000b4k8yani676jc","_id":"ck7u2pvk900164k8y6fb93ij9"},{"post_id":"ck7u2pvk1000s4k8y1n6jfm29","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvka00194k8yg0738cm8"},{"post_id":"ck7u2pvk3000x4k8y95cf3ox5","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvke001e4k8y8f70db9f"},{"post_id":"ck7u2pvjn000a4k8y3nuuam3b","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvkg001h4k8yeluubswg"},{"post_id":"ck7u2pvk500104k8yh1q8eiju","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvki001m4k8y80mz7ihz"},{"post_id":"ck7u2pvjs000f4k8y310o6m8o","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvkk001p4k8y30ib9rsa"},{"post_id":"ck7u2pvk900184k8yggk18v2d","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvkt001t4k8ybc8n55lm"},{"post_id":"ck7u2pvkd001d4k8yej4b455y","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvkv001w4k8y07jmas9k"},{"post_id":"ck7u2pvjw000k4k8ybnye4inp","category_id":"ck7u2pvka001a4k8y1uqz70u2","_id":"ck7u2pvkw001z4k8ybe9hg66r"},{"post_id":"ck7u2pvkf001g4k8y6ej1abme","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvkx00234k8ycc532xds"},{"post_id":"ck7u2pvkh001l4k8ya8yy95wv","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvkz00264k8yh2ja1yvv"},{"post_id":"ck7u2pvk700154k8yczgcaol6","category_id":"ck7u2pvka001a4k8y1uqz70u2","_id":"ck7u2pvl1002a4k8y1zeketwr"},{"post_id":"ck7u2pvkj001o4k8yfl2c9b8r","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvl2002d4k8ycmj401qn"},{"post_id":"ck7u2pvkl001s4k8y5juj8i1g","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvl4002h4k8ygfkve8y1"},{"post_id":"ck7u2pvku001v4k8y6v85g6e7","category_id":"ck7u2pvjn000b4k8yani676jc","_id":"ck7u2pvl6002k4k8y3hfb94n8"},{"post_id":"ck7u2pvkv001y4k8y0gyo53rn","category_id":"ck7u2pvjn000b4k8yani676jc","_id":"ck7u2pvl9002o4k8y9xwj41vt"},{"post_id":"ck7u2pvkx00224k8y3amjbda9","category_id":"ck7u2pvjn000b4k8yani676jc","_id":"ck7u2pvlb002r4k8yckn518y7"},{"post_id":"ck7u2pvky00254k8y5l2j1o1k","category_id":"ck7u2pvjn000b4k8yani676jc","_id":"ck7u2pvld002u4k8y53rm6f9l"},{"post_id":"ck7u2pvl000294k8y9nsf6xzw","category_id":"ck7u2pvjn000b4k8yani676jc","_id":"ck7u2pvle002y4k8yezwegr13"},{"post_id":"ck7u2pvl2002c4k8y5zp6d1yn","category_id":"ck7u2pvjn000b4k8yani676jc","_id":"ck7u2pvlf00314k8y024rg4hb"},{"post_id":"ck7u2pvl3002g4k8y143w0td2","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvlg00344k8yfmqw8eun"},{"post_id":"ck7u2pvl5002j4k8ye4f95amu","category_id":"ck7u2pvjn000b4k8yani676jc","_id":"ck7u2pvlg00364k8y3ckq9rxy"},{"post_id":"ck7u2pvl8002n4k8yhn55av7w","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvlh00394k8y57t7gplu"},{"post_id":"ck7u2pvla002q4k8yacaw7n58","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvlh003b4k8y41kma6mq"},{"post_id":"ck7u2pvlb002t4k8ycijtefsb","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvli003e4k8y33vdeai0"},{"post_id":"ck7u2pvld002x4k8y5vq0esaw","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvli003g4k8ydxjn0iir"},{"post_id":"ck7u2pvle00304k8y9h34f9dv","category_id":"ck7u2pvji00044k8ybsqqbmkf","_id":"ck7u2pvli003j4k8y3c2rfj1v"},{"post_id":"ck7u2pvmh003y4k8y8txc52y6","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvmk00444k8y7u5h6y1p"},{"post_id":"ck7u2pvmh003z4k8ygyb5hbdc","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvml00484k8y6mxy94l2"},{"post_id":"ck7u2pvmi00414k8y8b2veu8h","category_id":"ck7u2pvjn000b4k8yani676jc","_id":"ck7u2pvmn004b4k8y9a6r0qc2"},{"post_id":"ck7u2pvmj00434k8yfbf93cyg","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvmp004f4k8y77b59qqo"},{"post_id":"ck7u2pvml00474k8year6b00q","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvmr004i4k8ybnat5l83"},{"post_id":"ck7u2pvmm004a4k8y93gmb7fs","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvmt004l4k8yggmj0vxn"},{"post_id":"ck7u2pvmo004d4k8y36mz3uml","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvmv004p4k8ydkty6j0m"},{"post_id":"ck7u2pvmq004h4k8y8cpl9ppi","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvmw004s4k8yhy4vhxll"},{"post_id":"ck7u2pvms004k4k8yh9ythba8","category_id":"ck7u2pvka001a4k8y1uqz70u2","_id":"ck7u2pvmx004v4k8y29s43q97"},{"post_id":"ck7u2pvmu004o4k8y5gq45yuw","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvmy004y4k8ybsq747rv"},{"post_id":"ck7u2pvmv004r4k8yhfa5hy1v","category_id":"ck7u2pvjn000b4k8yani676jc","_id":"ck7u2pvn000524k8y7tgm6jgj"},{"post_id":"ck7u2pvmw004u4k8yb4fgc6mq","category_id":"ck7u2pvjn000b4k8yani676jc","_id":"ck7u2pvn100554k8yg0rjb40k"},{"post_id":"ck7u2pvmy004x4k8ybmxt5ip8","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvn200584k8y1me4gjf0"},{"post_id":"ck7u2pvn000514k8yh7gg783w","category_id":"ck7u2pvji00044k8ybsqqbmkf","_id":"ck7u2pvn3005b4k8y4pfw9ifv"},{"post_id":"ck7u2pvn100544k8ygwmc1d18","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvn4005e4k8yaawkcbyy"},{"post_id":"ck7u2pvn200574k8y80zkdg7i","category_id":"ck7u2pvjn000b4k8yani676jc","_id":"ck7u2pvn7005j4k8yeibe7jrd"},{"post_id":"ck7u2pvn4005d4k8yfbnl6reo","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvn8005n4k8yaxp88ndw"},{"post_id":"ck7u2pvn5005i4k8y6momf7iy","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvn9005q4k8y5typ5are"},{"post_id":"ck7u2pvn7005l4k8y4m4t5j00","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvn9005s4k8yacc6gbxs"},{"post_id":"ck7u2pvn3005a4k8yetv952y0","category_id":"ck7u2pvn4005f4k8ydb649ny6","_id":"ck7u2pvna005u4k8yfysk5x9v"},{"post_id":"ck7u2pvnn00654k8ychmy2xiv","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvnq006b4k8yfa58ectw"},{"post_id":"ck7u2pvno00664k8y80p89c4b","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvnr006e4k8y9vrm4o9u"},{"post_id":"ck7u2pvnp00684k8y74gkf1yy","category_id":"ck7u2pvka001a4k8y1uqz70u2","_id":"ck7u2pvnr006h4k8yaywb895w"},{"post_id":"ck7u2pvnp006a4k8ybzyncbo4","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvns006j4k8yhmswaqln"},{"post_id":"ck7u2pvnq006d4k8y809r4t3l","category_id":"ck7u2pvji00044k8ybsqqbmkf","_id":"ck7u2pvns006l4k8ycdfp9usb"},{"post_id":"ck7u2pvny006n4k8y4sjkgnf7","category_id":"ck7u2pvjn000b4k8yani676jc","_id":"ck7u2pvo1006u4k8y349c0ijf"},{"post_id":"ck7u2pvnz006o4k8yge7s2gsi","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvo2006x4k8yahu6356l"},{"post_id":"ck7u2pvnz006q4k8yh8bn1izl","category_id":"ck7u2pvka001a4k8y1uqz70u2","_id":"ck7u2pvo2006z4k8yeq2o98dn"},{"post_id":"ck7u2pvo0006t4k8y2e308xsb","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvo300714k8yd4n93cka"},{"post_id":"ck7u2pvo1006w4k8yg2g007pp","category_id":"ck7u2pvji00044k8ybsqqbmkf","_id":"ck7u2pvo300734k8ybxv55lmy"},{"post_id":"ck7u2pvo800764k8y414k1n0e","category_id":"ck7u2pvjt000h4k8y899m5mjg","_id":"ck7u2pvoa007a4k8y10oq8897"},{"post_id":"ck7u2pvo900774k8yhoz8bgxh","category_id":"ck7u2pvjn000b4k8yani676jc","_id":"ck7u2pvoa007c4k8yb1wx931w"},{"post_id":"ck82s23on0000ss8y7w338fc6","category_id":"ck7u2pvn4005f4k8ydb649ny6","_id":"ck82s23or0002ss8y40gw4g8d"},{"post_id":"ck98g1t4c00000w8y21rr4pc8","category_id":"ck7u2pvn4005f4k8ydb649ny6","_id":"ck98g1t4o00030w8y5c89dd3w"}],"PostTag":[{"post_id":"ck7u2pvj200004k8y12ox6u1n","tag_id":"ck7u2pvjj00054k8y4h4jedys","_id":"ck7u2pvjp000d4k8y59gm180r"},{"post_id":"ck7u2pvju000j4k8y93b99707","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvjy000o4k8y7v086wx2"},{"post_id":"ck7u2pvjk00064k8ye9lta5ar","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvk1000r4k8yhh8d2crl"},{"post_id":"ck7u2pvjk00064k8ye9lta5ar","tag_id":"ck7u2pvjt000i4k8yag6y0y00","_id":"ck7u2pvk3000w4k8yem21h7r3"},{"post_id":"ck7u2pvjw000k4k8ybnye4inp","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvk4000z4k8y03i6988s"},{"post_id":"ck7u2pvjz000p4k8ygkm2etna","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvk700134k8ycskj1g01"},{"post_id":"ck7u2pvk1000s4k8y1n6jfm29","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvk900174k8ycjaa6f14"},{"post_id":"ck7u2pvk1000s4k8y1n6jfm29","tag_id":"ck7u2pvjt000i4k8yag6y0y00","_id":"ck7u2pvkd001b4k8ye5u53l3c"},{"post_id":"ck7u2pvk3000x4k8y95cf3ox5","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvkf001f4k8ybky903no"},{"post_id":"ck7u2pvk3000x4k8y95cf3ox5","tag_id":"ck7u2pvjt000i4k8yag6y0y00","_id":"ck7u2pvkg001i4k8y4bkc8v8n"},{"post_id":"ck7u2pvjl00084k8y4bp020he","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvkj001n4k8yee3h22xb"},{"post_id":"ck7u2pvjl00084k8y4bp020he","tag_id":"ck7u2pvk2000v4k8yf0kr2sev","_id":"ck7u2pvkl001q4k8y62o71pqh"},{"post_id":"ck7u2pvk900184k8yggk18v2d","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvkt001u4k8yhbtj1hhd"},{"post_id":"ck7u2pvjn000a4k8y3nuuam3b","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvkv001x4k8ydlsrcdu2"},{"post_id":"ck7u2pvjn000a4k8y3nuuam3b","tag_id":"ck7u2pvjt000i4k8yag6y0y00","_id":"ck7u2pvkw00214k8y65p07y4d"},{"post_id":"ck7u2pvkf001g4k8y6ej1abme","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvky00244k8yd62568pn"},{"post_id":"ck7u2pvkh001l4k8ya8yy95wv","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvl000284k8y2g9r2286"},{"post_id":"ck7u2pvjp000e4k8y4fzc1pjp","tag_id":"ck7u2pvk2000v4k8yf0kr2sev","_id":"ck7u2pvl2002b4k8y8771hk7i"},{"post_id":"ck7u2pvkj001o4k8yfl2c9b8r","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvl3002f4k8y3rwt80g6"},{"post_id":"ck7u2pvkl001s4k8y5juj8i1g","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvl5002i4k8ydjfpfc6t"},{"post_id":"ck7u2pvkl001s4k8y5juj8i1g","tag_id":"ck7u2pvjt000i4k8yag6y0y00","_id":"ck7u2pvl7002l4k8y1rvf1sjk"},{"post_id":"ck7u2pvjs000f4k8y310o6m8o","tag_id":"ck7u2pvkl001r4k8ygoyr4qry","_id":"ck7u2pvla002p4k8ydvggfdik"},{"post_id":"ck7u2pvk500104k8yh1q8eiju","tag_id":"ck7u2pvkw00204k8y1k9h6jld","_id":"ck7u2pvlb002s4k8y7mnnblba"},{"post_id":"ck7u2pvk700154k8yczgcaol6","tag_id":"ck7u2pvkz00274k8y4qv8bkvm","_id":"ck7u2pvld002w4k8yg6gwebi9"},{"post_id":"ck7u2pvl3002g4k8y143w0td2","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvle002z4k8y6y8xcx8f"},{"post_id":"ck7u2pvkd001d4k8yej4b455y","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvlg00334k8y2r9m0cym"},{"post_id":"ck7u2pvkd001d4k8yej4b455y","tag_id":"ck7u2pvl3002e4k8y4udi72yr","_id":"ck7u2pvlg00354k8y057z9q8c"},{"post_id":"ck7u2pvl8002n4k8yhn55av7w","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvlg00384k8y4o7y35wm"},{"post_id":"ck7u2pvla002q4k8yacaw7n58","tag_id":"ck7u2pvjt000i4k8yag6y0y00","_id":"ck7u2pvlh003a4k8y97e8cs7d"},{"post_id":"ck7u2pvku001v4k8y6v85g6e7","tag_id":"ck7u2pvl7002m4k8yhsl74i63","_id":"ck7u2pvli003d4k8ycher7zxx"},{"post_id":"ck7u2pvld002x4k8y5vq0esaw","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvli003f4k8y1gh1apjm"},{"post_id":"ck7u2pvld002x4k8y5vq0esaw","tag_id":"ck7u2pvjt000i4k8yag6y0y00","_id":"ck7u2pvli003i4k8y0yi2835z"},{"post_id":"ck7u2pvkv001y4k8y0gyo53rn","tag_id":"ck7u2pvld002v4k8yedabcw69","_id":"ck7u2pvli003k4k8y4yky1btd"},{"post_id":"ck7u2pvkx00224k8y3amjbda9","tag_id":"ck7u2pvl7002m4k8yhsl74i63","_id":"ck7u2pvlj003m4k8yaoql0v0e"},{"post_id":"ck7u2pvky00254k8y5l2j1o1k","tag_id":"ck7u2pvl7002m4k8yhsl74i63","_id":"ck7u2pvlj003n4k8y0ow4cs5g"},{"post_id":"ck7u2pvl000294k8y9nsf6xzw","tag_id":"ck7u2pvl7002m4k8yhsl74i63","_id":"ck7u2pvlj003p4k8y2h2t2cc6"},{"post_id":"ck7u2pvl2002c4k8y5zp6d1yn","tag_id":"ck7u2pvl7002m4k8yhsl74i63","_id":"ck7u2pvlj003q4k8ybrn5d949"},{"post_id":"ck7u2pvl2002c4k8y5zp6d1yn","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvlj003s4k8yfxah1u33"},{"post_id":"ck7u2pvl5002j4k8ye4f95amu","tag_id":"ck7u2pvl7002m4k8yhsl74i63","_id":"ck7u2pvlj003t4k8y3h0m1ttg"},{"post_id":"ck7u2pvlb002t4k8ycijtefsb","tag_id":"ck7u2pvlj003o4k8y6dlkcor8","_id":"ck7u2pvlk003v4k8y0cd17rfb"},{"post_id":"ck7u2pvlb002t4k8ycijtefsb","tag_id":"ck7u2pvlj003r4k8yckbq7ytc","_id":"ck7u2pvlk003w4k8yex2z30of"},{"post_id":"ck7u2pvle00304k8y9h34f9dv","tag_id":"ck7u2pvlk003u4k8y14tmha07","_id":"ck7u2pvlk003x4k8y261u40qv"},{"post_id":"ck7u2pvmh003y4k8y8txc52y6","tag_id":"ck7u2pvkl001r4k8ygoyr4qry","_id":"ck7u2pvmi00404k8y99v3emts"},{"post_id":"ck7u2pvmh003y4k8y8txc52y6","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvmj00424k8ye0wshmjt"},{"post_id":"ck7u2pvmh003z4k8ygyb5hbdc","tag_id":"ck7u2pvkl001r4k8ygoyr4qry","_id":"ck7u2pvml00464k8ye0t84048"},{"post_id":"ck7u2pvmj00434k8yfbf93cyg","tag_id":"ck7u2pvkl001r4k8ygoyr4qry","_id":"ck7u2pvmm00494k8y627z2q5w"},{"post_id":"ck7u2pvml00474k8year6b00q","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvmo004c4k8ye7mn2gs9"},{"post_id":"ck7u2pvml00474k8year6b00q","tag_id":"ck7u2pvjt000i4k8yag6y0y00","_id":"ck7u2pvmp004g4k8y5pc3bv9q"},{"post_id":"ck7u2pvmm004a4k8y93gmb7fs","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvms004j4k8y2lsq24yg"},{"post_id":"ck7u2pvmm004a4k8y93gmb7fs","tag_id":"ck7u2pvjt000i4k8yag6y0y00","_id":"ck7u2pvmt004n4k8y85ch4k4v"},{"post_id":"ck7u2pvmo004d4k8y36mz3uml","tag_id":"ck7u2pvjt000i4k8yag6y0y00","_id":"ck7u2pvmv004q4k8yfwlf1bp5"},{"post_id":"ck7u2pvmq004h4k8y8cpl9ppi","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvmw004t4k8yd5bxgsir"},{"post_id":"ck7u2pvms004k4k8yh9ythba8","tag_id":"ck7u2pvl7002m4k8yhsl74i63","_id":"ck7u2pvmx004w4k8y9js4excb"},{"post_id":"ck7u2pvmu004o4k8y5gq45yuw","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvmz00504k8y9jp544a5"},{"post_id":"ck7u2pvmi00414k8y8b2veu8h","tag_id":"ck7u2pvmk00454k8y6we0ck8l","_id":"ck7u2pvn100534k8y17vc34pv"},{"post_id":"ck7u2pvmi00414k8y8b2veu8h","tag_id":"ck7u2pvmp004e4k8y9d963s4h","_id":"ck7u2pvn200564k8y1xk1crrw"},{"post_id":"ck7u2pvmi00414k8y8b2veu8h","tag_id":"ck7u2pvmt004m4k8y7luv34fw","_id":"ck7u2pvn300594k8y1c646idu"},{"post_id":"ck7u2pvmv004r4k8yhfa5hy1v","tag_id":"ck7u2pvl7002m4k8yhsl74i63","_id":"ck7u2pvn3005c4k8y81ix8e2i"},{"post_id":"ck7u2pvmy004x4k8ybmxt5ip8","tag_id":"ck7u2pvkw00204k8y1k9h6jld","_id":"ck7u2pvn5005h4k8yais516ee"},{"post_id":"ck7u2pvn000514k8yh7gg783w","tag_id":"ck7u2pvjj00054k8y4h4jedys","_id":"ck7u2pvn7005k4k8yb45g8er9"},{"post_id":"ck7u2pvn100544k8ygwmc1d18","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvn8005m4k8ydel5cf6a"},{"post_id":"ck7u2pvmw004u4k8yb4fgc6mq","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvn9005p4k8ye30ohp5y"},{"post_id":"ck7u2pvmw004u4k8yb4fgc6mq","tag_id":"ck7u2pvmz004z4k8y4zsxb0i4","_id":"ck7u2pvn9005r4k8y9o7y7rli"},{"post_id":"ck7u2pvn200574k8y80zkdg7i","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvna005t4k8y8i4j8u6w"},{"post_id":"ck7u2pvn200574k8y80zkdg7i","tag_id":"ck7u2pvl7002m4k8yhsl74i63","_id":"ck7u2pvna005v4k8y5ay6cig7"},{"post_id":"ck7u2pvn4005d4k8yfbnl6reo","tag_id":"ck7u2pvjt000i4k8yag6y0y00","_id":"ck7u2pvna005w4k8ydcg1cs3v"},{"post_id":"ck7u2pvn4005d4k8yfbnl6reo","tag_id":"ck7u2pvmp004e4k8y9d963s4h","_id":"ck7u2pvna005x4k8ydv9pc5c3"},{"post_id":"ck7u2pvn4005d4k8yfbnl6reo","tag_id":"ck7u2pvmt004m4k8y7luv34fw","_id":"ck7u2pvna005y4k8y79zn57lc"},{"post_id":"ck7u2pvn5005i4k8y6momf7iy","tag_id":"ck7u2pvjt000i4k8yag6y0y00","_id":"ck7u2pvna005z4k8y9eipgc9q"},{"post_id":"ck7u2pvn3005a4k8yetv952y0","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvna00604k8y9oo46r72"},{"post_id":"ck7u2pvn3005a4k8yetv952y0","tag_id":"ck7u2pvn5005g4k8yb5pa8qk7","_id":"ck7u2pvna00614k8y3svk7hgc"},{"post_id":"ck7u2pvn7005l4k8y4m4t5j00","tag_id":"ck7u2pvjt000i4k8yag6y0y00","_id":"ck7u2pvna00624k8yaqg96kl6"},{"post_id":"ck7u2pvn7005l4k8y4m4t5j00","tag_id":"ck7u2pvmp004e4k8y9d963s4h","_id":"ck7u2pvna00634k8y487640ev"},{"post_id":"ck7u2pvn7005l4k8y4m4t5j00","tag_id":"ck7u2pvn9005o4k8ydm4r3rfn","_id":"ck7u2pvna00644k8yhodid3wc"},{"post_id":"ck7u2pvno00664k8y80p89c4b","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvnp00694k8ydmk7dvwv"},{"post_id":"ck7u2pvnp00684k8y74gkf1yy","tag_id":"ck7u2pvl7002m4k8yhsl74i63","_id":"ck7u2pvnq006c4k8ycns663ap"},{"post_id":"ck7u2pvnn00654k8ychmy2xiv","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvnr006g4k8y3kp2817l"},{"post_id":"ck7u2pvnn00654k8ychmy2xiv","tag_id":"ck7u2pvno00674k8yg1jbecyz","_id":"ck7u2pvns006i4k8ye0lpho9y"},{"post_id":"ck7u2pvnq006d4k8y809r4t3l","tag_id":"ck7u2pvlk003u4k8y14tmha07","_id":"ck7u2pvns006k4k8y27vcceif"},{"post_id":"ck7u2pvnp006a4k8ybzyncbo4","tag_id":"ck7u2pvnr006f4k8y44br5blx","_id":"ck7u2pvns006m4k8yha7zajj1"},{"post_id":"ck7u2pvny006n4k8y4sjkgnf7","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvnz006p4k8yh2n63prq"},{"post_id":"ck7u2pvny006n4k8y4sjkgnf7","tag_id":"ck7u2pvk2000v4k8yf0kr2sev","_id":"ck7u2pvo0006s4k8y0n5ef5tf"},{"post_id":"ck7u2pvnz006q4k8yh8bn1izl","tag_id":"ck7u2pvl7002m4k8yhsl74i63","_id":"ck7u2pvo1006v4k8yen3a7uaq"},{"post_id":"ck7u2pvo1006w4k8yg2g007pp","tag_id":"ck7u2pvlk003u4k8y14tmha07","_id":"ck7u2pvo200704k8ya0p13ib9"},{"post_id":"ck7u2pvnz006o4k8yge7s2gsi","tag_id":"ck7u2pvo0006r4k8yhyp75n15","_id":"ck7u2pvo300724k8y6s7yhcs3"},{"post_id":"ck7u2pvo0006t4k8y2e308xsb","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvo300744k8y48gn6bag"},{"post_id":"ck7u2pvo0006t4k8y2e308xsb","tag_id":"ck7u2pvo2006y4k8ycxehe8pj","_id":"ck7u2pvo300754k8y82ua9p8e"},{"post_id":"ck7u2pvo800764k8y414k1n0e","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvo900784k8y2m65dx3r"},{"post_id":"ck7u2pvo800764k8y414k1n0e","tag_id":"ck7u2pvjt000i4k8yag6y0y00","_id":"ck7u2pvoa00794k8yb42r3s93"},{"post_id":"ck7u2pvo900774k8yhoz8bgxh","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck7u2pvoa007b4k8y6ecn1kdg"},{"post_id":"ck7u2pvjf00024k8y5j1y5n2r","tag_id":"ck7u2pvjo000c4k8ygila0ao1","_id":"ck82rv7ng0000cu8y6utgf6sx"},{"post_id":"ck82s23on0000ss8y7w338fc6","tag_id":"ck7u2pvn5005g4k8yb5pa8qk7","_id":"ck82s23or0003ss8yay7f2oev"},{"post_id":"ck82s23on0000ss8y7w338fc6","tag_id":"ck82s23or0001ss8yfxoo81vv","_id":"ck82s23or0004ss8y3hysa4b1"},{"post_id":"ck98g1t4c00000w8y21rr4pc8","tag_id":"ck7u2pvn5005g4k8yb5pa8qk7","_id":"ck98g1t4o00010w8y9rz1eih6"},{"post_id":"ck98g1t4c00000w8y21rr4pc8","tag_id":"ck7u2pvnr006f4k8y44br5blx","_id":"ck98g1t4o00020w8y6omuby0s"}],"Tag":[{"name":"生活","_id":"ck7u2pvjj00054k8y4h4jedys"},{"name":"技术","_id":"ck7u2pvjo000c4k8ygila0ao1"},{"name":"vue","_id":"ck7u2pvjt000i4k8yag6y0y00"},{"name":"git","_id":"ck7u2pvk2000v4k8yf0kr2sev"},{"name":"CSS","_id":"ck7u2pvkl001r4k8ygoyr4qry"},{"name":"前端","_id":"ck7u2pvkw00204k8y1k9h6jld"},{"name":"host","_id":"ck7u2pvkz00274k8y4qv8bkvm"},{"name":"node","_id":"ck7u2pvl3002e4k8y4udi72yr"},{"name":"工具","_id":"ck7u2pvl7002m4k8yhsl74i63"},{"name":"翻墙","_id":"ck7u2pvld002v4k8yedabcw69"},{"name":"ES6","_id":"ck7u2pvlj003o4k8y6dlkcor8"},{"name":"JavaScript","_id":"ck7u2pvlj003r4k8yckbq7ytc"},{"name":"人生百态","_id":"ck7u2pvlk003u4k8y14tmha07"},{"name":"Jekyll","_id":"ck7u2pvmk00454k8y6we0ck8l"},{"name":"GitHub","_id":"ck7u2pvmp004e4k8y9d963s4h"},{"name":"教程","_id":"ck7u2pvmt004m4k8y7luv34fw"},{"name":"Linux","_id":"ck7u2pvmz004z4k8y4zsxb0i4"},{"name":"面试","_id":"ck7u2pvn5005g4k8yb5pa8qk7"},{"name":"指令","_id":"ck7u2pvn9005o4k8ydm4r3rfn"},{"name":"规范","_id":"ck7u2pvno00674k8yg1jbecyz"},{"name":"js","_id":"ck7u2pvnr006f4k8y44br5blx"},{"name":"优化","_id":"ck7u2pvo0006r4k8yhyp75n15"},{"name":"网络","_id":"ck7u2pvo2006y4k8ycxehe8pj"},{"name":"HTTP","_id":"ck82s23or0001ss8yfxoo81vv"}]}}